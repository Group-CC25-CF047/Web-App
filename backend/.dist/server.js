import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __legacyDecorateClassTS = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1;i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __legacyDecorateParamTS = (index, decorator) => (target, key) => decorator(target, key, index);
var __legacyMetadataTS = (k, v) => {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
};
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS(() => {
  /*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var Reflect2;
  (function(Reflect3) {
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
      var exporter = makeExporter(Reflect3);
      if (typeof root.Reflect !== "undefined") {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory(exporter, root);
      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect3;
      }
      function makeExporter(target, previous) {
        return function(key, value) {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
          if (previous)
            previous(key, value);
        };
      }
      function functionThis() {
        try {
          return Function("return this;")();
        } catch (_) {}
      }
      function indirectEvalThis() {
        try {
          return (undefined, eval)("(function() { return this; })()");
        } catch (_) {}
      }
      function sloppyModeThis() {
        return functionThis() || indirectEvalThis();
      }
    })(function(exporter, root) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
      var supportsCreate = typeof Object.create === "function";
      var supportsProto = { __proto__: [] } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        create: supportsCreate ? function() {
          return MakeDictionary(Object.create(null));
        } : supportsProto ? function() {
          return MakeDictionary({ __proto__: null });
        } : function() {
          return MakeDictionary({});
        },
        has: downLevel ? function(map, key) {
          return hasOwn.call(map, key);
        } : function(map, key) {
          return key in map;
        },
        get: downLevel ? function(map, key) {
          return hasOwn.call(map, key) ? map[key] : undefined;
        } : function(map, key) {
          return map[key];
        }
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
      var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
      var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
      var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : undefined;
      var metadataRegistry = GetOrCreateMetadataRegistry();
      var metadataProvider = CreateMetadataProvider(metadataRegistry);
      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators))
            throw new TypeError;
          if (!IsObject(target))
            throw new TypeError;
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
            throw new TypeError;
          if (IsNull(attributes))
            attributes = undefined;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators))
            throw new TypeError;
          if (!IsConstructor(target))
            throw new TypeError;
          return DecorateConstructor(decorators, target);
        }
      }
      exporter("decorate", decorate);
      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError;
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
            throw new TypeError;
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
      }
      exporter("metadata", metadata);
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter("defineMetadata", defineMetadata);
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasMetadata", hasMetadata);
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasOwnMetadata", hasOwnMetadata);
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter("getMetadata", getMetadata);
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("getOwnMetadata", getOwnMetadata);
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter("getMetadataKeys", getMetadataKeys);
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter("getOwnMetadataKeys", getOwnMetadataKeys);
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey))
          propertyKey = ToPropertyKey(propertyKey);
        var provider = GetMetadataProvider(target, propertyKey, false);
        if (IsUndefined(provider))
          return false;
        return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
      }
      exporter("deleteMetadata", deleteMetadata);
      function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1;i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated))
              throw new TypeError;
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1;i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target, propertyKey, descriptor);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated))
              throw new TypeError;
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined(provider))
          return false;
        return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2)
          return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
          return OrdinaryGetMetadata(MetadataKey, parent, P);
        return;
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined(provider))
          return;
        return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var provider = GetMetadataProvider(O, P, true);
        provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
      }
      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
          return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
          return ownKeys;
        if (ownKeys.length <= 0)
          return parentKeys;
        var set = new _Set;
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys;_i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        for (var _a = 0, parentKeys_1 = parentKeys;_a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (!provider) {
          return [];
        }
        return provider.OrdinaryOwnMetadataKeys(O, P);
      }
      function Type(x) {
        if (x === null)
          return 1;
        switch (typeof x) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return x === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined(x) {
        return x === undefined;
      }
      function IsNull(x) {
        return x === null;
      }
      function IsSymbol(x) {
        return typeof x === "symbol";
      }
      function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
            return input;
          case 1:
            return input;
          case 2:
            return input;
          case 3:
            return input;
          case 4:
            return input;
          case 5:
            return input;
        }
        var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result))
            throw new TypeError;
          return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result))
              return result;
          }
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
        } else {
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result))
              return result;
          }
          var toString_2 = O.toString;
          if (IsCallable(toString_2)) {
            var result = toString_2.call(O);
            if (!IsObject(result))
              return result;
          }
        }
        throw new TypeError;
      }
      function ToBoolean(argument) {
        return !!argument;
      }
      function ToString(argument) {
        return "" + argument;
      }
      function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3);
        if (IsSymbol(key))
          return key;
        return ToString(key);
      }
      function IsArray(argument) {
        return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
      }
      function IsCallable(argument) {
        return typeof argument === "function";
      }
      function IsConstructor(argument) {
        return typeof argument === "function";
      }
      function IsPropertyKey(argument) {
        switch (Type(argument)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function SameValueZero(x, y) {
        return x === y || x !== x && y !== y;
      }
      function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
          return;
        if (!IsCallable(func))
          throw new TypeError;
        return func;
      }
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
          throw new TypeError;
        var iterator = method.call(obj);
        if (!IsObject(iterator))
          throw new TypeError;
        return iterator;
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
      }
      function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
          f.call(iterator);
      }
      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
          return proto;
        if (proto !== functionPrototype)
          return proto;
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
          return proto;
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
          return proto;
        if (constructor === O)
          return proto;
        return constructor;
      }
      function CreateMetadataRegistry() {
        var fallback;
        if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
          fallback = CreateFallbackProvider(root.Reflect);
        }
        var first;
        var second;
        var rest;
        var targetProviderMap = new _WeakMap;
        var registry = {
          registerProvider,
          getProvider,
          setProvider
        };
        return registry;
        function registerProvider(provider) {
          if (!Object.isExtensible(registry)) {
            throw new Error("Cannot add provider to a frozen registry.");
          }
          switch (true) {
            case fallback === provider:
              break;
            case IsUndefined(first):
              first = provider;
              break;
            case first === provider:
              break;
            case IsUndefined(second):
              second = provider;
              break;
            case second === provider:
              break;
            default:
              if (rest === undefined)
                rest = new _Set;
              rest.add(provider);
              break;
          }
        }
        function getProviderNoCache(O, P) {
          if (!IsUndefined(first)) {
            if (first.isProviderFor(O, P))
              return first;
            if (!IsUndefined(second)) {
              if (second.isProviderFor(O, P))
                return first;
              if (!IsUndefined(rest)) {
                var iterator = GetIterator(rest);
                while (true) {
                  var next = IteratorStep(iterator);
                  if (!next) {
                    return;
                  }
                  var provider = IteratorValue(next);
                  if (provider.isProviderFor(O, P)) {
                    IteratorClose(iterator);
                    return provider;
                  }
                }
              }
            }
          }
          if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
            return fallback;
          }
          return;
        }
        function getProvider(O, P) {
          var providerMap = targetProviderMap.get(O);
          var provider;
          if (!IsUndefined(providerMap)) {
            provider = providerMap.get(P);
          }
          if (!IsUndefined(provider)) {
            return provider;
          }
          provider = getProviderNoCache(O, P);
          if (!IsUndefined(provider)) {
            if (IsUndefined(providerMap)) {
              providerMap = new _Map;
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return provider;
        }
        function hasProvider(provider) {
          if (IsUndefined(provider))
            throw new TypeError;
          return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
        }
        function setProvider(O, P, provider) {
          if (!hasProvider(provider)) {
            throw new Error("Metadata provider not registered.");
          }
          var existingProvider = getProvider(O, P);
          if (existingProvider !== provider) {
            if (!IsUndefined(existingProvider)) {
              return false;
            }
            var providerMap = targetProviderMap.get(O);
            if (IsUndefined(providerMap)) {
              providerMap = new _Map;
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return true;
        }
      }
      function GetOrCreateMetadataRegistry() {
        var metadataRegistry2;
        if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
          metadataRegistry2 = root.Reflect[registrySymbol];
        }
        if (IsUndefined(metadataRegistry2)) {
          metadataRegistry2 = CreateMetadataRegistry();
        }
        if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
          Object.defineProperty(root.Reflect, registrySymbol, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: metadataRegistry2
          });
        }
        return metadataRegistry2;
      }
      function CreateMetadataProvider(registry) {
        var metadata2 = new _WeakMap;
        var provider = {
          isProviderFor: function(O, P) {
            var targetMetadata = metadata2.get(O);
            if (IsUndefined(targetMetadata))
              return false;
            return targetMetadata.has(P);
          },
          OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
          OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
          OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
          OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
          OrdinaryDeleteMetadata
        };
        metadataRegistry.registerProvider(provider);
        return provider;
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = metadata2.get(O);
          var createdTargetMetadata = false;
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return;
            targetMetadata = new _Map;
            metadata2.set(O, targetMetadata);
            createdTargetMetadata = true;
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return;
            metadataMap = new _Map;
            targetMetadata.set(P, metadataMap);
            if (!registry.setProvider(O, P, provider)) {
              targetMetadata.delete(P);
              if (createdTargetMetadata) {
                metadata2.delete(O);
              }
              throw new Error("Wrong provider for target.");
            }
          }
          return metadataMap;
        }
        function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, true);
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryOwnMetadataKeys2(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function OrdinaryDeleteMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(MetadataKey))
            return false;
          if (metadataMap.size === 0) {
            var targetMetadata = metadata2.get(O);
            if (!IsUndefined(targetMetadata)) {
              targetMetadata.delete(P);
              if (targetMetadata.size === 0) {
                metadata2.delete(targetMetadata);
              }
            }
          }
          return true;
        }
      }
      function CreateFallbackProvider(reflect) {
        var { defineMetadata: defineMetadata2, hasOwnMetadata: hasOwnMetadata2, getOwnMetadata: getOwnMetadata2, getOwnMetadataKeys: getOwnMetadataKeys2, deleteMetadata: deleteMetadata2 } = reflect;
        var metadataOwner = new _WeakMap;
        var provider = {
          isProviderFor: function(O, P) {
            var metadataPropertySet = metadataOwner.get(O);
            if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
              return true;
            }
            if (getOwnMetadataKeys2(O, P).length) {
              if (IsUndefined(metadataPropertySet)) {
                metadataPropertySet = new _Set;
                metadataOwner.set(O, metadataPropertySet);
              }
              metadataPropertySet.add(P);
              return true;
            }
            return false;
          },
          OrdinaryDefineOwnMetadata: defineMetadata2,
          OrdinaryHasOwnMetadata: hasOwnMetadata2,
          OrdinaryGetOwnMetadata: getOwnMetadata2,
          OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
          OrdinaryDeleteMetadata: deleteMetadata2
        };
        return provider;
      }
      function GetMetadataProvider(O, P, Create) {
        var registeredProvider = metadataRegistry.getProvider(O, P);
        if (!IsUndefined(registeredProvider)) {
          return registeredProvider;
        }
        if (Create) {
          if (metadataRegistry.setProvider(O, P, metadataProvider)) {
            return metadataProvider;
          }
          throw new Error("Illegal state.");
        }
        return;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: undefined, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }();
        var Map2 = function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(key, false) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(key, false);
            return index >= 0 ? this._values[index] : undefined;
          };
          Map3.prototype.set = function(key, value) {
            var index = this._find(key, true);
            this._values[index] = value;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(key, false);
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1;i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i = 0;i < this._keys.length; i++) {
                if (SameValueZero(this._keys[i], key)) {
                  this._cacheIndex = i;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(undefined);
            }
            return this._cacheIndex;
          };
          return Map3;
        }();
        return Map2;
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      function CreateSetPolyfill() {
        var Set2 = function() {
          function Set3() {
            this._map = new _Map;
          }
          Object.defineProperty(Set3.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set3.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set3.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set3.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set3.prototype.clear = function() {
            this._map.clear();
          };
          Set3.prototype.keys = function() {
            return this._map.keys();
          };
          Set3.prototype.values = function() {
            return this._map.keys();
          };
          Set3.prototype.entries = function() {
            return this._map.entries();
          };
          Set3.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set3;
        }();
        return Set2;
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.get(table, this._key) : undefined;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(target, true);
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }();
        function CreateUniqueKey() {
          var key;
          do
            key = "@@WeakMap@@" + CreateUUID();
          while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create)
              return;
            Object.defineProperty(target, rootKey, { value: HashMap.create() });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i = 0;i < size; ++i)
            buffer[i] = Math.random() * 255 | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            var array = new Uint8Array(size);
            if (typeof crypto !== "undefined") {
              crypto.getRandomValues(array);
            } else if (typeof msCrypto !== "undefined") {
              msCrypto.getRandomValues(array);
            } else {
              FillRandomBytes(array, size);
            }
            return array;
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = data[6] & 79 | 64;
          data[8] = data[8] & 191 | 128;
          var result = "";
          for (var offset = 0;offset < UUID_SIZE; ++offset) {
            var byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8)
              result += "-";
            if (byte < 16)
              result += "0";
            result += byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect2 || (Reflect2 = {}));
});

// node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  exports.parse = function(source, transform) {
    return new ArrayParser(source, transform).parse();
  };

  class ArrayParser {
    constructor(source, transform) {
      this.source = source;
      this.transform = transform || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value) {
    return value;
  }
});

// node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array = require_postgres_array();
  module.exports = {
    create: function(source, transform) {
      return {
        parse: function() {
          return array.parse(source, transform);
        }
      };
    }
  };
});

// node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
      if (is0To99(year)) {
        date.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date.setTime(date.getTime() - offset);
      }
    } else {
      date = new Date(year, month, day, hour, minute, second, ms);
      if (is0To99(year)) {
        date.setFullYear(year);
      }
    }
    return date;
  };
  function getDate(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var date = new Date(year, month, day);
    if (is0To99(year)) {
      date.setFullYear(year);
    }
    return date;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type = zone[1];
    if (type === "Z") {
      return 0;
    }
    var sign = type === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  }
  function bcYearToNegativeYear(year) {
    return -(year - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  module.exports = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var extend = require_mutable();
  module.exports = PostgresInterval;
  function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw);
    }
    extend(this, parse(raw));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  }
});

// node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var array = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  function allowNull(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  }
  function parseBool(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  }
  function parseBoolArray(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  }
  function parseBaseTenInt(string) {
    return parseInt(string, 10);
  }
  function parseIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var BASE = 1e6;
  function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t = 4294967296 * carry + low;
      digits = "" + t % BASE;
      return sign + digits + result;
    }
  }
  module.exports = readInt8;
});

// node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array[i2] = parse(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  }
  function setTypeParser(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  }
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// node_modules/pg/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var defaults = require_defaults();
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result = "{";
    for (let i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        let item = val[i];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  }
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (val instanceof Date) {
        if (defaults.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date) {
    let offset = -date.getTimezoneOffset();
    let year = date.getFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0") + "T" + String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0") + "." + String(date.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date) {
    let year = date.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date.getUTCDate()).padStart(2, "0") + "T" + String(date.getUTCHours()).padStart(2, "0") + ":" + String(date.getUTCMinutes()).padStart(2, "0") + ":" + String(date.getUTCSeconds()).padStart(2, "0") + "." + String(date.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config, values, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values) {
      if (typeof values === "function") {
        config.callback = values;
      } else {
        config.values = values;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  }
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    for (let i = 0;i < str.length; i++) {
      const c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  function md5(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    const inner = md5(password + user);
    const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha256(text) {
    return nodeCrypto.createHash("sha256").update(text).digest();
  }
  function hashByName(hashName, text) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
});

// node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
  function randomBytes(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  }
  async function md5(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string === "string" ? textEncoder.encode(string) : string;
      const hash = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md5(password + user);
    const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text) {
    return await subtleCrypto.digest("SHA-256", text);
  }
  async function hashByName(hashName, text) {
    return await subtleCrypto.digest(hashName, text);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
});

// node_modules/pg/lib/crypto/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS((exports, module) => {
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index) {
    let length = data[index++];
    if (length < 128)
      return { length, index };
    const lengthBytes = length & 127;
    if (lengthBytes > 4)
      throw x509Error("bad length", data);
    length = 0;
    for (let i = 0;i < lengthBytes; i++) {
      length = length << 8 | data[index++];
    }
    return { length, index };
  }
  function readASN1OID(data, index) {
    if (data[index++] !== 6)
      throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index < lastIndex) {
      let value = 0;
      while (index < lastIndex) {
        const nextByte = data[index++];
        value = value << 7 | nextByte & 127;
        if (nextByte < 128)
          break;
      }
      oid += "." + value;
    }
    return { oid, index };
  }
  function expectASN1Seq(data, index) {
    if (data[index++] !== 48)
      throw x509Error("non-sequence data", data);
    return readASN1Length(data, index);
  }
  function signatureAlgorithmHashFromCertificate(data, index) {
    if (index === undefined)
      index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength;
    index = expectASN1Seq(data, index).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch (oid) {
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      case "1.2.840.113549.1.1.10": {
        index = indexAfterOID;
        index = expectASN1Seq(data, index).index;
        if (data[index++] !== 160)
          throw x509Error("non-tag data", data);
        index = readASN1Length(data, index).index;
        index = expectASN1Seq(data, index).index;
        const { oid: hashOID } = readASN1OID(data, index);
        switch (hashOID) {
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  module.exports = { signatureAlgorithmHashFromCertificate };
});

// node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var crypto2 = require_utils2();
  var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
  function startSession(mechanisms, stream) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream)
      candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData, stream) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream ? "eSws" : "biws";
    if (session.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1")
        hashName = "SHA-256";
      const certHash = await crypto2.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto2.sha256(clientKey);
    const clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text.split("").map((_, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
  }
  function parseAttributePairs(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value = attrValue.substring(2);
      return [name, value];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  }
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var types = require_pg_types();
  function TypeOverrides(userTypes) {
    this._types = userTypes || types;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  function parse(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      result = new URL(str, "postgres://base");
    } catch (e) {
      result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
      dummyHost = true;
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs = config.sslcert || config.sslkey || config.sslrootcert ? __require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config.sslrootcert) {
            config.ssl.checkServerIdentity = function() {};
          } else {
            config.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config.ssl.ca) {
            throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
          }
          config.ssl.checkServerIdentity = function() {};
          break;
        }
        case "verify-full": {
          break;
        }
      }
    } else {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {
      if (value !== undefined && value !== null) {
        c[key] = value;
      }
      return c;
    }, {});
    return connectionOptions;
  }
  function toClientConfig(config) {
    const poolConfig = Object.entries(config).reduce((c, [key, value]) => {
      if (key === "ssl") {
        const sslConfig = value;
        if (typeof sslConfig === "boolean") {
          c[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c[key] = toConnectionOptions(sslConfig);
        }
      } else if (value !== undefined && value !== null) {
        if (key === "port") {
          if (value !== "") {
            const v = parseInt(value, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value}`);
            }
            c[key] = v;
          }
        } else {
          c[key] = value;
        }
      }
      return c;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig(str) {
    return toClientConfig(parse(str));
  }
  module.exports = parse;
  parse.parse = parse;
  parse.toClientConfig = toClientConfig;
  parse.parseIntoClientConfig = parseIntoClientConfig;
});

// node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = __require("dns");
  var defaults = require_defaults();
  var parse = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {} else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params, config, paramName) {
    const value = config[paramName];
    if (value !== undefined && value !== null) {
      params.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types2) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types2;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      let match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        const field = this.fields[i].name;
        if (rawValue !== null) {
          row[field] = this._parsers[i](rawValue);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i = 0;i < fieldDescriptions.length; i++) {
        const desc = fieldDescriptions[i];
        row[desc.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var Result = require_result();
  var utils = require_utils();

  class Query extends EventEmitter {
    constructor(config, values, callback) {
      super();
      config = utils.normalizeQueryConfig(config, values, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection.sync();
      }
    }
    handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
    handleError(err, connection) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection.stream.cork && connection.stream.cork();
        try {
          this.prepare(connection);
        } finally {
          connection.stream.uncork && connection.stream.uncork();
        }
      } else {
        connection.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection.sync();
      } else {
        connection.flush();
      }
    }
    prepare(connection) {
      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection);
        return;
      }
      connection.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
      connection.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection) {}
  }
  module.exports = Query;
});

// node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text) {
      this.length = length;
      this.text = text;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      const len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query = (text) => {
    return writer.addCString(text).flush(81);
  };
  var emptyArray = [];
  var parse = (query2) => {
    const name = query2.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types = query2.types || emptyArray;
    const len = types.length;
    const buffer = writer.addCString(name).addCString(query2.text).addInt16(len);
    for (let i = 0;i < len; i++) {
      buffer.addInt32(types[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values, valueMapper) {
    for (let i = 0;i < values.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values = config.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse,
    bind,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize;
});

// node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {}
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          {
            message.name = "authenticationSASL";
            message.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message.mechanisms.push(mechanism);
              }
            } while (mechanism);
          }
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\x00") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser;
});

// node_modules/pg-protocol/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  function parse(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve) => stream.on("end", () => resolve()));
  }
  exports.parse = parse;
});

// node_modules/pg-cloudflare/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CloudflareSocket = undefined;
  var events_1 = __require("events");

  class CloudflareSocket extends events_1.EventEmitter {
    constructor(ssl) {
      super();
      this.ssl = ssl;
      this.writable = false;
      this.destroyed = false;
      this._upgrading = false;
      this._upgraded = false;
      this._cfSocket = null;
      this._cfWriter = null;
      this._cfReader = null;
    }
    setNoDelay() {
      return this;
    }
    setKeepAlive() {
      return this;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    async connect(port, host, connectListener) {
      try {
        log("connecting");
        if (connectListener)
          this.once("connect", connectListener);
        const options = this.ssl ? { secureTransport: "starttls" } : {};
        const mod = await import("cloudflare:sockets");
        const connect = mod.connect;
        this._cfSocket = connect(`${host}:${port}`, options);
        this._cfWriter = this._cfSocket.writable.getWriter();
        this._addClosedHandler();
        this._cfReader = this._cfSocket.readable.getReader();
        if (this.ssl) {
          this._listenOnce().catch((e) => this.emit("error", e));
        } else {
          this._listen().catch((e) => this.emit("error", e));
        }
        await this._cfWriter.ready;
        log("socket ready");
        this.writable = true;
        this.emit("connect");
        return this;
      } catch (e) {
        this.emit("error", e);
      }
    }
    async _listen() {
      while (true) {
        log("awaiting receive from CF socket");
        const { done, value } = await this._cfReader.read();
        log("CF socket received:", done, value);
        if (done) {
          log("done");
          break;
        }
        this.emit("data", Buffer.from(value));
      }
    }
    async _listenOnce() {
      log("awaiting first receive from CF socket");
      const { done, value } = await this._cfReader.read();
      log("First CF socket received:", done, value);
      this.emit("data", Buffer.from(value));
    }
    write(data, encoding = "utf8", callback = () => {}) {
      if (data.length === 0)
        return callback();
      if (typeof data === "string")
        data = Buffer.from(data, encoding);
      log("sending data direct:", data);
      this._cfWriter.write(data).then(() => {
        log("data sent");
        callback();
      }, (err) => {
        log("send error", err);
        callback(err);
      });
      return true;
    }
    end(data = Buffer.alloc(0), encoding = "utf8", callback = () => {}) {
      log("ending CF socket");
      this.write(data, encoding, (err) => {
        this._cfSocket.close();
        if (callback)
          callback(err);
      });
      return this;
    }
    destroy(reason) {
      log("destroying CF socket", reason);
      this.destroyed = true;
      return this.end();
    }
    startTls(options) {
      if (this._upgraded) {
        this.emit("error", "Cannot call `startTls()` more than once on a socket");
        return;
      }
      this._cfWriter.releaseLock();
      this._cfReader.releaseLock();
      this._upgrading = true;
      this._cfSocket = this._cfSocket.startTls(options);
      this._cfWriter = this._cfSocket.writable.getWriter();
      this._cfReader = this._cfSocket.readable.getReader();
      this._addClosedHandler();
      this._listen().catch((e) => this.emit("error", e));
    }
    _addClosedHandler() {
      this._cfSocket.closed.then(() => {
        if (!this._upgrading) {
          log("CF socket closed");
          this._cfSocket = null;
          this.emit("close");
        } else {
          this._upgrading = false;
          this._upgraded = true;
        }
      }).catch((e) => this.emit("error", e));
    }
  }
  exports.CloudflareSocket = CloudflareSocket;
  var debug = false;
  function dump(data) {
    if (data instanceof Uint8Array || data instanceof ArrayBuffer) {
      const hex = Buffer.from(data).toString("hex");
      const str = new TextDecoder().decode(data);
      return `
>>> STR: "${str.replace(/\n/g, "\\n")}"
>>> HEX: ${hex}
`;
    } else {
      return data;
    }
  }
  function log(...args) {
    debug && console.log(...args.map(dump));
  }
});

// node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { getStream, getSecureStream } = getStreamFuncs();
  module.exports = {
    getStream,
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = __require("net");
      return new net.Socket;
    }
    function getSecureStream2(options) {
      const tls = __require("tls");
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = require_dist2();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
});

// node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var { parse, serialize } = require_dist();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize.flush();
  var syncBuffer = serialize.sync();
  var endBuffer = serialize.end();

  class Connection extends EventEmitter {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      const self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error) {
        if (self2._ending && (error.code === "ECONNRESET" || error.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        const responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        const net = __require("net");
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err) {
          return self2.emit("error", err);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse(stream, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text) {
      this._send(serialize.query(text));
    }
    parse(query) {
      this._send(serialize.parse(query));
    }
    bind(config) {
      this._send(serialize.bind(config));
    }
    execute(config) {
      this._send(serialize.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize.close(msg));
    }
    describe(msg) {
      this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var { Transform } = __require("stream");
  var { StringDecoder } = __require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  function transform(chunk, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0;i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error) {
        return cb(error);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error) {
        return cb(error);
      }
    }
    cb();
  }
  function push(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  }
  function noop(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream;
  }
  module.exports = split;
});

// node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var path2 = __require("path");
  var Stream = __require("stream").Stream;
  var split = require_split2();
  var util = __require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  function warn() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat(`
`);
      warnStream.write(util.format.apply(util, args));
    }
  }
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env2 = rawEnv || process.env;
    var file = env2.PGPASSFILE || (isWin ? path2.join(env2.APPDATA || "./", "postgresql", "pgpass.conf") : path2.join(env2.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/pgpass/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var path2 = __require("path");
  var fs = __require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err, stat) {
      if (err || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// node_modules/pg/lib/client.js
var require_client = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var utils = require_utils();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto2 = require_utils2();

  class Client extends EventEmitter {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c = config || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.enableChannelBinding = Boolean(c.enableChannelBinding);
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      const self2 = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error);
            } else {
              this._handleErrorEvent(error);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject) => {
        this._connect((error) => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query) {
      if (client.activeQuery === query) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values, callback) {
      let query;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;
        if (typeof values === "function") {
          query.callback = query.callback || values;
        }
      } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query = new Query(config, values, callback);
        if (!query.callback) {
          result = new this._Promise((resolve, reject) => {
            query.callback = (err, res) => err ? reject(err) : resolve(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          const error = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error, this.connection);
          });
          queryCallback(error);
          query.callback = () => {};
          const index = this.queryQueue.indexOf(query);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query.binary) {
        query.binary = true;
      }
      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var NOOP = function() {};
  var removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise2, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client) {
      err ? rej(err) : res(client);
    };
    const result = new Promise2(function(resolve, reject) {
      res = resolve;
      rej = reject;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err) {
      err.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client);
      pool.emit("error", err, client);
    };
  }

  class Pool2 extends EventEmitter {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {};
      this.Client = this.options.Client || Client || require_lib2().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      client.end();
      this.emit("remove", client);
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err = new Error("Connection terminated due to connection timeout", { cause: err });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err2, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err) => {
            if (err) {
              client.release(err);
              return pendingItem.callback(err, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err);
      };
    }
    _release(client, idleListener, err) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err, client);
      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        this._remove(client);
        this._pulseQueue();
        return;
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        this._remove(client);
        this._pulseQueue();
        return;
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client);
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text, values, cb) {
      if (typeof text === "function") {
        const response2 = promisify(this.Promise, text);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values === "function") {
        cb = values;
        values = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err2);
          cb(err2);
        };
        client.once("error", onError);
        this.log("dispatching query");
        try {
          client.query(text, values, (err2, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool2;
});

// node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var util = __require("util");
  var utils = require_utils();
  var NativeQuery = module.exports = function(config, values, callback) {
    EventEmitter.call(this);
    config = utils.normalizeQueryConfig(config, values, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.queryMode = config.queryMode;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (const key in fields) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject) {
      this._once("end", resolve);
      this._once("error", reject);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    const self2 = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after = function(err, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err) {
        return self2.handleError(err);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values = (this.values || []).map(utils.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client.native.execute(this.name, values, after);
      }
      return client.native.prepare(this.name, this.text, values.length, function(err) {
        if (err)
          return after(err);
        client.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      const vals = this.values.map(utils.prepareValue);
      client.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after);
    } else {
      client.native.query(this.text, after);
    }
  };
});

// node_modules/pg/lib/native/client.js
var require_client2 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error("Cannot require module "+"pg-native");})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = __require("events").EventEmitter;
  var util = __require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config) {
    EventEmitter.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util.inherits(Client, EventEmitter);
  Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.native = this.native;
        query.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    const self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self2.native.connect(conString, function(err2) {
        if (err2) {
          self2.native.end();
          return cb(err2);
        }
        self2._connected = true;
        self2.native.on("error", function(err3) {
          self2._queryable = false;
          self2._errorAllQueries(err3);
          self2.emit("error", err3);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject) => {
      this._connect((error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config, values, callback) {
    let query;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query = config;
      if (typeof values === "function") {
        config.callback = values;
      }
    } else {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      query = new NativeQuery(config, values, callback);
      if (!query.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject) => {
          resolveOut = resolve;
          rejectOut = reject;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query.callback;
      readTimeoutTimer = setTimeout(() => {
        const error = new Error("Query read timeout");
        process.nextTick(() => {
          query.handleError(error, this.connection);
        });
        queryCallback(error);
        query.callback = () => {};
        const index = this._queryQueue.indexOf(query);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    const self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject) {
        cb = (err) => err ? reject(err) : resolve();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query = this._queryQueue.shift();
    if (!query) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query;
    query.submit(this);
    const self2 = this;
    query.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
      this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
  };
  Client.prototype.ref = function() {};
  Client.prototype.unref = function() {};
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// node_modules/pg/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Client = require_client();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Result = require_result();
  var utils = require_utils();
  var Pool2 = require_pg_pool();
  var TypeOverrides = require_type_overrides();
  var { DatabaseError } = require_dist();
  var { escapeIdentifier, escapeLiteral } = require_utils();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool2 {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result;
    this.utils = utils;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client2());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native = null;
        try {
          native = new PG(require_client2());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// node_modules/@redis/client/dist/lib/RESP/verbatim-string.js
var require_verbatim_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VerbatimString = undefined;

  class VerbatimString extends String {
    format;
    constructor(format, value) {
      super(value);
      this.format = format;
    }
  }
  exports.VerbatimString = VerbatimString;
});

// node_modules/@redis/client/dist/lib/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiErrorReply = exports.TimeoutError = exports.BlobError = exports.SimpleError = exports.ErrorReply = exports.ReconnectStrategyError = exports.RootNodesUnavailableError = exports.SocketClosedUnexpectedlyError = exports.DisconnectsClientError = exports.ClientOfflineError = exports.ClientClosedError = exports.SocketTimeoutError = exports.ConnectionTimeoutError = exports.WatchError = exports.AbortError = undefined;

  class AbortError extends Error {
    constructor() {
      super("The command was aborted");
    }
  }
  exports.AbortError = AbortError;

  class WatchError extends Error {
    constructor(message = "One (or more) of the watched keys has been changed") {
      super(message);
    }
  }
  exports.WatchError = WatchError;

  class ConnectionTimeoutError extends Error {
    constructor() {
      super("Connection timeout");
    }
  }
  exports.ConnectionTimeoutError = ConnectionTimeoutError;

  class SocketTimeoutError extends Error {
    constructor(timeout) {
      super(`Socket timeout timeout. Expecting data, but didn't receive any in ${timeout}ms.`);
    }
  }
  exports.SocketTimeoutError = SocketTimeoutError;

  class ClientClosedError extends Error {
    constructor() {
      super("The client is closed");
    }
  }
  exports.ClientClosedError = ClientClosedError;

  class ClientOfflineError extends Error {
    constructor() {
      super("The client is offline");
    }
  }
  exports.ClientOfflineError = ClientOfflineError;

  class DisconnectsClientError extends Error {
    constructor() {
      super("Disconnects client");
    }
  }
  exports.DisconnectsClientError = DisconnectsClientError;

  class SocketClosedUnexpectedlyError extends Error {
    constructor() {
      super("Socket closed unexpectedly");
    }
  }
  exports.SocketClosedUnexpectedlyError = SocketClosedUnexpectedlyError;

  class RootNodesUnavailableError extends Error {
    constructor() {
      super("All the root nodes are unavailable");
    }
  }
  exports.RootNodesUnavailableError = RootNodesUnavailableError;

  class ReconnectStrategyError extends Error {
    originalError;
    socketError;
    constructor(originalError, socketError) {
      super(originalError.message);
      this.originalError = originalError;
      this.socketError = socketError;
    }
  }
  exports.ReconnectStrategyError = ReconnectStrategyError;

  class ErrorReply extends Error {
    constructor(message) {
      super(message);
      this.stack = undefined;
    }
  }
  exports.ErrorReply = ErrorReply;

  class SimpleError extends ErrorReply {
  }
  exports.SimpleError = SimpleError;

  class BlobError extends ErrorReply {
  }
  exports.BlobError = BlobError;

  class TimeoutError extends Error {
  }
  exports.TimeoutError = TimeoutError;

  class MultiErrorReply extends ErrorReply {
    replies;
    errorIndexes;
    constructor(replies, errorIndexes) {
      super(`${errorIndexes.length} commands failed, see .replies and .errorIndexes for more information`);
      this.replies = replies;
      this.errorIndexes = errorIndexes;
    }
    *errors() {
      for (const index of this.errorIndexes) {
        yield this.replies[index];
      }
    }
  }
  exports.MultiErrorReply = MultiErrorReply;
});

// node_modules/@redis/client/dist/lib/RESP/decoder.js
var require_decoder = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Decoder = exports.PUSH_TYPE_MAPPING = exports.RESP_TYPES = undefined;
  var verbatim_string_1 = require_verbatim_string();
  var errors_1 = require_errors();
  exports.RESP_TYPES = {
    NULL: 95,
    BOOLEAN: 35,
    NUMBER: 58,
    BIG_NUMBER: 40,
    DOUBLE: 44,
    SIMPLE_STRING: 43,
    BLOB_STRING: 36,
    VERBATIM_STRING: 61,
    SIMPLE_ERROR: 45,
    BLOB_ERROR: 33,
    ARRAY: 42,
    SET: 126,
    MAP: 37,
    PUSH: 62
  };
  var ASCII = {
    "\r": 13,
    t: 116,
    "+": 43,
    "-": 45,
    "0": 48,
    ".": 46,
    i: 105,
    n: 110,
    E: 69,
    e: 101
  };
  exports.PUSH_TYPE_MAPPING = {
    [exports.RESP_TYPES.BLOB_STRING]: Buffer
  };

  class Decoder {
    onReply;
    onErrorReply;
    onPush;
    getTypeMapping;
    #cursor = 0;
    #next;
    constructor(config) {
      this.onReply = config.onReply;
      this.onErrorReply = config.onErrorReply;
      this.onPush = config.onPush;
      this.getTypeMapping = config.getTypeMapping;
    }
    reset() {
      this.#cursor = 0;
      this.#next = undefined;
    }
    write(chunk) {
      if (this.#cursor >= chunk.length) {
        this.#cursor -= chunk.length;
        return;
      }
      if (this.#next) {
        if (this.#next(chunk) || this.#cursor >= chunk.length) {
          this.#cursor -= chunk.length;
          return;
        }
      }
      do {
        const type = chunk[this.#cursor];
        if (++this.#cursor === chunk.length) {
          this.#next = this.#continueDecodeTypeValue.bind(this, type);
          break;
        }
        if (this.#decodeTypeValue(type, chunk)) {
          break;
        }
      } while (this.#cursor < chunk.length);
      this.#cursor -= chunk.length;
    }
    #continueDecodeTypeValue(type, chunk) {
      this.#next = undefined;
      return this.#decodeTypeValue(type, chunk);
    }
    #decodeTypeValue(type, chunk) {
      switch (type) {
        case exports.RESP_TYPES.NULL:
          this.onReply(this.#decodeNull());
          return false;
        case exports.RESP_TYPES.BOOLEAN:
          return this.#handleDecodedValue(this.onReply, this.#decodeBoolean(chunk));
        case exports.RESP_TYPES.NUMBER:
          return this.#handleDecodedValue(this.onReply, this.#decodeNumber(this.getTypeMapping()[exports.RESP_TYPES.NUMBER], chunk));
        case exports.RESP_TYPES.BIG_NUMBER:
          return this.#handleDecodedValue(this.onReply, this.#decodeBigNumber(this.getTypeMapping()[exports.RESP_TYPES.BIG_NUMBER], chunk));
        case exports.RESP_TYPES.DOUBLE:
          return this.#handleDecodedValue(this.onReply, this.#decodeDouble(this.getTypeMapping()[exports.RESP_TYPES.DOUBLE], chunk));
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeSimpleString(this.getTypeMapping()[exports.RESP_TYPES.SIMPLE_STRING], chunk));
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeBlobString(this.getTypeMapping()[exports.RESP_TYPES.BLOB_STRING], chunk));
        case exports.RESP_TYPES.VERBATIM_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeVerbatimString(this.getTypeMapping()[exports.RESP_TYPES.VERBATIM_STRING], chunk));
        case exports.RESP_TYPES.SIMPLE_ERROR:
          return this.#handleDecodedValue(this.onErrorReply, this.#decodeSimpleError(chunk));
        case exports.RESP_TYPES.BLOB_ERROR:
          return this.#handleDecodedValue(this.onErrorReply, this.#decodeBlobError(chunk));
        case exports.RESP_TYPES.ARRAY:
          return this.#handleDecodedValue(this.onReply, this.#decodeArray(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.SET:
          return this.#handleDecodedValue(this.onReply, this.#decodeSet(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.MAP:
          return this.#handleDecodedValue(this.onReply, this.#decodeMap(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.PUSH:
          return this.#handleDecodedValue(this.onPush, this.#decodeArray(exports.PUSH_TYPE_MAPPING, chunk));
        default:
          throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
      }
    }
    #handleDecodedValue(cb, value) {
      if (typeof value === "function") {
        this.#next = this.#continueDecodeValue.bind(this, cb, value);
        return true;
      }
      cb(value);
      return false;
    }
    #continueDecodeValue(cb, next, chunk) {
      this.#next = undefined;
      return this.#handleDecodedValue(cb, next(chunk));
    }
    #decodeNull() {
      this.#cursor += 2;
      return null;
    }
    #decodeBoolean(chunk) {
      const boolean = chunk[this.#cursor] === ASCII.t;
      this.#cursor += 3;
      return boolean;
    }
    #decodeNumber(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return this.#maybeDecodeNumberValue(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeNumberValue(true, chunk);
        default:
          return this.#decodeNumberValue(false, this.#decodeUnsingedNumber.bind(this, 0), chunk);
      }
    }
    #maybeDecodeNumberValue(isNegative, chunk) {
      const cb = this.#decodeUnsingedNumber.bind(this, 0);
      return ++this.#cursor === chunk.length ? this.#decodeNumberValue.bind(this, isNegative, cb) : this.#decodeNumberValue(isNegative, cb, chunk);
    }
    #decodeNumberValue(isNegative, numberCb, chunk) {
      const number = numberCb(chunk);
      return typeof number === "function" ? this.#decodeNumberValue.bind(this, isNegative, number) : isNegative ? -number : number;
    }
    #decodeUnsingedNumber(number, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return number;
        }
        number = number * 10 + byte - ASCII["0"];
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeUnsingedNumber.bind(this, number);
    }
    #decodeBigNumber(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return this.#maybeDecodeBigNumberValue(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeBigNumberValue(true, chunk);
        default:
          return this.#decodeBigNumberValue(false, this.#decodeUnsingedBigNumber.bind(this, 0n), chunk);
      }
    }
    #maybeDecodeBigNumberValue(isNegative, chunk) {
      const cb = this.#decodeUnsingedBigNumber.bind(this, 0n);
      return ++this.#cursor === chunk.length ? this.#decodeBigNumberValue.bind(this, isNegative, cb) : this.#decodeBigNumberValue(isNegative, cb, chunk);
    }
    #decodeBigNumberValue(isNegative, bigNumberCb, chunk) {
      const bigNumber = bigNumberCb(chunk);
      return typeof bigNumber === "function" ? this.#decodeBigNumberValue.bind(this, isNegative, bigNumber) : isNegative ? -bigNumber : bigNumber;
    }
    #decodeUnsingedBigNumber(bigNumber, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return bigNumber;
        }
        bigNumber = bigNumber * 10n + BigInt(byte - ASCII["0"]);
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeUnsingedBigNumber.bind(this, bigNumber);
    }
    #decodeDouble(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII.n:
          this.#cursor += 5;
          return NaN;
        case ASCII["+"]:
          return this.#maybeDecodeDoubleInteger(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeDoubleInteger(true, chunk);
        default:
          return this.#decodeDoubleInteger(false, 0, chunk);
      }
    }
    #maybeDecodeDoubleInteger(isNegative, chunk) {
      return ++this.#cursor === chunk.length ? this.#decodeDoubleInteger.bind(this, isNegative, 0) : this.#decodeDoubleInteger(isNegative, 0, chunk);
    }
    #decodeDoubleInteger(isNegative, integer, chunk) {
      if (chunk[this.#cursor] === ASCII.i) {
        this.#cursor += 5;
        return isNegative ? -Infinity : Infinity;
      }
      return this.#continueDecodeDoubleInteger(isNegative, integer, chunk);
    }
    #continueDecodeDoubleInteger(isNegative, integer, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        switch (byte) {
          case ASCII["."]:
            this.#cursor = cursor + 1;
            return this.#cursor < chunk.length ? this.#decodeDoubleDecimal(isNegative, 0, integer, chunk) : this.#decodeDoubleDecimal.bind(this, isNegative, 0, integer);
          case ASCII.E:
          case ASCII.e:
            this.#cursor = cursor + 1;
            const i = isNegative ? -integer : integer;
            return this.#cursor < chunk.length ? this.#decodeDoubleExponent(i, chunk) : this.#decodeDoubleExponent.bind(this, i);
          case ASCII["\r"]:
            this.#cursor = cursor + 2;
            return isNegative ? -integer : integer;
          default:
            integer = integer * 10 + byte - ASCII["0"];
        }
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#continueDecodeDoubleInteger.bind(this, isNegative, integer);
    }
    static #DOUBLE_DECIMAL_MULTIPLIERS = [
      0.1,
      0.01,
      0.001,
      0.0001,
      0.00001,
      0.000001,
      0.0000001,
      0.00000001,
      0.000000001,
      0.0000000001,
      0.00000000001,
      0.000000000001,
      0.0000000000001,
      0.00000000000001,
      0.000000000000001,
      0.0000000000000001,
      0.00000000000000001
    ];
    #decodeDoubleDecimal(isNegative, decimalIndex, double, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        switch (byte) {
          case ASCII.E:
          case ASCII.e:
            this.#cursor = cursor + 1;
            const d = isNegative ? -double : double;
            return this.#cursor === chunk.length ? this.#decodeDoubleExponent.bind(this, d) : this.#decodeDoubleExponent(d, chunk);
          case ASCII["\r"]:
            this.#cursor = cursor + 2;
            return isNegative ? -double : double;
        }
        if (decimalIndex < _a.#DOUBLE_DECIMAL_MULTIPLIERS.length) {
          double += (byte - ASCII["0"]) * _a.#DOUBLE_DECIMAL_MULTIPLIERS[decimalIndex++];
        }
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeDoubleDecimal.bind(this, isNegative, decimalIndex, double);
    }
    #decodeDoubleExponent(double, chunk) {
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return ++this.#cursor === chunk.length ? this.#continueDecodeDoubleExponent.bind(this, false, double, 0) : this.#continueDecodeDoubleExponent(false, double, 0, chunk);
        case ASCII["-"]:
          return ++this.#cursor === chunk.length ? this.#continueDecodeDoubleExponent.bind(this, true, double, 0) : this.#continueDecodeDoubleExponent(true, double, 0, chunk);
      }
      return this.#continueDecodeDoubleExponent(false, double, 0, chunk);
    }
    #continueDecodeDoubleExponent(isNegative, double, exponent, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return double * 10 ** (isNegative ? -exponent : exponent);
        }
        exponent = exponent * 10 + byte - ASCII["0"];
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#continueDecodeDoubleExponent.bind(this, isNegative, double, exponent);
    }
    #findCRLF(chunk, cursor) {
      while (chunk[cursor] !== ASCII["\r"]) {
        if (++cursor === chunk.length) {
          this.#cursor = chunk.length;
          return -1;
        }
      }
      this.#cursor = cursor + 2;
      return cursor;
    }
    #decodeSimpleString(type, chunk) {
      const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
      if (crlfIndex === -1) {
        return this.#continueDecodeSimpleString.bind(this, [chunk.subarray(start)], type);
      }
      const slice = chunk.subarray(start, crlfIndex);
      return type === Buffer ? slice : slice.toString();
    }
    #continueDecodeSimpleString(chunks, type, chunk) {
      const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
      if (crlfIndex === -1) {
        chunks.push(chunk.subarray(start));
        return this.#continueDecodeSimpleString.bind(this, chunks, type);
      }
      chunks.push(chunk.subarray(start, crlfIndex));
      return type === Buffer ? Buffer.concat(chunks) : chunks.join("");
    }
    #decodeBlobString(type, chunk) {
      if (chunk[this.#cursor] === ASCII["-"]) {
        this.#cursor += 4;
        return null;
      }
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeBlobStringLength.bind(this, length, type);
      } else if (this.#cursor >= chunk.length) {
        return this.#decodeBlobStringWithLength.bind(this, length, type);
      }
      return this.#decodeBlobStringWithLength(length, type, chunk);
    }
    #continueDecodeBlobStringLength(lengthCb, type, chunk) {
      const length = lengthCb(chunk);
      if (typeof length === "function") {
        return this.#continueDecodeBlobStringLength.bind(this, length, type);
      } else if (this.#cursor >= chunk.length) {
        return this.#decodeBlobStringWithLength.bind(this, length, type);
      }
      return this.#decodeBlobStringWithLength(length, type, chunk);
    }
    #decodeStringWithLength(length, skip, type, chunk) {
      const end = this.#cursor + length;
      if (end >= chunk.length) {
        const slice2 = chunk.subarray(this.#cursor);
        this.#cursor = chunk.length;
        return this.#continueDecodeStringWithLength.bind(this, length - slice2.length, [slice2], skip, type);
      }
      const slice = chunk.subarray(this.#cursor, end);
      this.#cursor = end + skip;
      return type === Buffer ? slice : slice.toString();
    }
    #continueDecodeStringWithLength(length, chunks, skip, type, chunk) {
      const end = this.#cursor + length;
      if (end >= chunk.length) {
        const slice = chunk.subarray(this.#cursor);
        chunks.push(slice);
        this.#cursor = chunk.length;
        return this.#continueDecodeStringWithLength.bind(this, length - slice.length, chunks, skip, type);
      }
      chunks.push(chunk.subarray(this.#cursor, end));
      this.#cursor = end + skip;
      return type === Buffer ? Buffer.concat(chunks) : chunks.join("");
    }
    #decodeBlobStringWithLength(length, type, chunk) {
      return this.#decodeStringWithLength(length, 2, type, chunk);
    }
    #decodeVerbatimString(type, chunk) {
      return this.#continueDecodeVerbatimStringLength(this.#decodeUnsingedNumber.bind(this, 0), type, chunk);
    }
    #continueDecodeVerbatimStringLength(lengthCb, type, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeVerbatimStringLength.bind(this, length, type) : this.#decodeVerbatimStringWithLength(length, type, chunk);
    }
    #decodeVerbatimStringWithLength(length, type, chunk) {
      const stringLength = length - 4;
      if (type === verbatim_string_1.VerbatimString) {
        return this.#decodeVerbatimStringFormat(stringLength, chunk);
      }
      this.#cursor += 4;
      return this.#cursor >= chunk.length ? this.#decodeBlobStringWithLength.bind(this, stringLength, type) : this.#decodeBlobStringWithLength(stringLength, type, chunk);
    }
    #decodeVerbatimStringFormat(stringLength, chunk) {
      const formatCb = this.#decodeStringWithLength.bind(this, 3, 1, String);
      return this.#cursor >= chunk.length ? this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, formatCb) : this.#continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk);
    }
    #continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk) {
      const format = formatCb(chunk);
      return typeof format === "function" ? this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, format) : this.#decodeVerbatimStringWithFormat(stringLength, format, chunk);
    }
    #decodeVerbatimStringWithFormat(stringLength, format, chunk) {
      return this.#continueDecodeVerbatimStringWithFormat(format, this.#decodeBlobStringWithLength.bind(this, stringLength, String), chunk);
    }
    #continueDecodeVerbatimStringWithFormat(format, stringCb, chunk) {
      const string = stringCb(chunk);
      return typeof string === "function" ? this.#continueDecodeVerbatimStringWithFormat.bind(this, format, string) : new verbatim_string_1.VerbatimString(format, string);
    }
    #decodeSimpleError(chunk) {
      const string = this.#decodeSimpleString(String, chunk);
      return typeof string === "function" ? this.#continueDecodeSimpleError.bind(this, string) : new errors_1.SimpleError(string);
    }
    #continueDecodeSimpleError(stringCb, chunk) {
      const string = stringCb(chunk);
      return typeof string === "function" ? this.#continueDecodeSimpleError.bind(this, string) : new errors_1.SimpleError(string);
    }
    #decodeBlobError(chunk) {
      const string = this.#decodeBlobString(String, chunk);
      return typeof string === "function" ? this.#continueDecodeBlobError.bind(this, string) : new errors_1.BlobError(string);
    }
    #continueDecodeBlobError(stringCb, chunk) {
      const string = stringCb(chunk);
      return typeof string === "function" ? this.#continueDecodeBlobError.bind(this, string) : new errors_1.BlobError(string);
    }
    #decodeNestedType(typeMapping, chunk) {
      const type = chunk[this.#cursor];
      return ++this.#cursor === chunk.length ? this.#decodeNestedTypeValue.bind(this, type, typeMapping) : this.#decodeNestedTypeValue(type, typeMapping, chunk);
    }
    #decodeNestedTypeValue(type, typeMapping, chunk) {
      switch (type) {
        case exports.RESP_TYPES.NULL:
          return this.#decodeNull();
        case exports.RESP_TYPES.BOOLEAN:
          return this.#decodeBoolean(chunk);
        case exports.RESP_TYPES.NUMBER:
          return this.#decodeNumber(typeMapping[exports.RESP_TYPES.NUMBER], chunk);
        case exports.RESP_TYPES.BIG_NUMBER:
          return this.#decodeBigNumber(typeMapping[exports.RESP_TYPES.BIG_NUMBER], chunk);
        case exports.RESP_TYPES.DOUBLE:
          return this.#decodeDouble(typeMapping[exports.RESP_TYPES.DOUBLE], chunk);
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#decodeSimpleString(typeMapping[exports.RESP_TYPES.SIMPLE_STRING], chunk);
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#decodeBlobString(typeMapping[exports.RESP_TYPES.BLOB_STRING], chunk);
        case exports.RESP_TYPES.VERBATIM_STRING:
          return this.#decodeVerbatimString(typeMapping[exports.RESP_TYPES.VERBATIM_STRING], chunk);
        case exports.RESP_TYPES.SIMPLE_ERROR:
          return this.#decodeSimpleError(chunk);
        case exports.RESP_TYPES.BLOB_ERROR:
          return this.#decodeBlobError(chunk);
        case exports.RESP_TYPES.ARRAY:
          return this.#decodeArray(typeMapping, chunk);
        case exports.RESP_TYPES.SET:
          return this.#decodeSet(typeMapping, chunk);
        case exports.RESP_TYPES.MAP:
          return this.#decodeMap(typeMapping, chunk);
        default:
          throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
      }
    }
    #decodeArray(typeMapping, chunk) {
      if (chunk[this.#cursor] === ASCII["-"]) {
        this.#cursor += 4;
        return null;
      }
      return this.#decodeArrayWithLength(this.#decodeUnsingedNumber(0, chunk), typeMapping, chunk);
    }
    #decodeArrayWithLength(length, typeMapping, chunk) {
      return typeof length === "function" ? this.#continueDecodeArrayLength.bind(this, length, typeMapping) : this.#decodeArrayItems(new Array(length), 0, typeMapping, chunk);
    }
    #continueDecodeArrayLength(lengthCb, typeMapping, chunk) {
      return this.#decodeArrayWithLength(lengthCb(chunk), typeMapping, chunk);
    }
    #decodeArrayItems(array, filled, typeMapping, chunk) {
      for (let i = filled;i < array.length; i++) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeArrayItems.bind(this, array, i, typeMapping);
        }
        const item = this.#decodeNestedType(typeMapping, chunk);
        if (typeof item === "function") {
          return this.#continueDecodeArrayItems.bind(this, array, i, item, typeMapping);
        }
        array[i] = item;
      }
      return array;
    }
    #continueDecodeArrayItems(array, filled, itemCb, typeMapping, chunk) {
      const item = itemCb(chunk);
      if (typeof item === "function") {
        return this.#continueDecodeArrayItems.bind(this, array, filled, item, typeMapping);
      }
      array[filled++] = item;
      return this.#decodeArrayItems(array, filled, typeMapping, chunk);
    }
    #decodeSet(typeMapping, chunk) {
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeSetLength.bind(this, length, typeMapping);
      }
      return this.#decodeSetItems(length, typeMapping, chunk);
    }
    #continueDecodeSetLength(lengthCb, typeMapping, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeSetLength.bind(this, length, typeMapping) : this.#decodeSetItems(length, typeMapping, chunk);
    }
    #decodeSetItems(length, typeMapping, chunk) {
      return typeMapping[exports.RESP_TYPES.SET] === Set ? this.#decodeSetAsSet(new Set, length, typeMapping, chunk) : this.#decodeArrayItems(new Array(length), 0, typeMapping, chunk);
    }
    #decodeSetAsSet(set, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeSetAsSet.bind(this, set, remaining, typeMapping);
        }
        const item = this.#decodeNestedType(typeMapping, chunk);
        if (typeof item === "function") {
          return this.#continueDecodeSetAsSet.bind(this, set, remaining, item, typeMapping);
        }
        set.add(item);
        --remaining;
      }
      return set;
    }
    #continueDecodeSetAsSet(set, remaining, itemCb, typeMapping, chunk) {
      const item = itemCb(chunk);
      if (typeof item === "function") {
        return this.#continueDecodeSetAsSet.bind(this, set, remaining, item, typeMapping);
      }
      set.add(item);
      return this.#decodeSetAsSet(set, remaining - 1, typeMapping, chunk);
    }
    #decodeMap(typeMapping, chunk) {
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeMapLength.bind(this, length, typeMapping);
      }
      return this.#decodeMapItems(length, typeMapping, chunk);
    }
    #continueDecodeMapLength(lengthCb, typeMapping, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeMapLength.bind(this, length, typeMapping) : this.#decodeMapItems(length, typeMapping, chunk);
    }
    #decodeMapItems(length, typeMapping, chunk) {
      switch (typeMapping[exports.RESP_TYPES.MAP]) {
        case Map:
          return this.#decodeMapAsMap(new Map, length, typeMapping, chunk);
        case Array:
          return this.#decodeArrayItems(new Array(length * 2), 0, typeMapping, chunk);
        default:
          return this.#decodeMapAsObject(Object.create(null), length, typeMapping, chunk);
      }
    }
    #decodeMapAsMap(map, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeMapAsMap.bind(this, map, remaining, typeMapping);
        }
        const key = this.#decodeMapKey(typeMapping, chunk);
        if (typeof key === "function") {
          return this.#continueDecodeMapKey.bind(this, map, remaining, key, typeMapping);
        }
        if (this.#cursor >= chunk.length) {
          return this.#continueDecodeMapValue.bind(this, map, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
        }
        const value = this.#decodeNestedType(typeMapping, chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
        }
        map.set(key, value);
        --remaining;
      }
      return map;
    }
    #decodeMapKey(typeMapping, chunk) {
      const type = chunk[this.#cursor];
      return ++this.#cursor === chunk.length ? this.#decodeMapKeyValue.bind(this, type, typeMapping) : this.#decodeMapKeyValue(type, typeMapping, chunk);
    }
    #decodeMapKeyValue(type, typeMapping, chunk) {
      switch (type) {
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#decodeSimpleString(String, chunk);
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#decodeBlobString(String, chunk);
        default:
          return this.#decodeNestedTypeValue(type, typeMapping, chunk);
      }
    }
    #continueDecodeMapKey(map, remaining, keyCb, typeMapping, chunk) {
      const key = keyCb(chunk);
      if (typeof key === "function") {
        return this.#continueDecodeMapKey.bind(this, map, remaining, key, typeMapping);
      }
      if (this.#cursor >= chunk.length) {
        return this.#continueDecodeMapValue.bind(this, map, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
      }
      const value = this.#decodeNestedType(typeMapping, chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
      }
      map.set(key, value);
      return this.#decodeMapAsMap(map, remaining - 1, typeMapping, chunk);
    }
    #continueDecodeMapValue(map, remaining, key, valueCb, typeMapping, chunk) {
      const value = valueCb(chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
      }
      map.set(key, value);
      return this.#decodeMapAsMap(map, remaining - 1, typeMapping, chunk);
    }
    #decodeMapAsObject(object, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeMapAsObject.bind(this, object, remaining, typeMapping);
        }
        const key = this.#decodeMapKey(typeMapping, chunk);
        if (typeof key === "function") {
          return this.#continueDecodeMapAsObjectKey.bind(this, object, remaining, key, typeMapping);
        }
        if (this.#cursor >= chunk.length) {
          return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
        }
        const value = this.#decodeNestedType(typeMapping, chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
        }
        object[key] = value;
        --remaining;
      }
      return object;
    }
    #continueDecodeMapAsObjectKey(object, remaining, keyCb, typeMapping, chunk) {
      const key = keyCb(chunk);
      if (typeof key === "function") {
        return this.#continueDecodeMapAsObjectKey.bind(this, object, remaining, key, typeMapping);
      }
      if (this.#cursor >= chunk.length) {
        return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
      }
      const value = this.#decodeNestedType(typeMapping, chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
      }
      object[key] = value;
      return this.#decodeMapAsObject(object, remaining - 1, typeMapping, chunk);
    }
    #continueDecodeMapAsObjectValue(object, remaining, key, valueCb, typeMapping, chunk) {
      const value = valueCb(chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
      }
      object[key] = value;
      return this.#decodeMapAsObject(object, remaining - 1, typeMapping, chunk);
    }
  }
  exports.Decoder = Decoder;
  _a = Decoder;
});

// node_modules/@redis/client/dist/lib/lua-script.js
var require_lua_script = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scriptSha1 = exports.defineScript = undefined;
  var node_crypto_1 = __require("node:crypto");
  function defineScript(script) {
    return {
      ...script,
      SHA1: scriptSha1(script.SCRIPT)
    };
  }
  exports.defineScript = defineScript;
  function scriptSha1(script) {
    return (0, node_crypto_1.createHash)("sha1").update(script).digest("hex");
  }
  exports.scriptSha1 = scriptSha1;
});

// node_modules/@redis/client/dist/lib/commands/ACL_CAT.js
var require_ACL_CAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, categoryName) {
      parser.push("ACL", "CAT");
      if (categoryName) {
        parser.push(categoryName);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_DELUSER.js
var require_ACL_DELUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username) {
      parser.push("ACL", "DELUSER");
      parser.pushVariadic(username);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_DRYRUN.js
var require_ACL_DRYRUN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username, command) {
      parser.push("ACL", "DRYRUN", username, ...command);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_GENPASS.js
var require_ACL_GENPASS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, bits) {
      parser.push("ACL", "GENPASS");
      if (bits) {
        parser.push(bits.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_GETUSER.js
var require_ACL_GETUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username) {
      parser.push("ACL", "GETUSER", username);
    },
    transformReply: {
      2: (reply) => ({
        flags: reply[1],
        passwords: reply[3],
        commands: reply[5],
        keys: reply[7],
        channels: reply[9],
        selectors: reply[11]?.map((selector) => {
          const inferred = selector;
          return {
            commands: inferred[1],
            keys: inferred[3],
            channels: inferred[5]
          };
        })
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_LIST.js
var require_ACL_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "LIST");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOAD.js
var require_ACL_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "LOAD");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/client/parser.js
var require_parser2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicCommandParser = undefined;

  class BasicCommandParser {
    #redisArgs = [];
    #keys = [];
    preserve;
    get redisArgs() {
      return this.#redisArgs;
    }
    get keys() {
      return this.#keys;
    }
    get firstKey() {
      return this.#keys[0];
    }
    get cacheKey() {
      const tmp = new Array(this.#redisArgs.length * 2);
      for (let i = 0;i < this.#redisArgs.length; i++) {
        tmp[i] = this.#redisArgs[i].length;
        tmp[i + this.#redisArgs.length] = this.#redisArgs[i];
      }
      return tmp.join("_");
    }
    push(...arg) {
      this.#redisArgs.push(...arg);
    }
    pushVariadic(vals) {
      if (Array.isArray(vals)) {
        for (const val of vals) {
          this.push(val);
        }
      } else {
        this.push(vals);
      }
    }
    pushVariadicWithLength(vals) {
      if (Array.isArray(vals)) {
        this.#redisArgs.push(vals.length.toString());
      } else {
        this.#redisArgs.push("1");
      }
      this.pushVariadic(vals);
    }
    pushVariadicNumber(vals) {
      if (Array.isArray(vals)) {
        for (const val of vals) {
          this.push(val.toString());
        }
      } else {
        this.push(vals.toString());
      }
    }
    pushKey(key) {
      this.#keys.push(key);
      this.#redisArgs.push(key);
    }
    pushKeysLength(keys) {
      if (Array.isArray(keys)) {
        this.#redisArgs.push(keys.length.toString());
      } else {
        this.#redisArgs.push("1");
      }
      this.pushKeys(keys);
    }
    pushKeys(keys) {
      if (Array.isArray(keys)) {
        this.#keys.push(...keys);
        this.#redisArgs.push(...keys);
      } else {
        this.#keys.push(keys);
        this.#redisArgs.push(keys);
      }
    }
  }
  exports.BasicCommandParser = BasicCommandParser;
});

// node_modules/@redis/client/dist/lib/commands/generic-transformers.js
var require_generic_transformers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformStreamsMessagesReplyResp3 = exports.transformStreamsMessagesReplyResp2 = exports.transformStreamMessagesReply = exports.transformStreamMessageNullReply = exports.transformStreamMessageReply = exports.parseArgs = exports.parseZKeysArguments = exports.transformRangeReply = exports.parseSlotRangesArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.parseOptionalVariadicArgument = exports.pushVariadicArgument = exports.pushVariadicNumberArguments = exports.pushVariadicArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformSortedSetReply = exports.transformTuplesReply = exports.createTransformTuplesReplyFunc = exports.transformTuplesToMap = exports.transformNullableDoubleReply = exports.createTransformNullableDoubleReplyResp2Func = exports.transformDoubleArrayReply = exports.createTransformDoubleReplyResp2Func = exports.transformDoubleReply = exports.transformStringDoubleArgument = exports.transformDoubleArgument = exports.transformBooleanArrayReply = exports.transformBooleanReply = exports.isArrayReply = exports.isNullReply = undefined;
  var parser_1 = require_parser2();
  var decoder_1 = require_decoder();
  function isNullReply(reply) {
    return reply === null;
  }
  exports.isNullReply = isNullReply;
  function isArrayReply(reply) {
    return Array.isArray(reply);
  }
  exports.isArrayReply = isArrayReply;
  exports.transformBooleanReply = {
    2: (reply) => reply === 1,
    3: undefined
  };
  exports.transformBooleanArrayReply = {
    2: (reply) => {
      return reply.map(exports.transformBooleanReply[2]);
    },
    3: undefined
  };
  function transformDoubleArgument(num) {
    switch (num) {
      case Infinity:
        return "+inf";
      case -Infinity:
        return "-inf";
      default:
        return num.toString();
    }
  }
  exports.transformDoubleArgument = transformDoubleArgument;
  function transformStringDoubleArgument(num) {
    if (typeof num !== "number")
      return num;
    return transformDoubleArgument(num);
  }
  exports.transformStringDoubleArgument = transformStringDoubleArgument;
  exports.transformDoubleReply = {
    2: (reply, preserve, typeMapping) => {
      const double = typeMapping ? typeMapping[decoder_1.RESP_TYPES.DOUBLE] : undefined;
      switch (double) {
        case String: {
          return reply;
        }
        default: {
          let ret;
          switch (reply.toString()) {
            case "inf":
            case "+inf":
              ret = Infinity;
            case "-inf":
              ret = -Infinity;
            case "nan":
              ret = NaN;
            default:
              ret = Number(reply);
          }
          return ret;
        }
      }
    },
    3: undefined
  };
  function createTransformDoubleReplyResp2Func(preserve, typeMapping) {
    return (reply) => {
      return exports.transformDoubleReply[2](reply, preserve, typeMapping);
    };
  }
  exports.createTransformDoubleReplyResp2Func = createTransformDoubleReplyResp2Func;
  exports.transformDoubleArrayReply = {
    2: (reply, preserve, typeMapping) => {
      return reply.map(createTransformDoubleReplyResp2Func(preserve, typeMapping));
    },
    3: undefined
  };
  function createTransformNullableDoubleReplyResp2Func(preserve, typeMapping) {
    return (reply) => {
      return exports.transformNullableDoubleReply[2](reply, preserve, typeMapping);
    };
  }
  exports.createTransformNullableDoubleReplyResp2Func = createTransformNullableDoubleReplyResp2Func;
  exports.transformNullableDoubleReply = {
    2: (reply, preserve, typeMapping) => {
      if (reply === null)
        return null;
      return exports.transformDoubleReply[2](reply, preserve, typeMapping);
    },
    3: undefined
  };
  function transformTuplesToMap(reply, func) {
    const message = Object.create(null);
    for (let i = 0;i < reply.length; i += 2) {
      message[reply[i].toString()] = func(reply[i + 1]);
    }
    return message;
  }
  exports.transformTuplesToMap = transformTuplesToMap;
  function createTransformTuplesReplyFunc(preserve, typeMapping) {
    return (reply) => {
      return transformTuplesReply(reply, preserve, typeMapping);
    };
  }
  exports.createTransformTuplesReplyFunc = createTransformTuplesReplyFunc;
  function transformTuplesReply(reply, preserve, typeMapping) {
    const mapType = typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : undefined;
    const inferred = reply;
    switch (mapType) {
      case Array: {
        return reply;
      }
      case Map: {
        const ret = new Map;
        for (let i = 0;i < inferred.length; i += 2) {
          ret.set(inferred[i].toString(), inferred[i + 1]);
        }
        return ret;
      }
      default: {
        const ret = Object.create(null);
        for (let i = 0;i < inferred.length; i += 2) {
          ret[inferred[i].toString()] = inferred[i + 1];
        }
        return ret;
      }
    }
  }
  exports.transformTuplesReply = transformTuplesReply;
  exports.transformSortedSetReply = {
    2: (reply, preserve, typeMapping) => {
      const inferred = reply, members = [];
      for (let i = 0;i < inferred.length; i += 2) {
        members.push({
          value: inferred[i],
          score: exports.transformDoubleReply[2](inferred[i + 1], preserve, typeMapping)
        });
      }
      return members;
    },
    3: (reply) => {
      return reply.map((member) => {
        const [value, score] = member;
        return {
          value,
          score
        };
      });
    }
  };
  function transformEXAT(EXAT) {
    return (typeof EXAT === "number" ? EXAT : Math.floor(EXAT.getTime() / 1000)).toString();
  }
  exports.transformEXAT = transformEXAT;
  function transformPXAT(PXAT) {
    return (typeof PXAT === "number" ? PXAT : PXAT.getTime()).toString();
  }
  exports.transformPXAT = transformPXAT;
  function evalFirstKeyIndex(options) {
    return options?.keys?.[0];
  }
  exports.evalFirstKeyIndex = evalFirstKeyIndex;
  function pushEvalArguments(args, options) {
    if (options?.keys) {
      args.push(options.keys.length.toString(), ...options.keys);
    } else {
      args.push("0");
    }
    if (options?.arguments) {
      args.push(...options.arguments);
    }
    return args;
  }
  exports.pushEvalArguments = pushEvalArguments;
  function pushVariadicArguments(args, value) {
    if (Array.isArray(value)) {
      args = args.concat(value);
    } else {
      args.push(value);
    }
    return args;
  }
  exports.pushVariadicArguments = pushVariadicArguments;
  function pushVariadicNumberArguments(args, value) {
    if (Array.isArray(value)) {
      for (const item of value) {
        args.push(item.toString());
      }
    } else {
      args.push(value.toString());
    }
    return args;
  }
  exports.pushVariadicNumberArguments = pushVariadicNumberArguments;
  function pushVariadicArgument(args, value) {
    if (Array.isArray(value)) {
      args.push(value.length.toString(), ...value);
    } else {
      args.push("1", value);
    }
    return args;
  }
  exports.pushVariadicArgument = pushVariadicArgument;
  function parseOptionalVariadicArgument(parser, name, value) {
    if (value === undefined)
      return;
    parser.push(name);
    parser.pushVariadicWithLength(value);
  }
  exports.parseOptionalVariadicArgument = parseOptionalVariadicArgument;
  var CommandFlags;
  (function(CommandFlags2) {
    CommandFlags2["WRITE"] = "write";
    CommandFlags2["READONLY"] = "readonly";
    CommandFlags2["DENYOOM"] = "denyoom";
    CommandFlags2["ADMIN"] = "admin";
    CommandFlags2["PUBSUB"] = "pubsub";
    CommandFlags2["NOSCRIPT"] = "noscript";
    CommandFlags2["RANDOM"] = "random";
    CommandFlags2["SORT_FOR_SCRIPT"] = "sort_for_script";
    CommandFlags2["LOADING"] = "loading";
    CommandFlags2["STALE"] = "stale";
    CommandFlags2["SKIP_MONITOR"] = "skip_monitor";
    CommandFlags2["ASKING"] = "asking";
    CommandFlags2["FAST"] = "fast";
    CommandFlags2["MOVABLEKEYS"] = "movablekeys";
  })(CommandFlags || (exports.CommandFlags = CommandFlags = {}));
  var CommandCategories;
  (function(CommandCategories2) {
    CommandCategories2["KEYSPACE"] = "@keyspace";
    CommandCategories2["READ"] = "@read";
    CommandCategories2["WRITE"] = "@write";
    CommandCategories2["SET"] = "@set";
    CommandCategories2["SORTEDSET"] = "@sortedset";
    CommandCategories2["LIST"] = "@list";
    CommandCategories2["HASH"] = "@hash";
    CommandCategories2["STRING"] = "@string";
    CommandCategories2["BITMAP"] = "@bitmap";
    CommandCategories2["HYPERLOGLOG"] = "@hyperloglog";
    CommandCategories2["GEO"] = "@geo";
    CommandCategories2["STREAM"] = "@stream";
    CommandCategories2["PUBSUB"] = "@pubsub";
    CommandCategories2["ADMIN"] = "@admin";
    CommandCategories2["FAST"] = "@fast";
    CommandCategories2["SLOW"] = "@slow";
    CommandCategories2["BLOCKING"] = "@blocking";
    CommandCategories2["DANGEROUS"] = "@dangerous";
    CommandCategories2["CONNECTION"] = "@connection";
    CommandCategories2["TRANSACTION"] = "@transaction";
    CommandCategories2["SCRIPTING"] = "@scripting";
  })(CommandCategories || (exports.CommandCategories = CommandCategories = {}));
  function transformCommandReply([name, arity, flags, firstKeyIndex, lastKeyIndex, step, categories]) {
    return {
      name,
      arity,
      flags: new Set(flags),
      firstKeyIndex,
      lastKeyIndex,
      step,
      categories: new Set(categories)
    };
  }
  exports.transformCommandReply = transformCommandReply;
  var RedisFunctionFlags;
  (function(RedisFunctionFlags2) {
    RedisFunctionFlags2["NO_WRITES"] = "no-writes";
    RedisFunctionFlags2["ALLOW_OOM"] = "allow-oom";
    RedisFunctionFlags2["ALLOW_STALE"] = "allow-stale";
    RedisFunctionFlags2["NO_CLUSTER"] = "no-cluster";
  })(RedisFunctionFlags || (exports.RedisFunctionFlags = RedisFunctionFlags = {}));
  function transformFunctionListItemReply(reply) {
    return {
      libraryName: reply[1],
      engine: reply[3],
      functions: reply[5].map((fn) => ({
        name: fn[1],
        description: fn[3],
        flags: fn[5]
      }))
    };
  }
  exports.transformFunctionListItemReply = transformFunctionListItemReply;
  function parseSlotRangeArguments(parser, range) {
    parser.push(range.start.toString(), range.end.toString());
  }
  function parseSlotRangesArguments(parser, ranges) {
    if (Array.isArray(ranges)) {
      for (const range of ranges) {
        parseSlotRangeArguments(parser, range);
      }
    } else {
      parseSlotRangeArguments(parser, ranges);
    }
  }
  exports.parseSlotRangesArguments = parseSlotRangesArguments;
  function transformRangeReply([start, end]) {
    return {
      start,
      end
    };
  }
  exports.transformRangeReply = transformRangeReply;
  function parseZKeysArguments(parser, keys) {
    if (Array.isArray(keys)) {
      parser.push(keys.length.toString());
      if (keys.length) {
        if (isPlainKeys(keys)) {
          parser.pushKeys(keys);
        } else {
          for (let i = 0;i < keys.length; i++) {
            parser.pushKey(keys[i].key);
          }
          parser.push("WEIGHTS");
          for (let i = 0;i < keys.length; i++) {
            parser.push(transformDoubleArgument(keys[i].weight));
          }
        }
      }
    } else {
      parser.push("1");
      if (isPlainKey(keys)) {
        parser.pushKey(keys);
      } else {
        parser.pushKey(keys.key);
        parser.push("WEIGHTS", transformDoubleArgument(keys.weight));
      }
    }
  }
  exports.parseZKeysArguments = parseZKeysArguments;
  function isPlainKey(key) {
    return typeof key === "string" || key instanceof Buffer;
  }
  function isPlainKeys(keys) {
    return isPlainKey(keys[0]);
  }
  function parseArgs(command, ...args) {
    const parser = new parser_1.BasicCommandParser;
    command.parseCommand(parser, ...args);
    const redisArgs = parser.redisArgs;
    if (parser.preserve) {
      redisArgs.preserve = parser.preserve;
    }
    return redisArgs;
  }
  exports.parseArgs = parseArgs;
  function transformStreamMessageReply(typeMapping, reply) {
    const [id, message] = reply;
    return {
      id,
      message: transformTuplesReply(message, undefined, typeMapping)
    };
  }
  exports.transformStreamMessageReply = transformStreamMessageReply;
  function transformStreamMessageNullReply(typeMapping, reply) {
    return isNullReply(reply) ? reply : transformStreamMessageReply(typeMapping, reply);
  }
  exports.transformStreamMessageNullReply = transformStreamMessageNullReply;
  function transformStreamMessagesReply(r, typeMapping) {
    const reply = r;
    return reply.map(transformStreamMessageReply.bind(undefined, typeMapping));
  }
  exports.transformStreamMessagesReply = transformStreamMessagesReply;
  function transformStreamsMessagesReplyResp2(reply, preserve, typeMapping) {
    if (reply === null)
      return null;
    switch (typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : undefined) {
      default: {
        const ret = [];
        for (let i = 0;i < reply.length; i++) {
          const stream = reply[i];
          ret.push({
            name: stream[0],
            messages: transformStreamMessagesReply(stream[1])
          });
        }
        return ret;
      }
    }
  }
  exports.transformStreamsMessagesReplyResp2 = transformStreamsMessagesReplyResp2;
  function transformStreamsMessagesReplyResp3(reply) {
    if (reply === null)
      return null;
    if (reply instanceof Map) {
      const ret = new Map;
      for (const [n, rawMessages] of reply) {
        const name = n;
        ret.set(name.toString(), transformStreamMessagesReply(rawMessages));
      }
      return ret;
    } else if (reply instanceof Array) {
      const ret = [];
      for (let i = 0;i < reply.length; i += 2) {
        const name = reply[i];
        const rawMessages = reply[i + 1];
        ret.push(name);
        ret.push(transformStreamMessagesReply(rawMessages));
      }
      return ret;
    } else {
      const ret = Object.create(null);
      for (const [name, rawMessages] of Object.entries(reply)) {
        ret[name] = transformStreamMessagesReply(rawMessages);
      }
      return ret;
    }
  }
  exports.transformStreamsMessagesReplyResp3 = transformStreamsMessagesReplyResp3;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOG.js
var require_ACL_LOG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, count) {
      parser.push("ACL", "LOG");
      if (count != null) {
        parser.push(count.toString());
      }
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        return reply.map((item) => {
          const inferred = item;
          return {
            count: inferred[1],
            reason: inferred[3],
            context: inferred[5],
            object: inferred[7],
            username: inferred[9],
            "age-seconds": generic_transformers_1.transformDoubleReply[2](inferred[11], preserve, typeMapping),
            "client-info": inferred[13],
            "entry-id": inferred[15],
            "timestamp-created": inferred[17],
            "timestamp-last-updated": inferred[19]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOG_RESET.js
var require_ACL_LOG_RESET = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ACL_LOG_1 = __importDefault(require_ACL_LOG());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: ACL_LOG_1.default.IS_READ_ONLY,
    parseCommand(parser) {
      parser.push("ACL", "LOG", "RESET");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_SAVE.js
var require_ACL_SAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "SAVE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_SETUSER.js
var require_ACL_SETUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username, rule) {
      parser.push("ACL", "SETUSER", username);
      parser.pushVariadic(rule);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_USERS.js
var require_ACL_USERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "USERS");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_WHOAMI.js
var require_ACL_WHOAMI = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "WHOAMI");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/APPEND.js
var require_APPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, value) {
      parser.push("APPEND", key, value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ASKING.js
var require_ASKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ASKING_CMD = undefined;
  exports.ASKING_CMD = "ASKING";
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push(exports.ASKING_CMD);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/AUTH.js
var require_AUTH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, { username, password }) {
      parser.push("AUTH");
      if (username !== undefined) {
        parser.push(username);
      }
      parser.push(password);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BGREWRITEAOF.js
var require_BGREWRITEAOF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("BGREWRITEAOF");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BGSAVE.js
var require_BGSAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("BGSAVE");
      if (options?.SCHEDULE) {
        parser.push("SCHEDULE");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITCOUNT.js
var require_BITCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, range) {
      parser.push("BITCOUNT");
      parser.pushKey(key);
      if (range) {
        parser.push(range.start.toString());
        parser.push(range.end.toString());
        if (range.mode) {
          parser.push(range.mode);
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITFIELD_RO.js
var require_BITFIELD_RO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, operations) {
      parser.push("BITFIELD_RO");
      parser.pushKey(key);
      for (const operation of operations) {
        parser.push("GET");
        parser.push(operation.encoding);
        parser.push(operation.offset.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITFIELD.js
var require_BITFIELD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, operations) {
      parser.push("BITFIELD");
      parser.pushKey(key);
      for (const options of operations) {
        switch (options.operation) {
          case "GET":
            parser.push("GET", options.encoding, options.offset.toString());
            break;
          case "SET":
            parser.push("SET", options.encoding, options.offset.toString(), options.value.toString());
            break;
          case "INCRBY":
            parser.push("INCRBY", options.encoding, options.offset.toString(), options.increment.toString());
            break;
          case "OVERFLOW":
            parser.push("OVERFLOW", options.behavior);
            break;
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITOP.js
var require_BITOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, operation, destKey, key) {
      parser.push("BITOP", operation);
      parser.pushKey(destKey);
      parser.pushKeys(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITPOS.js
var require_BITPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, bit, start, end, mode) {
      parser.push("BITPOS");
      parser.pushKey(key);
      parser.push(bit.toString());
      if (start !== undefined) {
        parser.push(start.toString());
      }
      if (end !== undefined) {
        parser.push(end.toString());
      }
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BLMOVE.js
var require_BLMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, sourceSide, destinationSide, timeout) {
      parser.push("BLMOVE");
      parser.pushKeys([source, destination]);
      parser.push(sourceSide, destinationSide, timeout.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LMPOP.js
var require_LMPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseLMPopArguments = undefined;
  function parseLMPopArguments(parser, keys, side, options) {
    parser.pushKeysLength(keys);
    parser.push(side);
    if (options?.COUNT !== undefined) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseLMPopArguments = parseLMPopArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, ...args) {
      parser.push("LMPOP");
      parseLMPopArguments(parser, ...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BLMPOP.js
var require_BLMPOP = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LMPOP_1 = __importStar(require_LMPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, timeout, ...args) {
      parser.push("BLMPOP", timeout.toString());
      (0, LMPOP_1.parseLMPopArguments)(parser, ...args);
    },
    transformReply: LMPOP_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/BLPOP.js
var require_BLPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timeout) {
      parser.push("BLPOP");
      parser.pushKeys(key);
      parser.push(timeout.toString());
    },
    transformReply(reply) {
      if (reply === null)
        return null;
      return {
        key: reply[0],
        element: reply[1]
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/BRPOP.js
var require_BRPOP = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BLPOP_1 = __importDefault(require_BLPOP());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timeout) {
      parser.push("BRPOP");
      parser.pushKeys(key);
      parser.push(timeout.toString());
    },
    transformReply: BLPOP_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/BRPOPLPUSH.js
var require_BRPOPLPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, timeout) {
      parser.push("BRPOPLPUSH");
      parser.pushKeys([source, destination]);
      parser.push(timeout.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZMPOP.js
var require_ZMPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseZMPopArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseZMPopArguments(parser, keys, side, options) {
    parser.pushKeysLength(keys);
    parser.push(side);
    if (options?.COUNT) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseZMPopArguments = parseZMPopArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys, side, options) {
      parser.push("ZMPOP");
      parseZMPopArguments(parser, keys, side, options);
    },
    transformReply: {
      2(reply, preserve, typeMapping) {
        return reply === null ? null : {
          key: reply[0],
          members: reply[1].map((member) => {
            const [value, score] = member;
            return {
              value,
              score: generic_transformers_1.transformDoubleReply[2](score, preserve, typeMapping)
            };
          })
        };
      },
      3(reply) {
        return reply === null ? null : {
          key: reply[0],
          members: generic_transformers_1.transformSortedSetReply[3](reply[1])
        };
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/BZMPOP.js
var require_BZMPOP = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZMPOP_1 = __importStar(require_ZMPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, timeout, ...args) {
      parser.push("BZMPOP", timeout.toString());
      (0, ZMPOP_1.parseZMPopArguments)(parser, ...args);
    },
    transformReply: ZMPOP_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/BZPOPMAX.js
var require_BZPOPMAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys, timeout) {
      parser.push("BZPOPMAX");
      parser.pushKeys(keys);
      parser.push(timeout.toString());
    },
    transformReply: {
      2(reply, preserve, typeMapping) {
        return reply === null ? null : {
          key: reply[0],
          value: reply[1],
          score: generic_transformers_1.transformDoubleReply[2](reply[2], preserve, typeMapping)
        };
      },
      3(reply) {
        return reply === null ? null : {
          key: reply[0],
          value: reply[1],
          score: reply[2]
        };
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/BZPOPMIN.js
var require_BZPOPMIN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BZPOPMAX_1 = __importDefault(require_BZPOPMAX());
  exports.default = {
    IS_READ_ONLY: BZPOPMAX_1.default.IS_READ_ONLY,
    parseCommand(parser, keys, timeout) {
      parser.push("BZPOPMIN");
      parser.pushKeys(keys);
      parser.push(timeout.toString());
    },
    transformReply: BZPOPMAX_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_CACHING.js
var require_CLIENT_CACHING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "CACHING", value ? "YES" : "NO");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_GETNAME.js
var require_CLIENT_GETNAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "GETNAME");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_GETREDIR.js
var require_CLIENT_GETREDIR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "GETREDIR");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_ID.js
var require_CLIENT_ID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "ID");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_INFO.js
var require_CLIENT_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CLIENT_INFO_REGEX = /([^\s=]+)=([^\s]*)/g;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "INFO");
    },
    transformReply(rawReply) {
      const map = {};
      for (const item of rawReply.toString().matchAll(CLIENT_INFO_REGEX)) {
        map[item[1]] = item[2];
      }
      const reply = {
        id: Number(map.id),
        addr: map.addr,
        fd: Number(map.fd),
        name: map.name,
        age: Number(map.age),
        idle: Number(map.idle),
        flags: map.flags,
        db: Number(map.db),
        sub: Number(map.sub),
        psub: Number(map.psub),
        multi: Number(map.multi),
        qbuf: Number(map.qbuf),
        qbufFree: Number(map["qbuf-free"]),
        argvMem: Number(map["argv-mem"]),
        obl: Number(map.obl),
        oll: Number(map.oll),
        omem: Number(map.omem),
        totMem: Number(map["tot-mem"]),
        events: map.events,
        cmd: map.cmd,
        user: map.user,
        libName: map["lib-name"],
        libVer: map["lib-ver"]
      };
      if (map.laddr !== undefined) {
        reply.laddr = map.laddr;
      }
      if (map.redir !== undefined) {
        reply.redir = Number(map.redir);
      }
      if (map.ssub !== undefined) {
        reply.ssub = Number(map.ssub);
      }
      if (map["multi-mem"] !== undefined) {
        reply.multiMem = Number(map["multi-mem"]);
      }
      if (map.resp !== undefined) {
        reply.resp = Number(map.resp);
      }
      return reply;
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_KILL.js
var require_CLIENT_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CLIENT_KILL_FILTERS = undefined;
  exports.CLIENT_KILL_FILTERS = {
    ADDRESS: "ADDR",
    LOCAL_ADDRESS: "LADDR",
    ID: "ID",
    TYPE: "TYPE",
    USER: "USER",
    SKIP_ME: "SKIPME",
    MAXAGE: "MAXAGE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filters) {
      parser.push("CLIENT", "KILL");
      if (Array.isArray(filters)) {
        for (const filter of filters) {
          pushFilter(parser, filter);
        }
      } else {
        pushFilter(parser, filters);
      }
    },
    transformReply: undefined
  };
  function pushFilter(parser, filter) {
    if (filter === exports.CLIENT_KILL_FILTERS.SKIP_ME) {
      parser.push("SKIPME");
      return;
    }
    parser.push(filter.filter);
    switch (filter.filter) {
      case exports.CLIENT_KILL_FILTERS.ADDRESS:
        parser.push(filter.address);
        break;
      case exports.CLIENT_KILL_FILTERS.LOCAL_ADDRESS:
        parser.push(filter.localAddress);
        break;
      case exports.CLIENT_KILL_FILTERS.ID:
        parser.push(typeof filter.id === "number" ? filter.id.toString() : filter.id);
        break;
      case exports.CLIENT_KILL_FILTERS.TYPE:
        parser.push(filter.type);
        break;
      case exports.CLIENT_KILL_FILTERS.USER:
        parser.push(filter.username);
        break;
      case exports.CLIENT_KILL_FILTERS.SKIP_ME:
        parser.push(filter.skipMe ? "yes" : "no");
        break;
      case exports.CLIENT_KILL_FILTERS.MAXAGE:
        parser.push(filter.maxAge.toString());
        break;
    }
  }
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_LIST.js
var require_CLIENT_LIST = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var CLIENT_INFO_1 = __importDefault(require_CLIENT_INFO());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter) {
      parser.push("CLIENT", "LIST");
      if (filter) {
        if (filter.TYPE !== undefined) {
          parser.push("TYPE", filter.TYPE);
        } else {
          parser.push("ID");
          parser.pushVariadic(filter.ID);
        }
      }
    },
    transformReply(rawReply) {
      const split = rawReply.toString().split(`
`), length = split.length - 1, reply = [];
      for (let i = 0;i < length; i++) {
        reply.push(CLIENT_INFO_1.default.transformReply(split[i]));
      }
      return reply;
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_NO-EVICT.js
var require_CLIENT_NO_EVICT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "NO-EVICT", value ? "ON" : "OFF");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_NO-TOUCH.js
var require_CLIENT_NO_TOUCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "NO-TOUCH", value ? "ON" : "OFF");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_PAUSE.js
var require_CLIENT_PAUSE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, timeout, mode) {
      parser.push("CLIENT", "PAUSE", timeout.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_SETNAME.js
var require_CLIENT_SETNAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, name) {
      parser.push("CLIENT", "SETNAME", name);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKING.js
var require_CLIENT_TRACKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode, options) {
      parser.push("CLIENT", "TRACKING", mode ? "ON" : "OFF");
      if (mode) {
        if (options?.REDIRECT) {
          parser.push("REDIRECT", options.REDIRECT.toString());
        }
        if (isBroadcast(options)) {
          parser.push("BCAST");
          if (options?.PREFIX) {
            if (Array.isArray(options.PREFIX)) {
              for (const prefix of options.PREFIX) {
                parser.push("PREFIX", prefix);
              }
            } else {
              parser.push("PREFIX", options.PREFIX);
            }
          }
        } else if (isOptIn(options)) {
          parser.push("OPTIN");
        } else if (isOptOut(options)) {
          parser.push("OPTOUT");
        }
        if (options?.NOLOOP) {
          parser.push("NOLOOP");
        }
      }
    },
    transformReply: undefined
  };
  function isBroadcast(options) {
    return options?.BCAST === true;
  }
  function isOptIn(options) {
    return options?.OPTIN === true;
  }
  function isOptOut(options) {
    return options?.OPTOUT === true;
  }
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKINGINFO.js
var require_CLIENT_TRACKINGINFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "TRACKINGINFO");
    },
    transformReply: {
      2: (reply) => ({
        flags: reply[1],
        redirect: reply[3],
        prefixes: reply[5]
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_UNPAUSE.js
var require_CLIENT_UNPAUSE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "UNPAUSE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTS.js
var require_CLUSTER_ADDSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slots) {
      parser.push("CLUSTER", "ADDSLOTS");
      parser.pushVariadicNumber(slots);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTSRANGE.js
var require_CLUSTER_ADDSLOTSRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ranges) {
      parser.push("CLUSTER", "ADDSLOTSRANGE");
      (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_BUMPEPOCH.js
var require_CLUSTER_BUMPEPOCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "BUMPEPOCH");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNT-FAILURE-REPORTS.js
var require_CLUSTER_COUNT_FAILURE_REPORTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "COUNT-FAILURE-REPORTS", nodeId);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNTKEYSINSLOT.js
var require_CLUSTER_COUNTKEYSINSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot) {
      parser.push("CLUSTER", "COUNTKEYSINSLOT", slot.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTS.js
var require_CLUSTER_DELSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slots) {
      parser.push("CLUSTER", "DELSLOTS");
      parser.pushVariadicNumber(slots);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTSRANGE.js
var require_CLUSTER_DELSLOTSRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ranges) {
      parser.push("CLUSTER", "DELSLOTSRANGE");
      (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FAILOVER.js
var require_CLUSTER_FAILOVER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FAILOVER_MODES = undefined;
  exports.FAILOVER_MODES = {
    FORCE: "FORCE",
    TAKEOVER: "TAKEOVER"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("CLUSTER", "FAILOVER");
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FLUSHSLOTS.js
var require_CLUSTER_FLUSHSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "FLUSHSLOTS");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FORGET.js
var require_CLUSTER_FORGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "FORGET", nodeId);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_GETKEYSINSLOT.js
var require_CLUSTER_GETKEYSINSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot, count) {
      parser.push("CLUSTER", "GETKEYSINSLOT", slot.toString(), count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_INFO.js
var require_CLUSTER_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "INFO");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_KEYSLOT.js
var require_CLUSTER_KEYSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CLUSTER", "KEYSLOT", key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_LINKS.js
var require_CLUSTER_LINKS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "LINKS");
    },
    transformReply: {
      2: (reply) => reply.map((link) => {
        const unwrapped = link;
        return {
          direction: unwrapped[1],
          node: unwrapped[3],
          "create-time": unwrapped[5],
          events: unwrapped[7],
          "send-buffer-allocated": unwrapped[9],
          "send-buffer-used": unwrapped[11]
        };
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MEET.js
var require_CLUSTER_MEET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, host, port) {
      parser.push("CLUSTER", "MEET", host, port.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MYID.js
var require_CLUSTER_MYID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "MYID");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MYSHARDID.js
var require_CLUSTER_MYSHARDID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "MYSHARDID");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_NODES.js
var require_CLUSTER_NODES = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "NODES");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICAS.js
var require_CLUSTER_REPLICAS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "REPLICAS", nodeId);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICATE.js
var require_CLUSTER_REPLICATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "REPLICATE", nodeId);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_RESET.js
var require_CLUSTER_RESET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("CLUSTER", "RESET");
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SAVECONFIG.js
var require_CLUSTER_SAVECONFIG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "SAVECONFIG");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SET-CONFIG-EPOCH.js
var require_CLUSTER_SET_CONFIG_EPOCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, configEpoch) {
      parser.push("CLUSTER", "SET-CONFIG-EPOCH", configEpoch.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SETSLOT.js
var require_CLUSTER_SETSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CLUSTER_SLOT_STATES = undefined;
  exports.CLUSTER_SLOT_STATES = {
    IMPORTING: "IMPORTING",
    MIGRATING: "MIGRATING",
    STABLE: "STABLE",
    NODE: "NODE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot, state, nodeId) {
      parser.push("CLUSTER", "SETSLOT", slot.toString(), state);
      if (nodeId) {
        parser.push(nodeId);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SLOTS.js
var require_CLUSTER_SLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "SLOTS");
    },
    transformReply(reply) {
      return reply.map(([from, to, master, ...replicas]) => ({
        from,
        to,
        master: transformNode(master),
        replicas: replicas.map(transformNode)
      }));
    }
  };
  function transformNode(node) {
    const [host, port, id] = node;
    return {
      host,
      port,
      id
    };
  }
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_COUNT.js
var require_COMMAND_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("COMMAND", "COUNT");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYS.js
var require_COMMAND_GETKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, args) {
      parser.push("COMMAND", "GETKEYS");
      parser.push(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYSANDFLAGS.js
var require_COMMAND_GETKEYSANDFLAGS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, args) {
      parser.push("COMMAND", "GETKEYSANDFLAGS");
      parser.push(...args);
    },
    transformReply(reply) {
      return reply.map((entry) => {
        const [key, flags] = entry;
        return {
          key,
          flags
        };
      });
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_INFO.js
var require_COMMAND_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, commands) {
      parser.push("COMMAND", "INFO", ...commands);
    },
    transformReply(reply) {
      return reply.map((command) => command ? (0, generic_transformers_1.transformCommandReply)(command) : null);
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_LIST.js
var require_COMMAND_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.COMMAND_LIST_FILTER_BY = undefined;
  exports.COMMAND_LIST_FILTER_BY = {
    MODULE: "MODULE",
    ACLCAT: "ACLCAT",
    PATTERN: "PATTERN"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("COMMAND", "LIST");
      if (options?.FILTERBY) {
        parser.push("FILTERBY", options.FILTERBY.type, options.FILTERBY.value);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND.js
var require_COMMAND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("COMMAND");
    },
    transformReply(reply) {
      return reply.map(generic_transformers_1.transformCommandReply);
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_GET.js
var require_CONFIG_GET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, parameters) {
      parser.push("CONFIG", "GET");
      parser.pushVariadic(parameters);
    },
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_RESETSTAT.js
var require_CONFIG_RESETSTAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CONFIG", "RESETSTAT");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_REWRITE.js
var require_CONFIG_REWRITE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CONFIG", "REWRITE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_SET.js
var require_CONFIG_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ...[parameterOrConfig, value]) {
      parser.push("CONFIG", "SET");
      if (typeof parameterOrConfig === "string" || parameterOrConfig instanceof Buffer) {
        parser.push(parameterOrConfig, value);
      } else {
        for (const [key, value2] of Object.entries(parameterOrConfig)) {
          parser.push(key, value2);
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/COPY.js
var require_COPY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, options) {
      parser.push("COPY");
      parser.pushKeys([source, destination]);
      if (options?.DB) {
        parser.push("DB", options.DB.toString());
      }
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DBSIZE.js
var require_DBSIZE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("DBSIZE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DECR.js
var require_DECR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("DECR");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DECRBY.js
var require_DECRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, decrement) {
      parser.push("DECRBY");
      parser.pushKey(key);
      parser.push(decrement.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DEL.js
var require_DEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys) {
      parser.push("DEL");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DUMP.js
var require_DUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("DUMP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ECHO.js
var require_ECHO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, message) {
      parser.push("ECHO", message);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EVAL.js
var require_EVAL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEvalArguments = undefined;
  function parseEvalArguments(parser, script, options) {
    parser.push(script);
    if (options?.keys) {
      parser.pushKeysLength(options.keys);
    } else {
      parser.push("0");
    }
    if (options?.arguments) {
      parser.push(...options.arguments);
    }
  }
  exports.parseEvalArguments = parseEvalArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("EVAL");
      parseEvalArguments(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EVAL_RO.js
var require_EVAL_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("EVAL_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/EVALSHA_RO.js
var require_EVALSHA_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("EVALSHA_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/EVALSHA.js
var require_EVALSHA = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("EVALSHA");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOADD.js
var require_GEOADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, toAdd, options) {
      parser.push("GEOADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.CH) {
        parser.push("CH");
      }
      if (Array.isArray(toAdd)) {
        for (const member of toAdd) {
          pushMember(parser, member);
        }
      } else {
        pushMember(parser, toAdd);
      }
    },
    transformReply: undefined
  };
  function pushMember(parser, { longitude, latitude, member }) {
    parser.push(longitude.toString(), latitude.toString(), member);
  }
});

// node_modules/@redis/client/dist/lib/commands/GEODIST.js
var require_GEODIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member1, member2, unit) {
      parser.push("GEODIST");
      parser.pushKey(key);
      parser.push(member1, member2);
      if (unit) {
        parser.push(unit);
      }
    },
    transformReply(reply) {
      return reply === null ? null : Number(reply);
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOHASH.js
var require_GEOHASH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("GEOHASH");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOPOS.js
var require_GEOPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("GEOPOS");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply(reply) {
      return reply.map((item) => {
        const unwrapped = item;
        return unwrapped === null ? null : {
          longitude: unwrapped[0],
          latitude: unwrapped[1]
        };
      });
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCH.js
var require_GEOSEARCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoSearchOptions = exports.parseGeoSearchArguments = undefined;
  function parseGeoSearchArguments(parser, key, from, by, options) {
    parser.pushKey(key);
    if (typeof from === "string" || from instanceof Buffer) {
      parser.push("FROMMEMBER", from);
    } else {
      parser.push("FROMLONLAT", from.longitude.toString(), from.latitude.toString());
    }
    if ("radius" in by) {
      parser.push("BYRADIUS", by.radius.toString(), by.unit);
    } else {
      parser.push("BYBOX", by.width.toString(), by.height.toString(), by.unit);
    }
    parseGeoSearchOptions(parser, options);
  }
  exports.parseGeoSearchArguments = parseGeoSearchArguments;
  function parseGeoSearchOptions(parser, options) {
    if (options?.SORT) {
      parser.push(options.SORT);
    }
    if (options?.COUNT) {
      if (typeof options.COUNT === "number") {
        parser.push("COUNT", options.COUNT.toString());
      } else {
        parser.push("COUNT", options.COUNT.value.toString());
        if (options.COUNT.ANY) {
          parser.push("ANY");
        }
      }
    }
  }
  exports.parseGeoSearchOptions = parseGeoSearchOptions;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, from, by, options) {
      parser.push("GEOSEARCH");
      parseGeoSearchArguments(parser, key, from, by, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS.js
var require_GEORADIUS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusArguments = undefined;
  var GEOSEARCH_1 = require_GEOSEARCH();
  function parseGeoRadiusArguments(parser, key, from, radius, unit, options) {
    parser.pushKey(key);
    parser.push(from.longitude.toString(), from.latitude.toString(), radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
  }
  exports.parseGeoRadiusArguments = parseGeoRadiusArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("GEORADIUS");
      return parseGeoRadiusArguments(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCH_WITH.js
var require_GEOSEARCH_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GEO_REPLY_WITH = undefined;
  var GEOSEARCH_1 = __importDefault(require_GEOSEARCH());
  exports.GEO_REPLY_WITH = {
    DISTANCE: "WITHDIST",
    HASH: "WITHHASH",
    COORDINATES: "WITHCOORD"
  };
  exports.default = {
    IS_READ_ONLY: GEOSEARCH_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, by, replyWith, options) {
      GEOSEARCH_1.default.parseCommand(parser, key, from, by, options);
      parser.push(...replyWith);
      parser.preserve = replyWith;
    },
    transformReply(reply, replyWith) {
      const replyWithSet = new Set(replyWith);
      let index = 0;
      const distanceIndex = replyWithSet.has(exports.GEO_REPLY_WITH.DISTANCE) && ++index, hashIndex = replyWithSet.has(exports.GEO_REPLY_WITH.HASH) && ++index, coordinatesIndex = replyWithSet.has(exports.GEO_REPLY_WITH.COORDINATES) && ++index;
      return reply.map((raw) => {
        const unwrapped = raw;
        const item = {
          member: unwrapped[0]
        };
        if (distanceIndex) {
          item.distance = unwrapped[distanceIndex];
        }
        if (hashIndex) {
          item.hash = unwrapped[hashIndex];
        }
        if (coordinatesIndex) {
          const [longitude, latitude] = unwrapped[coordinatesIndex];
          item.coordinates = {
            longitude,
            latitude
          };
        }
        return item;
      });
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_WITH.js
var require_GEORADIUS_WITH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusWithArguments = undefined;
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  function parseGeoRadiusWithArguments(parser, key, from, radius, unit, replyWith, options) {
    (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from, radius, unit, options);
    parser.pushVariadic(replyWith);
    parser.preserve = replyWith;
  }
  exports.parseGeoRadiusWithArguments = parseGeoRadiusWithArguments;
  exports.default = {
    IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, replyWith, options) {
      parser.push("GEORADIUS");
      parseGeoRadiusWithArguments(parser, key, from, radius, unit, replyWith, options);
    },
    transformReply: GEOSEARCH_WITH_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO_WITH.js
var require_GEORADIUS_RO_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_WITH_1 = require_GEORADIUS_WITH();
  var GEORADIUS_WITH_2 = __importDefault(require_GEORADIUS_WITH());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("GEORADIUS_RO");
      (0, GEORADIUS_WITH_1.parseGeoRadiusWithArguments)(...args);
    },
    transformReply: GEORADIUS_WITH_2.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO.js
var require_GEORADIUS_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("GEORADIUS_RO");
      (0, GEORADIUS_1.parseGeoRadiusArguments)(...args);
    },
    transformReply: GEORADIUS_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_STORE.js
var require_GEORADIUS_STORE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  exports.default = {
    IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, destination, options) {
      parser.push("GEORADIUS");
      (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from, radius, unit, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
        parser.pushKey(destination);
      } else {
        parser.push("STORE");
        parser.pushKey(destination);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER.js
var require_GEORADIUSBYMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusByMemberArguments = undefined;
  var GEOSEARCH_1 = require_GEOSEARCH();
  function parseGeoRadiusByMemberArguments(parser, key, from, radius, unit, options) {
    parser.pushKey(key);
    parser.push(from, radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
  }
  exports.parseGeoRadiusByMemberArguments = parseGeoRadiusByMemberArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, from, radius, unit, options) {
      parser.push("GEORADIUSBYMEMBER");
      parseGeoRadiusByMemberArguments(parser, key, from, radius, unit, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_WITH.js
var require_GEORADIUSBYMEMBER_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusByMemberWithArguments = undefined;
  var GEORADIUSBYMEMBER_1 = __importDefault(require_GEORADIUSBYMEMBER());
  var GEOSEARCH_1 = require_GEOSEARCH();
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  function parseGeoRadiusByMemberWithArguments(parser, key, from, radius, unit, replyWith, options) {
    parser.pushKey(key);
    parser.push(from, radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
    parser.push(...replyWith);
    parser.preserve = replyWith;
  }
  exports.parseGeoRadiusByMemberWithArguments = parseGeoRadiusByMemberWithArguments;
  exports.default = {
    IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, replyWith, options) {
      parser.push("GEORADIUSBYMEMBER");
      parseGeoRadiusByMemberWithArguments(parser, key, from, radius, unit, replyWith, options);
    },
    transformReply: GEOSEARCH_WITH_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO_WITH.js
var require_GEORADIUSBYMEMBER_RO_WITH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_WITH_1 = __importStar(require_GEORADIUSBYMEMBER_WITH());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("GEORADIUSBYMEMBER_RO");
      (0, GEORADIUSBYMEMBER_WITH_1.parseGeoRadiusByMemberWithArguments)(...args);
    },
    transformReply: GEORADIUSBYMEMBER_WITH_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO.js
var require_GEORADIUSBYMEMBER_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_1 = __importStar(require_GEORADIUSBYMEMBER());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("GEORADIUSBYMEMBER_RO");
      (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(...args);
    },
    transformReply: GEORADIUSBYMEMBER_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_STORE.js
var require_GEORADIUSBYMEMBER_STORE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_1 = __importStar(require_GEORADIUSBYMEMBER());
  exports.default = {
    IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, destination, options) {
      parser.push("GEORADIUSBYMEMBER");
      (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(parser, key, from, radius, unit, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
        parser.pushKey(destination);
      } else {
        parser.push("STORE");
        parser.pushKey(destination);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCHSTORE.js
var require_GEOSEARCHSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEOSEARCH_1 = require_GEOSEARCH();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, from, by, options) {
      parser.push("GEOSEARCHSTORE");
      if (destination !== undefined) {
        parser.pushKey(destination);
      }
      (0, GEOSEARCH_1.parseGeoSearchArguments)(parser, source, from, by, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GET.js
var require_GET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("GET");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETBIT.js
var require_GETBIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, offset) {
      parser.push("GETBIT");
      parser.pushKey(key);
      parser.push(offset.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETDEL.js
var require_GETDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("GETDEL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETEX.js
var require_GETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("GETEX");
      parser.pushKey(key);
      if ("type" in options) {
        switch (options.type) {
          case "EX":
          case "PX":
            parser.push(options.type, options.value.toString());
            break;
          case "EXAT":
          case "PXAT":
            parser.push(options.type, (0, generic_transformers_1.transformEXAT)(options.value));
            break;
          case "PERSIST":
            parser.push("PERSIST");
            break;
        }
      } else {
        if ("EX" in options) {
          parser.push("EX", options.EX.toString());
        } else if ("PX" in options) {
          parser.push("PX", options.PX.toString());
        } else if ("EXAT" in options) {
          parser.push("EXAT", (0, generic_transformers_1.transformEXAT)(options.EXAT));
        } else if ("PXAT" in options) {
          parser.push("PXAT", (0, generic_transformers_1.transformPXAT)(options.PXAT));
        } else {
          parser.push("PERSIST");
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETRANGE.js
var require_GETRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, start, end) {
      parser.push("GETRANGE");
      parser.pushKey(key);
      parser.push(start.toString(), end.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETSET.js
var require_GETSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, value) {
      parser.push("GETSET");
      parser.pushKey(key);
      parser.push(value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EXISTS.js
var require_EXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("EXISTS");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EXPIRE.js
var require_EXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, seconds, mode) {
      parser.push("EXPIRE");
      parser.pushKey(key);
      parser.push(seconds.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EXPIREAT.js
var require_EXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timestamp, mode) {
      parser.push("EXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EXPIRETIME.js
var require_EXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("EXPIRETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FLUSHALL.js
var require_FLUSHALL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.REDIS_FLUSH_MODES = undefined;
  exports.REDIS_FLUSH_MODES = {
    ASYNC: "ASYNC",
    SYNC: "SYNC"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FLUSHALL");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FLUSHDB.js
var require_FLUSHDB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FLUSHDB");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FCALL.js
var require_FCALL = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("FCALL");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/FCALL_RO.js
var require_FCALL_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("FCALL_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_DELETE.js
var require_FUNCTION_DELETE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, library) {
      parser.push("FUNCTION", "DELETE", library);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_DUMP.js
var require_FUNCTION_DUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "DUMP");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_FLUSH.js
var require_FUNCTION_FLUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FUNCTION", "FLUSH");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_KILL.js
var require_FUNCTION_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "KILL");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST.js
var require_FUNCTION_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, options) {
      parser.push("FUNCTION", "LIST");
      if (options?.LIBRARYNAME) {
        parser.push("LIBRARYNAME", options.LIBRARYNAME);
      }
    },
    transformReply: {
      2: (reply) => {
        return reply.map((library) => {
          const unwrapped = library;
          return {
            library_name: unwrapped[1],
            engine: unwrapped[3],
            functions: unwrapped[5].map((fn) => {
              const unwrapped2 = fn;
              return {
                name: unwrapped2[1],
                description: unwrapped2[3],
                flags: unwrapped2[5]
              };
            })
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST_WITHCODE.js
var require_FUNCTION_LIST_WITHCODE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var FUNCTION_LIST_1 = __importDefault(require_FUNCTION_LIST());
  exports.default = {
    NOT_KEYED_COMMAND: FUNCTION_LIST_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: FUNCTION_LIST_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      FUNCTION_LIST_1.default.parseCommand(...args);
      args[0].push("WITHCODE");
    },
    transformReply: {
      2: (reply) => {
        return reply.map((library) => {
          const unwrapped = library;
          return {
            library_name: unwrapped[1],
            engine: unwrapped[3],
            functions: unwrapped[5].map((fn) => {
              const unwrapped2 = fn;
              return {
                name: unwrapped2[1],
                description: unwrapped2[3],
                flags: unwrapped2[5]
              };
            }),
            library_code: unwrapped[7]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LOAD.js
var require_FUNCTION_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, code, options) {
      parser.push("FUNCTION", "LOAD");
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      parser.push(code);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_RESTORE.js
var require_FUNCTION_RESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, dump, options) {
      parser.push("FUNCTION", "RESTORE", dump);
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_STATS.js
var require_FUNCTION_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "STATS");
    },
    transformReply: {
      2: (reply) => {
        return {
          running_script: transformRunningScript(reply[1]),
          engines: transformEngines(reply[3])
        };
      },
      3: undefined
    }
  };
  function transformRunningScript(reply) {
    if ((0, generic_transformers_1.isNullReply)(reply)) {
      return null;
    }
    const unwraped = reply;
    return {
      name: unwraped[1],
      command: unwraped[3],
      duration_ms: unwraped[5]
    };
  }
  function transformEngines(reply) {
    const unwraped = reply;
    const engines = Object.create(null);
    for (let i = 0;i < unwraped.length; i++) {
      const name = unwraped[i], stats = unwraped[++i], unwrapedStats = stats;
      engines[name.toString()] = {
        libraries_count: unwrapedStats[1],
        functions_count: unwrapedStats[3]
      };
    }
    return engines;
  }
});

// node_modules/@redis/client/dist/lib/commands/HDEL.js
var require_HDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field) {
      parser.push("HDEL");
      parser.pushKey(key);
      parser.pushVariadic(field);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HELLO.js
var require_HELLO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, protover, options) {
      parser.push("HELLO");
      if (protover) {
        parser.push(protover.toString());
        if (options?.AUTH) {
          parser.push("AUTH", options.AUTH.username, options.AUTH.password);
        }
        if (options?.SETNAME) {
          parser.push("SETNAME", options.SETNAME);
        }
      }
    },
    transformReply: {
      2: (reply) => ({
        server: reply[1],
        version: reply[3],
        proto: reply[5],
        id: reply[7],
        mode: reply[9],
        role: reply[11],
        modules: reply[13]
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HEXISTS.js
var require_HEXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HEXISTS");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HEXPIRE.js
var require_HEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HASH_EXPIRATION = undefined;
  exports.HASH_EXPIRATION = {
    FIELD_NOT_EXISTS: -2,
    CONDITION_NOT_MET: 0,
    UPDATED: 1,
    DELETED: 2
  };
  exports.default = {
    parseCommand(parser, key, fields, seconds, mode) {
      parser.push("HEXPIRE");
      parser.pushKey(key);
      parser.push(seconds.toString());
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HEXPIREAT.js
var require_HEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, fields, timestamp, mode) {
      parser.push("HEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HEXPIRETIME.js
var require_HEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HASH_EXPIRATION_TIME = undefined;
  exports.HASH_EXPIRATION_TIME = {
    FIELD_NOT_EXISTS: -2,
    NO_EXPIRATION: -1
  };
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HEXPIRETIME");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HGET.js
var require_HGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HGET");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HGETALL.js
var require_HGETALL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HGETALL");
      parser.pushKey(key);
    },
    TRANSFORM_LEGACY_REPLY: true,
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HGETDEL.js
var require_HGETDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields) {
      parser.push("HGETDEL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HGETEX.js
var require_HGETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields, options) {
      parser.push("HGETEX");
      parser.pushKey(key);
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "PERSIST") {
          parser.push("PERSIST");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HINCRBY.js
var require_HINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field, increment) {
      parser.push("HINCRBY");
      parser.pushKey(key);
      parser.push(field, increment.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HINCRBYFLOAT.js
var require_HINCRBYFLOAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field, increment) {
      parser.push("HINCRBYFLOAT");
      parser.pushKey(key);
      parser.push(field, increment.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HKEYS.js
var require_HKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HKEYS");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HLEN.js
var require_HLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HMGET.js
var require_HMGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HMGET");
      parser.pushKey(key);
      parser.pushVariadic(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPERSIST.js
var require_HPERSIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields) {
      parser.push("HPERSIST");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIRE.js
var require_HPEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields, ms, mode) {
      parser.push("HPEXPIRE");
      parser.pushKey(key);
      parser.push(ms.toString());
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIREAT.js
var require_HPEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields, timestamp, mode) {
      parser.push("HPEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformPXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIRETIME.js
var require_HPEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HPEXPIRETIME");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPTTL.js
var require_HPTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HPTTL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT_WITHVALUES.js
var require_HRANDFIELD_COUNT_WITHVALUES = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
      parser.push(count.toString(), "WITHVALUES");
    },
    transformReply: {
      2: (rawReply) => {
        const reply = [];
        let i = 0;
        while (i < rawReply.length) {
          reply.push({
            field: rawReply[i++],
            value: rawReply[i++]
          });
        }
        return reply;
      },
      3: (reply) => {
        return reply.map((entry) => {
          const [field, value] = entry;
          return {
            field,
            value
          };
        });
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT.js
var require_HRANDFIELD_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD.js
var require_HRANDFIELD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCAN.js
var require_SCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushScanArguments = exports.parseScanArguments = undefined;
  function parseScanArguments(parser, cursor, options) {
    parser.push(cursor);
    if (options?.MATCH) {
      parser.push("MATCH", options.MATCH);
    }
    if (options?.COUNT) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseScanArguments = parseScanArguments;
  function pushScanArguments(args, cursor, options) {
    args.push(cursor.toString());
    if (options?.MATCH) {
      args.push("MATCH", options.MATCH);
    }
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  }
  exports.pushScanArguments = pushScanArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, cursor, options) {
      parser.push("SCAN");
      parseScanArguments(parser, cursor, options);
      if (options?.TYPE) {
        parser.push("TYPE", options.TYPE);
      }
    },
    transformReply([cursor, keys]) {
      return {
        cursor,
        keys
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HSCAN.js
var require_HSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("HSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, rawEntries]) {
      const entries = [];
      let i = 0;
      while (i < rawEntries.length) {
        entries.push({
          field: rawEntries[i++],
          value: rawEntries[i++]
        });
      }
      return {
        cursor,
        entries
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HSCAN_NOVALUES.js
var require_HSCAN_NOVALUES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var HSCAN_1 = __importDefault(require_HSCAN());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      HSCAN_1.default.parseCommand(...args);
      parser.push("NOVALUES");
    },
    transformReply([cursor, fields]) {
      return {
        cursor,
        fields
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HSET.js
var require_HSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, ...[key, value, fieldValue]) {
      parser.push("HSET");
      parser.pushKey(key);
      if (typeof value === "string" || typeof value === "number" || value instanceof Buffer) {
        parser.push(convertValue(value), convertValue(fieldValue));
      } else if (value instanceof Map) {
        pushMap(parser, value);
      } else if (Array.isArray(value)) {
        pushTuples(parser, value);
      } else {
        pushObject(parser, value);
      }
    },
    transformReply: undefined
  };
  function pushMap(parser, map) {
    for (const [key, value] of map.entries()) {
      parser.push(convertValue(key), convertValue(value));
    }
  }
  function pushTuples(parser, tuples) {
    for (const tuple of tuples) {
      if (Array.isArray(tuple)) {
        pushTuples(parser, tuple);
        continue;
      }
      parser.push(convertValue(tuple));
    }
  }
  function pushObject(parser, object) {
    for (const key of Object.keys(object)) {
      parser.push(convertValue(key), convertValue(object[key]));
    }
  }
  function convertValue(value) {
    return typeof value === "number" ? value.toString() : value;
  }
});

// node_modules/@redis/client/dist/lib/commands/HSETEX.js
var require_HSETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var parser_1 = require_parser2();
  exports.default = {
    parseCommand(parser, key, fields, options) {
      parser.push("HSETEX");
      parser.pushKey(key);
      if (options?.mode) {
        parser.push(options.mode);
      }
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "KEEPTTL") {
          parser.push("KEEPTTL");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      }
      parser.push("FIELDS");
      if (fields instanceof Map) {
        pushMap(parser, fields);
      } else if (Array.isArray(fields)) {
        pushTuples(parser, fields);
      } else {
        pushObject(parser, fields);
      }
    },
    transformReply: undefined
  };
  function pushMap(parser, map) {
    parser.push(map.size.toString());
    for (const [key, value] of map.entries()) {
      parser.push(convertValue(key), convertValue(value));
    }
  }
  function pushTuples(parser, tuples) {
    const tmpParser = new parser_1.BasicCommandParser;
    _pushTuples(tmpParser, tuples);
    if (tmpParser.redisArgs.length % 2 != 0) {
      throw Error("invalid number of arguments, expected key value ....[key value] pairs, got key without value");
    }
    parser.push((tmpParser.redisArgs.length / 2).toString());
    parser.push(...tmpParser.redisArgs);
  }
  function _pushTuples(parser, tuples) {
    for (const tuple of tuples) {
      if (Array.isArray(tuple)) {
        _pushTuples(parser, tuple);
        continue;
      }
      parser.push(convertValue(tuple));
    }
  }
  function pushObject(parser, object) {
    const len = Object.keys(object).length;
    if (len == 0) {
      throw Error("object without keys");
    }
    parser.push(len.toString());
    for (const key of Object.keys(object)) {
      parser.push(convertValue(key), convertValue(object[key]));
    }
  }
  function convertValue(value) {
    return typeof value === "number" ? value.toString() : value;
  }
});

// node_modules/@redis/client/dist/lib/commands/HSETNX.js
var require_HSETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, field, value) {
      parser.push("HSETNX");
      parser.pushKey(key);
      parser.push(field, value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HSTRLEN.js
var require_HSTRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HSTRLEN");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HTTL.js
var require_HTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HTTL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HVALS.js
var require_HVALS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HVALS");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/INCR.js
var require_INCR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("INCR");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/INCRBY.js
var require_INCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, increment) {
      parser.push("INCRBY");
      parser.pushKey(key);
      parser.push(increment.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/INCRBYFLOAT.js
var require_INCRBYFLOAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, increment) {
      parser.push("INCRBYFLOAT");
      parser.pushKey(key);
      parser.push(increment.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/INFO.js
var require_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, section) {
      parser.push("INFO");
      if (section) {
        parser.push(section);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/KEYS.js
var require_KEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("KEYS", pattern);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LASTSAVE.js
var require_LASTSAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LASTSAVE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_DOCTOR.js
var require_LATENCY_DOCTOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LATENCY", "DOCTOR");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_GRAPH.js
var require_LATENCY_GRAPH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LATENCY_EVENTS = undefined;
  exports.LATENCY_EVENTS = {
    ACTIVE_DEFRAG_CYCLE: "active-defrag-cycle",
    AOF_FSYNC_ALWAYS: "aof-fsync-always",
    AOF_STAT: "aof-stat",
    AOF_REWRITE_DIFF_WRITE: "aof-rewrite-diff-write",
    AOF_RENAME: "aof-rename",
    AOF_WRITE: "aof-write",
    AOF_WRITE_ACTIVE_CHILD: "aof-write-active-child",
    AOF_WRITE_ALONE: "aof-write-alone",
    AOF_WRITE_PENDING_FSYNC: "aof-write-pending-fsync",
    COMMAND: "command",
    EXPIRE_CYCLE: "expire-cycle",
    EVICTION_CYCLE: "eviction-cycle",
    EVICTION_DEL: "eviction-del",
    FAST_COMMAND: "fast-command",
    FORK: "fork",
    RDB_UNLINK_TEMP_FILE: "rdb-unlink-temp-file"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, event) {
      parser.push("LATENCY", "GRAPH", event);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_HISTORY.js
var require_LATENCY_HISTORY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, event) {
      parser.push("LATENCY", "HISTORY", event);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_LATEST.js
var require_LATENCY_LATEST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LATENCY", "LATEST");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LCS.js
var require_LCS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key1, key2) {
      parser.push("LCS");
      parser.pushKeys([key1, key2]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LCS_IDX.js
var require_LCS_IDX = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_1 = __importDefault(require_LCS());
  exports.default = {
    IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
    parseCommand(parser, key1, key2, options) {
      LCS_1.default.parseCommand(parser, key1, key2);
      parser.push("IDX");
      if (options?.MINMATCHLEN) {
        parser.push("MINMATCHLEN", options.MINMATCHLEN.toString());
      }
    },
    transformReply: {
      2: (reply) => ({
        matches: reply[1],
        len: reply[3]
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/LCS_IDX_WITHMATCHLEN.js
var require_LCS_IDX_WITHMATCHLEN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_IDX_1 = __importDefault(require_LCS_IDX());
  exports.default = {
    IS_READ_ONLY: LCS_IDX_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      LCS_IDX_1.default.parseCommand(...args);
      parser.push("WITHMATCHLEN");
    },
    transformReply: {
      2: (reply) => ({
        matches: reply[1],
        len: reply[3]
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/LCS_LEN.js
var require_LCS_LEN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_1 = __importDefault(require_LCS());
  exports.default = {
    IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      LCS_1.default.parseCommand(...args);
      parser.push("LEN");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LINDEX.js
var require_LINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, index) {
      parser.push("LINDEX");
      parser.pushKey(key);
      parser.push(index.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LINSERT.js
var require_LINSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, position, pivot, element) {
      parser.push("LINSERT");
      parser.pushKey(key);
      parser.push(position, pivot, element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LLEN.js
var require_LLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("LLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LMOVE.js
var require_LMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, sourceSide, destinationSide) {
      parser.push("LMOVE");
      parser.pushKeys([source, destination]);
      parser.push(sourceSide, destinationSide);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LOLWUT.js
var require_LOLWUT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, version, ...optionalArguments) {
      parser.push("LOLWUT");
      if (version) {
        parser.push("VERSION", version.toString());
        parser.pushVariadic(optionalArguments.map(String));
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPOP.js
var require_LPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("LPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPOP_COUNT.js
var require_LPOP_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LPOP_1 = __importDefault(require_LPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      LPOP_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPOS.js
var require_LPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, element, options) {
      parser.push("LPOS");
      parser.pushKey(key);
      parser.push(element);
      if (options?.RANK !== undefined) {
        parser.push("RANK", options.RANK.toString());
      }
      if (options?.MAXLEN !== undefined) {
        parser.push("MAXLEN", options.MAXLEN.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPOS_COUNT.js
var require_LPOS_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LPOS_1 = __importDefault(require_LPOS());
  exports.default = {
    CACHEABLE: LPOS_1.default.CACHEABLE,
    IS_READ_ONLY: LPOS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, element, count, options) {
      LPOS_1.default.parseCommand(parser, key, element, options);
      parser.push("COUNT", count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPUSH.js
var require_LPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, elements) {
      parser.push("LPUSH");
      parser.pushKey(key);
      parser.pushVariadic(elements);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPUSHX.js
var require_LPUSHX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, elements) {
      parser.push("LPUSHX");
      parser.pushKey(key);
      parser.pushVariadic(elements);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LRANGE.js
var require_LRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, start, stop) {
      parser.push("LRANGE");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LREM.js
var require_LREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count, element) {
      parser.push("LREM");
      parser.pushKey(key);
      parser.push(count.toString());
      parser.push(element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LSET.js
var require_LSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, index, element) {
      parser.push("LSET");
      parser.pushKey(key);
      parser.push(index.toString(), element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LTRIM.js
var require_LTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, start, stop) {
      parser.push("LTRIM");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_DOCTOR.js
var require_MEMORY_DOCTOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "DOCTOR");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_MALLOC-STATS.js
var require_MEMORY_MALLOC_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "MALLOC-STATS");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_PURGE.js
var require_MEMORY_PURGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser) {
      parser.push("MEMORY", "PURGE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_STATS.js
var require_MEMORY_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "STATS");
    },
    transformReply: {
      2: (rawReply, preserve, typeMapping) => {
        const reply = {};
        let i = 0;
        while (i < rawReply.length) {
          switch (rawReply[i].toString()) {
            case "dataset.percentage":
            case "peak.percentage":
            case "allocator-fragmentation.ratio":
            case "allocator-rss.ratio":
            case "rss-overhead.ratio":
            case "fragmentation":
              reply[rawReply[i++]] = generic_transformers_1.transformDoubleReply[2](rawReply[i++], preserve, typeMapping);
              break;
            default:
              reply[rawReply[i++]] = rawReply[i++];
          }
        }
        return reply;
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_USAGE.js
var require_MEMORY_USAGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("MEMORY", "USAGE");
      parser.pushKey(key);
      if (options?.SAMPLES) {
        parser.push("SAMPLES", options.SAMPLES.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MGET.js
var require_MGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("MGET");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MIGRATE.js
var require_MIGRATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, host, port, key, destinationDb, timeout, options) {
      parser.push("MIGRATE", host, port.toString());
      const isKeyArray = Array.isArray(key);
      if (isKeyArray) {
        parser.push("");
      } else {
        parser.push(key);
      }
      parser.push(destinationDb.toString(), timeout.toString());
      if (options?.COPY) {
        parser.push("COPY");
      }
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      if (options?.AUTH) {
        if (options.AUTH.username) {
          parser.push("AUTH2", options.AUTH.username, options.AUTH.password);
        } else {
          parser.push("AUTH", options.AUTH.password);
        }
      }
      if (isKeyArray) {
        parser.push("KEYS");
        parser.pushVariadic(key);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MODULE_LIST.js
var require_MODULE_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MODULE", "LIST");
    },
    transformReply: {
      2: (reply) => {
        return reply.map((module2) => {
          const unwrapped = module2;
          return {
            name: unwrapped[1],
            ver: unwrapped[3]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/MODULE_LOAD.js
var require_MODULE_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, path2, moduleArguments) {
      parser.push("MODULE", "LOAD", path2);
      if (moduleArguments) {
        parser.push(...moduleArguments);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MODULE_UNLOAD.js
var require_MODULE_UNLOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, name) {
      parser.push("MODULE", "UNLOAD", name);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MOVE.js
var require_MOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, db) {
      parser.push("MOVE");
      parser.pushKey(key);
      parser.push(db.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MSET.js
var require_MSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseMSetArguments = undefined;
  function parseMSetArguments(parser, toSet) {
    if (Array.isArray(toSet)) {
      if (toSet.length == 0) {
        throw new Error("empty toSet Argument");
      }
      if (Array.isArray(toSet[0])) {
        for (const tuple of toSet) {
          parser.pushKey(tuple[0]);
          parser.push(tuple[1]);
        }
      } else {
        const arr = toSet;
        for (let i = 0;i < arr.length; i += 2) {
          parser.pushKey(arr[i]);
          parser.push(arr[i + 1]);
        }
      }
    } else {
      for (const tuple of Object.entries(toSet)) {
        parser.pushKey(tuple[0]);
        parser.push(tuple[1]);
      }
    }
  }
  exports.parseMSetArguments = parseMSetArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, toSet) {
      parser.push("MSET");
      return parseMSetArguments(parser, toSet);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MSETNX.js
var require_MSETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MSET_1 = require_MSET();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, toSet) {
      parser.push("MSETNX");
      return (0, MSET_1.parseMSetArguments)(parser, toSet);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_ENCODING.js
var require_OBJECT_ENCODING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "ENCODING");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_FREQ.js
var require_OBJECT_FREQ = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "FREQ");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_IDLETIME.js
var require_OBJECT_IDLETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "IDLETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_REFCOUNT.js
var require_OBJECT_REFCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "REFCOUNT");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PERSIST.js
var require_PERSIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("PERSIST");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PEXPIRE.js
var require_PEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, ms, mode) {
      parser.push("PEXPIRE");
      parser.pushKey(key);
      parser.push(ms.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PEXPIREAT.js
var require_PEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, msTimestamp, mode) {
      parser.push("PEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformPXAT)(msTimestamp));
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PEXPIRETIME.js
var require_PEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("PEXPIRETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PFADD.js
var require_PFADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("PFADD");
      parser.pushKey(key);
      if (element) {
        parser.pushVariadic(element);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PFCOUNT.js
var require_PFCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("PFCOUNT");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PFMERGE.js
var require_PFMERGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, destination, sources) {
      parser.push("PFMERGE");
      parser.pushKey(destination);
      if (sources) {
        parser.pushKeys(sources);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PING.js
var require_PING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, message) {
      parser.push("PING");
      if (message) {
        parser.push(message);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PSETEX.js
var require_PSETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, ms, value) {
      parser.push("PSETEX");
      parser.pushKey(key);
      parser.push(ms.toString(), value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PTTL.js
var require_PTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("PTTL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBLISH.js
var require_PUBLISH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    IS_FORWARD_COMMAND: true,
    parseCommand(parser, channel, message) {
      parser.push("PUBLISH", channel, message);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_CHANNELS.js
var require_PUBSUB_CHANNELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("PUBSUB", "CHANNELS");
      if (pattern) {
        parser.push(pattern);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMPAT.js
var require_PUBSUB_NUMPAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("PUBSUB", "NUMPAT");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMSUB.js
var require_PUBSUB_NUMSUB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, channels) {
      parser.push("PUBSUB", "NUMSUB");
      if (channels) {
        parser.pushVariadic(channels);
      }
    },
    transformReply(rawReply) {
      const reply = Object.create(null);
      let i = 0;
      while (i < rawReply.length) {
        reply[rawReply[i++].toString()] = rawReply[i++].toString();
      }
      return reply;
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDNUMSUB.js
var require_PUBSUB_SHARDNUMSUB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, channels) {
      parser.push("PUBSUB", "SHARDNUMSUB");
      if (channels) {
        parser.pushVariadic(channels);
      }
    },
    transformReply(reply) {
      const transformedReply = Object.create(null);
      for (let i = 0;i < reply.length; i += 2) {
        transformedReply[reply[i].toString()] = reply[i + 1];
      }
      return transformedReply;
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDCHANNELS.js
var require_PUBSUB_SHARDCHANNELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("PUBSUB", "SHARDCHANNELS");
      if (pattern) {
        parser.push(pattern);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RANDOMKEY.js
var require_RANDOMKEY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("RANDOMKEY");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/READONLY.js
var require_READONLY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("READONLY");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RENAME.js
var require_RENAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, newKey) {
      parser.push("RENAME");
      parser.pushKeys([key, newKey]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RENAMENX.js
var require_RENAMENX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, newKey) {
      parser.push("RENAMENX");
      parser.pushKeys([key, newKey]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/REPLICAOF.js
var require_REPLICAOF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, host, port) {
      parser.push("REPLICAOF", host, port.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RESTORE-ASKING.js
var require_RESTORE_ASKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("RESTORE-ASKING");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RESTORE.js
var require_RESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, ttl, serializedValue, options) {
      parser.push("RESTORE");
      parser.pushKey(key);
      parser.push(ttl.toString(), serializedValue);
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      if (options?.ABSTTL) {
        parser.push("ABSTTL");
      }
      if (options?.IDLETIME) {
        parser.push("IDLETIME", options.IDLETIME.toString());
      }
      if (options?.FREQ) {
        parser.push("FREQ", options.FREQ.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ROLE.js
var require_ROLE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ROLE");
    },
    transformReply(reply) {
      switch (reply[0]) {
        case "master": {
          const [role, replicationOffest, replicas] = reply;
          return {
            role,
            replicationOffest,
            replicas: replicas.map((replica) => {
              const [host, port, replicationOffest2] = replica;
              return {
                host,
                port: Number(port),
                replicationOffest: Number(replicationOffest2)
              };
            })
          };
        }
        case "slave": {
          const [role, masterHost, masterPort, state, dataReceived] = reply;
          return {
            role,
            master: {
              host: masterHost,
              port: masterPort
            },
            state,
            dataReceived
          };
        }
        case "sentinel": {
          const [role, masterNames] = reply;
          return {
            role,
            masterNames
          };
        }
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/RPOP_COUNT.js
var require_RPOP_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, count) {
      parser.push("RPOP");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RPOP.js
var require_RPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("RPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RPOPLPUSH.js
var require_RPOPLPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, source, destination) {
      parser.push("RPOPLPUSH");
      parser.pushKeys([source, destination]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RPUSH.js
var require_RPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, element) {
      parser.push("RPUSH");
      parser.pushKey(key);
      parser.pushVariadic(element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RPUSHX.js
var require_RPUSHX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, element) {
      parser.push("RPUSHX");
      parser.pushKey(key);
      parser.pushVariadic(element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SADD.js
var require_SADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, members) {
      parser.push("SADD");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCARD.js
var require_SCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SCARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_DEBUG.js
var require_SCRIPT_DEBUG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode) {
      parser.push("SCRIPT", "DEBUG", mode);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_EXISTS.js
var require_SCRIPT_EXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, sha1) {
      parser.push("SCRIPT", "EXISTS");
      parser.pushVariadic(sha1);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_FLUSH.js
var require_SCRIPT_FLUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode) {
      parser.push("SCRIPT", "FLUSH");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_KILL.js
var require_SCRIPT_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("SCRIPT", "KILL");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_LOAD.js
var require_SCRIPT_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, script) {
      parser.push("SCRIPT", "LOAD", script);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SDIFF.js
var require_SDIFF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SDIFF");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SDIFFSTORE.js
var require_SDIFFSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, destination, keys) {
      parser.push("SDIFFSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SET.js
var require_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, value, options) {
      parser.push("SET");
      parser.pushKey(key);
      parser.push(typeof value === "number" ? value.toString() : value);
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "KEEPTTL") {
          parser.push("KEEPTTL");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      } else if (options?.EX !== undefined) {
        parser.push("EX", options.EX.toString());
      } else if (options?.PX !== undefined) {
        parser.push("PX", options.PX.toString());
      } else if (options?.EXAT !== undefined) {
        parser.push("EXAT", options.EXAT.toString());
      } else if (options?.PXAT !== undefined) {
        parser.push("PXAT", options.PXAT.toString());
      } else if (options?.KEEPTTL) {
        parser.push("KEEPTTL");
      }
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.GET) {
        parser.push("GET");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SETBIT.js
var require_SETBIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, offset, value) {
      parser.push("SETBIT");
      parser.pushKey(key);
      parser.push(offset.toString(), value.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SETEX.js
var require_SETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, seconds, value) {
      parser.push("SETEX");
      parser.pushKey(key);
      parser.push(seconds.toString(), value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SETNX.js
var require_SETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, value) {
      parser.push("SETNX");
      parser.pushKey(key);
      parser.push(value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SETRANGE.js
var require_SETRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, offset, value) {
      parser.push("SETRANGE");
      parser.pushKey(key);
      parser.push(offset.toString(), value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SINTER.js
var require_SINTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SINTER");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SINTERCARD.js
var require_SINTERCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("SINTERCARD");
      parser.pushKeysLength(keys);
      if (typeof options === "number") {
        parser.push("LIMIT", options.toString());
      } else if (options?.LIMIT !== undefined) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SINTERSTORE.js
var require_SINTERSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys) {
      parser.push("SINTERSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SISMEMBER.js
var require_SISMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("SISMEMBER");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SMEMBERS.js
var require_SMEMBERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SMEMBERS");
      parser.pushKey(key);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/SMISMEMBER.js
var require_SMISMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, members) {
      parser.push("SMISMEMBER");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SMOVE.js
var require_SMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, member) {
      parser.push("SMOVE");
      parser.pushKeys([source, destination]);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SORT.js
var require_SORT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseSortArguments = undefined;
  function parseSortArguments(parser, key, options) {
    parser.pushKey(key);
    if (options?.BY) {
      parser.push("BY", options.BY);
    }
    if (options?.LIMIT) {
      parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    if (options?.GET) {
      if (Array.isArray(options.GET)) {
        for (const pattern of options.GET) {
          parser.push("GET", pattern);
        }
      } else {
        parser.push("GET", options.GET);
      }
    }
    if (options?.DIRECTION) {
      parser.push(options.DIRECTION);
    }
    if (options?.ALPHA) {
      parser.push("ALPHA");
    }
  }
  exports.parseSortArguments = parseSortArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("SORT");
      parseSortArguments(parser, key, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SORT_RO.js
var require_SORT_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SORT_1 = __importStar(require_SORT());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("SORT_RO");
      (0, SORT_1.parseSortArguments)(...args);
    },
    transformReply: SORT_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/SORT_STORE.js
var require_SORT_STORE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SORT_1 = __importDefault(require_SORT());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, options) {
      SORT_1.default.parseCommand(parser, source, options);
      parser.push("STORE", destination);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SPOP_COUNT.js
var require_SPOP_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("SPOP");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SPOP.js
var require_SPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("SPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SPUBLISH.js
var require_SPUBLISH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, channel, message) {
      parser.push("SPUBLISH");
      parser.pushKey(channel);
      parser.push(message);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SRANDMEMBER.js
var require_SRANDMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SRANDMEMBER");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SRANDMEMBER_COUNT.js
var require_SRANDMEMBER_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SRANDMEMBER_1 = __importDefault(require_SRANDMEMBER());
  exports.default = {
    IS_READ_ONLY: SRANDMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      SRANDMEMBER_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SREM.js
var require_SREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, members) {
      parser.push("SREM");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SSCAN.js
var require_SSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("SSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, members]) {
      return {
        cursor,
        members
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/STRLEN.js
var require_STRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("STRLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SUNION.js
var require_SUNION = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SUNION");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SUNIONSTORE.js
var require_SUNIONSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys) {
      parser.push("SUNIONSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SWAPDB.js
var require_SWAPDB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, index1, index2) {
      parser.push("SWAPDB", index1.toString(), index2.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/TIME.js
var require_TIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("TIME");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/TOUCH.js
var require_TOUCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("TOUCH");
      parser.pushKeys(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/TTL.js
var require_TTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TTL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/TYPE.js
var require_TYPE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TYPE");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/UNLINK.js
var require_UNLINK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys) {
      parser.push("UNLINK");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/WAIT.js
var require_WAIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, numberOfReplicas, timeout) {
      parser.push("WAIT", numberOfReplicas.toString(), timeout.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XACK.js
var require_XACK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id) {
      parser.push("XACK");
      parser.pushKey(key);
      parser.push(group);
      parser.pushVariadic(id);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XADD.js
var require_XADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseXAddArguments = undefined;
  function parseXAddArguments(optional, parser, key, id, message, options) {
    parser.push("XADD");
    parser.pushKey(key);
    if (optional) {
      parser.push(optional);
    }
    if (options?.TRIM) {
      if (options.TRIM.strategy) {
        parser.push(options.TRIM.strategy);
      }
      if (options.TRIM.strategyModifier) {
        parser.push(options.TRIM.strategyModifier);
      }
      parser.push(options.TRIM.threshold.toString());
      if (options.TRIM.limit) {
        parser.push("LIMIT", options.TRIM.limit.toString());
      }
    }
    parser.push(id);
    for (const [key2, value] of Object.entries(message)) {
      parser.push(key2, value);
    }
  }
  exports.parseXAddArguments = parseXAddArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      return parseXAddArguments(undefined, ...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XADD_NOMKSTREAM.js
var require_XADD_NOMKSTREAM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var XADD_1 = require_XADD();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      return (0, XADD_1.parseXAddArguments)("NOMKSTREAM", ...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM.js
var require_XAUTOCLAIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer, minIdleTime, start, options) {
      parser.push("XAUTOCLAIM");
      parser.pushKey(key);
      parser.push(group, consumer, minIdleTime.toString(), start);
      if (options?.COUNT) {
        parser.push("COUNT", options.COUNT.toString());
      }
    },
    transformReply(reply, preserve, typeMapping) {
      return {
        nextId: reply[0],
        messages: reply[1].map(generic_transformers_1.transformStreamMessageNullReply.bind(undefined, typeMapping)),
        deletedMessages: reply[2]
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM_JUSTID.js
var require_XAUTOCLAIM_JUSTID = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XAUTOCLAIM_1 = __importDefault(require_XAUTOCLAIM());
  exports.default = {
    IS_READ_ONLY: XAUTOCLAIM_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      XAUTOCLAIM_1.default.parseCommand(...args);
      parser.push("JUSTID");
    },
    transformReply(reply) {
      return {
        nextId: reply[0],
        messages: reply[1],
        deletedMessages: reply[2]
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XCLAIM.js
var require_XCLAIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer, minIdleTime, id, options) {
      parser.push("XCLAIM");
      parser.pushKey(key);
      parser.push(group, consumer, minIdleTime.toString());
      parser.pushVariadic(id);
      if (options?.IDLE !== undefined) {
        parser.push("IDLE", options.IDLE.toString());
      }
      if (options?.TIME !== undefined) {
        parser.push("TIME", (options.TIME instanceof Date ? options.TIME.getTime() : options.TIME).toString());
      }
      if (options?.RETRYCOUNT !== undefined) {
        parser.push("RETRYCOUNT", options.RETRYCOUNT.toString());
      }
      if (options?.FORCE) {
        parser.push("FORCE");
      }
      if (options?.LASTID !== undefined) {
        parser.push("LASTID", options.LASTID);
      }
    },
    transformReply(reply, preserve, typeMapping) {
      return reply.map(generic_transformers_1.transformStreamMessageNullReply.bind(undefined, typeMapping));
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XCLAIM_JUSTID.js
var require_XCLAIM_JUSTID = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XCLAIM_1 = __importDefault(require_XCLAIM());
  exports.default = {
    IS_READ_ONLY: XCLAIM_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      XCLAIM_1.default.parseCommand(...args);
      parser.push("JUSTID");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XDEL.js
var require_XDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, id) {
      parser.push("XDEL");
      parser.pushKey(key);
      parser.pushVariadic(id);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_CREATE.js
var require_XGROUP_CREATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id, options) {
      parser.push("XGROUP", "CREATE");
      parser.pushKey(key);
      parser.push(group, id);
      if (options?.MKSTREAM) {
        parser.push("MKSTREAM");
      }
      if (options?.ENTRIESREAD) {
        parser.push("ENTRIESREAD", options.ENTRIESREAD.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_CREATECONSUMER.js
var require_XGROUP_CREATECONSUMER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer) {
      parser.push("XGROUP", "CREATECONSUMER");
      parser.pushKey(key);
      parser.push(group, consumer);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_DELCONSUMER.js
var require_XGROUP_DELCONSUMER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer) {
      parser.push("XGROUP", "DELCONSUMER");
      parser.pushKey(key);
      parser.push(group, consumer);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_DESTROY.js
var require_XGROUP_DESTROY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group) {
      parser.push("XGROUP", "DESTROY");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_SETID.js
var require_XGROUP_SETID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id, options) {
      parser.push("XGROUP", "SETID");
      parser.pushKey(key);
      parser.push(group, id);
      if (options?.ENTRIESREAD) {
        parser.push("ENTRIESREAD", options.ENTRIESREAD.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XINFO_CONSUMERS.js
var require_XINFO_CONSUMERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, group) {
      parser.push("XINFO", "CONSUMERS");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply: {
      2: (reply) => {
        return reply.map((consumer) => {
          const unwrapped = consumer;
          return {
            name: unwrapped[1],
            pending: unwrapped[3],
            idle: unwrapped[5],
            inactive: unwrapped[7]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XINFO_GROUPS.js
var require_XINFO_GROUPS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XINFO", "GROUPS");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply) => {
        return reply.map((group) => {
          const unwrapped = group;
          return {
            name: unwrapped[1],
            consumers: unwrapped[3],
            pending: unwrapped[5],
            "last-delivered-id": unwrapped[7],
            "entries-read": unwrapped[9],
            lag: unwrapped[11]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XINFO_STREAM.js
var require_XINFO_STREAM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XINFO", "STREAM");
      parser.pushKey(key);
    },
    transformReply: {
      2(reply) {
        const parsedReply = {};
        for (let i = 0;i < reply.length; i += 2) {
          switch (reply[i]) {
            case "first-entry":
            case "last-entry":
              parsedReply[reply[i]] = transformEntry(reply[i + 1]);
              break;
            default:
              parsedReply[reply[i]] = reply[i + 1];
              break;
          }
        }
        return parsedReply;
      },
      3(reply) {
        if (reply instanceof Map) {
          reply.set("first-entry", transformEntry(reply.get("first-entry")));
          reply.set("last-entry", transformEntry(reply.get("last-entry")));
        } else if (reply instanceof Array) {
          reply[17] = transformEntry(reply[17]);
          reply[19] = transformEntry(reply[19]);
        } else {
          reply["first-entry"] = transformEntry(reply["first-entry"]);
          reply["last-entry"] = transformEntry(reply["last-entry"]);
        }
        return reply;
      }
    }
  };
  function transformEntry(entry) {
    if ((0, generic_transformers_1.isNullReply)(entry))
      return entry;
    const [id, message] = entry;
    return {
      id,
      message: (0, generic_transformers_1.transformTuplesReply)(message)
    };
  }
});

// node_modules/@redis/client/dist/lib/commands/XLEN.js
var require_XLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XPENDING_RANGE.js
var require_XPENDING_RANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, group, start, end, count, options) {
      parser.push("XPENDING");
      parser.pushKey(key);
      parser.push(group);
      if (options?.IDLE !== undefined) {
        parser.push("IDLE", options.IDLE.toString());
      }
      parser.push(start, end, count.toString());
      if (options?.consumer) {
        parser.push(options.consumer);
      }
    },
    transformReply(reply) {
      return reply.map((pending) => {
        const unwrapped = pending;
        return {
          id: unwrapped[0],
          consumer: unwrapped[1],
          millisecondsSinceLastDelivery: unwrapped[2],
          deliveriesCounter: unwrapped[3]
        };
      });
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XPENDING.js
var require_XPENDING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, group) {
      parser.push("XPENDING");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply(reply) {
      const consumers = reply[3];
      return {
        pending: reply[0],
        firstId: reply[1],
        lastId: reply[2],
        consumers: consumers === null ? null : consumers.map((consumer) => {
          const [name, deliveriesCounter] = consumer;
          return {
            name,
            deliveriesCounter: Number(deliveriesCounter)
          };
        })
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XRANGE.js
var require_XRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.xRangeArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function xRangeArguments(start, end, options) {
    const args = [start, end];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  }
  exports.xRangeArguments = xRangeArguments;
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, ...args) {
      parser.push("XRANGE");
      parser.pushKey(key);
      parser.pushVariadic(xRangeArguments(args[0], args[1], args[2]));
    },
    transformReply(reply, preserve, typeMapping) {
      return reply.map(generic_transformers_1.transformStreamMessageReply.bind(undefined, typeMapping));
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XREAD.js
var require_XREAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushXReadStreams = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function pushXReadStreams(parser, streams) {
    parser.push("STREAMS");
    if (Array.isArray(streams)) {
      for (let i = 0;i < streams.length; i++) {
        parser.pushKey(streams[i].key);
      }
      for (let i = 0;i < streams.length; i++) {
        parser.push(streams[i].id);
      }
    } else {
      parser.pushKey(streams.key);
      parser.push(streams.id);
    }
  }
  exports.pushXReadStreams = pushXReadStreams;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, streams, options) {
      parser.push("XREAD");
      if (options?.COUNT) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.BLOCK !== undefined) {
        parser.push("BLOCK", options.BLOCK.toString());
      }
      pushXReadStreams(parser, streams);
    },
    transformReply: {
      2: generic_transformers_1.transformStreamsMessagesReplyResp2,
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/client/dist/lib/commands/XREADGROUP.js
var require_XREADGROUP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var XREAD_1 = require_XREAD();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, group, consumer, streams, options) {
      parser.push("XREADGROUP", "GROUP", group, consumer);
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.BLOCK !== undefined) {
        parser.push("BLOCK", options.BLOCK.toString());
      }
      if (options?.NOACK) {
        parser.push("NOACK");
      }
      (0, XREAD_1.pushXReadStreams)(parser, streams);
    },
    transformReply: {
      2: generic_transformers_1.transformStreamsMessagesReplyResp2,
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/client/dist/lib/commands/XREVRANGE.js
var require_XREVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XRANGE_1 = __importStar(require_XRANGE());
  exports.default = {
    CACHEABLE: XRANGE_1.default.CACHEABLE,
    IS_READ_ONLY: XRANGE_1.default.IS_READ_ONLY,
    parseCommand(parser, key, ...args) {
      parser.push("XREVRANGE");
      parser.pushKey(key);
      parser.pushVariadic((0, XRANGE_1.xRangeArguments)(args[0], args[1], args[2]));
    },
    transformReply: XRANGE_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/XSETID.js
var require_XSETID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, lastId, options) {
      parser.push("XSETID");
      parser.pushKey(key);
      parser.push(lastId);
      if (options?.ENTRIESADDED) {
        parser.push("ENTRIESADDED", options.ENTRIESADDED.toString());
      }
      if (options?.MAXDELETEDID) {
        parser.push("MAXDELETEDID", options.MAXDELETEDID);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XTRIM.js
var require_XTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, strategy, threshold, options) {
      parser.push("XTRIM");
      parser.pushKey(key);
      parser.push(strategy);
      if (options?.strategyModifier) {
        parser.push(options.strategyModifier);
      }
      parser.push(threshold.toString());
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZADD.js
var require_ZADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushMembers = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, members, options) {
      parser.push("ZADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.comparison) {
        parser.push(options.comparison);
      } else if (options?.LT) {
        parser.push("LT");
      } else if (options?.GT) {
        parser.push("GT");
      }
      if (options?.CH) {
        parser.push("CH");
      }
      pushMembers(parser, members);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
  function pushMembers(parser, members) {
    if (Array.isArray(members)) {
      for (const member of members) {
        pushMember(parser, member);
      }
    } else {
      pushMember(parser, members);
    }
  }
  exports.pushMembers = pushMembers;
  function pushMember(parser, member) {
    parser.push((0, generic_transformers_1.transformDoubleArgument)(member.score), member.value);
  }
});

// node_modules/@redis/client/dist/lib/commands/ZADD_INCR.js
var require_ZADD_INCR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZADD_1 = require_ZADD();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, members, options) {
      parser.push("ZADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      }
      if (options?.comparison) {
        parser.push(options.comparison);
      }
      if (options?.CH) {
        parser.push("CH");
      }
      parser.push("INCR");
      (0, ZADD_1.pushMembers)(parser, members);
    },
    transformReply: generic_transformers_1.transformNullableDoubleReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZCARD.js
var require_ZCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("ZCARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZCOUNT.js
var require_ZCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max) {
      parser.push("ZCOUNT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZDIFF.js
var require_ZDIFF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("ZDIFF");
      parser.pushKeysLength(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZDIFF_WITHSCORES.js
var require_ZDIFF_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZDIFF_1 = __importDefault(require_ZDIFF());
  exports.default = {
    IS_READ_ONLY: ZDIFF_1.default.IS_READ_ONLY,
    parseCommand(parser, keys) {
      ZDIFF_1.default.parseCommand(parser, keys);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZDIFFSTORE.js
var require_ZDIFFSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, destination, inputKeys) {
      parser.push("ZDIFFSTORE");
      parser.pushKey(destination);
      parser.pushKeysLength(inputKeys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINCRBY.js
var require_ZINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, increment, member) {
      parser.push("ZINCRBY");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformDoubleArgument)(increment), member);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINTER.js
var require_ZINTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseZInterArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseZInterArguments(parser, keys, options) {
    (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
    if (options?.AGGREGATE) {
      parser.push("AGGREGATE", options.AGGREGATE);
    }
  }
  exports.parseZInterArguments = parseZInterArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZINTER");
      parseZInterArguments(parser, keys, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINTER_WITHSCORES.js
var require_ZINTER_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZINTER_1 = __importDefault(require_ZINTER());
  exports.default = {
    IS_READ_ONLY: ZINTER_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      ZINTER_1.default.parseCommand(...args);
      args[0].push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINTERCARD.js
var require_ZINTERCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZINTERCARD");
      parser.pushKeysLength(keys);
      if (typeof options === "number") {
        parser.push("LIMIT", options.toString());
      } else if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINTERSTORE.js
var require_ZINTERSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZINTER_1 = require_ZINTER();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys, options) {
      parser.push("ZINTERSTORE");
      parser.pushKey(destination);
      (0, ZINTER_1.parseZInterArguments)(parser, keys, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZLEXCOUNT.js
var require_ZLEXCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max) {
      parser.push("ZLEXCOUNT");
      parser.pushKey(key);
      parser.push(min);
      parser.push(max);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZMSCORE.js
var require_ZMSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZMSCORE");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        return reply.map((0, generic_transformers_1.createTransformNullableDoubleReplyResp2Func)(preserve, typeMapping));
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMAX_COUNT.js
var require_ZPOPMAX_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("ZPOPMAX");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMAX.js
var require_ZPOPMAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("ZPOPMAX");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if (reply.length === 0)
          return null;
        return {
          value: reply[0],
          score: generic_transformers_1.transformDoubleReply[2](reply[1], preserve, typeMapping)
        };
      },
      3: (reply) => {
        if (reply.length === 0)
          return null;
        return {
          value: reply[0],
          score: reply[1]
        };
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMIN_COUNT.js
var require_ZPOPMIN_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("ZPOPMIN");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMIN.js
var require_ZPOPMIN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZPOPMAX_1 = __importDefault(require_ZPOPMAX());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("ZPOPMIN");
      parser.pushKey(key);
    },
    transformReply: ZPOPMAX_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER.js
var require_ZRANDMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("ZRANDMEMBER");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT.js
var require_ZRANDMEMBER_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZRANDMEMBER_1 = __importDefault(require_ZRANDMEMBER());
  exports.default = {
    IS_READ_ONLY: ZRANDMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      ZRANDMEMBER_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT_WITHSCORES.js
var require_ZRANDMEMBER_COUNT_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANDMEMBER_COUNT_1 = __importDefault(require_ZRANDMEMBER_COUNT());
  exports.default = {
    IS_READ_ONLY: ZRANDMEMBER_COUNT_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      ZRANDMEMBER_COUNT_1.default.parseCommand(parser, key, count);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGE.js
var require_ZRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zRangeArgument = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function zRangeArgument(min, max, options) {
    const args = [
      (0, generic_transformers_1.transformStringDoubleArgument)(min),
      (0, generic_transformers_1.transformStringDoubleArgument)(max)
    ];
    switch (options?.BY) {
      case "SCORE":
        args.push("BYSCORE");
        break;
      case "LEX":
        args.push("BYLEX");
        break;
    }
    if (options?.REV) {
      args.push("REV");
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  }
  exports.zRangeArgument = zRangeArgument;
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGE");
      parser.pushKey(key);
      parser.pushVariadic(zRangeArgument(min, max, options));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGE_WITHSCORES.js
var require_ZRANGE_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANGE_1 = __importDefault(require_ZRANGE());
  exports.default = {
    CACHEABLE: ZRANGE_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANGE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANGE_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYLEX.js
var require_ZRANGEBYLEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGEBYLEX");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE.js
var require_ZRANGEBYSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGEBYSCORE");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE_WITHSCORES.js
var require_ZRANGEBYSCORE_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANGEBYSCORE_1 = __importDefault(require_ZRANGEBYSCORE());
  exports.default = {
    CACHEABLE: ZRANGEBYSCORE_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANGEBYSCORE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANGEBYSCORE_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGESTORE.js
var require_ZRANGESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, min, max, options) {
      parser.push("ZRANGESTORE");
      parser.pushKey(destination);
      parser.pushKey(source);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      switch (options?.BY) {
        case "SCORE":
          parser.push("BYSCORE");
          break;
        case "LEX":
          parser.push("BYLEX");
          break;
      }
      if (options?.REV) {
        parser.push("REV");
      }
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYSCORE.js
var require_ZREMRANGEBYSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, min, max) {
      parser.push("ZREMRANGEBYSCORE");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANK.js
var require_ZRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZRANK");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANK_WITHSCORE.js
var require_ZRANK_WITHSCORE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZRANK_1 = __importDefault(require_ZRANK());
  exports.default = {
    CACHEABLE: ZRANK_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANK_1.default.parseCommand(...args);
      parser.push("WITHSCORE");
    },
    transformReply: {
      2: (reply) => {
        if (reply === null)
          return null;
        return {
          rank: reply[0],
          score: Number(reply[1])
        };
      },
      3: (reply) => {
        if (reply === null)
          return null;
        return {
          rank: reply[0],
          score: reply[1]
        };
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREM.js
var require_ZREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, member) {
      parser.push("ZREM");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYLEX.js
var require_ZREMRANGEBYLEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, min, max) {
      parser.push("ZREMRANGEBYLEX");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYRANK.js
var require_ZREMRANGEBYRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, start, stop) {
      parser.push("ZREMRANGEBYRANK");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREVRANK.js
var require_ZREVRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZREVRANK");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZSCAN.js
var require_ZSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("ZSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, rawMembers]) {
      return {
        cursor,
        members: generic_transformers_1.transformSortedSetReply[2](rawMembers)
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ZSCORE.js
var require_ZSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZSCORE");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: generic_transformers_1.transformNullableDoubleReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZUNION.js
var require_ZUNION = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZUNION");
      (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
      if (options?.AGGREGATE) {
        parser.push("AGGREGATE", options.AGGREGATE);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZUNION_WITHSCORES.js
var require_ZUNION_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZUNION_1 = __importDefault(require_ZUNION());
  exports.default = {
    IS_READ_ONLY: ZUNION_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZUNION_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZUNIONSTORE.js
var require_ZUNIONSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys, options) {
      parser.push("ZUNIONSTORE");
      parser.pushKey(destination);
      (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
      if (options?.AGGREGATE) {
        parser.push("AGGREGATE", options.AGGREGATE);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/index.js
var require_commands = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ACL_CAT_1 = __importDefault(require_ACL_CAT());
  var ACL_DELUSER_1 = __importDefault(require_ACL_DELUSER());
  var ACL_DRYRUN_1 = __importDefault(require_ACL_DRYRUN());
  var ACL_GENPASS_1 = __importDefault(require_ACL_GENPASS());
  var ACL_GETUSER_1 = __importDefault(require_ACL_GETUSER());
  var ACL_LIST_1 = __importDefault(require_ACL_LIST());
  var ACL_LOAD_1 = __importDefault(require_ACL_LOAD());
  var ACL_LOG_RESET_1 = __importDefault(require_ACL_LOG_RESET());
  var ACL_LOG_1 = __importDefault(require_ACL_LOG());
  var ACL_SAVE_1 = __importDefault(require_ACL_SAVE());
  var ACL_SETUSER_1 = __importDefault(require_ACL_SETUSER());
  var ACL_USERS_1 = __importDefault(require_ACL_USERS());
  var ACL_WHOAMI_1 = __importDefault(require_ACL_WHOAMI());
  var APPEND_1 = __importDefault(require_APPEND());
  var ASKING_1 = __importDefault(require_ASKING());
  var AUTH_1 = __importDefault(require_AUTH());
  var BGREWRITEAOF_1 = __importDefault(require_BGREWRITEAOF());
  var BGSAVE_1 = __importDefault(require_BGSAVE());
  var BITCOUNT_1 = __importDefault(require_BITCOUNT());
  var BITFIELD_RO_1 = __importDefault(require_BITFIELD_RO());
  var BITFIELD_1 = __importDefault(require_BITFIELD());
  var BITOP_1 = __importDefault(require_BITOP());
  var BITPOS_1 = __importDefault(require_BITPOS());
  var BLMOVE_1 = __importDefault(require_BLMOVE());
  var BLMPOP_1 = __importDefault(require_BLMPOP());
  var BLPOP_1 = __importDefault(require_BLPOP());
  var BRPOP_1 = __importDefault(require_BRPOP());
  var BRPOPLPUSH_1 = __importDefault(require_BRPOPLPUSH());
  var BZMPOP_1 = __importDefault(require_BZMPOP());
  var BZPOPMAX_1 = __importDefault(require_BZPOPMAX());
  var BZPOPMIN_1 = __importDefault(require_BZPOPMIN());
  var CLIENT_CACHING_1 = __importDefault(require_CLIENT_CACHING());
  var CLIENT_GETNAME_1 = __importDefault(require_CLIENT_GETNAME());
  var CLIENT_GETREDIR_1 = __importDefault(require_CLIENT_GETREDIR());
  var CLIENT_ID_1 = __importDefault(require_CLIENT_ID());
  var CLIENT_INFO_1 = __importDefault(require_CLIENT_INFO());
  var CLIENT_KILL_1 = __importDefault(require_CLIENT_KILL());
  var CLIENT_LIST_1 = __importDefault(require_CLIENT_LIST());
  var CLIENT_NO_EVICT_1 = __importDefault(require_CLIENT_NO_EVICT());
  var CLIENT_NO_TOUCH_1 = __importDefault(require_CLIENT_NO_TOUCH());
  var CLIENT_PAUSE_1 = __importDefault(require_CLIENT_PAUSE());
  var CLIENT_SETNAME_1 = __importDefault(require_CLIENT_SETNAME());
  var CLIENT_TRACKING_1 = __importDefault(require_CLIENT_TRACKING());
  var CLIENT_TRACKINGINFO_1 = __importDefault(require_CLIENT_TRACKINGINFO());
  var CLIENT_UNPAUSE_1 = __importDefault(require_CLIENT_UNPAUSE());
  var CLUSTER_ADDSLOTS_1 = __importDefault(require_CLUSTER_ADDSLOTS());
  var CLUSTER_ADDSLOTSRANGE_1 = __importDefault(require_CLUSTER_ADDSLOTSRANGE());
  var CLUSTER_BUMPEPOCH_1 = __importDefault(require_CLUSTER_BUMPEPOCH());
  var CLUSTER_COUNT_FAILURE_REPORTS_1 = __importDefault(require_CLUSTER_COUNT_FAILURE_REPORTS());
  var CLUSTER_COUNTKEYSINSLOT_1 = __importDefault(require_CLUSTER_COUNTKEYSINSLOT());
  var CLUSTER_DELSLOTS_1 = __importDefault(require_CLUSTER_DELSLOTS());
  var CLUSTER_DELSLOTSRANGE_1 = __importDefault(require_CLUSTER_DELSLOTSRANGE());
  var CLUSTER_FAILOVER_1 = __importDefault(require_CLUSTER_FAILOVER());
  var CLUSTER_FLUSHSLOTS_1 = __importDefault(require_CLUSTER_FLUSHSLOTS());
  var CLUSTER_FORGET_1 = __importDefault(require_CLUSTER_FORGET());
  var CLUSTER_GETKEYSINSLOT_1 = __importDefault(require_CLUSTER_GETKEYSINSLOT());
  var CLUSTER_INFO_1 = __importDefault(require_CLUSTER_INFO());
  var CLUSTER_KEYSLOT_1 = __importDefault(require_CLUSTER_KEYSLOT());
  var CLUSTER_LINKS_1 = __importDefault(require_CLUSTER_LINKS());
  var CLUSTER_MEET_1 = __importDefault(require_CLUSTER_MEET());
  var CLUSTER_MYID_1 = __importDefault(require_CLUSTER_MYID());
  var CLUSTER_MYSHARDID_1 = __importDefault(require_CLUSTER_MYSHARDID());
  var CLUSTER_NODES_1 = __importDefault(require_CLUSTER_NODES());
  var CLUSTER_REPLICAS_1 = __importDefault(require_CLUSTER_REPLICAS());
  var CLUSTER_REPLICATE_1 = __importDefault(require_CLUSTER_REPLICATE());
  var CLUSTER_RESET_1 = __importDefault(require_CLUSTER_RESET());
  var CLUSTER_SAVECONFIG_1 = __importDefault(require_CLUSTER_SAVECONFIG());
  var CLUSTER_SET_CONFIG_EPOCH_1 = __importDefault(require_CLUSTER_SET_CONFIG_EPOCH());
  var CLUSTER_SETSLOT_1 = __importDefault(require_CLUSTER_SETSLOT());
  var CLUSTER_SLOTS_1 = __importDefault(require_CLUSTER_SLOTS());
  var COMMAND_COUNT_1 = __importDefault(require_COMMAND_COUNT());
  var COMMAND_GETKEYS_1 = __importDefault(require_COMMAND_GETKEYS());
  var COMMAND_GETKEYSANDFLAGS_1 = __importDefault(require_COMMAND_GETKEYSANDFLAGS());
  var COMMAND_INFO_1 = __importDefault(require_COMMAND_INFO());
  var COMMAND_LIST_1 = __importDefault(require_COMMAND_LIST());
  var COMMAND_1 = __importDefault(require_COMMAND());
  var CONFIG_GET_1 = __importDefault(require_CONFIG_GET());
  var CONFIG_RESETSTAT_1 = __importDefault(require_CONFIG_RESETSTAT());
  var CONFIG_REWRITE_1 = __importDefault(require_CONFIG_REWRITE());
  var CONFIG_SET_1 = __importDefault(require_CONFIG_SET());
  var COPY_1 = __importDefault(require_COPY());
  var DBSIZE_1 = __importDefault(require_DBSIZE());
  var DECR_1 = __importDefault(require_DECR());
  var DECRBY_1 = __importDefault(require_DECRBY());
  var DEL_1 = __importDefault(require_DEL());
  var DUMP_1 = __importDefault(require_DUMP());
  var ECHO_1 = __importDefault(require_ECHO());
  var EVAL_RO_1 = __importDefault(require_EVAL_RO());
  var EVAL_1 = __importDefault(require_EVAL());
  var EVALSHA_RO_1 = __importDefault(require_EVALSHA_RO());
  var EVALSHA_1 = __importDefault(require_EVALSHA());
  var GEOADD_1 = __importDefault(require_GEOADD());
  var GEODIST_1 = __importDefault(require_GEODIST());
  var GEOHASH_1 = __importDefault(require_GEOHASH());
  var GEOPOS_1 = __importDefault(require_GEOPOS());
  var GEORADIUS_RO_WITH_1 = __importDefault(require_GEORADIUS_RO_WITH());
  var GEORADIUS_RO_1 = __importDefault(require_GEORADIUS_RO());
  var GEORADIUS_STORE_1 = __importDefault(require_GEORADIUS_STORE());
  var GEORADIUS_WITH_1 = __importDefault(require_GEORADIUS_WITH());
  var GEORADIUS_1 = __importDefault(require_GEORADIUS());
  var GEORADIUSBYMEMBER_RO_WITH_1 = __importDefault(require_GEORADIUSBYMEMBER_RO_WITH());
  var GEORADIUSBYMEMBER_RO_1 = __importDefault(require_GEORADIUSBYMEMBER_RO());
  var GEORADIUSBYMEMBER_STORE_1 = __importDefault(require_GEORADIUSBYMEMBER_STORE());
  var GEORADIUSBYMEMBER_WITH_1 = __importDefault(require_GEORADIUSBYMEMBER_WITH());
  var GEORADIUSBYMEMBER_1 = __importDefault(require_GEORADIUSBYMEMBER());
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  var GEOSEARCH_1 = __importDefault(require_GEOSEARCH());
  var GEOSEARCHSTORE_1 = __importDefault(require_GEOSEARCHSTORE());
  var GET_1 = __importDefault(require_GET());
  var GETBIT_1 = __importDefault(require_GETBIT());
  var GETDEL_1 = __importDefault(require_GETDEL());
  var GETEX_1 = __importDefault(require_GETEX());
  var GETRANGE_1 = __importDefault(require_GETRANGE());
  var GETSET_1 = __importDefault(require_GETSET());
  var EXISTS_1 = __importDefault(require_EXISTS());
  var EXPIRE_1 = __importDefault(require_EXPIRE());
  var EXPIREAT_1 = __importDefault(require_EXPIREAT());
  var EXPIRETIME_1 = __importDefault(require_EXPIRETIME());
  var FLUSHALL_1 = __importDefault(require_FLUSHALL());
  var FLUSHDB_1 = __importDefault(require_FLUSHDB());
  var FCALL_1 = __importDefault(require_FCALL());
  var FCALL_RO_1 = __importDefault(require_FCALL_RO());
  var FUNCTION_DELETE_1 = __importDefault(require_FUNCTION_DELETE());
  var FUNCTION_DUMP_1 = __importDefault(require_FUNCTION_DUMP());
  var FUNCTION_FLUSH_1 = __importDefault(require_FUNCTION_FLUSH());
  var FUNCTION_KILL_1 = __importDefault(require_FUNCTION_KILL());
  var FUNCTION_LIST_WITHCODE_1 = __importDefault(require_FUNCTION_LIST_WITHCODE());
  var FUNCTION_LIST_1 = __importDefault(require_FUNCTION_LIST());
  var FUNCTION_LOAD_1 = __importDefault(require_FUNCTION_LOAD());
  var FUNCTION_RESTORE_1 = __importDefault(require_FUNCTION_RESTORE());
  var FUNCTION_STATS_1 = __importDefault(require_FUNCTION_STATS());
  var HDEL_1 = __importDefault(require_HDEL());
  var HELLO_1 = __importDefault(require_HELLO());
  var HEXISTS_1 = __importDefault(require_HEXISTS());
  var HEXPIRE_1 = __importDefault(require_HEXPIRE());
  var HEXPIREAT_1 = __importDefault(require_HEXPIREAT());
  var HEXPIRETIME_1 = __importDefault(require_HEXPIRETIME());
  var HGET_1 = __importDefault(require_HGET());
  var HGETALL_1 = __importDefault(require_HGETALL());
  var HGETDEL_1 = __importDefault(require_HGETDEL());
  var HGETEX_1 = __importDefault(require_HGETEX());
  var HINCRBY_1 = __importDefault(require_HINCRBY());
  var HINCRBYFLOAT_1 = __importDefault(require_HINCRBYFLOAT());
  var HKEYS_1 = __importDefault(require_HKEYS());
  var HLEN_1 = __importDefault(require_HLEN());
  var HMGET_1 = __importDefault(require_HMGET());
  var HPERSIST_1 = __importDefault(require_HPERSIST());
  var HPEXPIRE_1 = __importDefault(require_HPEXPIRE());
  var HPEXPIREAT_1 = __importDefault(require_HPEXPIREAT());
  var HPEXPIRETIME_1 = __importDefault(require_HPEXPIRETIME());
  var HPTTL_1 = __importDefault(require_HPTTL());
  var HRANDFIELD_COUNT_WITHVALUES_1 = __importDefault(require_HRANDFIELD_COUNT_WITHVALUES());
  var HRANDFIELD_COUNT_1 = __importDefault(require_HRANDFIELD_COUNT());
  var HRANDFIELD_1 = __importDefault(require_HRANDFIELD());
  var HSCAN_1 = __importDefault(require_HSCAN());
  var HSCAN_NOVALUES_1 = __importDefault(require_HSCAN_NOVALUES());
  var HSET_1 = __importDefault(require_HSET());
  var HSETEX_1 = __importDefault(require_HSETEX());
  var HSETNX_1 = __importDefault(require_HSETNX());
  var HSTRLEN_1 = __importDefault(require_HSTRLEN());
  var HTTL_1 = __importDefault(require_HTTL());
  var HVALS_1 = __importDefault(require_HVALS());
  var INCR_1 = __importDefault(require_INCR());
  var INCRBY_1 = __importDefault(require_INCRBY());
  var INCRBYFLOAT_1 = __importDefault(require_INCRBYFLOAT());
  var INFO_1 = __importDefault(require_INFO());
  var KEYS_1 = __importDefault(require_KEYS());
  var LASTSAVE_1 = __importDefault(require_LASTSAVE());
  var LATENCY_DOCTOR_1 = __importDefault(require_LATENCY_DOCTOR());
  var LATENCY_GRAPH_1 = __importDefault(require_LATENCY_GRAPH());
  var LATENCY_HISTORY_1 = __importDefault(require_LATENCY_HISTORY());
  var LATENCY_LATEST_1 = __importDefault(require_LATENCY_LATEST());
  var LCS_IDX_WITHMATCHLEN_1 = __importDefault(require_LCS_IDX_WITHMATCHLEN());
  var LCS_IDX_1 = __importDefault(require_LCS_IDX());
  var LCS_LEN_1 = __importDefault(require_LCS_LEN());
  var LCS_1 = __importDefault(require_LCS());
  var LINDEX_1 = __importDefault(require_LINDEX());
  var LINSERT_1 = __importDefault(require_LINSERT());
  var LLEN_1 = __importDefault(require_LLEN());
  var LMOVE_1 = __importDefault(require_LMOVE());
  var LMPOP_1 = __importDefault(require_LMPOP());
  var LOLWUT_1 = __importDefault(require_LOLWUT());
  var LPOP_COUNT_1 = __importDefault(require_LPOP_COUNT());
  var LPOP_1 = __importDefault(require_LPOP());
  var LPOS_COUNT_1 = __importDefault(require_LPOS_COUNT());
  var LPOS_1 = __importDefault(require_LPOS());
  var LPUSH_1 = __importDefault(require_LPUSH());
  var LPUSHX_1 = __importDefault(require_LPUSHX());
  var LRANGE_1 = __importDefault(require_LRANGE());
  var LREM_1 = __importDefault(require_LREM());
  var LSET_1 = __importDefault(require_LSET());
  var LTRIM_1 = __importDefault(require_LTRIM());
  var MEMORY_DOCTOR_1 = __importDefault(require_MEMORY_DOCTOR());
  var MEMORY_MALLOC_STATS_1 = __importDefault(require_MEMORY_MALLOC_STATS());
  var MEMORY_PURGE_1 = __importDefault(require_MEMORY_PURGE());
  var MEMORY_STATS_1 = __importDefault(require_MEMORY_STATS());
  var MEMORY_USAGE_1 = __importDefault(require_MEMORY_USAGE());
  var MGET_1 = __importDefault(require_MGET());
  var MIGRATE_1 = __importDefault(require_MIGRATE());
  var MODULE_LIST_1 = __importDefault(require_MODULE_LIST());
  var MODULE_LOAD_1 = __importDefault(require_MODULE_LOAD());
  var MODULE_UNLOAD_1 = __importDefault(require_MODULE_UNLOAD());
  var MOVE_1 = __importDefault(require_MOVE());
  var MSET_1 = __importDefault(require_MSET());
  var MSETNX_1 = __importDefault(require_MSETNX());
  var OBJECT_ENCODING_1 = __importDefault(require_OBJECT_ENCODING());
  var OBJECT_FREQ_1 = __importDefault(require_OBJECT_FREQ());
  var OBJECT_IDLETIME_1 = __importDefault(require_OBJECT_IDLETIME());
  var OBJECT_REFCOUNT_1 = __importDefault(require_OBJECT_REFCOUNT());
  var PERSIST_1 = __importDefault(require_PERSIST());
  var PEXPIRE_1 = __importDefault(require_PEXPIRE());
  var PEXPIREAT_1 = __importDefault(require_PEXPIREAT());
  var PEXPIRETIME_1 = __importDefault(require_PEXPIRETIME());
  var PFADD_1 = __importDefault(require_PFADD());
  var PFCOUNT_1 = __importDefault(require_PFCOUNT());
  var PFMERGE_1 = __importDefault(require_PFMERGE());
  var PING_1 = __importDefault(require_PING());
  var PSETEX_1 = __importDefault(require_PSETEX());
  var PTTL_1 = __importDefault(require_PTTL());
  var PUBLISH_1 = __importDefault(require_PUBLISH());
  var PUBSUB_CHANNELS_1 = __importDefault(require_PUBSUB_CHANNELS());
  var PUBSUB_NUMPAT_1 = __importDefault(require_PUBSUB_NUMPAT());
  var PUBSUB_NUMSUB_1 = __importDefault(require_PUBSUB_NUMSUB());
  var PUBSUB_SHARDNUMSUB_1 = __importDefault(require_PUBSUB_SHARDNUMSUB());
  var PUBSUB_SHARDCHANNELS_1 = __importDefault(require_PUBSUB_SHARDCHANNELS());
  var RANDOMKEY_1 = __importDefault(require_RANDOMKEY());
  var READONLY_1 = __importDefault(require_READONLY());
  var RENAME_1 = __importDefault(require_RENAME());
  var RENAMENX_1 = __importDefault(require_RENAMENX());
  var REPLICAOF_1 = __importDefault(require_REPLICAOF());
  var RESTORE_ASKING_1 = __importDefault(require_RESTORE_ASKING());
  var RESTORE_1 = __importDefault(require_RESTORE());
  var ROLE_1 = __importDefault(require_ROLE());
  var RPOP_COUNT_1 = __importDefault(require_RPOP_COUNT());
  var RPOP_1 = __importDefault(require_RPOP());
  var RPOPLPUSH_1 = __importDefault(require_RPOPLPUSH());
  var RPUSH_1 = __importDefault(require_RPUSH());
  var RPUSHX_1 = __importDefault(require_RPUSHX());
  var SADD_1 = __importDefault(require_SADD());
  var SCAN_1 = __importDefault(require_SCAN());
  var SCARD_1 = __importDefault(require_SCARD());
  var SCRIPT_DEBUG_1 = __importDefault(require_SCRIPT_DEBUG());
  var SCRIPT_EXISTS_1 = __importDefault(require_SCRIPT_EXISTS());
  var SCRIPT_FLUSH_1 = __importDefault(require_SCRIPT_FLUSH());
  var SCRIPT_KILL_1 = __importDefault(require_SCRIPT_KILL());
  var SCRIPT_LOAD_1 = __importDefault(require_SCRIPT_LOAD());
  var SDIFF_1 = __importDefault(require_SDIFF());
  var SDIFFSTORE_1 = __importDefault(require_SDIFFSTORE());
  var SET_1 = __importDefault(require_SET());
  var SETBIT_1 = __importDefault(require_SETBIT());
  var SETEX_1 = __importDefault(require_SETEX());
  var SETNX_1 = __importDefault(require_SETNX());
  var SETRANGE_1 = __importDefault(require_SETRANGE());
  var SINTER_1 = __importDefault(require_SINTER());
  var SINTERCARD_1 = __importDefault(require_SINTERCARD());
  var SINTERSTORE_1 = __importDefault(require_SINTERSTORE());
  var SISMEMBER_1 = __importDefault(require_SISMEMBER());
  var SMEMBERS_1 = __importDefault(require_SMEMBERS());
  var SMISMEMBER_1 = __importDefault(require_SMISMEMBER());
  var SMOVE_1 = __importDefault(require_SMOVE());
  var SORT_RO_1 = __importDefault(require_SORT_RO());
  var SORT_STORE_1 = __importDefault(require_SORT_STORE());
  var SORT_1 = __importDefault(require_SORT());
  var SPOP_COUNT_1 = __importDefault(require_SPOP_COUNT());
  var SPOP_1 = __importDefault(require_SPOP());
  var SPUBLISH_1 = __importDefault(require_SPUBLISH());
  var SRANDMEMBER_COUNT_1 = __importDefault(require_SRANDMEMBER_COUNT());
  var SRANDMEMBER_1 = __importDefault(require_SRANDMEMBER());
  var SREM_1 = __importDefault(require_SREM());
  var SSCAN_1 = __importDefault(require_SSCAN());
  var STRLEN_1 = __importDefault(require_STRLEN());
  var SUNION_1 = __importDefault(require_SUNION());
  var SUNIONSTORE_1 = __importDefault(require_SUNIONSTORE());
  var SWAPDB_1 = __importDefault(require_SWAPDB());
  var TIME_1 = __importDefault(require_TIME());
  var TOUCH_1 = __importDefault(require_TOUCH());
  var TTL_1 = __importDefault(require_TTL());
  var TYPE_1 = __importDefault(require_TYPE());
  var UNLINK_1 = __importDefault(require_UNLINK());
  var WAIT_1 = __importDefault(require_WAIT());
  var XACK_1 = __importDefault(require_XACK());
  var XADD_NOMKSTREAM_1 = __importDefault(require_XADD_NOMKSTREAM());
  var XADD_1 = __importDefault(require_XADD());
  var XAUTOCLAIM_JUSTID_1 = __importDefault(require_XAUTOCLAIM_JUSTID());
  var XAUTOCLAIM_1 = __importDefault(require_XAUTOCLAIM());
  var XCLAIM_JUSTID_1 = __importDefault(require_XCLAIM_JUSTID());
  var XCLAIM_1 = __importDefault(require_XCLAIM());
  var XDEL_1 = __importDefault(require_XDEL());
  var XGROUP_CREATE_1 = __importDefault(require_XGROUP_CREATE());
  var XGROUP_CREATECONSUMER_1 = __importDefault(require_XGROUP_CREATECONSUMER());
  var XGROUP_DELCONSUMER_1 = __importDefault(require_XGROUP_DELCONSUMER());
  var XGROUP_DESTROY_1 = __importDefault(require_XGROUP_DESTROY());
  var XGROUP_SETID_1 = __importDefault(require_XGROUP_SETID());
  var XINFO_CONSUMERS_1 = __importDefault(require_XINFO_CONSUMERS());
  var XINFO_GROUPS_1 = __importDefault(require_XINFO_GROUPS());
  var XINFO_STREAM_1 = __importDefault(require_XINFO_STREAM());
  var XLEN_1 = __importDefault(require_XLEN());
  var XPENDING_RANGE_1 = __importDefault(require_XPENDING_RANGE());
  var XPENDING_1 = __importDefault(require_XPENDING());
  var XRANGE_1 = __importDefault(require_XRANGE());
  var XREAD_1 = __importDefault(require_XREAD());
  var XREADGROUP_1 = __importDefault(require_XREADGROUP());
  var XREVRANGE_1 = __importDefault(require_XREVRANGE());
  var XSETID_1 = __importDefault(require_XSETID());
  var XTRIM_1 = __importDefault(require_XTRIM());
  var ZADD_INCR_1 = __importDefault(require_ZADD_INCR());
  var ZADD_1 = __importDefault(require_ZADD());
  var ZCARD_1 = __importDefault(require_ZCARD());
  var ZCOUNT_1 = __importDefault(require_ZCOUNT());
  var ZDIFF_WITHSCORES_1 = __importDefault(require_ZDIFF_WITHSCORES());
  var ZDIFF_1 = __importDefault(require_ZDIFF());
  var ZDIFFSTORE_1 = __importDefault(require_ZDIFFSTORE());
  var ZINCRBY_1 = __importDefault(require_ZINCRBY());
  var ZINTER_WITHSCORES_1 = __importDefault(require_ZINTER_WITHSCORES());
  var ZINTER_1 = __importDefault(require_ZINTER());
  var ZINTERCARD_1 = __importDefault(require_ZINTERCARD());
  var ZINTERSTORE_1 = __importDefault(require_ZINTERSTORE());
  var ZLEXCOUNT_1 = __importDefault(require_ZLEXCOUNT());
  var ZMPOP_1 = __importDefault(require_ZMPOP());
  var ZMSCORE_1 = __importDefault(require_ZMSCORE());
  var ZPOPMAX_COUNT_1 = __importDefault(require_ZPOPMAX_COUNT());
  var ZPOPMAX_1 = __importDefault(require_ZPOPMAX());
  var ZPOPMIN_COUNT_1 = __importDefault(require_ZPOPMIN_COUNT());
  var ZPOPMIN_1 = __importDefault(require_ZPOPMIN());
  var ZRANDMEMBER_COUNT_WITHSCORES_1 = __importDefault(require_ZRANDMEMBER_COUNT_WITHSCORES());
  var ZRANDMEMBER_COUNT_1 = __importDefault(require_ZRANDMEMBER_COUNT());
  var ZRANDMEMBER_1 = __importDefault(require_ZRANDMEMBER());
  var ZRANGE_WITHSCORES_1 = __importDefault(require_ZRANGE_WITHSCORES());
  var ZRANGE_1 = __importDefault(require_ZRANGE());
  var ZRANGEBYLEX_1 = __importDefault(require_ZRANGEBYLEX());
  var ZRANGEBYSCORE_WITHSCORES_1 = __importDefault(require_ZRANGEBYSCORE_WITHSCORES());
  var ZRANGEBYSCORE_1 = __importDefault(require_ZRANGEBYSCORE());
  var ZRANGESTORE_1 = __importDefault(require_ZRANGESTORE());
  var ZREMRANGEBYSCORE_1 = __importDefault(require_ZREMRANGEBYSCORE());
  var ZRANK_WITHSCORE_1 = __importDefault(require_ZRANK_WITHSCORE());
  var ZRANK_1 = __importDefault(require_ZRANK());
  var ZREM_1 = __importDefault(require_ZREM());
  var ZREMRANGEBYLEX_1 = __importDefault(require_ZREMRANGEBYLEX());
  var ZREMRANGEBYRANK_1 = __importDefault(require_ZREMRANGEBYRANK());
  var ZREVRANK_1 = __importDefault(require_ZREVRANK());
  var ZSCAN_1 = __importDefault(require_ZSCAN());
  var ZSCORE_1 = __importDefault(require_ZSCORE());
  var ZUNION_WITHSCORES_1 = __importDefault(require_ZUNION_WITHSCORES());
  var ZUNION_1 = __importDefault(require_ZUNION());
  var ZUNIONSTORE_1 = __importDefault(require_ZUNIONSTORE());
  exports.default = {
    ACL_CAT: ACL_CAT_1.default,
    aclCat: ACL_CAT_1.default,
    ACL_DELUSER: ACL_DELUSER_1.default,
    aclDelUser: ACL_DELUSER_1.default,
    ACL_DRYRUN: ACL_DRYRUN_1.default,
    aclDryRun: ACL_DRYRUN_1.default,
    ACL_GENPASS: ACL_GENPASS_1.default,
    aclGenPass: ACL_GENPASS_1.default,
    ACL_GETUSER: ACL_GETUSER_1.default,
    aclGetUser: ACL_GETUSER_1.default,
    ACL_LIST: ACL_LIST_1.default,
    aclList: ACL_LIST_1.default,
    ACL_LOAD: ACL_LOAD_1.default,
    aclLoad: ACL_LOAD_1.default,
    ACL_LOG_RESET: ACL_LOG_RESET_1.default,
    aclLogReset: ACL_LOG_RESET_1.default,
    ACL_LOG: ACL_LOG_1.default,
    aclLog: ACL_LOG_1.default,
    ACL_SAVE: ACL_SAVE_1.default,
    aclSave: ACL_SAVE_1.default,
    ACL_SETUSER: ACL_SETUSER_1.default,
    aclSetUser: ACL_SETUSER_1.default,
    ACL_USERS: ACL_USERS_1.default,
    aclUsers: ACL_USERS_1.default,
    ACL_WHOAMI: ACL_WHOAMI_1.default,
    aclWhoAmI: ACL_WHOAMI_1.default,
    APPEND: APPEND_1.default,
    append: APPEND_1.default,
    ASKING: ASKING_1.default,
    asking: ASKING_1.default,
    AUTH: AUTH_1.default,
    auth: AUTH_1.default,
    BGREWRITEAOF: BGREWRITEAOF_1.default,
    bgRewriteAof: BGREWRITEAOF_1.default,
    BGSAVE: BGSAVE_1.default,
    bgSave: BGSAVE_1.default,
    BITCOUNT: BITCOUNT_1.default,
    bitCount: BITCOUNT_1.default,
    BITFIELD_RO: BITFIELD_RO_1.default,
    bitFieldRo: BITFIELD_RO_1.default,
    BITFIELD: BITFIELD_1.default,
    bitField: BITFIELD_1.default,
    BITOP: BITOP_1.default,
    bitOp: BITOP_1.default,
    BITPOS: BITPOS_1.default,
    bitPos: BITPOS_1.default,
    BLMOVE: BLMOVE_1.default,
    blMove: BLMOVE_1.default,
    BLMPOP: BLMPOP_1.default,
    blmPop: BLMPOP_1.default,
    BLPOP: BLPOP_1.default,
    blPop: BLPOP_1.default,
    BRPOP: BRPOP_1.default,
    brPop: BRPOP_1.default,
    BRPOPLPUSH: BRPOPLPUSH_1.default,
    brPopLPush: BRPOPLPUSH_1.default,
    BZMPOP: BZMPOP_1.default,
    bzmPop: BZMPOP_1.default,
    BZPOPMAX: BZPOPMAX_1.default,
    bzPopMax: BZPOPMAX_1.default,
    BZPOPMIN: BZPOPMIN_1.default,
    bzPopMin: BZPOPMIN_1.default,
    CLIENT_CACHING: CLIENT_CACHING_1.default,
    clientCaching: CLIENT_CACHING_1.default,
    CLIENT_GETNAME: CLIENT_GETNAME_1.default,
    clientGetName: CLIENT_GETNAME_1.default,
    CLIENT_GETREDIR: CLIENT_GETREDIR_1.default,
    clientGetRedir: CLIENT_GETREDIR_1.default,
    CLIENT_ID: CLIENT_ID_1.default,
    clientId: CLIENT_ID_1.default,
    CLIENT_INFO: CLIENT_INFO_1.default,
    clientInfo: CLIENT_INFO_1.default,
    CLIENT_KILL: CLIENT_KILL_1.default,
    clientKill: CLIENT_KILL_1.default,
    CLIENT_LIST: CLIENT_LIST_1.default,
    clientList: CLIENT_LIST_1.default,
    "CLIENT_NO-EVICT": CLIENT_NO_EVICT_1.default,
    clientNoEvict: CLIENT_NO_EVICT_1.default,
    "CLIENT_NO-TOUCH": CLIENT_NO_TOUCH_1.default,
    clientNoTouch: CLIENT_NO_TOUCH_1.default,
    CLIENT_PAUSE: CLIENT_PAUSE_1.default,
    clientPause: CLIENT_PAUSE_1.default,
    CLIENT_SETNAME: CLIENT_SETNAME_1.default,
    clientSetName: CLIENT_SETNAME_1.default,
    CLIENT_TRACKING: CLIENT_TRACKING_1.default,
    clientTracking: CLIENT_TRACKING_1.default,
    CLIENT_TRACKINGINFO: CLIENT_TRACKINGINFO_1.default,
    clientTrackingInfo: CLIENT_TRACKINGINFO_1.default,
    CLIENT_UNPAUSE: CLIENT_UNPAUSE_1.default,
    clientUnpause: CLIENT_UNPAUSE_1.default,
    CLUSTER_ADDSLOTS: CLUSTER_ADDSLOTS_1.default,
    clusterAddSlots: CLUSTER_ADDSLOTS_1.default,
    CLUSTER_ADDSLOTSRANGE: CLUSTER_ADDSLOTSRANGE_1.default,
    clusterAddSlotsRange: CLUSTER_ADDSLOTSRANGE_1.default,
    CLUSTER_BUMPEPOCH: CLUSTER_BUMPEPOCH_1.default,
    clusterBumpEpoch: CLUSTER_BUMPEPOCH_1.default,
    "CLUSTER_COUNT-FAILURE-REPORTS": CLUSTER_COUNT_FAILURE_REPORTS_1.default,
    clusterCountFailureReports: CLUSTER_COUNT_FAILURE_REPORTS_1.default,
    CLUSTER_COUNTKEYSINSLOT: CLUSTER_COUNTKEYSINSLOT_1.default,
    clusterCountKeysInSlot: CLUSTER_COUNTKEYSINSLOT_1.default,
    CLUSTER_DELSLOTS: CLUSTER_DELSLOTS_1.default,
    clusterDelSlots: CLUSTER_DELSLOTS_1.default,
    CLUSTER_DELSLOTSRANGE: CLUSTER_DELSLOTSRANGE_1.default,
    clusterDelSlotsRange: CLUSTER_DELSLOTSRANGE_1.default,
    CLUSTER_FAILOVER: CLUSTER_FAILOVER_1.default,
    clusterFailover: CLUSTER_FAILOVER_1.default,
    CLUSTER_FLUSHSLOTS: CLUSTER_FLUSHSLOTS_1.default,
    clusterFlushSlots: CLUSTER_FLUSHSLOTS_1.default,
    CLUSTER_FORGET: CLUSTER_FORGET_1.default,
    clusterForget: CLUSTER_FORGET_1.default,
    CLUSTER_GETKEYSINSLOT: CLUSTER_GETKEYSINSLOT_1.default,
    clusterGetKeysInSlot: CLUSTER_GETKEYSINSLOT_1.default,
    CLUSTER_INFO: CLUSTER_INFO_1.default,
    clusterInfo: CLUSTER_INFO_1.default,
    CLUSTER_KEYSLOT: CLUSTER_KEYSLOT_1.default,
    clusterKeySlot: CLUSTER_KEYSLOT_1.default,
    CLUSTER_LINKS: CLUSTER_LINKS_1.default,
    clusterLinks: CLUSTER_LINKS_1.default,
    CLUSTER_MEET: CLUSTER_MEET_1.default,
    clusterMeet: CLUSTER_MEET_1.default,
    CLUSTER_MYID: CLUSTER_MYID_1.default,
    clusterMyId: CLUSTER_MYID_1.default,
    CLUSTER_MYSHARDID: CLUSTER_MYSHARDID_1.default,
    clusterMyShardId: CLUSTER_MYSHARDID_1.default,
    CLUSTER_NODES: CLUSTER_NODES_1.default,
    clusterNodes: CLUSTER_NODES_1.default,
    CLUSTER_REPLICAS: CLUSTER_REPLICAS_1.default,
    clusterReplicas: CLUSTER_REPLICAS_1.default,
    CLUSTER_REPLICATE: CLUSTER_REPLICATE_1.default,
    clusterReplicate: CLUSTER_REPLICATE_1.default,
    CLUSTER_RESET: CLUSTER_RESET_1.default,
    clusterReset: CLUSTER_RESET_1.default,
    CLUSTER_SAVECONFIG: CLUSTER_SAVECONFIG_1.default,
    clusterSaveConfig: CLUSTER_SAVECONFIG_1.default,
    "CLUSTER_SET-CONFIG-EPOCH": CLUSTER_SET_CONFIG_EPOCH_1.default,
    clusterSetConfigEpoch: CLUSTER_SET_CONFIG_EPOCH_1.default,
    CLUSTER_SETSLOT: CLUSTER_SETSLOT_1.default,
    clusterSetSlot: CLUSTER_SETSLOT_1.default,
    CLUSTER_SLOTS: CLUSTER_SLOTS_1.default,
    clusterSlots: CLUSTER_SLOTS_1.default,
    COMMAND_COUNT: COMMAND_COUNT_1.default,
    commandCount: COMMAND_COUNT_1.default,
    COMMAND_GETKEYS: COMMAND_GETKEYS_1.default,
    commandGetKeys: COMMAND_GETKEYS_1.default,
    COMMAND_GETKEYSANDFLAGS: COMMAND_GETKEYSANDFLAGS_1.default,
    commandGetKeysAndFlags: COMMAND_GETKEYSANDFLAGS_1.default,
    COMMAND_INFO: COMMAND_INFO_1.default,
    commandInfo: COMMAND_INFO_1.default,
    COMMAND_LIST: COMMAND_LIST_1.default,
    commandList: COMMAND_LIST_1.default,
    COMMAND: COMMAND_1.default,
    command: COMMAND_1.default,
    CONFIG_GET: CONFIG_GET_1.default,
    configGet: CONFIG_GET_1.default,
    CONFIG_RESETASTAT: CONFIG_RESETSTAT_1.default,
    configResetStat: CONFIG_RESETSTAT_1.default,
    CONFIG_REWRITE: CONFIG_REWRITE_1.default,
    configRewrite: CONFIG_REWRITE_1.default,
    CONFIG_SET: CONFIG_SET_1.default,
    configSet: CONFIG_SET_1.default,
    COPY: COPY_1.default,
    copy: COPY_1.default,
    DBSIZE: DBSIZE_1.default,
    dbSize: DBSIZE_1.default,
    DECR: DECR_1.default,
    decr: DECR_1.default,
    DECRBY: DECRBY_1.default,
    decrBy: DECRBY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    DUMP: DUMP_1.default,
    dump: DUMP_1.default,
    ECHO: ECHO_1.default,
    echo: ECHO_1.default,
    EVAL_RO: EVAL_RO_1.default,
    evalRo: EVAL_RO_1.default,
    EVAL: EVAL_1.default,
    eval: EVAL_1.default,
    EVALSHA_RO: EVALSHA_RO_1.default,
    evalShaRo: EVALSHA_RO_1.default,
    EVALSHA: EVALSHA_1.default,
    evalSha: EVALSHA_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    EXPIRE: EXPIRE_1.default,
    expire: EXPIRE_1.default,
    EXPIREAT: EXPIREAT_1.default,
    expireAt: EXPIREAT_1.default,
    EXPIRETIME: EXPIRETIME_1.default,
    expireTime: EXPIRETIME_1.default,
    FLUSHALL: FLUSHALL_1.default,
    flushAll: FLUSHALL_1.default,
    FLUSHDB: FLUSHDB_1.default,
    flushDb: FLUSHDB_1.default,
    FCALL: FCALL_1.default,
    fCall: FCALL_1.default,
    FCALL_RO: FCALL_RO_1.default,
    fCallRo: FCALL_RO_1.default,
    FUNCTION_DELETE: FUNCTION_DELETE_1.default,
    functionDelete: FUNCTION_DELETE_1.default,
    FUNCTION_DUMP: FUNCTION_DUMP_1.default,
    functionDump: FUNCTION_DUMP_1.default,
    FUNCTION_FLUSH: FUNCTION_FLUSH_1.default,
    functionFlush: FUNCTION_FLUSH_1.default,
    FUNCTION_KILL: FUNCTION_KILL_1.default,
    functionKill: FUNCTION_KILL_1.default,
    FUNCTION_LIST_WITHCODE: FUNCTION_LIST_WITHCODE_1.default,
    functionListWithCode: FUNCTION_LIST_WITHCODE_1.default,
    FUNCTION_LIST: FUNCTION_LIST_1.default,
    functionList: FUNCTION_LIST_1.default,
    FUNCTION_LOAD: FUNCTION_LOAD_1.default,
    functionLoad: FUNCTION_LOAD_1.default,
    FUNCTION_RESTORE: FUNCTION_RESTORE_1.default,
    functionRestore: FUNCTION_RESTORE_1.default,
    FUNCTION_STATS: FUNCTION_STATS_1.default,
    functionStats: FUNCTION_STATS_1.default,
    GEOADD: GEOADD_1.default,
    geoAdd: GEOADD_1.default,
    GEODIST: GEODIST_1.default,
    geoDist: GEODIST_1.default,
    GEOHASH: GEOHASH_1.default,
    geoHash: GEOHASH_1.default,
    GEOPOS: GEOPOS_1.default,
    geoPos: GEOPOS_1.default,
    GEORADIUS_RO_WITH: GEORADIUS_RO_WITH_1.default,
    geoRadiusRoWith: GEORADIUS_RO_WITH_1.default,
    GEORADIUS_RO: GEORADIUS_RO_1.default,
    geoRadiusRo: GEORADIUS_RO_1.default,
    GEORADIUS_STORE: GEORADIUS_STORE_1.default,
    geoRadiusStore: GEORADIUS_STORE_1.default,
    GEORADIUS_WITH: GEORADIUS_WITH_1.default,
    geoRadiusWith: GEORADIUS_WITH_1.default,
    GEORADIUS: GEORADIUS_1.default,
    geoRadius: GEORADIUS_1.default,
    GEORADIUSBYMEMBER_RO_WITH: GEORADIUSBYMEMBER_RO_WITH_1.default,
    geoRadiusByMemberRoWith: GEORADIUSBYMEMBER_RO_WITH_1.default,
    GEORADIUSBYMEMBER_RO: GEORADIUSBYMEMBER_RO_1.default,
    geoRadiusByMemberRo: GEORADIUSBYMEMBER_RO_1.default,
    GEORADIUSBYMEMBER_STORE: GEORADIUSBYMEMBER_STORE_1.default,
    geoRadiusByMemberStore: GEORADIUSBYMEMBER_STORE_1.default,
    GEORADIUSBYMEMBER_WITH: GEORADIUSBYMEMBER_WITH_1.default,
    geoRadiusByMemberWith: GEORADIUSBYMEMBER_WITH_1.default,
    GEORADIUSBYMEMBER: GEORADIUSBYMEMBER_1.default,
    geoRadiusByMember: GEORADIUSBYMEMBER_1.default,
    GEOSEARCH_WITH: GEOSEARCH_WITH_1.default,
    geoSearchWith: GEOSEARCH_WITH_1.default,
    GEOSEARCH: GEOSEARCH_1.default,
    geoSearch: GEOSEARCH_1.default,
    GEOSEARCHSTORE: GEOSEARCHSTORE_1.default,
    geoSearchStore: GEOSEARCHSTORE_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    GETBIT: GETBIT_1.default,
    getBit: GETBIT_1.default,
    GETDEL: GETDEL_1.default,
    getDel: GETDEL_1.default,
    GETEX: GETEX_1.default,
    getEx: GETEX_1.default,
    GETRANGE: GETRANGE_1.default,
    getRange: GETRANGE_1.default,
    GETSET: GETSET_1.default,
    getSet: GETSET_1.default,
    HDEL: HDEL_1.default,
    hDel: HDEL_1.default,
    HELLO: HELLO_1.default,
    hello: HELLO_1.default,
    HEXISTS: HEXISTS_1.default,
    hExists: HEXISTS_1.default,
    HEXPIRE: HEXPIRE_1.default,
    hExpire: HEXPIRE_1.default,
    HEXPIREAT: HEXPIREAT_1.default,
    hExpireAt: HEXPIREAT_1.default,
    HEXPIRETIME: HEXPIRETIME_1.default,
    hExpireTime: HEXPIRETIME_1.default,
    HGET: HGET_1.default,
    hGet: HGET_1.default,
    HGETALL: HGETALL_1.default,
    hGetAll: HGETALL_1.default,
    HGETDEL: HGETDEL_1.default,
    hGetDel: HGETDEL_1.default,
    HGETEX: HGETEX_1.default,
    hGetEx: HGETEX_1.default,
    HINCRBY: HINCRBY_1.default,
    hIncrBy: HINCRBY_1.default,
    HINCRBYFLOAT: HINCRBYFLOAT_1.default,
    hIncrByFloat: HINCRBYFLOAT_1.default,
    HKEYS: HKEYS_1.default,
    hKeys: HKEYS_1.default,
    HLEN: HLEN_1.default,
    hLen: HLEN_1.default,
    HMGET: HMGET_1.default,
    hmGet: HMGET_1.default,
    HPERSIST: HPERSIST_1.default,
    hPersist: HPERSIST_1.default,
    HPEXPIRE: HPEXPIRE_1.default,
    hpExpire: HPEXPIRE_1.default,
    HPEXPIREAT: HPEXPIREAT_1.default,
    hpExpireAt: HPEXPIREAT_1.default,
    HPEXPIRETIME: HPEXPIRETIME_1.default,
    hpExpireTime: HPEXPIRETIME_1.default,
    HPTTL: HPTTL_1.default,
    hpTTL: HPTTL_1.default,
    HRANDFIELD_COUNT_WITHVALUES: HRANDFIELD_COUNT_WITHVALUES_1.default,
    hRandFieldCountWithValues: HRANDFIELD_COUNT_WITHVALUES_1.default,
    HRANDFIELD_COUNT: HRANDFIELD_COUNT_1.default,
    hRandFieldCount: HRANDFIELD_COUNT_1.default,
    HRANDFIELD: HRANDFIELD_1.default,
    hRandField: HRANDFIELD_1.default,
    HSCAN: HSCAN_1.default,
    hScan: HSCAN_1.default,
    HSCAN_NOVALUES: HSCAN_NOVALUES_1.default,
    hScanNoValues: HSCAN_NOVALUES_1.default,
    HSET: HSET_1.default,
    hSet: HSET_1.default,
    HSETEX: HSETEX_1.default,
    hSetEx: HSETEX_1.default,
    HSETNX: HSETNX_1.default,
    hSetNX: HSETNX_1.default,
    HSTRLEN: HSTRLEN_1.default,
    hStrLen: HSTRLEN_1.default,
    HTTL: HTTL_1.default,
    hTTL: HTTL_1.default,
    HVALS: HVALS_1.default,
    hVals: HVALS_1.default,
    INCR: INCR_1.default,
    incr: INCR_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INCRBYFLOAT: INCRBYFLOAT_1.default,
    incrByFloat: INCRBYFLOAT_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    KEYS: KEYS_1.default,
    keys: KEYS_1.default,
    LASTSAVE: LASTSAVE_1.default,
    lastSave: LASTSAVE_1.default,
    LATENCY_DOCTOR: LATENCY_DOCTOR_1.default,
    latencyDoctor: LATENCY_DOCTOR_1.default,
    LATENCY_GRAPH: LATENCY_GRAPH_1.default,
    latencyGraph: LATENCY_GRAPH_1.default,
    LATENCY_HISTORY: LATENCY_HISTORY_1.default,
    latencyHistory: LATENCY_HISTORY_1.default,
    LATENCY_LATEST: LATENCY_LATEST_1.default,
    latencyLatest: LATENCY_LATEST_1.default,
    LCS_IDX_WITHMATCHLEN: LCS_IDX_WITHMATCHLEN_1.default,
    lcsIdxWithMatchLen: LCS_IDX_WITHMATCHLEN_1.default,
    LCS_IDX: LCS_IDX_1.default,
    lcsIdx: LCS_IDX_1.default,
    LCS_LEN: LCS_LEN_1.default,
    lcsLen: LCS_LEN_1.default,
    LCS: LCS_1.default,
    lcs: LCS_1.default,
    LINDEX: LINDEX_1.default,
    lIndex: LINDEX_1.default,
    LINSERT: LINSERT_1.default,
    lInsert: LINSERT_1.default,
    LLEN: LLEN_1.default,
    lLen: LLEN_1.default,
    LMOVE: LMOVE_1.default,
    lMove: LMOVE_1.default,
    LMPOP: LMPOP_1.default,
    lmPop: LMPOP_1.default,
    LOLWUT: LOLWUT_1.default,
    LPOP_COUNT: LPOP_COUNT_1.default,
    lPopCount: LPOP_COUNT_1.default,
    LPOP: LPOP_1.default,
    lPop: LPOP_1.default,
    LPOS_COUNT: LPOS_COUNT_1.default,
    lPosCount: LPOS_COUNT_1.default,
    LPOS: LPOS_1.default,
    lPos: LPOS_1.default,
    LPUSH: LPUSH_1.default,
    lPush: LPUSH_1.default,
    LPUSHX: LPUSHX_1.default,
    lPushX: LPUSHX_1.default,
    LRANGE: LRANGE_1.default,
    lRange: LRANGE_1.default,
    LREM: LREM_1.default,
    lRem: LREM_1.default,
    LSET: LSET_1.default,
    lSet: LSET_1.default,
    LTRIM: LTRIM_1.default,
    lTrim: LTRIM_1.default,
    MEMORY_DOCTOR: MEMORY_DOCTOR_1.default,
    memoryDoctor: MEMORY_DOCTOR_1.default,
    "MEMORY_MALLOC-STATS": MEMORY_MALLOC_STATS_1.default,
    memoryMallocStats: MEMORY_MALLOC_STATS_1.default,
    MEMORY_PURGE: MEMORY_PURGE_1.default,
    memoryPurge: MEMORY_PURGE_1.default,
    MEMORY_STATS: MEMORY_STATS_1.default,
    memoryStats: MEMORY_STATS_1.default,
    MEMORY_USAGE: MEMORY_USAGE_1.default,
    memoryUsage: MEMORY_USAGE_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MIGRATE: MIGRATE_1.default,
    migrate: MIGRATE_1.default,
    MODULE_LIST: MODULE_LIST_1.default,
    moduleList: MODULE_LIST_1.default,
    MODULE_LOAD: MODULE_LOAD_1.default,
    moduleLoad: MODULE_LOAD_1.default,
    MODULE_UNLOAD: MODULE_UNLOAD_1.default,
    moduleUnload: MODULE_UNLOAD_1.default,
    MOVE: MOVE_1.default,
    move: MOVE_1.default,
    MSET: MSET_1.default,
    mSet: MSET_1.default,
    MSETNX: MSETNX_1.default,
    mSetNX: MSETNX_1.default,
    OBJECT_ENCODING: OBJECT_ENCODING_1.default,
    objectEncoding: OBJECT_ENCODING_1.default,
    OBJECT_FREQ: OBJECT_FREQ_1.default,
    objectFreq: OBJECT_FREQ_1.default,
    OBJECT_IDLETIME: OBJECT_IDLETIME_1.default,
    objectIdleTime: OBJECT_IDLETIME_1.default,
    OBJECT_REFCOUNT: OBJECT_REFCOUNT_1.default,
    objectRefCount: OBJECT_REFCOUNT_1.default,
    PERSIST: PERSIST_1.default,
    persist: PERSIST_1.default,
    PEXPIRE: PEXPIRE_1.default,
    pExpire: PEXPIRE_1.default,
    PEXPIREAT: PEXPIREAT_1.default,
    pExpireAt: PEXPIREAT_1.default,
    PEXPIRETIME: PEXPIRETIME_1.default,
    pExpireTime: PEXPIRETIME_1.default,
    PFADD: PFADD_1.default,
    pfAdd: PFADD_1.default,
    PFCOUNT: PFCOUNT_1.default,
    pfCount: PFCOUNT_1.default,
    PFMERGE: PFMERGE_1.default,
    pfMerge: PFMERGE_1.default,
    PING: PING_1.default,
    ping: PING_1.default,
    PSETEX: PSETEX_1.default,
    pSetEx: PSETEX_1.default,
    PTTL: PTTL_1.default,
    pTTL: PTTL_1.default,
    PUBLISH: PUBLISH_1.default,
    publish: PUBLISH_1.default,
    PUBSUB_CHANNELS: PUBSUB_CHANNELS_1.default,
    pubSubChannels: PUBSUB_CHANNELS_1.default,
    PUBSUB_NUMPAT: PUBSUB_NUMPAT_1.default,
    pubSubNumPat: PUBSUB_NUMPAT_1.default,
    PUBSUB_NUMSUB: PUBSUB_NUMSUB_1.default,
    pubSubNumSub: PUBSUB_NUMSUB_1.default,
    PUBSUB_SHARDNUMSUB: PUBSUB_SHARDNUMSUB_1.default,
    pubSubShardNumSub: PUBSUB_SHARDNUMSUB_1.default,
    PUBSUB_SHARDCHANNELS: PUBSUB_SHARDCHANNELS_1.default,
    pubSubShardChannels: PUBSUB_SHARDCHANNELS_1.default,
    RANDOMKEY: RANDOMKEY_1.default,
    randomKey: RANDOMKEY_1.default,
    READONLY: READONLY_1.default,
    readonly: READONLY_1.default,
    RENAME: RENAME_1.default,
    rename: RENAME_1.default,
    RENAMENX: RENAMENX_1.default,
    renameNX: RENAMENX_1.default,
    REPLICAOF: REPLICAOF_1.default,
    replicaOf: REPLICAOF_1.default,
    "RESTORE-ASKING": RESTORE_ASKING_1.default,
    restoreAsking: RESTORE_ASKING_1.default,
    RESTORE: RESTORE_1.default,
    restore: RESTORE_1.default,
    RPOP_COUNT: RPOP_COUNT_1.default,
    rPopCount: RPOP_COUNT_1.default,
    ROLE: ROLE_1.default,
    role: ROLE_1.default,
    RPOP: RPOP_1.default,
    rPop: RPOP_1.default,
    RPOPLPUSH: RPOPLPUSH_1.default,
    rPopLPush: RPOPLPUSH_1.default,
    RPUSH: RPUSH_1.default,
    rPush: RPUSH_1.default,
    RPUSHX: RPUSHX_1.default,
    rPushX: RPUSHX_1.default,
    SADD: SADD_1.default,
    sAdd: SADD_1.default,
    SCAN: SCAN_1.default,
    scan: SCAN_1.default,
    SCARD: SCARD_1.default,
    sCard: SCARD_1.default,
    SCRIPT_DEBUG: SCRIPT_DEBUG_1.default,
    scriptDebug: SCRIPT_DEBUG_1.default,
    SCRIPT_EXISTS: SCRIPT_EXISTS_1.default,
    scriptExists: SCRIPT_EXISTS_1.default,
    SCRIPT_FLUSH: SCRIPT_FLUSH_1.default,
    scriptFlush: SCRIPT_FLUSH_1.default,
    SCRIPT_KILL: SCRIPT_KILL_1.default,
    scriptKill: SCRIPT_KILL_1.default,
    SCRIPT_LOAD: SCRIPT_LOAD_1.default,
    scriptLoad: SCRIPT_LOAD_1.default,
    SDIFF: SDIFF_1.default,
    sDiff: SDIFF_1.default,
    SDIFFSTORE: SDIFFSTORE_1.default,
    sDiffStore: SDIFFSTORE_1.default,
    SET: SET_1.default,
    set: SET_1.default,
    SETBIT: SETBIT_1.default,
    setBit: SETBIT_1.default,
    SETEX: SETEX_1.default,
    setEx: SETEX_1.default,
    SETNX: SETNX_1.default,
    setNX: SETNX_1.default,
    SETRANGE: SETRANGE_1.default,
    setRange: SETRANGE_1.default,
    SINTER: SINTER_1.default,
    sInter: SINTER_1.default,
    SINTERCARD: SINTERCARD_1.default,
    sInterCard: SINTERCARD_1.default,
    SINTERSTORE: SINTERSTORE_1.default,
    sInterStore: SINTERSTORE_1.default,
    SISMEMBER: SISMEMBER_1.default,
    sIsMember: SISMEMBER_1.default,
    SMEMBERS: SMEMBERS_1.default,
    sMembers: SMEMBERS_1.default,
    SMISMEMBER: SMISMEMBER_1.default,
    smIsMember: SMISMEMBER_1.default,
    SMOVE: SMOVE_1.default,
    sMove: SMOVE_1.default,
    SORT_RO: SORT_RO_1.default,
    sortRo: SORT_RO_1.default,
    SORT_STORE: SORT_STORE_1.default,
    sortStore: SORT_STORE_1.default,
    SORT: SORT_1.default,
    sort: SORT_1.default,
    SPOP_COUNT: SPOP_COUNT_1.default,
    sPopCount: SPOP_COUNT_1.default,
    SPOP: SPOP_1.default,
    sPop: SPOP_1.default,
    SPUBLISH: SPUBLISH_1.default,
    sPublish: SPUBLISH_1.default,
    SRANDMEMBER_COUNT: SRANDMEMBER_COUNT_1.default,
    sRandMemberCount: SRANDMEMBER_COUNT_1.default,
    SRANDMEMBER: SRANDMEMBER_1.default,
    sRandMember: SRANDMEMBER_1.default,
    SREM: SREM_1.default,
    sRem: SREM_1.default,
    SSCAN: SSCAN_1.default,
    sScan: SSCAN_1.default,
    STRLEN: STRLEN_1.default,
    strLen: STRLEN_1.default,
    SUNION: SUNION_1.default,
    sUnion: SUNION_1.default,
    SUNIONSTORE: SUNIONSTORE_1.default,
    sUnionStore: SUNIONSTORE_1.default,
    SWAPDB: SWAPDB_1.default,
    swapDb: SWAPDB_1.default,
    TIME: TIME_1.default,
    time: TIME_1.default,
    TOUCH: TOUCH_1.default,
    touch: TOUCH_1.default,
    TTL: TTL_1.default,
    ttl: TTL_1.default,
    TYPE: TYPE_1.default,
    type: TYPE_1.default,
    UNLINK: UNLINK_1.default,
    unlink: UNLINK_1.default,
    WAIT: WAIT_1.default,
    wait: WAIT_1.default,
    XACK: XACK_1.default,
    xAck: XACK_1.default,
    XADD_NOMKSTREAM: XADD_NOMKSTREAM_1.default,
    xAddNoMkStream: XADD_NOMKSTREAM_1.default,
    XADD: XADD_1.default,
    xAdd: XADD_1.default,
    XAUTOCLAIM_JUSTID: XAUTOCLAIM_JUSTID_1.default,
    xAutoClaimJustId: XAUTOCLAIM_JUSTID_1.default,
    XAUTOCLAIM: XAUTOCLAIM_1.default,
    xAutoClaim: XAUTOCLAIM_1.default,
    XCLAIM_JUSTID: XCLAIM_JUSTID_1.default,
    xClaimJustId: XCLAIM_JUSTID_1.default,
    XCLAIM: XCLAIM_1.default,
    xClaim: XCLAIM_1.default,
    XDEL: XDEL_1.default,
    xDel: XDEL_1.default,
    XGROUP_CREATE: XGROUP_CREATE_1.default,
    xGroupCreate: XGROUP_CREATE_1.default,
    XGROUP_CREATECONSUMER: XGROUP_CREATECONSUMER_1.default,
    xGroupCreateConsumer: XGROUP_CREATECONSUMER_1.default,
    XGROUP_DELCONSUMER: XGROUP_DELCONSUMER_1.default,
    xGroupDelConsumer: XGROUP_DELCONSUMER_1.default,
    XGROUP_DESTROY: XGROUP_DESTROY_1.default,
    xGroupDestroy: XGROUP_DESTROY_1.default,
    XGROUP_SETID: XGROUP_SETID_1.default,
    xGroupSetId: XGROUP_SETID_1.default,
    XINFO_CONSUMERS: XINFO_CONSUMERS_1.default,
    xInfoConsumers: XINFO_CONSUMERS_1.default,
    XINFO_GROUPS: XINFO_GROUPS_1.default,
    xInfoGroups: XINFO_GROUPS_1.default,
    XINFO_STREAM: XINFO_STREAM_1.default,
    xInfoStream: XINFO_STREAM_1.default,
    XLEN: XLEN_1.default,
    xLen: XLEN_1.default,
    XPENDING_RANGE: XPENDING_RANGE_1.default,
    xPendingRange: XPENDING_RANGE_1.default,
    XPENDING: XPENDING_1.default,
    xPending: XPENDING_1.default,
    XRANGE: XRANGE_1.default,
    xRange: XRANGE_1.default,
    XREAD: XREAD_1.default,
    xRead: XREAD_1.default,
    XREADGROUP: XREADGROUP_1.default,
    xReadGroup: XREADGROUP_1.default,
    XREVRANGE: XREVRANGE_1.default,
    xRevRange: XREVRANGE_1.default,
    XSETID: XSETID_1.default,
    xSetId: XSETID_1.default,
    XTRIM: XTRIM_1.default,
    xTrim: XTRIM_1.default,
    ZADD_INCR: ZADD_INCR_1.default,
    zAddIncr: ZADD_INCR_1.default,
    ZADD: ZADD_1.default,
    zAdd: ZADD_1.default,
    ZCARD: ZCARD_1.default,
    zCard: ZCARD_1.default,
    ZCOUNT: ZCOUNT_1.default,
    zCount: ZCOUNT_1.default,
    ZDIFF_WITHSCORES: ZDIFF_WITHSCORES_1.default,
    zDiffWithScores: ZDIFF_WITHSCORES_1.default,
    ZDIFF: ZDIFF_1.default,
    zDiff: ZDIFF_1.default,
    ZDIFFSTORE: ZDIFFSTORE_1.default,
    zDiffStore: ZDIFFSTORE_1.default,
    ZINCRBY: ZINCRBY_1.default,
    zIncrBy: ZINCRBY_1.default,
    ZINTER_WITHSCORES: ZINTER_WITHSCORES_1.default,
    zInterWithScores: ZINTER_WITHSCORES_1.default,
    ZINTER: ZINTER_1.default,
    zInter: ZINTER_1.default,
    ZINTERCARD: ZINTERCARD_1.default,
    zInterCard: ZINTERCARD_1.default,
    ZINTERSTORE: ZINTERSTORE_1.default,
    zInterStore: ZINTERSTORE_1.default,
    ZLEXCOUNT: ZLEXCOUNT_1.default,
    zLexCount: ZLEXCOUNT_1.default,
    ZMPOP: ZMPOP_1.default,
    zmPop: ZMPOP_1.default,
    ZMSCORE: ZMSCORE_1.default,
    zmScore: ZMSCORE_1.default,
    ZPOPMAX_COUNT: ZPOPMAX_COUNT_1.default,
    zPopMaxCount: ZPOPMAX_COUNT_1.default,
    ZPOPMAX: ZPOPMAX_1.default,
    zPopMax: ZPOPMAX_1.default,
    ZPOPMIN_COUNT: ZPOPMIN_COUNT_1.default,
    zPopMinCount: ZPOPMIN_COUNT_1.default,
    ZPOPMIN: ZPOPMIN_1.default,
    zPopMin: ZPOPMIN_1.default,
    ZRANDMEMBER_COUNT_WITHSCORES: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
    zRandMemberCountWithScores: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
    ZRANDMEMBER_COUNT: ZRANDMEMBER_COUNT_1.default,
    zRandMemberCount: ZRANDMEMBER_COUNT_1.default,
    ZRANDMEMBER: ZRANDMEMBER_1.default,
    zRandMember: ZRANDMEMBER_1.default,
    ZRANGE_WITHSCORES: ZRANGE_WITHSCORES_1.default,
    zRangeWithScores: ZRANGE_WITHSCORES_1.default,
    ZRANGE: ZRANGE_1.default,
    zRange: ZRANGE_1.default,
    ZRANGEBYLEX: ZRANGEBYLEX_1.default,
    zRangeByLex: ZRANGEBYLEX_1.default,
    ZRANGEBYSCORE_WITHSCORES: ZRANGEBYSCORE_WITHSCORES_1.default,
    zRangeByScoreWithScores: ZRANGEBYSCORE_WITHSCORES_1.default,
    ZRANGEBYSCORE: ZRANGEBYSCORE_1.default,
    zRangeByScore: ZRANGEBYSCORE_1.default,
    ZRANGESTORE: ZRANGESTORE_1.default,
    zRangeStore: ZRANGESTORE_1.default,
    ZRANK_WITHSCORE: ZRANK_WITHSCORE_1.default,
    zRankWithScore: ZRANK_WITHSCORE_1.default,
    ZRANK: ZRANK_1.default,
    zRank: ZRANK_1.default,
    ZREM: ZREM_1.default,
    zRem: ZREM_1.default,
    ZREMRANGEBYLEX: ZREMRANGEBYLEX_1.default,
    zRemRangeByLex: ZREMRANGEBYLEX_1.default,
    ZREMRANGEBYRANK: ZREMRANGEBYRANK_1.default,
    zRemRangeByRank: ZREMRANGEBYRANK_1.default,
    ZREMRANGEBYSCORE: ZREMRANGEBYSCORE_1.default,
    zRemRangeByScore: ZREMRANGEBYSCORE_1.default,
    ZREVRANK: ZREVRANK_1.default,
    zRevRank: ZREVRANK_1.default,
    ZSCAN: ZSCAN_1.default,
    zScan: ZSCAN_1.default,
    ZSCORE: ZSCORE_1.default,
    zScore: ZSCORE_1.default,
    ZUNION_WITHSCORES: ZUNION_WITHSCORES_1.default,
    zUnionWithScores: ZUNION_WITHSCORES_1.default,
    ZUNION: ZUNION_1.default,
    zUnion: ZUNION_1.default,
    ZUNIONSTORE: ZUNIONSTORE_1.default,
    zUnionStore: ZUNIONSTORE_1.default
  };
});

// node_modules/@redis/client/dist/lib/client/socket.js
var require_socket = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_events_1 = __require("node:events");
  var node_net_1 = __importDefault(__require("node:net"));
  var node_tls_1 = __importDefault(__require("node:tls"));
  var errors_1 = require_errors();
  var promises_1 = __require("node:timers/promises");

  class RedisSocket extends node_events_1.EventEmitter {
    #initiator;
    #connectTimeout;
    #reconnectStrategy;
    #socketFactory;
    #socketTimeout;
    #socket;
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #isReady = false;
    get isReady() {
      return this.#isReady;
    }
    #isSocketUnrefed = false;
    #socketEpoch = 0;
    get socketEpoch() {
      return this.#socketEpoch;
    }
    constructor(initiator, options) {
      super();
      this.#initiator = initiator;
      this.#connectTimeout = options?.connectTimeout ?? 5000;
      this.#reconnectStrategy = this.#createReconnectStrategy(options);
      this.#socketFactory = this.#createSocketFactory(options);
      this.#socketTimeout = options?.socketTimeout;
    }
    #createReconnectStrategy(options) {
      const strategy = options?.reconnectStrategy;
      if (strategy === false || typeof strategy === "number") {
        return () => strategy;
      }
      if (strategy) {
        return (retries, cause) => {
          try {
            const retryIn = strategy(retries, cause);
            if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== "number") {
              throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
            }
            return retryIn;
          } catch (err) {
            this.emit("error", err);
            return this.defaultReconnectStrategy(retries, err);
          }
        };
      }
      return this.defaultReconnectStrategy;
    }
    #createSocketFactory(options) {
      if (options?.tls === true) {
        const withDefaults2 = {
          ...options,
          port: options?.port ?? 6379,
          noDelay: options?.noDelay ?? true,
          keepAlive: options?.keepAlive ?? true,
          keepAliveInitialDelay: options?.keepAliveInitialDelay ?? 5000,
          timeout: undefined,
          onread: undefined,
          readable: true,
          writable: true
        };
        return {
          create() {
            return node_tls_1.default.connect(withDefaults2);
          },
          event: "secureConnect"
        };
      }
      if (options && "path" in options) {
        const withDefaults2 = {
          ...options,
          timeout: undefined,
          onread: undefined,
          readable: true,
          writable: true
        };
        return {
          create() {
            return node_net_1.default.createConnection(withDefaults2);
          },
          event: "connect"
        };
      }
      const withDefaults = {
        ...options,
        port: options?.port ?? 6379,
        noDelay: options?.noDelay ?? true,
        keepAlive: options?.keepAlive ?? true,
        keepAliveInitialDelay: options?.keepAliveInitialDelay ?? 5000,
        timeout: undefined,
        onread: undefined,
        readable: true,
        writable: true
      };
      return {
        create() {
          return node_net_1.default.createConnection(withDefaults);
        },
        event: "connect"
      };
    }
    #shouldReconnect(retries, cause) {
      const retryIn = this.#reconnectStrategy(retries, cause);
      if (retryIn === false) {
        this.#isOpen = false;
        this.emit("error", cause);
        return cause;
      } else if (retryIn instanceof Error) {
        this.#isOpen = false;
        this.emit("error", cause);
        return new errors_1.ReconnectStrategyError(retryIn, cause);
      }
      return retryIn;
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("Socket already opened");
      }
      this.#isOpen = true;
      return this.#connect();
    }
    async#connect() {
      let retries = 0;
      do {
        try {
          this.#socket = await this.#createSocket();
          this.emit("connect");
          try {
            await this.#initiator();
          } catch (err) {
            this.#socket.destroy();
            this.#socket = undefined;
            throw err;
          }
          this.#isReady = true;
          this.#socketEpoch++;
          this.emit("ready");
        } catch (err) {
          const retryIn = this.#shouldReconnect(retries++, err);
          if (typeof retryIn !== "number") {
            throw retryIn;
          }
          this.emit("error", err);
          await (0, promises_1.setTimeout)(retryIn);
          this.emit("reconnecting");
        }
      } while (this.#isOpen && !this.#isReady);
    }
    async#createSocket() {
      const socket = this.#socketFactory.create();
      let onTimeout;
      if (this.#connectTimeout !== undefined) {
        onTimeout = () => socket.destroy(new errors_1.ConnectionTimeoutError);
        socket.once("timeout", onTimeout);
        socket.setTimeout(this.#connectTimeout);
      }
      if (this.#isSocketUnrefed) {
        socket.unref();
      }
      await (0, node_events_1.once)(socket, this.#socketFactory.event);
      if (onTimeout) {
        socket.removeListener("timeout", onTimeout);
      }
      if (this.#socketTimeout) {
        socket.once("timeout", () => {
          socket.destroy(new errors_1.SocketTimeoutError(this.#socketTimeout));
        });
        socket.setTimeout(this.#socketTimeout);
      }
      socket.once("error", (err) => this.#onSocketError(err)).once("close", (hadError) => {
        if (hadError || !this.#isOpen || this.#socket !== socket)
          return;
        this.#onSocketError(new errors_1.SocketClosedUnexpectedlyError);
      }).on("drain", () => this.emit("drain")).on("data", (data) => this.emit("data", data));
      return socket;
    }
    #onSocketError(err) {
      const wasReady = this.#isReady;
      this.#isReady = false;
      this.emit("error", err);
      if (!wasReady || !this.#isOpen || typeof this.#shouldReconnect(0, err) !== "number")
        return;
      this.emit("reconnecting");
      this.#connect().catch(() => {});
    }
    write(iterable) {
      if (!this.#socket)
        return;
      this.#socket.cork();
      for (const args of iterable) {
        for (const toWrite of args) {
          this.#socket.write(toWrite);
        }
        if (this.#socket.writableNeedDrain)
          break;
      }
      this.#socket.uncork();
    }
    async quit(fn) {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
      const reply = await fn();
      this.destroySocket();
      return reply;
    }
    close() {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
    }
    destroy() {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
      this.destroySocket();
    }
    destroySocket() {
      this.#isReady = false;
      if (this.#socket) {
        this.#socket.destroy();
        this.#socket = undefined;
      }
      this.emit("end");
    }
    ref() {
      this.#isSocketUnrefed = false;
      this.#socket?.ref();
    }
    unref() {
      this.#isSocketUnrefed = true;
      this.#socket?.unref();
    }
    defaultReconnectStrategy(retries, cause) {
      if (cause instanceof errors_1.SocketTimeoutError) {
        return false;
      }
      const jitter = Math.floor(Math.random() * 200);
      const delay = Math.min(Math.pow(2, retries) * 50, 2000);
      return delay + jitter;
    }
  }
  exports.default = RedisSocket;
});

// node_modules/@redis/client/dist/lib/authx/token.js
var require_token = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Token = undefined;

  class Token {
    value;
    expiresAtMs;
    receivedAtMs;
    constructor(value, expiresAtMs, receivedAtMs) {
      this.value = value;
      this.expiresAtMs = expiresAtMs;
      this.receivedAtMs = receivedAtMs;
    }
    getTtlMs(now) {
      if (this.expiresAtMs < now) {
        return 0;
      }
      return this.expiresAtMs - now;
    }
  }
  exports.Token = Token;
});

// node_modules/@redis/client/dist/lib/authx/token-manager.js
var require_token_manager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenManager = exports.IDPError = undefined;
  var token_1 = require_token();

  class IDPError extends Error {
    message;
    isRetryable;
    constructor(message, isRetryable) {
      super(message);
      this.message = message;
      this.isRetryable = isRetryable;
      this.name = "IDPError";
    }
  }
  exports.IDPError = IDPError;

  class TokenManager {
    identityProvider;
    config;
    currentToken = null;
    refreshTimeout = null;
    listener = null;
    retryAttempt = 0;
    constructor(identityProvider, config) {
      this.identityProvider = identityProvider;
      this.config = config;
      if (this.config.expirationRefreshRatio > 1) {
        throw new Error("expirationRefreshRatio must be less than or equal to 1");
      }
      if (this.config.expirationRefreshRatio < 0) {
        throw new Error("expirationRefreshRatio must be greater or equal to 0");
      }
    }
    start(listener, initialDelayMs = 0) {
      if (this.listener) {
        this.stop();
      }
      this.listener = listener;
      this.retryAttempt = 0;
      this.scheduleNextRefresh(initialDelayMs);
      return {
        dispose: () => this.stop()
      };
    }
    calculateRetryDelay() {
      if (!this.config.retry)
        return 0;
      const { initialDelayMs, maxDelayMs, backoffMultiplier, jitterPercentage } = this.config.retry;
      let delay = initialDelayMs * Math.pow(backoffMultiplier, this.retryAttempt - 1);
      delay = Math.min(delay, maxDelayMs);
      if (jitterPercentage) {
        const jitterRange = delay * (jitterPercentage / 100);
        const jitterAmount = Math.random() * jitterRange - jitterRange / 2;
        delay += jitterAmount;
      }
      let result = Math.max(0, Math.floor(delay));
      return result;
    }
    shouldRetry(error) {
      if (!this.config.retry)
        return false;
      const { maxAttempts, isRetryable } = this.config.retry;
      if (this.retryAttempt >= maxAttempts) {
        return false;
      }
      if (isRetryable) {
        return isRetryable(error, this.retryAttempt);
      }
      return false;
    }
    isRunning() {
      return this.listener !== null;
    }
    async refresh() {
      if (!this.listener) {
        throw new Error("TokenManager is not running, but refresh was called");
      }
      try {
        await this.identityProvider.requestToken().then(this.handleNewToken);
        this.retryAttempt = 0;
      } catch (error) {
        if (this.shouldRetry(error)) {
          this.retryAttempt++;
          const retryDelay = this.calculateRetryDelay();
          this.notifyError(`Token refresh failed (attempt ${this.retryAttempt}), retrying in ${retryDelay}ms: ${error}`, true);
          this.scheduleNextRefresh(retryDelay);
        } else {
          this.notifyError(error, false);
          this.stop();
        }
      }
    }
    handleNewToken = async ({ token: nativeToken, ttlMs }) => {
      if (!this.listener) {
        throw new Error("TokenManager is not running, but a new token was received");
      }
      const token = this.wrapAndSetCurrentToken(nativeToken, ttlMs);
      this.listener.onNext(token);
      this.scheduleNextRefresh(this.calculateRefreshTime(token));
    };
    wrapAndSetCurrentToken(nativeToken, ttlMs) {
      const now = Date.now();
      const token = new token_1.Token(nativeToken, now + ttlMs, now);
      this.currentToken = token;
      return token;
    }
    scheduleNextRefresh(delayMs) {
      if (this.refreshTimeout) {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = null;
      }
      if (delayMs === 0) {
        this.refresh();
      } else {
        this.refreshTimeout = setTimeout(() => this.refresh(), delayMs);
      }
    }
    calculateRefreshTime(token, now = Date.now()) {
      const ttlMs = token.getTtlMs(now);
      return Math.floor(ttlMs * this.config.expirationRefreshRatio);
    }
    stop() {
      if (this.refreshTimeout) {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = null;
      }
      this.listener = null;
      this.currentToken = null;
      this.retryAttempt = 0;
    }
    getCurrentToken() {
      return this.currentToken;
    }
    notifyError(error, isRetryable) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (!this.listener) {
        throw new Error(`TokenManager is not running but received an error: ${errorMessage}`);
      }
      this.listener.onError(new IDPError(errorMessage, isRetryable));
    }
  }
  exports.TokenManager = TokenManager;
});

// node_modules/@redis/client/dist/lib/authx/credentials-provider.js
var require_credentials_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnableToObtainNewCredentialsError = exports.CredentialsError = undefined;

  class CredentialsError extends Error {
    constructor(message) {
      super(`Re-authentication with latest credentials failed: ${message}`);
      this.name = "CredentialsError";
    }
  }
  exports.CredentialsError = CredentialsError;

  class UnableToObtainNewCredentialsError extends Error {
    constructor(message) {
      super(`Unable to obtain new credentials : ${message}`);
      this.name = "UnableToObtainNewCredentialsError";
    }
  }
  exports.UnableToObtainNewCredentialsError = UnableToObtainNewCredentialsError;
});

// node_modules/@redis/client/dist/lib/authx/index.js
var require_authx = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Token = exports.CredentialsError = exports.UnableToObtainNewCredentialsError = exports.IDPError = exports.TokenManager = undefined;
  var token_manager_1 = require_token_manager();
  Object.defineProperty(exports, "TokenManager", { enumerable: true, get: function() {
    return token_manager_1.TokenManager;
  } });
  Object.defineProperty(exports, "IDPError", { enumerable: true, get: function() {
    return token_manager_1.IDPError;
  } });
  var credentials_provider_1 = require_credentials_provider();
  Object.defineProperty(exports, "UnableToObtainNewCredentialsError", { enumerable: true, get: function() {
    return credentials_provider_1.UnableToObtainNewCredentialsError;
  } });
  Object.defineProperty(exports, "CredentialsError", { enumerable: true, get: function() {
    return credentials_provider_1.CredentialsError;
  } });
  var token_1 = require_token();
  Object.defineProperty(exports, "Token", { enumerable: true, get: function() {
    return token_1.Token;
  } });
});

// node_modules/@redis/client/dist/lib/client/linked-list.js
var require_linked_list = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinglyLinkedList = exports.DoublyLinkedList = undefined;

  class DoublyLinkedList {
    #length = 0;
    get length() {
      return this.#length;
    }
    #head;
    get head() {
      return this.#head;
    }
    #tail;
    get tail() {
      return this.#tail;
    }
    push(value) {
      ++this.#length;
      if (this.#tail === undefined) {
        return this.#tail = this.#head = {
          previous: this.#head,
          next: undefined,
          value
        };
      }
      return this.#tail = this.#tail.next = {
        previous: this.#tail,
        next: undefined,
        value
      };
    }
    unshift(value) {
      ++this.#length;
      if (this.#head === undefined) {
        return this.#head = this.#tail = {
          previous: undefined,
          next: undefined,
          value
        };
      }
      return this.#head = this.#head.previous = {
        previous: undefined,
        next: this.#head,
        value
      };
    }
    add(value, prepend = false) {
      return prepend ? this.unshift(value) : this.push(value);
    }
    shift() {
      if (this.#head === undefined)
        return;
      --this.#length;
      const node = this.#head;
      if (node.next) {
        node.next.previous = node.previous;
        this.#head = node.next;
        node.next = undefined;
      } else {
        this.#head = this.#tail = undefined;
      }
      return node.value;
    }
    remove(node) {
      --this.#length;
      if (this.#tail === node) {
        this.#tail = node.previous;
      }
      if (this.#head === node) {
        this.#head = node.next;
      } else {
        node.previous.next = node.next;
        node.previous = undefined;
      }
      node.next = undefined;
    }
    reset() {
      this.#length = 0;
      this.#head = this.#tail = undefined;
    }
    *[Symbol.iterator]() {
      let node = this.#head;
      while (node !== undefined) {
        yield node.value;
        node = node.next;
      }
    }
  }
  exports.DoublyLinkedList = DoublyLinkedList;

  class SinglyLinkedList {
    #length = 0;
    get length() {
      return this.#length;
    }
    #head;
    get head() {
      return this.#head;
    }
    #tail;
    get tail() {
      return this.#tail;
    }
    push(value) {
      ++this.#length;
      const node = {
        value,
        next: undefined,
        removed: false
      };
      if (this.#head === undefined) {
        return this.#head = this.#tail = node;
      }
      return this.#tail.next = this.#tail = node;
    }
    remove(node, parent) {
      if (node.removed) {
        throw new Error("node already removed");
      }
      --this.#length;
      if (this.#head === node) {
        if (this.#tail === node) {
          this.#head = this.#tail = undefined;
        } else {
          this.#head = node.next;
        }
      } else if (this.#tail === node) {
        this.#tail = parent;
        parent.next = undefined;
      } else {
        parent.next = node.next;
      }
      node.removed = true;
    }
    shift() {
      if (this.#head === undefined)
        return;
      const node = this.#head;
      if (--this.#length === 0) {
        this.#head = this.#tail = undefined;
      } else {
        this.#head = node.next;
      }
      node.removed = true;
      return node.value;
    }
    reset() {
      this.#length = 0;
      this.#head = this.#tail = undefined;
    }
    *[Symbol.iterator]() {
      let node = this.#head;
      while (node !== undefined) {
        yield node.value;
        node = node.next;
      }
    }
  }
  exports.SinglyLinkedList = SinglyLinkedList;
});

// node_modules/@redis/client/dist/lib/RESP/encoder.js
var require_encoder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CRLF = `\r
`;
  function encodeCommand(args) {
    const toWrite = [];
    let strings = "*" + args.length + CRLF;
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string") {
        strings += "$" + Buffer.byteLength(arg) + CRLF + arg + CRLF;
      } else if (arg instanceof Buffer) {
        toWrite.push(strings + "$" + arg.length.toString() + CRLF, arg);
        strings = CRLF;
      } else {
        throw new TypeError(`"arguments[${i}]" must be of type "string | Buffer", got ${typeof arg} instead.`);
      }
    }
    toWrite.push(strings);
    return toWrite;
  }
  exports.default = encodeCommand;
});

// node_modules/@redis/client/dist/lib/client/pub-sub.js
var require_pub_sub = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PubSub = exports.PUBSUB_TYPE = undefined;
  exports.PUBSUB_TYPE = {
    CHANNELS: "CHANNELS",
    PATTERNS: "PATTERNS",
    SHARDED: "SHARDED"
  };
  var COMMANDS = {
    [exports.PUBSUB_TYPE.CHANNELS]: {
      subscribe: Buffer.from("subscribe"),
      unsubscribe: Buffer.from("unsubscribe"),
      message: Buffer.from("message")
    },
    [exports.PUBSUB_TYPE.PATTERNS]: {
      subscribe: Buffer.from("psubscribe"),
      unsubscribe: Buffer.from("punsubscribe"),
      message: Buffer.from("pmessage")
    },
    [exports.PUBSUB_TYPE.SHARDED]: {
      subscribe: Buffer.from("ssubscribe"),
      unsubscribe: Buffer.from("sunsubscribe"),
      message: Buffer.from("smessage")
    }
  };

  class PubSub {
    static isStatusReply(reply) {
      return COMMANDS[exports.PUBSUB_TYPE.CHANNELS].subscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.CHANNELS].unsubscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.PATTERNS].subscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.PATTERNS].unsubscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.SHARDED].subscribe.equals(reply[0]);
    }
    static isShardedUnsubscribe(reply) {
      return COMMANDS[exports.PUBSUB_TYPE.SHARDED].unsubscribe.equals(reply[0]);
    }
    static #channelsArray(channels) {
      return Array.isArray(channels) ? channels : [channels];
    }
    static #listenersSet(listeners, returnBuffers) {
      return returnBuffers ? listeners.buffers : listeners.strings;
    }
    #subscribing = 0;
    #isActive = false;
    get isActive() {
      return this.#isActive;
    }
    listeners = {
      [exports.PUBSUB_TYPE.CHANNELS]: new Map,
      [exports.PUBSUB_TYPE.PATTERNS]: new Map,
      [exports.PUBSUB_TYPE.SHARDED]: new Map
    };
    subscribe(type, channels, listener, returnBuffers) {
      const args = [COMMANDS[type].subscribe], channelsArray = PubSub.#channelsArray(channels);
      for (const channel of channelsArray) {
        let channelListeners = this.listeners[type].get(channel);
        if (!channelListeners || channelListeners.unsubscribing) {
          args.push(channel);
        }
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          PubSub.#listenersSet(this.listeners[type].get(channel), returnBuffers).add(listener);
        }
        return;
      }
      this.#isActive = true;
      this.#subscribing++;
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => {
          this.#subscribing--;
          for (const channel of channelsArray) {
            let listeners = this.listeners[type].get(channel);
            if (!listeners) {
              listeners = {
                unsubscribing: false,
                buffers: new Set,
                strings: new Set
              };
              this.listeners[type].set(channel, listeners);
            }
            PubSub.#listenersSet(listeners, returnBuffers).add(listener);
          }
        },
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    extendChannelListeners(type, channel, listeners) {
      if (!this.#extendChannelListeners(type, channel, listeners))
        return;
      this.#isActive = true;
      this.#subscribing++;
      return {
        args: [
          COMMANDS[type].subscribe,
          channel
        ],
        channelsCounter: 1,
        resolve: () => this.#subscribing--,
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    #extendChannelListeners(type, channel, listeners) {
      const existingListeners = this.listeners[type].get(channel);
      if (!existingListeners) {
        this.listeners[type].set(channel, listeners);
        return true;
      }
      for (const listener of listeners.buffers) {
        existingListeners.buffers.add(listener);
      }
      for (const listener of listeners.strings) {
        existingListeners.strings.add(listener);
      }
      return false;
    }
    extendTypeListeners(type, listeners) {
      const args = [COMMANDS[type].subscribe];
      for (const [channel, channelListeners] of listeners) {
        if (this.#extendChannelListeners(type, channel, channelListeners)) {
          args.push(channel);
        }
      }
      if (args.length === 1)
        return;
      this.#isActive = true;
      this.#subscribing++;
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => this.#subscribing--,
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    unsubscribe(type, channels, listener, returnBuffers) {
      const listeners = this.listeners[type];
      if (!channels) {
        return this.#unsubscribeCommand([COMMANDS[type].unsubscribe], NaN, () => listeners.clear());
      }
      const channelsArray = PubSub.#channelsArray(channels);
      if (!listener) {
        return this.#unsubscribeCommand([COMMANDS[type].unsubscribe, ...channelsArray], channelsArray.length, () => {
          for (const channel of channelsArray) {
            listeners.delete(channel);
          }
        });
      }
      const args = [COMMANDS[type].unsubscribe];
      for (const channel of channelsArray) {
        const sets = listeners.get(channel);
        if (sets) {
          let current, other;
          if (returnBuffers) {
            current = sets.buffers;
            other = sets.strings;
          } else {
            current = sets.strings;
            other = sets.buffers;
          }
          const currentSize = current.has(listener) ? current.size - 1 : current.size;
          if (currentSize !== 0 || other.size !== 0)
            continue;
          sets.unsubscribing = true;
        }
        args.push(channel);
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          PubSub.#listenersSet(listeners.get(channel), returnBuffers).delete(listener);
        }
        return;
      }
      return this.#unsubscribeCommand(args, args.length - 1, () => {
        for (const channel of channelsArray) {
          const sets = listeners.get(channel);
          if (!sets)
            continue;
          (returnBuffers ? sets.buffers : sets.strings).delete(listener);
          if (sets.buffers.size === 0 && sets.strings.size === 0) {
            listeners.delete(channel);
          }
        }
      });
    }
    #unsubscribeCommand(args, channelsCounter, removeListeners) {
      return {
        args,
        channelsCounter,
        resolve: () => {
          removeListeners();
          this.#updateIsActive();
        },
        reject: undefined
      };
    }
    #updateIsActive() {
      this.#isActive = this.listeners[exports.PUBSUB_TYPE.CHANNELS].size !== 0 || this.listeners[exports.PUBSUB_TYPE.PATTERNS].size !== 0 || this.listeners[exports.PUBSUB_TYPE.SHARDED].size !== 0 || this.#subscribing !== 0;
    }
    reset() {
      this.#isActive = false;
      this.#subscribing = 0;
    }
    resubscribe() {
      const commands = [];
      for (const [type, listeners] of Object.entries(this.listeners)) {
        if (!listeners.size)
          continue;
        this.#isActive = true;
        this.#subscribing++;
        const callback = () => this.#subscribing--;
        commands.push({
          args: [
            COMMANDS[type].subscribe,
            ...listeners.keys()
          ],
          channelsCounter: listeners.size,
          resolve: callback,
          reject: callback
        });
      }
      return commands;
    }
    handleMessageReply(reply) {
      if (COMMANDS[exports.PUBSUB_TYPE.CHANNELS].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.CHANNELS, reply[2], reply[1]);
        return true;
      } else if (COMMANDS[exports.PUBSUB_TYPE.PATTERNS].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.PATTERNS, reply[3], reply[2], reply[1]);
        return true;
      } else if (COMMANDS[exports.PUBSUB_TYPE.SHARDED].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.SHARDED, reply[2], reply[1]);
        return true;
      }
      return false;
    }
    removeShardedListeners(channel) {
      const listeners = this.listeners[exports.PUBSUB_TYPE.SHARDED].get(channel);
      this.listeners[exports.PUBSUB_TYPE.SHARDED].delete(channel);
      this.#updateIsActive();
      return listeners;
    }
    #emitPubSubMessage(type, message, channel, pattern) {
      const keyString = (pattern ?? channel).toString(), listeners = this.listeners[type].get(keyString);
      if (!listeners)
        return;
      for (const listener of listeners.buffers) {
        listener(message, channel);
      }
      if (!listeners.strings.size)
        return;
      const channelString = pattern ? channel.toString() : keyString, messageString = channelString === "__redis__:invalidate" ? message === null ? null : message.map((x) => x.toString()) : message.toString();
      for (const listener of listeners.strings) {
        listener(messageString, channelString);
      }
    }
  }
  exports.PubSub = PubSub;
});

// node_modules/@redis/client/dist/lib/client/commands-queue.js
var require_commands_queue = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var linked_list_1 = require_linked_list();
  var encoder_1 = __importDefault(require_encoder());
  var decoder_1 = require_decoder();
  var pub_sub_1 = require_pub_sub();
  var errors_1 = require_errors();
  var PONG = Buffer.from("pong");
  var RESET = Buffer.from("RESET");
  var RESP2_PUSH_TYPE_MAPPING = {
    ...decoder_1.PUSH_TYPE_MAPPING,
    [decoder_1.RESP_TYPES.SIMPLE_STRING]: Buffer
  };

  class RedisCommandsQueue {
    #respVersion;
    #maxLength;
    #toWrite = new linked_list_1.DoublyLinkedList;
    #waitingForReply = new linked_list_1.SinglyLinkedList;
    #onShardedChannelMoved;
    #chainInExecution;
    decoder;
    #pubSub = new pub_sub_1.PubSub;
    get isPubSubActive() {
      return this.#pubSub.isActive;
    }
    #invalidateCallback;
    constructor(respVersion, maxLength, onShardedChannelMoved) {
      this.#respVersion = respVersion;
      this.#maxLength = maxLength;
      this.#onShardedChannelMoved = onShardedChannelMoved;
      this.decoder = this.#initiateDecoder();
    }
    #onReply(reply) {
      this.#waitingForReply.shift().resolve(reply);
    }
    #onErrorReply(err) {
      this.#waitingForReply.shift().reject(err);
    }
    #onPush(push) {
      if (this.#pubSub.handleMessageReply(push))
        return true;
      const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(push);
      if (isShardedUnsubscribe && !this.#waitingForReply.length) {
        const channel = push[1].toString();
        this.#onShardedChannelMoved(channel, this.#pubSub.removeShardedListeners(channel));
        return true;
      } else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(push)) {
        const head = this.#waitingForReply.head.value;
        if (Number.isNaN(head.channelsCounter) && push[2] === 0 || --head.channelsCounter === 0) {
          this.#waitingForReply.shift().resolve();
        }
        return true;
      }
    }
    #getTypeMapping() {
      return this.#waitingForReply.head.value.typeMapping ?? {};
    }
    #initiateDecoder() {
      return new decoder_1.Decoder({
        onReply: (reply) => this.#onReply(reply),
        onErrorReply: (err) => this.#onErrorReply(err),
        onPush: (push) => {
          if (!this.#onPush(push)) {
            switch (push[0].toString()) {
              case "invalidate": {
                if (this.#invalidateCallback) {
                  if (push[1] !== null) {
                    for (const key of push[1]) {
                      this.#invalidateCallback(key);
                    }
                  } else {
                    this.#invalidateCallback(null);
                  }
                }
                break;
              }
            }
          }
        },
        getTypeMapping: () => this.#getTypeMapping()
      });
    }
    setInvalidateCallback(callback) {
      this.#invalidateCallback = callback;
    }
    addCommand(args, options) {
      if (this.#maxLength && this.#toWrite.length + this.#waitingForReply.length >= this.#maxLength) {
        return Promise.reject(new Error("The queue is full"));
      } else if (options?.abortSignal?.aborted) {
        return Promise.reject(new errors_1.AbortError);
      }
      return new Promise((resolve, reject) => {
        let node;
        const value = {
          args,
          chainId: options?.chainId,
          abort: undefined,
          resolve,
          reject,
          channelsCounter: undefined,
          typeMapping: options?.typeMapping
        };
        const signal = options?.abortSignal;
        if (signal) {
          value.abort = {
            signal,
            listener: () => {
              this.#toWrite.remove(node);
              value.reject(new errors_1.AbortError);
            }
          };
          signal.addEventListener("abort", value.abort.listener, { once: true });
        }
        node = this.#toWrite.add(value, options?.asap);
      });
    }
    #addPubSubCommand(command, asap = false, chainId) {
      return new Promise((resolve, reject) => {
        this.#toWrite.add({
          args: command.args,
          chainId,
          abort: undefined,
          resolve() {
            command.resolve();
            resolve();
          },
          reject(err) {
            command.reject?.();
            reject(err);
          },
          channelsCounter: command.channelsCounter,
          typeMapping: decoder_1.PUSH_TYPE_MAPPING
        }, asap);
      });
    }
    #setupPubSubHandler() {
      if (this.#respVersion !== 2)
        return;
      this.decoder.onReply = (reply) => {
        if (Array.isArray(reply)) {
          if (this.#onPush(reply))
            return;
          if (PONG.equals(reply[0])) {
            const { resolve, typeMapping } = this.#waitingForReply.shift(), buffer = reply[1].length === 0 ? reply[0] : reply[1];
            resolve(typeMapping?.[decoder_1.RESP_TYPES.SIMPLE_STRING] === Buffer ? buffer : buffer.toString());
            return;
          }
        }
        return this.#onReply(reply);
      };
      this.decoder.getTypeMapping = () => RESP2_PUSH_TYPE_MAPPING;
    }
    subscribe(type, channels, listener, returnBuffers) {
      const command = this.#pubSub.subscribe(type, channels, listener, returnBuffers);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    #resetDecoderCallbacks() {
      this.decoder.onReply = (reply) => this.#onReply(reply);
      this.decoder.getTypeMapping = () => this.#getTypeMapping();
    }
    unsubscribe(type, channels, listener, returnBuffers) {
      const command = this.#pubSub.unsubscribe(type, channels, listener, returnBuffers);
      if (!command)
        return;
      if (command && this.#respVersion === 2) {
        const { resolve } = command;
        command.resolve = () => {
          if (!this.#pubSub.isActive) {
            this.#resetDecoderCallbacks();
          }
          resolve();
        };
      }
      return this.#addPubSubCommand(command);
    }
    resubscribe(chainId) {
      const commands = this.#pubSub.resubscribe();
      if (!commands.length)
        return;
      this.#setupPubSubHandler();
      return Promise.all(commands.map((command) => this.#addPubSubCommand(command, true, chainId)));
    }
    extendPubSubChannelListeners(type, channel, listeners) {
      const command = this.#pubSub.extendChannelListeners(type, channel, listeners);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    extendPubSubListeners(type, listeners) {
      const command = this.#pubSub.extendTypeListeners(type, listeners);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    getPubSubListeners(type) {
      return this.#pubSub.listeners[type];
    }
    monitor(callback, options) {
      return new Promise((resolve, reject) => {
        const typeMapping = options?.typeMapping ?? {};
        this.#toWrite.add({
          args: ["MONITOR"],
          chainId: options?.chainId,
          abort: undefined,
          resolve: () => {
            if (this.#resetFallbackOnReply) {
              this.#resetFallbackOnReply = callback;
            } else {
              this.decoder.onReply = callback;
            }
            this.decoder.getTypeMapping = () => typeMapping;
            resolve();
          },
          reject,
          channelsCounter: undefined,
          typeMapping
        }, options?.asap);
      });
    }
    resetDecoder() {
      this.#resetDecoderCallbacks();
      this.decoder.reset();
    }
    #resetFallbackOnReply;
    async reset(chainId, typeMapping) {
      return new Promise((resolve, reject) => {
        this.#resetFallbackOnReply = this.decoder.onReply;
        this.decoder.onReply = (reply) => {
          if (typeof reply === "string" && reply === "RESET" || reply instanceof Buffer && RESET.equals(reply)) {
            this.#resetDecoderCallbacks();
            this.#resetFallbackOnReply = undefined;
            this.#pubSub.reset();
            this.#waitingForReply.shift().resolve(reply);
            return;
          }
          this.#resetFallbackOnReply(reply);
        };
        this.#toWrite.push({
          args: ["RESET"],
          chainId,
          abort: undefined,
          resolve,
          reject,
          channelsCounter: undefined,
          typeMapping
        });
      });
    }
    isWaitingToWrite() {
      return this.#toWrite.length > 0;
    }
    *commandsToWrite() {
      let toSend = this.#toWrite.shift();
      while (toSend) {
        let encoded;
        try {
          encoded = (0, encoder_1.default)(toSend.args);
        } catch (err) {
          toSend.reject(err);
          toSend = this.#toWrite.shift();
          continue;
        }
        toSend.args = undefined;
        if (toSend.abort) {
          RedisCommandsQueue.#removeAbortListener(toSend);
          toSend.abort = undefined;
        }
        this.#chainInExecution = toSend.chainId;
        toSend.chainId = undefined;
        this.#waitingForReply.push(toSend);
        yield encoded;
        toSend = this.#toWrite.shift();
      }
    }
    #flushWaitingForReply(err) {
      for (const node of this.#waitingForReply) {
        node.reject(err);
      }
      this.#waitingForReply.reset();
    }
    static #removeAbortListener(command) {
      command.abort.signal.removeEventListener("abort", command.abort.listener);
    }
    static #flushToWrite(toBeSent, err) {
      if (toBeSent.abort) {
        RedisCommandsQueue.#removeAbortListener(toBeSent);
      }
      toBeSent.reject(err);
    }
    flushWaitingForReply(err) {
      this.resetDecoder();
      this.#pubSub.reset();
      this.#flushWaitingForReply(err);
      if (!this.#chainInExecution)
        return;
      while (this.#toWrite.head?.value.chainId === this.#chainInExecution) {
        RedisCommandsQueue.#flushToWrite(this.#toWrite.shift(), err);
      }
      this.#chainInExecution = undefined;
    }
    flushAll(err) {
      this.resetDecoder();
      this.#pubSub.reset();
      this.#flushWaitingForReply(err);
      for (const node of this.#toWrite) {
        RedisCommandsQueue.#flushToWrite(node, err);
      }
      this.#toWrite.reset();
    }
    isEmpty() {
      return this.#toWrite.length === 0 && this.#waitingForReply.length === 0;
    }
  }
  exports.default = RedisCommandsQueue;
});

// node_modules/@redis/client/dist/lib/commander.js
var require_commander = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scriptArgumentsPrefix = exports.functionArgumentsPrefix = exports.getTransformReply = exports.attachConfig = undefined;
  function throwResp3SearchModuleUnstableError() {
    throw new Error("Some RESP3 results for Redis Query Engine responses may change. Refer to the readme for guidance");
  }
  function attachConfig({ BaseClass, commands, createCommand, createModuleCommand, createFunctionCommand, createScriptCommand, config }) {
    const RESP = config?.RESP ?? 2, Class = class extends BaseClass {
    };
    for (const [name, command] of Object.entries(commands)) {
      Class.prototype[name] = createCommand(command, RESP);
    }
    if (config?.modules) {
      for (const [moduleName, module2] of Object.entries(config.modules)) {
        const fns = Object.create(null);
        for (const [name, command] of Object.entries(module2)) {
          if (config.RESP == 3 && command.unstableResp3 && !config.unstableResp3) {
            fns[name] = throwResp3SearchModuleUnstableError;
          } else {
            fns[name] = createModuleCommand(command, RESP);
          }
        }
        attachNamespace(Class.prototype, moduleName, fns);
      }
    }
    if (config?.functions) {
      for (const [library, commands2] of Object.entries(config.functions)) {
        const fns = Object.create(null);
        for (const [name, command] of Object.entries(commands2)) {
          fns[name] = createFunctionCommand(name, command, RESP);
        }
        attachNamespace(Class.prototype, library, fns);
      }
    }
    if (config?.scripts) {
      for (const [name, script] of Object.entries(config.scripts)) {
        Class.prototype[name] = createScriptCommand(script, RESP);
      }
    }
    return Class;
  }
  exports.attachConfig = attachConfig;
  function attachNamespace(prototype, name, fns) {
    Object.defineProperty(prototype, name, {
      get() {
        const value = Object.create(fns);
        value._self = this;
        Object.defineProperty(this, name, { value });
        return value;
      }
    });
  }
  function getTransformReply(command, resp) {
    switch (typeof command.transformReply) {
      case "function":
        return command.transformReply;
      case "object":
        return command.transformReply[resp];
    }
  }
  exports.getTransformReply = getTransformReply;
  function functionArgumentsPrefix(name, fn) {
    const prefix = [
      fn.IS_READ_ONLY ? "FCALL_RO" : "FCALL",
      name
    ];
    if (fn.NUMBER_OF_KEYS !== undefined) {
      prefix.push(fn.NUMBER_OF_KEYS.toString());
    }
    return prefix;
  }
  exports.functionArgumentsPrefix = functionArgumentsPrefix;
  function scriptArgumentsPrefix(script) {
    const prefix = [
      script.IS_READ_ONLY ? "EVALSHA_RO" : "EVALSHA",
      script.SHA1
    ];
    if (script.NUMBER_OF_KEYS !== undefined) {
      prefix.push(script.NUMBER_OF_KEYS.toString());
    }
    return prefix;
  }
  exports.scriptArgumentsPrefix = scriptArgumentsPrefix;
});

// node_modules/@redis/client/dist/lib/multi-command.js
var require_multi_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_1 = require_errors();

  class RedisMultiCommand {
    typeMapping;
    constructor(typeMapping) {
      this.typeMapping = typeMapping;
    }
    queue = [];
    scriptsInUse = new Set;
    addCommand(args, transformReply) {
      this.queue.push({
        args,
        transformReply
      });
    }
    addScript(script, args, transformReply) {
      const redisArgs = [];
      redisArgs.preserve = args.preserve;
      if (this.scriptsInUse.has(script.SHA1)) {
        redisArgs.push("EVALSHA", script.SHA1);
      } else {
        this.scriptsInUse.add(script.SHA1);
        redisArgs.push("EVAL", script.SCRIPT);
      }
      if (script.NUMBER_OF_KEYS !== undefined) {
        redisArgs.push(script.NUMBER_OF_KEYS.toString());
      }
      redisArgs.push(...args);
      this.addCommand(redisArgs, transformReply);
    }
    transformReplies(rawReplies) {
      const errorIndexes = [], replies = rawReplies.map((reply, i) => {
        if (reply instanceof errors_1.ErrorReply) {
          errorIndexes.push(i);
          return reply;
        }
        const { transformReply, args } = this.queue[i];
        return transformReply ? transformReply(reply, args.preserve, this.typeMapping) : reply;
      });
      if (errorIndexes.length)
        throw new errors_1.MultiErrorReply(replies, errorIndexes);
      return replies;
    }
  }
  exports.default = RedisMultiCommand;
});

// node_modules/@redis/client/dist/lib/client/multi-command.js
var require_multi_command2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser2();

  class RedisClientMultiCommand {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.addCommand(redisArgs, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(redisArgs, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(redisArgs, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.#addScript(script, redisArgs, transformReply);
      };
    }
    static extend(config) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisClientMultiCommand,
        commands: commands_1.default,
        createCommand: RedisClientMultiCommand.#createCommand,
        createModuleCommand: RedisClientMultiCommand.#createModuleCommand,
        createFunctionCommand: RedisClientMultiCommand.#createFunctionCommand,
        createScriptCommand: RedisClientMultiCommand.#createScriptCommand,
        config
      });
    }
    #multi;
    #executeMulti;
    #executePipeline;
    #selectedDB;
    constructor(executeMulti, executePipeline, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#executeMulti = executeMulti;
      this.#executePipeline = executePipeline;
    }
    SELECT(db, transformReply) {
      this.#selectedDB = db;
      this.#multi.addCommand(["SELECT", db.toString()], transformReply);
      return this;
    }
    select = this.SELECT;
    addCommand(args, transformReply) {
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(script, args, transformReply) {
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#executeMulti(this.#multi.queue, this.#selectedDB));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#executePipeline(this.#multi.queue, this.#selectedDB));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisClientMultiCommand;
});

// node_modules/@redis/client/dist/lib/client/legacy-mode.js
var require_legacy_mode = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisLegacyClient = undefined;
  var commander_1 = require_commander();
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());

  class RedisLegacyClient {
    static #transformArguments(redisArgs, args) {
      let callback;
      if (typeof args[args.length - 1] === "function") {
        callback = args.pop();
      }
      RedisLegacyClient.pushArguments(redisArgs, args);
      return callback;
    }
    static pushArguments(redisArgs, args) {
      for (let i = 0;i < args.length; ++i) {
        const arg = args[i];
        if (Array.isArray(arg)) {
          RedisLegacyClient.pushArguments(redisArgs, arg);
        } else {
          redisArgs.push(typeof arg === "number" || arg instanceof Date ? arg.toString() : arg);
        }
      }
    }
    static getTransformReply(command, resp) {
      return command.TRANSFORM_LEGACY_REPLY ? (0, commander_1.getTransformReply)(command, resp) : undefined;
    }
    static #createCommand(name, command, resp) {
      const transformReply = RedisLegacyClient.getTransformReply(command, resp);
      return function(...args) {
        const redisArgs = [name], callback = RedisLegacyClient.#transformArguments(redisArgs, args), promise = this.#client.sendCommand(redisArgs);
        if (!callback) {
          promise.catch((err) => this.#client.emit("error", err));
          return;
        }
        promise.then((reply) => callback(null, transformReply ? transformReply(reply) : reply)).catch((err) => callback(err));
      };
    }
    #client;
    #Multi;
    constructor(client) {
      this.#client = client;
      const RESP = client.options?.RESP ?? 2;
      for (const [name, command] of Object.entries(commands_1.default)) {
        this[name] = RedisLegacyClient.#createCommand(name, command, RESP);
      }
      this.#Multi = LegacyMultiCommand.factory(RESP);
    }
    sendCommand(...args) {
      const redisArgs = [], callback = RedisLegacyClient.#transformArguments(redisArgs, args), promise = this.#client.sendCommand(redisArgs);
      if (!callback) {
        promise.catch((err) => this.#client.emit("error", err));
        return;
      }
      promise.then((reply) => callback(null, reply)).catch((err) => callback(err));
    }
    multi() {
      return this.#Multi(this.#client);
    }
  }
  exports.RedisLegacyClient = RedisLegacyClient;

  class LegacyMultiCommand {
    static #createCommand(name, command, resp) {
      const transformReply = RedisLegacyClient.getTransformReply(command, resp);
      return function(...args) {
        const redisArgs = [name];
        RedisLegacyClient.pushArguments(redisArgs, args);
        this.#multi.addCommand(redisArgs, transformReply);
        return this;
      };
    }
    static factory(resp) {
      const Multi = class extends LegacyMultiCommand {
      };
      for (const [name, command] of Object.entries(commands_1.default)) {
        Multi.prototype[name] = LegacyMultiCommand.#createCommand(name, command, resp);
      }
      return (client) => {
        return new Multi(client);
      };
    }
    #multi = new multi_command_1.default;
    #client;
    constructor(client) {
      this.#client = client;
    }
    sendCommand(...args) {
      const redisArgs = [];
      RedisLegacyClient.pushArguments(redisArgs, args);
      this.#multi.addCommand(redisArgs);
      return this;
    }
    exec(cb) {
      const promise = this.#client._executeMulti(this.#multi.queue);
      if (!cb) {
        promise.catch((err) => this.#client.emit("error", err));
        return;
      }
      promise.then((results) => cb(null, this.#multi.transformReplies(results))).catch((err) => cb?.(err));
    }
  }
});

// node_modules/@redis/client/dist/lib/client/cache.js
var require_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PooledNoRedirectClientSideCache = exports.BasicPooledClientSideCache = exports.PooledClientSideCacheProvider = exports.BasicClientSideCache = exports.ClientSideCacheProvider = exports.CacheStats = undefined;
  var stream_1 = __require("stream");

  class CacheStats {
    hitCount;
    missCount;
    loadSuccessCount;
    loadFailureCount;
    totalLoadTime;
    evictionCount;
    constructor(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount) {
      this.hitCount = hitCount;
      this.missCount = missCount;
      this.loadSuccessCount = loadSuccessCount;
      this.loadFailureCount = loadFailureCount;
      this.totalLoadTime = totalLoadTime;
      this.evictionCount = evictionCount;
      if (hitCount < 0 || missCount < 0 || loadSuccessCount < 0 || loadFailureCount < 0 || totalLoadTime < 0 || evictionCount < 0) {
        throw new Error("All statistics values must be non-negative");
      }
    }
    static of(hitCount = 0, missCount = 0, loadSuccessCount = 0, loadFailureCount = 0, totalLoadTime = 0, evictionCount = 0) {
      return new CacheStats(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount);
    }
    static empty() {
      return CacheStats.EMPTY_STATS;
    }
    static EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);
    requestCount() {
      return this.hitCount + this.missCount;
    }
    hitRate() {
      const requestCount = this.requestCount();
      return requestCount === 0 ? 1 : this.hitCount / requestCount;
    }
    missRate() {
      const requestCount = this.requestCount();
      return requestCount === 0 ? 0 : this.missCount / requestCount;
    }
    loadCount() {
      return this.loadSuccessCount + this.loadFailureCount;
    }
    loadFailureRate() {
      const loadCount = this.loadCount();
      return loadCount === 0 ? 0 : this.loadFailureCount / loadCount;
    }
    averageLoadPenalty() {
      const loadCount = this.loadCount();
      return loadCount === 0 ? 0 : this.totalLoadTime / loadCount;
    }
    minus(other) {
      return CacheStats.of(Math.max(0, this.hitCount - other.hitCount), Math.max(0, this.missCount - other.missCount), Math.max(0, this.loadSuccessCount - other.loadSuccessCount), Math.max(0, this.loadFailureCount - other.loadFailureCount), Math.max(0, this.totalLoadTime - other.totalLoadTime), Math.max(0, this.evictionCount - other.evictionCount));
    }
    plus(other) {
      return CacheStats.of(this.hitCount + other.hitCount, this.missCount + other.missCount, this.loadSuccessCount + other.loadSuccessCount, this.loadFailureCount + other.loadFailureCount, this.totalLoadTime + other.totalLoadTime, this.evictionCount + other.evictionCount);
    }
  }
  exports.CacheStats = CacheStats;

  class DisabledStatsCounter {
    static INSTANCE = new DisabledStatsCounter;
    constructor() {}
    recordHits(count) {}
    recordMisses(count) {}
    recordLoadSuccess(loadTime) {}
    recordLoadFailure(loadTime) {}
    recordEvictions(count) {}
    snapshot() {
      return CacheStats.empty();
    }
  }
  function disabledStatsCounter() {
    return DisabledStatsCounter.INSTANCE;
  }

  class DefaultStatsCounter {
    #hitCount = 0;
    #missCount = 0;
    #loadSuccessCount = 0;
    #loadFailureCount = 0;
    #totalLoadTime = 0;
    #evictionCount = 0;
    recordHits(count) {
      this.#hitCount += count;
    }
    recordMisses(count) {
      this.#missCount += count;
    }
    recordLoadSuccess(loadTime) {
      this.#loadSuccessCount++;
      this.#totalLoadTime += loadTime;
    }
    recordLoadFailure(loadTime) {
      this.#loadFailureCount++;
      this.#totalLoadTime += loadTime;
    }
    recordEvictions(count) {
      this.#evictionCount += count;
    }
    snapshot() {
      return CacheStats.of(this.#hitCount, this.#missCount, this.#loadSuccessCount, this.#loadFailureCount, this.#totalLoadTime, this.#evictionCount);
    }
    static create() {
      return new DefaultStatsCounter;
    }
  }
  function generateCacheKey(redisArgs) {
    const tmp = new Array(redisArgs.length * 2);
    for (let i = 0;i < redisArgs.length; i++) {
      tmp[i] = redisArgs[i].length;
      tmp[i + redisArgs.length] = redisArgs[i];
    }
    return tmp.join("_");
  }

  class ClientSideCacheEntryBase {
    #invalidated = false;
    #expireTime;
    constructor(ttl) {
      if (ttl == 0) {
        this.#expireTime = 0;
      } else {
        this.#expireTime = Date.now() + ttl;
      }
    }
    invalidate() {
      this.#invalidated = true;
    }
    validate() {
      return !this.#invalidated && (this.#expireTime == 0 || Date.now() < this.#expireTime);
    }
  }

  class ClientSideCacheEntryValue extends ClientSideCacheEntryBase {
    #value;
    get value() {
      return this.#value;
    }
    constructor(ttl, value) {
      super(ttl);
      this.#value = value;
    }
  }

  class ClientSideCacheEntryPromise extends ClientSideCacheEntryBase {
    #sendCommandPromise;
    get promise() {
      return this.#sendCommandPromise;
    }
    constructor(ttl, sendCommandPromise) {
      super(ttl);
      this.#sendCommandPromise = sendCommandPromise;
    }
  }

  class ClientSideCacheProvider extends stream_1.EventEmitter {
  }
  exports.ClientSideCacheProvider = ClientSideCacheProvider;

  class BasicClientSideCache extends ClientSideCacheProvider {
    #cacheKeyToEntryMap;
    #keyToCacheKeySetMap;
    ttl;
    maxEntries;
    lru;
    #statsCounter;
    recordEvictions(count) {
      this.#statsCounter.recordEvictions(count);
    }
    recordHits(count) {
      this.#statsCounter.recordHits(count);
    }
    recordMisses(count) {
      this.#statsCounter.recordMisses(count);
    }
    constructor(config) {
      super();
      this.#cacheKeyToEntryMap = new Map;
      this.#keyToCacheKeySetMap = new Map;
      this.ttl = config?.ttl ?? 0;
      this.maxEntries = config?.maxEntries ?? 0;
      this.lru = config?.evictPolicy !== "FIFO";
      const recordStats = config?.recordStats !== false;
      this.#statsCounter = recordStats ? DefaultStatsCounter.create() : disabledStatsCounter();
    }
    async handleCache(client, parser, fn, transformReply, typeMapping) {
      let reply;
      const cacheKey = generateCacheKey(parser.redisArgs);
      let cacheEntry = this.get(cacheKey);
      if (cacheEntry) {
        if (cacheEntry instanceof ClientSideCacheEntryValue) {
          this.#statsCounter.recordHits(1);
          return structuredClone(cacheEntry.value);
        } else if (cacheEntry instanceof ClientSideCacheEntryPromise) {
          this.#statsCounter.recordMisses(1);
          reply = await cacheEntry.promise;
        } else {
          throw new Error("unknown cache entry type");
        }
      } else {
        this.#statsCounter.recordMisses(1);
        const startTime = performance.now();
        const promise = fn();
        cacheEntry = this.createPromiseEntry(client, promise);
        this.set(cacheKey, cacheEntry, parser.keys);
        try {
          reply = await promise;
          const loadTime = performance.now() - startTime;
          this.#statsCounter.recordLoadSuccess(loadTime);
        } catch (err) {
          const loadTime = performance.now() - startTime;
          this.#statsCounter.recordLoadFailure(loadTime);
          if (cacheEntry.validate()) {
            this.delete(cacheKey);
          }
          throw err;
        }
      }
      let val;
      if (transformReply) {
        val = transformReply(reply, parser.preserve, typeMapping);
      } else {
        val = reply;
      }
      if (cacheEntry.validate()) {
        cacheEntry = this.createValueEntry(client, val);
        this.set(cacheKey, cacheEntry, parser.keys);
        this.emit("cached-key", cacheKey);
      } else {}
      return structuredClone(val);
    }
    trackingOn() {
      return ["CLIENT", "TRACKING", "ON"];
    }
    invalidate(key) {
      if (key === null) {
        this.clear(false);
        this.emit("invalidate", key);
        return;
      }
      const keySet = this.#keyToCacheKeySetMap.get(key.toString());
      if (keySet) {
        for (const cacheKey of keySet) {
          const entry = this.#cacheKeyToEntryMap.get(cacheKey);
          if (entry) {
            entry.invalidate();
          }
          this.#cacheKeyToEntryMap.delete(cacheKey);
        }
        this.#keyToCacheKeySetMap.delete(key.toString());
      }
      this.emit("invalidate", key);
    }
    clear(resetStats = true) {
      const oldSize = this.#cacheKeyToEntryMap.size;
      this.#cacheKeyToEntryMap.clear();
      this.#keyToCacheKeySetMap.clear();
      if (resetStats) {
        if (!(this.#statsCounter instanceof DisabledStatsCounter)) {
          this.#statsCounter = DefaultStatsCounter.create();
        }
      } else {
        if (oldSize > 0) {
          this.#statsCounter.recordEvictions(oldSize);
        }
      }
    }
    get(cacheKey) {
      const val = this.#cacheKeyToEntryMap.get(cacheKey);
      if (val && !val.validate()) {
        this.delete(cacheKey);
        this.#statsCounter.recordEvictions(1);
        this.emit("cache-evict", cacheKey);
        return;
      }
      if (val !== undefined && this.lru) {
        this.#cacheKeyToEntryMap.delete(cacheKey);
        this.#cacheKeyToEntryMap.set(cacheKey, val);
      }
      return val;
    }
    delete(cacheKey) {
      const entry = this.#cacheKeyToEntryMap.get(cacheKey);
      if (entry) {
        entry.invalidate();
        this.#cacheKeyToEntryMap.delete(cacheKey);
      }
    }
    has(cacheKey) {
      return this.#cacheKeyToEntryMap.has(cacheKey);
    }
    set(cacheKey, cacheEntry, keys) {
      let count = this.#cacheKeyToEntryMap.size;
      const oldEntry = this.#cacheKeyToEntryMap.get(cacheKey);
      if (oldEntry) {
        count--;
        oldEntry.invalidate();
      }
      if (this.maxEntries > 0 && count >= this.maxEntries) {
        this.deleteOldest();
        this.#statsCounter.recordEvictions(1);
      }
      this.#cacheKeyToEntryMap.set(cacheKey, cacheEntry);
      for (const key of keys) {
        if (!this.#keyToCacheKeySetMap.has(key.toString())) {
          this.#keyToCacheKeySetMap.set(key.toString(), new Set);
        }
        const cacheKeySet = this.#keyToCacheKeySetMap.get(key.toString());
        cacheKeySet.add(cacheKey);
      }
    }
    size() {
      return this.#cacheKeyToEntryMap.size;
    }
    createValueEntry(client, value) {
      return new ClientSideCacheEntryValue(this.ttl, value);
    }
    createPromiseEntry(client, sendCommandPromise) {
      return new ClientSideCacheEntryPromise(this.ttl, sendCommandPromise);
    }
    stats() {
      return this.#statsCounter.snapshot();
    }
    onError() {
      this.clear();
    }
    onClose() {
      this.clear();
    }
    deleteOldest() {
      const it = this.#cacheKeyToEntryMap[Symbol.iterator]();
      const n = it.next();
      if (!n.done) {
        const key = n.value[0];
        const entry = this.#cacheKeyToEntryMap.get(key);
        if (entry) {
          entry.invalidate();
        }
        this.#cacheKeyToEntryMap.delete(key);
      }
    }
    entryEntries() {
      return this.#cacheKeyToEntryMap.entries();
    }
    keySetEntries() {
      return this.#keyToCacheKeySetMap.entries();
    }
  }
  exports.BasicClientSideCache = BasicClientSideCache;

  class PooledClientSideCacheProvider extends BasicClientSideCache {
    #disabled = false;
    disable() {
      this.#disabled = true;
    }
    enable() {
      this.#disabled = false;
    }
    get(cacheKey) {
      if (this.#disabled) {
        return;
      }
      return super.get(cacheKey);
    }
    has(cacheKey) {
      if (this.#disabled) {
        return false;
      }
      return super.has(cacheKey);
    }
    onPoolClose() {
      this.clear();
    }
  }
  exports.PooledClientSideCacheProvider = PooledClientSideCacheProvider;

  class BasicPooledClientSideCache extends PooledClientSideCacheProvider {
    onError() {
      this.clear(false);
    }
    onClose() {
      this.clear(false);
    }
  }
  exports.BasicPooledClientSideCache = BasicPooledClientSideCache;

  class PooledClientSideCacheEntryValue extends ClientSideCacheEntryValue {
    #creator;
    constructor(ttl, creator, value) {
      super(ttl, value);
      this.#creator = creator;
    }
    validate() {
      let ret = super.validate();
      if (this.#creator) {
        ret = ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
      }
      return ret;
    }
  }

  class PooledClientSideCacheEntryPromise extends ClientSideCacheEntryPromise {
    #creator;
    constructor(ttl, creator, sendCommandPromise) {
      super(ttl, sendCommandPromise);
      this.#creator = creator;
    }
    validate() {
      let ret = super.validate();
      return ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
    }
  }

  class PooledNoRedirectClientSideCache extends BasicPooledClientSideCache {
    createValueEntry(client, value) {
      const creator = {
        epoch: client.socketEpoch,
        client
      };
      return new PooledClientSideCacheEntryValue(this.ttl, creator, value);
    }
    createPromiseEntry(client, sendCommandPromise) {
      const creator = {
        epoch: client.socketEpoch,
        client
      };
      return new PooledClientSideCacheEntryPromise(this.ttl, creator, sendCommandPromise);
    }
    onError() {}
    onClose() {}
  }
  exports.PooledNoRedirectClientSideCache = PooledNoRedirectClientSideCache;
});

// node_modules/@redis/client/dist/lib/single-entry-cache.js
var require_single_entry_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class SingleEntryCache {
    #cached;
    #serializedKey;
    get(keyObj) {
      return JSON.stringify(keyObj, makeCircularReplacer()) === this.#serializedKey ? this.#cached : undefined;
    }
    set(keyObj, obj) {
      this.#cached = obj;
      this.#serializedKey = JSON.stringify(keyObj, makeCircularReplacer());
    }
  }
  exports.default = SingleEntryCache;
  function makeCircularReplacer() {
    const seen = new WeakSet;
    return function serialize(_, value) {
      if (value && typeof value === "object") {
        if (seen.has(value)) {
          return "circular";
        }
        seen.add(value);
        return value;
      }
      return value;
    };
  }
});

// node_modules/@redis/client/dist/lib/client/pool.js
var require_pool = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisClientPool = undefined;
  var commands_1 = __importDefault(require_commands());
  var _1 = __importDefault(require_client3());
  var node_events_1 = __require("node:events");
  var linked_list_1 = require_linked_list();
  var errors_1 = require_errors();
  var commander_1 = require_commander();
  var multi_command_1 = __importDefault(require_multi_command2());
  var cache_1 = require_cache();
  var parser_1 = require_parser2();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());

  class RedisClientPool extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this.execute((client) => client._executeCommand(command, parser, this._commandOptions, transformReply));
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self.execute((client) => client._executeCommand(command, parser, this._self._commandOptions, transformReply));
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self.execute((client) => client._executeCommand(fn, parser, this._self._commandOptions, transformReply));
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.pushVariadic(prefix);
        script.parseCommand(parser, ...args);
        return this.execute((client) => client._executeScript(script, parser, this._commandOptions, transformReply));
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static create(clientOptions, options) {
      let Pool4 = RedisClientPool.#SingleEntryCache.get(clientOptions);
      if (!Pool4) {
        Pool4 = (0, commander_1.attachConfig)({
          BaseClass: RedisClientPool,
          commands: commands_1.default,
          createCommand: RedisClientPool.#createCommand,
          createModuleCommand: RedisClientPool.#createModuleCommand,
          createFunctionCommand: RedisClientPool.#createFunctionCommand,
          createScriptCommand: RedisClientPool.#createScriptCommand,
          config: clientOptions
        });
        Pool4.prototype.Multi = multi_command_1.default.extend(clientOptions);
        RedisClientPool.#SingleEntryCache.set(clientOptions, Pool4);
      }
      return Object.create(new Pool4(clientOptions, options));
    }
    static #DEFAULTS = {
      minimum: 1,
      maximum: 100,
      acquireTimeout: 3000,
      cleanupDelay: 3000
    };
    #clientFactory;
    #options;
    #idleClients = new linked_list_1.SinglyLinkedList;
    get idleClients() {
      return this._self.#idleClients.length;
    }
    #clientsInUse = new linked_list_1.DoublyLinkedList;
    get clientsInUse() {
      return this._self.#clientsInUse.length;
    }
    get totalClients() {
      return this._self.#idleClients.length + this._self.#clientsInUse.length;
    }
    #tasksQueue = new linked_list_1.SinglyLinkedList;
    get tasksQueueLength() {
      return this._self.#tasksQueue.length;
    }
    #isOpen = false;
    get isOpen() {
      return this._self.#isOpen;
    }
    #isClosing = false;
    get isClosing() {
      return this._self.#isClosing;
    }
    #clientSideCache;
    get clientSideCache() {
      return this._self.#clientSideCache;
    }
    constructor(clientOptions, options) {
      super();
      this.#options = {
        ...RedisClientPool.#DEFAULTS,
        ...options
      };
      if (options?.clientSideCache) {
        if (clientOptions === undefined) {
          clientOptions = {};
        }
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.#clientSideCache = clientOptions.clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = clientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
        }
      }
      this.#clientFactory = _1.default.factory(clientOptions).bind(undefined, clientOptions);
    }
    _self = this;
    _commandOptions;
    withCommandOptions(options) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = options;
      return proxy;
    }
    #commandOptionsProxy(key, value) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._self.#commandOptionsProxy("typeMapping", typeMapping);
    }
    withAbortSignal(abortSignal) {
      return this._self.#commandOptionsProxy("abortSignal", abortSignal);
    }
    asap() {
      return this._self.#commandOptionsProxy("asap", true);
    }
    async connect() {
      if (this._self.#isOpen)
        return;
      this._self.#isOpen = true;
      const promises = [];
      while (promises.length < this._self.#options.minimum) {
        promises.push(this._self.#create());
      }
      try {
        await Promise.all(promises);
      } catch (err) {
        this.destroy();
        throw err;
      }
      return this;
    }
    async#create() {
      const node = this._self.#clientsInUse.push(this._self.#clientFactory().on("error", (err) => this.emit("error", err)));
      try {
        const client = node.value;
        await client.connect();
      } catch (err) {
        this._self.#clientsInUse.remove(node);
        throw err;
      }
      this._self.#returnClient(node);
    }
    execute(fn) {
      return new Promise((resolve, reject) => {
        const client = this._self.#idleClients.shift(), { tail } = this._self.#tasksQueue;
        if (!client) {
          let timeout;
          if (this._self.#options.acquireTimeout > 0) {
            timeout = setTimeout(() => {
              this._self.#tasksQueue.remove(task, tail);
              reject(new errors_1.TimeoutError("Timeout waiting for a client"));
            }, this._self.#options.acquireTimeout);
          }
          const task = this._self.#tasksQueue.push({
            timeout,
            resolve,
            reject,
            fn
          });
          if (this.totalClients < this._self.#options.maximum) {
            this._self.#create();
          }
          return;
        }
        const node = this._self.#clientsInUse.push(client);
        this._self.#executeTask(node, resolve, reject, fn);
      });
    }
    #executeTask(node, resolve, reject, fn) {
      const result = fn(node.value);
      if (result instanceof Promise) {
        result.then(resolve, reject);
        result.finally(() => this.#returnClient(node));
      } else {
        resolve(result);
        this.#returnClient(node);
      }
    }
    #returnClient(node) {
      const task = this.#tasksQueue.shift();
      if (task) {
        clearTimeout(task.timeout);
        this.#executeTask(node, task.resolve, task.reject, task.fn);
        return;
      }
      this.#clientsInUse.remove(node);
      this.#idleClients.push(node.value);
      this.#scheduleCleanup();
    }
    cleanupTimeout;
    #scheduleCleanup() {
      if (this.totalClients <= this.#options.minimum)
        return;
      clearTimeout(this.cleanupTimeout);
      this.cleanupTimeout = setTimeout(() => this.#cleanup(), this.#options.cleanupDelay);
    }
    #cleanup() {
      const toDestroy = Math.min(this.#idleClients.length, this.totalClients - this.#options.minimum);
      for (let i = 0;i < toDestroy; i++) {
        const client = this.#idleClients.shift();
        client.destroy();
      }
    }
    sendCommand(args, options) {
      return this.execute((client) => client.sendCommand(args, options));
    }
    MULTI() {
      return new this.Multi((commands, selectedDB) => this.execute((client) => client._executeMulti(commands, selectedDB)), (commands) => this.execute((client) => client._executePipeline(commands)), this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async close() {
      if (this._self.#isClosing)
        return;
      if (!this._self.#isOpen)
        return;
      this._self.#isClosing = true;
      try {
        const promises = [];
        for (const client of this._self.#idleClients) {
          promises.push(client.close());
        }
        for (const client of this._self.#clientsInUse) {
          promises.push(client.close());
        }
        await Promise.all(promises);
        this.#clientSideCache?.onPoolClose();
        this._self.#idleClients.reset();
        this._self.#clientsInUse.reset();
      } catch (err) {} finally {
        this._self.#isClosing = false;
      }
    }
    destroy() {
      for (const client of this._self.#idleClients) {
        client.destroy();
      }
      this._self.#idleClients.reset();
      for (const client of this._self.#clientsInUse) {
        client.destroy();
      }
      this._self.#clientSideCache?.onPoolClose();
      this._self.#clientsInUse.reset();
      this._self.#isOpen = false;
    }
  }
  exports.RedisClientPool = RedisClientPool;
});

// node_modules/@redis/client/dist/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "@redis/client",
    version: "5.1.1",
    license: "MIT",
    main: "./dist/index.js",
    types: "./dist/index.d.ts",
    files: [
      "dist/",
      "!dist/tsconfig.tsbuildinfo"
    ],
    scripts: {
      test: "nyc -r text-summary -r lcov mocha -r tsx './lib/**/*.spec.ts'",
      release: "release-it"
    },
    dependencies: {
      "cluster-key-slot": "1.1.2"
    },
    devDependencies: {
      "@redis/test-utils": "*",
      "@types/sinon": "^17.0.3",
      sinon: "^17.0.1"
    },
    engines: {
      node: ">= 18"
    },
    repository: {
      type: "git",
      url: "git://github.com/redis/node-redis.git"
    },
    bugs: {
      url: "https://github.com/redis/node-redis/issues"
    },
    homepage: "https://github.com/redis/node-redis/tree/master/packages/client",
    keywords: [
      "redis"
    ]
  };
});

// node_modules/@redis/client/dist/lib/client/index.js
var require_client3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var socket_1 = __importDefault(require_socket());
  var authx_1 = require_authx();
  var commands_queue_1 = __importDefault(require_commands_queue());
  var node_events_1 = __require("node:events");
  var commander_1 = require_commander();
  var errors_1 = require_errors();
  var node_url_1 = __require("node:url");
  var pub_sub_1 = require_pub_sub();
  var multi_command_1 = __importDefault(require_multi_command2());
  var HELLO_1 = __importDefault(require_HELLO());
  var legacy_mode_1 = require_legacy_mode();
  var pool_1 = require_pool();
  var generic_transformers_1 = require_generic_transformers();
  var cache_1 = require_cache();
  var parser_1 = require_parser2();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());
  var package_json_1 = require_package();

  class RedisClient extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._executeCommand(command, parser, this._commandOptions, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._executeCommand(command, parser, this._self._commandOptions, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self._executeCommand(fn, parser, this._self._commandOptions, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        script.parseCommand(parser, ...args);
        return this._executeScript(script, parser, this._commandOptions, transformReply);
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static factory(config) {
      let Client2 = _a.#SingleEntryCache.get(config);
      if (!Client2) {
        Client2 = (0, commander_1.attachConfig)({
          BaseClass: _a,
          commands: commands_1.default,
          createCommand: _a.#createCommand,
          createModuleCommand: _a.#createModuleCommand,
          createFunctionCommand: _a.#createFunctionCommand,
          createScriptCommand: _a.#createScriptCommand,
          config
        });
        Client2.prototype.Multi = multi_command_1.default.extend(config);
        _a.#SingleEntryCache.set(config, Client2);
      }
      return (options) => {
        return Object.create(new Client2(options));
      };
    }
    static create(options) {
      return _a.factory(options)(options);
    }
    static parseURL(url) {
      const { hostname, port, protocol, username, password, pathname } = new node_url_1.URL(url), parsed = {
        socket: {
          host: hostname
        }
      };
      if (protocol === "rediss:") {
        parsed.socket.tls = true;
      } else if (protocol !== "redis:") {
        throw new TypeError("Invalid protocol");
      }
      if (port) {
        parsed.socket.port = Number(port);
      }
      if (username) {
        parsed.username = decodeURIComponent(username);
      }
      if (password) {
        parsed.password = decodeURIComponent(password);
      }
      if (username || password) {
        parsed.credentialsProvider = {
          type: "async-credentials-provider",
          credentials: async () => ({
            username: username ? decodeURIComponent(username) : undefined,
            password: password ? decodeURIComponent(password) : undefined
          })
        };
      }
      if (pathname.length > 1) {
        const database = Number(pathname.substring(1));
        if (isNaN(database)) {
          throw new TypeError("Invalid pathname");
        }
        parsed.database = database;
      }
      return parsed;
    }
    #options;
    #socket;
    #queue;
    #selectedDB = 0;
    #monitorCallback;
    _self = this;
    _commandOptions;
    #dirtyWatch;
    #watchEpoch;
    #clientSideCache;
    #credentialsSubscription = null;
    get clientSideCache() {
      return this._self.#clientSideCache;
    }
    get options() {
      return this._self.#options;
    }
    get isOpen() {
      return this._self.#socket.isOpen;
    }
    get isReady() {
      return this._self.#socket.isReady;
    }
    get isPubSubActive() {
      return this._self.#queue.isPubSubActive;
    }
    get socketEpoch() {
      return this._self.#socket.socketEpoch;
    }
    get isWatching() {
      return this._self.#watchEpoch !== undefined;
    }
    get isDirtyWatch() {
      return this._self.#dirtyWatch !== undefined;
    }
    setDirtyWatch(msg) {
      this._self.#dirtyWatch = msg;
    }
    constructor(options) {
      super();
      this.#validateOptions(options);
      this.#options = this.#initiateOptions(options);
      this.#queue = this.#initiateQueue();
      this.#socket = this.#initiateSocket();
      if (options?.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.ClientSideCacheProvider) {
          this.#clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = new cache_1.BasicClientSideCache(cscConfig);
        }
        this.#queue.setInvalidateCallback(this.#clientSideCache.invalidate.bind(this.#clientSideCache));
      }
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    #initiateOptions(options) {
      if (!options?.credentialsProvider && (options?.username || options?.password)) {
        options.credentialsProvider = {
          type: "async-credentials-provider",
          credentials: async () => ({
            username: options.username,
            password: options.password
          })
        };
      }
      if (options?.url) {
        const parsed = _a.parseURL(options.url);
        if (options.socket) {
          parsed.socket = Object.assign(options.socket, parsed.socket);
        }
        Object.assign(options, parsed);
      }
      if (options?.database) {
        this._self.#selectedDB = options.database;
      }
      if (options?.commandOptions) {
        this._commandOptions = options.commandOptions;
      }
      return options;
    }
    #initiateQueue() {
      return new commands_queue_1.default(this.#options?.RESP ?? 2, this.#options?.commandsQueueMaxLength, (channel, listeners) => this.emit("sharded-channel-moved", channel, listeners));
    }
    reAuthenticate = async (credentials) => {
      if (!(this.isPubSubActive && !this.#options?.RESP)) {
        await this.sendCommand((0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
          username: credentials.username,
          password: credentials.password ?? ""
        }));
      }
    };
    #subscribeForStreamingCredentials(cp) {
      return cp.subscribe({
        onNext: (credentials) => {
          this.reAuthenticate(credentials).catch((error) => {
            const errorMessage = error instanceof Error ? error.message : String(error);
            cp.onReAuthenticationError(new authx_1.CredentialsError(errorMessage));
          });
        },
        onError: (e) => {
          const errorMessage = `Error from streaming credentials provider: ${e.message}`;
          cp.onReAuthenticationError(new authx_1.UnableToObtainNewCredentialsError(errorMessage));
        }
      });
    }
    async#handshake(chainId, asap) {
      const promises = [];
      const commandsWithErrorHandlers = await this.#getHandshakeCommands();
      if (asap)
        commandsWithErrorHandlers.reverse();
      for (const { cmd, errorHandler } of commandsWithErrorHandlers) {
        promises.push(this.#queue.addCommand(cmd, {
          chainId,
          asap
        }).catch(errorHandler));
      }
      return promises;
    }
    async#getHandshakeCommands() {
      const commands = [];
      const cp = this.#options?.credentialsProvider;
      if (this.#options?.RESP) {
        const hello = {};
        if (cp && cp.type === "async-credentials-provider") {
          const credentials = await cp.credentials();
          if (credentials.password) {
            hello.AUTH = {
              username: credentials.username ?? "default",
              password: credentials.password
            };
          }
        }
        if (cp && cp.type === "streaming-credentials-provider") {
          const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
          this.#credentialsSubscription = disposable;
          if (credentials.password) {
            hello.AUTH = {
              username: credentials.username ?? "default",
              password: credentials.password
            };
          }
        }
        if (this.#options.name) {
          hello.SETNAME = this.#options.name;
        }
        commands.push({ cmd: (0, generic_transformers_1.parseArgs)(HELLO_1.default, this.#options.RESP, hello) });
      } else {
        if (cp && cp.type === "async-credentials-provider") {
          const credentials = await cp.credentials();
          if (credentials.username || credentials.password) {
            commands.push({
              cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                username: credentials.username,
                password: credentials.password ?? ""
              })
            });
          }
        }
        if (cp && cp.type === "streaming-credentials-provider") {
          const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
          this.#credentialsSubscription = disposable;
          if (credentials.username || credentials.password) {
            commands.push({
              cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                username: credentials.username,
                password: credentials.password ?? ""
              })
            });
          }
        }
        if (this.#options?.name) {
          commands.push({
            cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.CLIENT_SETNAME, this.#options.name)
          });
        }
      }
      if (this.#selectedDB !== 0) {
        commands.push({ cmd: ["SELECT", this.#selectedDB.toString()] });
      }
      if (this.#options?.readonly) {
        commands.push({ cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.READONLY) });
      }
      if (!this.#options?.disableClientInfo) {
        commands.push({
          cmd: ["CLIENT", "SETINFO", "LIB-VER", package_json_1.version],
          errorHandler: () => {}
        });
        commands.push({
          cmd: [
            "CLIENT",
            "SETINFO",
            "LIB-NAME",
            this.#options?.clientInfoTag ? `node-redis(${this.#options.clientInfoTag})` : "node-redis"
          ],
          errorHandler: () => {}
        });
      }
      if (this.#clientSideCache) {
        commands.push({ cmd: this.#clientSideCache.trackingOn() });
      }
      return commands;
    }
    #initiateSocket() {
      const socketInitiator = async () => {
        const promises = [], chainId = Symbol("Socket Initiator");
        const resubscribePromise = this.#queue.resubscribe(chainId);
        if (resubscribePromise) {
          promises.push(resubscribePromise);
        }
        if (this.#monitorCallback) {
          promises.push(this.#queue.monitor(this.#monitorCallback, {
            typeMapping: this._commandOptions?.typeMapping,
            chainId,
            asap: true
          }));
        }
        promises.push(...await this.#handshake(chainId, true));
        if (promises.length) {
          this.#write();
          return Promise.all(promises);
        }
      };
      return new socket_1.default(socketInitiator, this.#options?.socket).on("data", (chunk) => {
        try {
          this.#queue.decoder.write(chunk);
        } catch (err) {
          this.#queue.resetDecoder();
          this.emit("error", err);
        }
      }).on("error", (err) => {
        this.emit("error", err);
        this.#clientSideCache?.onError();
        if (this.#socket.isOpen && !this.#options?.disableOfflineQueue) {
          this.#queue.flushWaitingForReply(err);
        } else {
          this.#queue.flushAll(err);
        }
      }).on("connect", () => this.emit("connect")).on("ready", () => {
        this.emit("ready");
        this.#setPingTimer();
        this.#maybeScheduleWrite();
      }).on("reconnecting", () => this.emit("reconnecting")).on("drain", () => this.#maybeScheduleWrite()).on("end", () => this.emit("end"));
    }
    #pingTimer;
    #setPingTimer() {
      if (!this.#options?.pingInterval || !this.#socket.isReady)
        return;
      clearTimeout(this.#pingTimer);
      this.#pingTimer = setTimeout(() => {
        if (!this.#socket.isReady)
          return;
        this.sendCommand(["PING"]).then((reply) => this.emit("ping-interval", reply)).catch((err) => this.emit("error", err)).finally(() => this.#setPingTimer());
      }, this.#options.pingInterval);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    withAbortSignal(abortSignal) {
      return this._commandOptionsProxy("abortSignal", abortSignal);
    }
    asap() {
      return this._commandOptionsProxy("asap", true);
    }
    legacy() {
      return new legacy_mode_1.RedisLegacyClient(this);
    }
    createPool(options) {
      return pool_1.RedisClientPool.create(this._self.#options, options);
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...this._self.#options,
        commandOptions: this._commandOptions,
        ...overrides
      });
    }
    async connect() {
      await this._self.#socket.connect();
      return this;
    }
    async _executeCommand(command, parser, commandOptions, transformReply) {
      const csc = this._self.#clientSideCache;
      const defaultTypeMapping = this._self.#options?.commandOptions === commandOptions;
      const fn = () => {
        return this.sendCommand(parser.redisArgs, commandOptions);
      };
      if (csc && command.CACHEABLE && defaultTypeMapping) {
        return await csc.handleCache(this._self, parser, fn, transformReply, commandOptions?.typeMapping);
      } else {
        const reply = await fn();
        if (transformReply) {
          return transformReply(reply, parser.preserve, commandOptions?.typeMapping);
        }
        return reply;
      }
    }
    async _executeScript(script, parser, options, transformReply) {
      const args = parser.redisArgs;
      let reply;
      try {
        reply = await this.sendCommand(args, options);
      } catch (err) {
        if (!err?.message?.startsWith?.("NOSCRIPT"))
          throw err;
        args[0] = "EVAL";
        args[1] = script.SCRIPT;
        reply = await this.sendCommand(args, options);
      }
      return transformReply ? transformReply(reply, parser.preserve, options?.typeMapping) : reply;
    }
    sendCommand(args, options) {
      if (!this._self.#socket.isOpen) {
        return Promise.reject(new errors_1.ClientClosedError);
      } else if (!this._self.#socket.isReady && this._self.#options?.disableOfflineQueue) {
        return Promise.reject(new errors_1.ClientOfflineError);
      }
      const promise = this._self.#queue.addCommand(args, options);
      this._self.#scheduleWrite();
      return promise;
    }
    async SELECT(db) {
      await this.sendCommand(["SELECT", db.toString()]);
      this._self.#selectedDB = db;
    }
    select = this.SELECT;
    #pubSubCommand(promise) {
      if (promise === undefined)
        return Promise.resolve();
      this.#scheduleWrite();
      return promise;
    }
    SUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
    }
    subscribe = this.SUBSCRIBE;
    UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    PSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
    }
    pSubscribe = this.PSUBSCRIBE;
    PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    SSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    async WATCH(key) {
      const reply = await this._self.sendCommand((0, generic_transformers_1.pushVariadicArguments)(["WATCH"], key));
      this._self.#watchEpoch ??= this._self.socketEpoch;
      return reply;
    }
    watch = this.WATCH;
    async UNWATCH() {
      const reply = await this._self.sendCommand(["UNWATCH"]);
      this._self.#watchEpoch = undefined;
      return reply;
    }
    unwatch = this.UNWATCH;
    getPubSubListeners(type) {
      return this._self.#queue.getPubSubListeners(type);
    }
    extendPubSubChannelListeners(type, channel, listeners) {
      return this._self.#pubSubCommand(this._self.#queue.extendPubSubChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
      return this._self.#pubSubCommand(this._self.#queue.extendPubSubListeners(type, listeners));
    }
    #write() {
      this.#socket.write(this.#queue.commandsToWrite());
    }
    #scheduledWrite;
    #scheduleWrite() {
      if (!this.#socket.isReady || this.#scheduledWrite)
        return;
      this.#scheduledWrite = setImmediate(() => {
        this.#write();
        this.#scheduledWrite = undefined;
      });
    }
    #maybeScheduleWrite() {
      if (!this.#queue.isWaitingToWrite())
        return;
      this.#scheduleWrite();
    }
    async _executePipeline(commands, selectedDB) {
      if (!this._self.#socket.isOpen) {
        return Promise.reject(new errors_1.ClientClosedError);
      }
      const chainId = Symbol("Pipeline Chain"), promise = Promise.all(commands.map(({ args }) => this._self.#queue.addCommand(args, {
        chainId,
        typeMapping: this._commandOptions?.typeMapping
      })));
      this._self.#scheduleWrite();
      const result = await promise;
      if (selectedDB !== undefined) {
        this._self.#selectedDB = selectedDB;
      }
      return result;
    }
    async _executeMulti(commands, selectedDB) {
      const dirtyWatch = this._self.#dirtyWatch;
      this._self.#dirtyWatch = undefined;
      const watchEpoch = this._self.#watchEpoch;
      this._self.#watchEpoch = undefined;
      if (!this._self.#socket.isOpen) {
        throw new errors_1.ClientClosedError;
      }
      if (dirtyWatch) {
        throw new errors_1.WatchError(dirtyWatch);
      }
      if (watchEpoch && watchEpoch !== this._self.socketEpoch) {
        throw new errors_1.WatchError("Client reconnected after WATCH");
      }
      const typeMapping = this._commandOptions?.typeMapping;
      const chainId = Symbol("MULTI Chain");
      const promises = [
        this._self.#queue.addCommand(["MULTI"], { chainId })
      ];
      for (const { args } of commands) {
        promises.push(this._self.#queue.addCommand(args, {
          chainId,
          typeMapping
        }));
      }
      promises.push(this._self.#queue.addCommand(["EXEC"], { chainId }));
      this._self.#scheduleWrite();
      const results = await Promise.all(promises), execResult = results[results.length - 1];
      if (execResult === null) {
        throw new errors_1.WatchError;
      }
      if (selectedDB !== undefined) {
        this._self.#selectedDB = selectedDB;
      }
      return execResult;
    }
    MULTI() {
      return new this.Multi(this._executeMulti.bind(this), this._executePipeline.bind(this), this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async* scanIterator(options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.scan(cursor, options);
        cursor = reply.cursor;
        yield reply.keys;
      } while (cursor !== "0");
    }
    async* hScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.entries;
      } while (cursor !== "0");
    }
    async* hScanValuesIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScanNoValues(key, cursor, options);
        cursor = reply.cursor;
        yield reply.fields;
      } while (cursor !== "0");
    }
    async* hScanNoValuesIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScanNoValues(key, cursor, options);
        cursor = reply.cursor;
        yield reply.fields;
      } while (cursor !== "0");
    }
    async* sScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.sScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.members;
      } while (cursor !== "0");
    }
    async* zScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.zScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.members;
      } while (cursor !== "0");
    }
    async MONITOR(callback) {
      const promise = this._self.#queue.monitor(callback, {
        typeMapping: this._commandOptions?.typeMapping
      });
      this._self.#scheduleWrite();
      await promise;
      this._self.#monitorCallback = callback;
    }
    monitor = this.MONITOR;
    async reset() {
      const chainId = Symbol("Reset Chain"), promises = [this._self.#queue.reset(chainId)], selectedDB = this._self.#options?.database ?? 0;
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
      promises.push(...await this._self.#handshake(chainId, false));
      this._self.#scheduleWrite();
      await Promise.all(promises);
      this._self.#selectedDB = selectedDB;
      this._self.#monitorCallback = undefined;
      this._self.#dirtyWatch = undefined;
      this._self.#watchEpoch = undefined;
    }
    resetIfDirty() {
      let shouldReset = false;
      if (this._self.#selectedDB !== (this._self.#options?.database ?? 0)) {
        console.warn("Returning a client with a different selected DB");
        shouldReset = true;
      }
      if (this._self.#monitorCallback) {
        console.warn("Returning a client with active MONITOR");
        shouldReset = true;
      }
      if (this._self.#queue.isPubSubActive) {
        console.warn("Returning a client with active PubSub");
        shouldReset = true;
      }
      if (this._self.#dirtyWatch || this._self.#watchEpoch) {
        console.warn("Returning a client with active WATCH");
        shouldReset = true;
      }
      if (shouldReset) {
        return this.reset();
      }
    }
    QUIT() {
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
      return this._self.#socket.quit(async () => {
        clearTimeout(this._self.#pingTimer);
        const quitPromise = this._self.#queue.addCommand(["QUIT"]);
        this._self.#scheduleWrite();
        return quitPromise;
      });
    }
    quit = this.QUIT;
    disconnect() {
      return Promise.resolve(this.destroy());
    }
    close() {
      return new Promise((resolve) => {
        clearTimeout(this._self.#pingTimer);
        this._self.#socket.close();
        this._self.#clientSideCache?.onClose();
        if (this._self.#queue.isEmpty()) {
          this._self.#socket.destroySocket();
          return resolve();
        }
        const maybeClose = () => {
          if (!this._self.#queue.isEmpty())
            return;
          this._self.#socket.off("data", maybeClose);
          this._self.#socket.destroySocket();
          resolve();
        };
        this._self.#socket.on("data", maybeClose);
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
      });
    }
    destroy() {
      clearTimeout(this._self.#pingTimer);
      this._self.#queue.flushAll(new errors_1.DisconnectsClientError);
      this._self.#socket.destroy();
      this._self.#clientSideCache?.onClose();
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
    }
    ref() {
      this._self.#socket.ref();
    }
    unref() {
      this._self.#socket.unref();
    }
  }
  _a = RedisClient;
  exports.default = RedisClient;
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var lookup = [
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ];
  var toUTF8Array = function toUTF8Array(str) {
    var char;
    var i = 0;
    var p = 0;
    var utf8 = [];
    var len = str.length;
    for (;i < len; i++) {
      char = str.charCodeAt(i);
      if (char < 128) {
        utf8[p++] = char;
      } else if (char < 2048) {
        utf8[p++] = char >> 6 | 192;
        utf8[p++] = char & 63 | 128;
      } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        utf8[p++] = char >> 18 | 240;
        utf8[p++] = char >> 12 & 63 | 128;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      } else {
        utf8[p++] = char >> 12 | 224;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      }
    }
    return utf8;
  };
  var generate = module.exports = function generate(str) {
    var char;
    var i = 0;
    var start = -1;
    var result = 0;
    var resultHash = 0;
    var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
    var len = utf8.length;
    while (i < len) {
      char = utf8[i++];
      if (start === -1) {
        if (char === 123) {
          start = i;
        }
      } else if (char !== 125) {
        resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
      } else if (i - 1 !== start) {
        return resultHash & 16383;
      }
      result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
    }
    return result & 16383;
  };
  module.exports.generateMulti = function generateMulti(keys) {
    var i = 1;
    var len = keys.length;
    var base = generate(keys[0]);
    while (i < len) {
      if (generate(keys[i++]) !== base)
        return -1;
    }
    return base;
  };
});

// node_modules/@redis/client/dist/lib/cluster/cluster-slots.js
var require_cluster_slots = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_1 = require_errors();
  var client_1 = __importDefault(require_client3());
  var pub_sub_1 = require_pub_sub();
  var cluster_key_slot_1 = __importDefault(require_lib3());
  var cache_1 = require_cache();

  class RedisClusterSlots {
    static #SLOTS = 16384;
    #options;
    #clientFactory;
    #emit;
    slots = new Array(_a.#SLOTS);
    masters = new Array;
    replicas = new Array;
    nodeByAddress = new Map;
    pubSubNode;
    clientSideCache;
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    constructor(options, emit) {
      this.#validateOptions(options);
      this.#options = options;
      if (options?.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.clientSideCache = options.clientSideCache;
        } else {
          this.clientSideCache = new cache_1.BasicPooledClientSideCache(options.clientSideCache);
        }
      }
      this.#clientFactory = client_1.default.factory(this.#options);
      this.#emit = emit;
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("Cluster already open");
      }
      this.#isOpen = true;
      try {
        await this.#discoverWithRootNodes();
      } catch (err) {
        this.#isOpen = false;
        throw err;
      }
    }
    async#discoverWithRootNodes() {
      let start = Math.floor(Math.random() * this.#options.rootNodes.length);
      for (let i = start;i < this.#options.rootNodes.length; i++) {
        if (!this.#isOpen)
          throw new Error("Cluster closed");
        if (await this.#discover(this.#options.rootNodes[i]))
          return;
      }
      for (let i = 0;i < start; i++) {
        if (!this.#isOpen)
          throw new Error("Cluster closed");
        if (await this.#discover(this.#options.rootNodes[i]))
          return;
      }
      throw new errors_1.RootNodesUnavailableError;
    }
    #resetSlots() {
      this.slots = new Array(_a.#SLOTS);
      this.masters = [];
      this.replicas = [];
      this._randomNodeIterator = undefined;
    }
    async#discover(rootNode) {
      this.clientSideCache?.clear();
      this.clientSideCache?.disable();
      try {
        const addressesInUse = new Set, promises = [], eagerConnect = this.#options.minimizeConnections !== true;
        const shards = await this.#getShards(rootNode);
        this.#resetSlots();
        for (const { from, to, master, replicas } of shards) {
          const shard = {
            master: this.#initiateSlotNode(master, false, eagerConnect, addressesInUse, promises)
          };
          if (this.#options.useReplicas) {
            shard.replicas = replicas.map((replica) => this.#initiateSlotNode(replica, true, eagerConnect, addressesInUse, promises));
          }
          for (let i = from;i <= to; i++) {
            this.slots[i] = shard;
          }
        }
        if (this.pubSubNode && !addressesInUse.has(this.pubSubNode.address)) {
          const channelsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS), patternsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS);
          this.pubSubNode.client.destroy();
          if (channelsListeners.size || patternsListeners.size) {
            promises.push(this.#initiatePubSubClient({
              [pub_sub_1.PUBSUB_TYPE.CHANNELS]: channelsListeners,
              [pub_sub_1.PUBSUB_TYPE.PATTERNS]: patternsListeners
            }));
          }
        }
        for (const [address, node] of this.nodeByAddress.entries()) {
          if (addressesInUse.has(address))
            continue;
          if (node.client) {
            node.client.destroy();
          }
          const { pubSub } = node;
          if (pubSub) {
            pubSub.client.destroy();
          }
          this.nodeByAddress.delete(address);
        }
        await Promise.all(promises);
        this.clientSideCache?.enable();
        return true;
      } catch (err) {
        this.#emit("error", err);
        return false;
      }
    }
    async#getShards(rootNode) {
      const options = this.#clientOptionsDefaults(rootNode);
      options.socket ??= {};
      options.socket.reconnectStrategy = false;
      options.RESP = this.#options.RESP;
      options.commandOptions = undefined;
      const client = await this.#clientFactory(options).on("error", (err) => this.#emit("error", err)).connect();
      try {
        return await client.clusterSlots();
      } finally {
        client.destroy();
      }
    }
    #getNodeAddress(address) {
      switch (typeof this.#options.nodeAddressMap) {
        case "object":
          return this.#options.nodeAddressMap[address];
        case "function":
          return this.#options.nodeAddressMap(address);
      }
    }
    #clientOptionsDefaults(options) {
      if (!this.#options.defaults)
        return options;
      let socket;
      if (this.#options.defaults.socket) {
        socket = {
          ...this.#options.defaults.socket,
          ...options?.socket
        };
      } else {
        socket = options?.socket;
      }
      return {
        ...this.#options.defaults,
        ...options,
        socket
      };
    }
    #initiateSlotNode(shard, readonly, eagerConnent, addressesInUse, promises) {
      const address = `${shard.host}:${shard.port}`;
      let node = this.nodeByAddress.get(address);
      if (!node) {
        node = {
          ...shard,
          address,
          readonly,
          client: undefined,
          connectPromise: undefined
        };
        if (eagerConnent) {
          promises.push(this.#createNodeClient(node));
        }
        this.nodeByAddress.set(address, node);
      }
      if (!addressesInUse.has(address)) {
        addressesInUse.add(address);
        (readonly ? this.replicas : this.masters).push(node);
      }
      return node;
    }
    #createClient(node, readonly = node.readonly) {
      return this.#clientFactory(this.#clientOptionsDefaults({
        clientSideCache: this.clientSideCache,
        RESP: this.#options.RESP,
        socket: this.#getNodeAddress(node.address) ?? {
          host: node.host,
          port: node.port
        },
        readonly
      })).on("error", (err) => console.error(err));
    }
    #createNodeClient(node, readonly) {
      const client = node.client = this.#createClient(node, readonly);
      return node.connectPromise = client.connect().finally(() => node.connectPromise = undefined);
    }
    nodeClient(node) {
      return node.connectPromise ?? node.client ?? this.#createNodeClient(node);
    }
    #runningRediscoverPromise;
    async rediscover(startWith) {
      this.#runningRediscoverPromise ??= this.#rediscover(startWith).finally(() => this.#runningRediscoverPromise = undefined);
      return this.#runningRediscoverPromise;
    }
    async#rediscover(startWith) {
      if (await this.#discover(startWith.options))
        return;
      return this.#discoverWithRootNodes();
    }
    quit() {
      return this.#destroy((client) => client.quit());
    }
    disconnect() {
      return this.#destroy((client) => client.disconnect());
    }
    close() {
      return this.#destroy((client) => client.close());
    }
    destroy() {
      this.#isOpen = false;
      for (const client of this.#clients()) {
        client.destroy();
      }
      if (this.pubSubNode) {
        this.pubSubNode.client.destroy();
        this.pubSubNode = undefined;
      }
      this.#resetSlots();
      this.nodeByAddress.clear();
    }
    *#clients() {
      for (const master of this.masters) {
        if (master.client) {
          yield master.client;
        }
        if (master.pubSub) {
          yield master.pubSub.client;
        }
      }
      for (const replica of this.replicas) {
        if (replica.client) {
          yield replica.client;
        }
      }
    }
    async#destroy(fn) {
      this.#isOpen = false;
      const promises = [];
      for (const client of this.#clients()) {
        promises.push(fn(client));
      }
      if (this.pubSubNode) {
        promises.push(fn(this.pubSubNode.client));
        this.pubSubNode = undefined;
      }
      this.#resetSlots();
      this.nodeByAddress.clear();
      await Promise.allSettled(promises);
    }
    getClient(firstKey, isReadonly) {
      if (!firstKey) {
        return this.nodeClient(this.getRandomNode());
      }
      const slotNumber = (0, cluster_key_slot_1.default)(firstKey);
      if (!isReadonly) {
        return this.nodeClient(this.slots[slotNumber].master);
      }
      return this.nodeClient(this.getSlotRandomNode(slotNumber));
    }
    *#iterateAllNodes() {
      let i = Math.floor(Math.random() * (this.masters.length + this.replicas.length));
      if (i < this.masters.length) {
        do {
          yield this.masters[i];
        } while (++i < this.masters.length);
        for (const replica of this.replicas) {
          yield replica;
        }
      } else {
        i -= this.masters.length;
        do {
          yield this.replicas[i];
        } while (++i < this.replicas.length);
      }
      while (true) {
        for (const master of this.masters) {
          yield master;
        }
        for (const replica of this.replicas) {
          yield replica;
        }
      }
    }
    _randomNodeIterator;
    getRandomNode() {
      this._randomNodeIterator ??= this.#iterateAllNodes();
      return this._randomNodeIterator.next().value;
    }
    *#slotNodesIterator(slot) {
      let i = Math.floor(Math.random() * (1 + slot.replicas.length));
      if (i < slot.replicas.length) {
        do {
          yield slot.replicas[i];
        } while (++i < slot.replicas.length);
      }
      while (true) {
        yield slot.master;
        for (const replica of slot.replicas) {
          yield replica;
        }
      }
    }
    getSlotRandomNode(slotNumber) {
      const slot = this.slots[slotNumber];
      if (!slot.replicas?.length) {
        return slot.master;
      }
      slot.nodesIterator ??= this.#slotNodesIterator(slot);
      return slot.nodesIterator.next().value;
    }
    getMasterByAddress(address) {
      const master = this.nodeByAddress.get(address);
      if (!master)
        return;
      return this.nodeClient(master);
    }
    getPubSubClient() {
      if (!this.pubSubNode)
        return this.#initiatePubSubClient();
      return this.pubSubNode.connectPromise ?? this.pubSubNode.client;
    }
    async#initiatePubSubClient(toResubscribe) {
      const index = Math.floor(Math.random() * (this.masters.length + this.replicas.length)), node = index < this.masters.length ? this.masters[index] : this.replicas[index - this.masters.length], client = this.#createClient(node, false);
      this.pubSubNode = {
        address: node.address,
        client,
        connectPromise: client.connect().then(async (client2) => {
          if (toResubscribe) {
            await Promise.all([
              client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, toResubscribe[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
              client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, toResubscribe[pub_sub_1.PUBSUB_TYPE.PATTERNS])
            ]);
          }
          this.pubSubNode.connectPromise = undefined;
          return client2;
        }).catch((err) => {
          this.pubSubNode = undefined;
          throw err;
        })
      };
      return this.pubSubNode.connectPromise;
    }
    async executeUnsubscribeCommand(unsubscribe) {
      const client = await this.getPubSubClient();
      await unsubscribe(client);
      if (!client.isPubSubActive) {
        client.destroy();
        this.pubSubNode = undefined;
      }
    }
    getShardedPubSubClient(channel) {
      const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
      if (!master.pubSub)
        return this.#initiateShardedPubSubClient(master);
      return master.pubSub.connectPromise ?? master.pubSub.client;
    }
    async#initiateShardedPubSubClient(master) {
      const client = this.#createClient(master, false).on("server-sunsubscribe", async (channel, listeners) => {
        try {
          await this.rediscover(client);
          const redirectTo = await this.getShardedPubSubClient(channel);
          await redirectTo.extendPubSubChannelListeners(pub_sub_1.PUBSUB_TYPE.SHARDED, channel, listeners);
        } catch (err) {
          this.#emit("sharded-shannel-moved-error", err, channel, listeners);
        }
      });
      master.pubSub = {
        client,
        connectPromise: client.connect().then((client2) => {
          master.pubSub.connectPromise = undefined;
          return client2;
        }).catch((err) => {
          master.pubSub = undefined;
          throw err;
        })
      };
      return master.pubSub.connectPromise;
    }
    async executeShardedUnsubscribeCommand(channel, unsubscribe) {
      const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
      if (!master.pubSub)
        return;
      const client = master.pubSub.connectPromise ? await master.pubSub.connectPromise : master.pubSub.client;
      await unsubscribe(client);
      if (!client.isPubSubActive) {
        client.destroy();
        master.pubSub = undefined;
      }
    }
  }
  _a = RedisClusterSlots;
  exports.default = RedisClusterSlots;
});

// node_modules/@redis/client/dist/lib/cluster/multi-command.js
var require_multi_command3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser2();

  class RedisClusterMultiCommand {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this._self.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this._self.addCommand(firstKey, fn.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const scriptArgs = parser.redisArgs;
        scriptArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this.#addScript(firstKey, script.IS_READ_ONLY, script, scriptArgs, transformReply);
      };
    }
    static extend(config) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisClusterMultiCommand,
        commands: commands_1.default,
        createCommand: RedisClusterMultiCommand.#createCommand,
        createModuleCommand: RedisClusterMultiCommand.#createModuleCommand,
        createFunctionCommand: RedisClusterMultiCommand.#createFunctionCommand,
        createScriptCommand: RedisClusterMultiCommand.#createScriptCommand,
        config
      });
    }
    #multi;
    #executeMulti;
    #executePipeline;
    #firstKey;
    #isReadonly = true;
    constructor(executeMulti, executePipeline, routing, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#executeMulti = executeMulti;
      this.#executePipeline = executePipeline;
      this.#firstKey = routing;
    }
    #setState(firstKey, isReadonly) {
      this.#firstKey ??= firstKey;
      this.#isReadonly &&= isReadonly;
    }
    addCommand(firstKey, isReadonly, args, transformReply) {
      this.#setState(firstKey, isReadonly);
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(firstKey, isReadonly, script, args, transformReply) {
      this.#setState(firstKey, isReadonly);
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#executeMulti(this.#firstKey, this.#isReadonly, this.#multi.queue));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#executePipeline(this.#firstKey, this.#isReadonly, this.#multi.queue));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisClusterMultiCommand;
});

// node_modules/@redis/client/dist/lib/cluster/index.js
var require_cluster = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var node_events_1 = __require("node:events");
  var commander_1 = require_commander();
  var cluster_slots_1 = __importDefault(require_cluster_slots());
  var multi_command_1 = __importDefault(require_multi_command3());
  var errors_1 = require_errors();
  var parser_1 = require_parser2();
  var ASKING_1 = require_ASKING();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());

  class RedisCluster extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, fn.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(fn, parser, opts, transformReply));
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        script.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, script.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeScript(script, parser, opts, transformReply));
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static factory(config) {
      let Cluster = RedisCluster.#SingleEntryCache.get(config);
      if (!Cluster) {
        Cluster = (0, commander_1.attachConfig)({
          BaseClass: RedisCluster,
          commands: commands_1.default,
          createCommand: RedisCluster.#createCommand,
          createModuleCommand: RedisCluster.#createModuleCommand,
          createFunctionCommand: RedisCluster.#createFunctionCommand,
          createScriptCommand: RedisCluster.#createScriptCommand,
          config
        });
        Cluster.prototype.Multi = multi_command_1.default.extend(config);
        RedisCluster.#SingleEntryCache.set(config, Cluster);
      }
      return (options) => {
        return Object.create(new Cluster(options));
      };
    }
    static create(options) {
      return RedisCluster.factory(options)(options);
    }
    _options;
    _slots;
    _self = this;
    _commandOptions;
    get slots() {
      return this._self._slots.slots;
    }
    get clientSideCache() {
      return this._self._slots.clientSideCache;
    }
    get masters() {
      return this._self._slots.masters;
    }
    get replicas() {
      return this._self._slots.replicas;
    }
    get nodeByAddress() {
      return this._self._slots.nodeByAddress;
    }
    get pubSubNode() {
      return this._self._slots.pubSubNode;
    }
    get isOpen() {
      return this._self._slots.isOpen;
    }
    constructor(options) {
      super();
      this._options = options;
      this._slots = new cluster_slots_1.default(options, this.emit.bind(this));
      if (options?.commandOptions) {
        this._commandOptions = options.commandOptions;
      }
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...this._self._options,
        commandOptions: this._commandOptions,
        ...overrides
      });
    }
    async connect() {
      await this._self._slots.connect();
      return this;
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    _handleAsk(fn) {
      return async (client, options) => {
        const chainId = Symbol("asking chain");
        const opts = options ? { ...options } : {};
        opts.chainId = chainId;
        const ret = await Promise.all([
          client.sendCommand([ASKING_1.ASKING_CMD], { chainId }),
          fn(client, opts)
        ]);
        return ret[1];
      };
    }
    async _execute(firstKey, isReadonly, options, fn) {
      const maxCommandRedirections = this._options.maxCommandRedirections ?? 16;
      let client = await this._slots.getClient(firstKey, isReadonly);
      let i = 0;
      let myFn = fn;
      while (true) {
        try {
          return await myFn(client, options);
        } catch (err) {
          myFn = fn;
          if (++i > maxCommandRedirections || !(err instanceof Error)) {
            throw err;
          }
          if (err.message.startsWith("ASK")) {
            const address = err.message.substring(err.message.lastIndexOf(" ") + 1);
            let redirectTo = await this._slots.getMasterByAddress(address);
            if (!redirectTo) {
              await this._slots.rediscover(client);
              redirectTo = await this._slots.getMasterByAddress(address);
            }
            if (!redirectTo) {
              throw new Error(`Cannot find node ${address}`);
            }
            client = redirectTo;
            myFn = this._handleAsk(fn);
            continue;
          }
          if (err.message.startsWith("MOVED")) {
            await this._slots.rediscover(client);
            client = await this._slots.getClient(firstKey, isReadonly);
            continue;
          }
          throw err;
        }
      }
    }
    async sendCommand(firstKey, isReadonly, args, options) {
      return this._self._execute(firstKey, isReadonly, options, (client, opts) => client.sendCommand(args, opts));
    }
    MULTI(routing) {
      return new this.Multi(async (firstKey, isReadonly, commands) => {
        const client = await this._self._slots.getClient(firstKey, isReadonly);
        return client._executeMulti(commands);
      }, async (firstKey, isReadonly, commands) => {
        const client = await this._self._slots.getClient(firstKey, isReadonly);
        return client._executePipeline(commands);
      }, routing, this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async SUBSCRIBE(channels, listener, bufferMode) {
      return (await this._self._slots.getPubSubClient()).SUBSCRIBE(channels, listener, bufferMode);
    }
    subscribe = this.SUBSCRIBE;
    async UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self._slots.executeUnsubscribeCommand((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    async PSUBSCRIBE(patterns, listener, bufferMode) {
      return (await this._self._slots.getPubSubClient()).PSUBSCRIBE(patterns, listener, bufferMode);
    }
    pSubscribe = this.PSUBSCRIBE;
    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self._slots.executeUnsubscribeCommand((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    async SSUBSCRIBE(channels, listener, bufferMode) {
      const maxCommandRedirections = this._self._options.maxCommandRedirections ?? 16, firstChannel = Array.isArray(channels) ? channels[0] : channels;
      let client = await this._self._slots.getShardedPubSubClient(firstChannel);
      for (let i = 0;; i++) {
        try {
          return await client.SSUBSCRIBE(channels, listener, bufferMode);
        } catch (err) {
          if (++i > maxCommandRedirections || !(err instanceof errors_1.ErrorReply)) {
            throw err;
          }
          if (err.message.startsWith("MOVED")) {
            await this._self._slots.rediscover(client);
            client = await this._self._slots.getShardedPubSubClient(firstChannel);
            continue;
          }
          throw err;
        }
      }
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self._slots.executeShardedUnsubscribeCommand(Array.isArray(channels) ? channels[0] : channels, (client) => client.SUNSUBSCRIBE(channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    quit() {
      return this._self._slots.quit();
    }
    disconnect() {
      return this._self._slots.disconnect();
    }
    close() {
      this._self._slots.clientSideCache?.onPoolClose();
      return this._self._slots.close();
    }
    destroy() {
      this._self._slots.clientSideCache?.onPoolClose();
      return this._self._slots.destroy();
    }
    nodeClient(node) {
      return this._self._slots.nodeClient(node);
    }
    getRandomNode() {
      return this._self._slots.getRandomNode();
    }
    getSlotRandomNode(slot) {
      return this._self._slots.getSlotRandomNode(slot);
    }
    getMasters() {
      return this.masters;
    }
    getSlotMaster(slot) {
      return this.slots[slot].master;
    }
  }
  exports.default = RedisCluster;
});

// node_modules/@redis/client/dist/lib/sentinel/utils.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createScriptCommand = exports.createModuleCommand = exports.createFunctionCommand = exports.createCommand = exports.clientSocketToNode = exports.createNodeList = exports.parseNode = undefined;
  var parser_1 = require_parser2();
  var commander_1 = require_commander();
  function parseNode(node) {
    if (node.flags.includes("s_down") || node.flags.includes("disconnected") || node.flags.includes("failover_in_progress")) {
      return;
    }
    return { host: node.ip, port: Number(node.port) };
  }
  exports.parseNode = parseNode;
  function createNodeList(nodes) {
    var nodeList = [];
    for (const nodeData of nodes) {
      const node = parseNode(nodeData);
      if (node === undefined) {
        continue;
      }
      nodeList.push(node);
    }
    return nodeList;
  }
  exports.createNodeList = createNodeList;
  function clientSocketToNode(socket) {
    const s = socket;
    return {
      host: s.host,
      port: s.port
    };
  }
  exports.clientSocketToNode = clientSocketToNode;
  function createCommand(command, resp) {
    const transformReply = (0, commander_1.getTransformReply)(command, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      command.parseCommand(parser, ...args);
      return this._self._execute(command.IS_READ_ONLY, (client) => client._executeCommand(command, parser, this.commandOptions, transformReply));
    };
  }
  exports.createCommand = createCommand;
  function createFunctionCommand(name, fn, resp) {
    const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
    const transformReply = (0, commander_1.getTransformReply)(fn, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      parser.push(...prefix);
      fn.parseCommand(parser, ...args);
      return this._self._execute(fn.IS_READ_ONLY, (client) => client._executeCommand(fn, parser, this._self.commandOptions, transformReply));
    };
  }
  exports.createFunctionCommand = createFunctionCommand;
  function createModuleCommand(command, resp) {
    const transformReply = (0, commander_1.getTransformReply)(command, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      command.parseCommand(parser, ...args);
      return this._self._execute(command.IS_READ_ONLY, (client) => client._executeCommand(command, parser, this._self.commandOptions, transformReply));
    };
  }
  exports.createModuleCommand = createModuleCommand;
  function createScriptCommand(script, resp) {
    const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
    const transformReply = (0, commander_1.getTransformReply)(script, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      parser.push(...prefix);
      script.parseCommand(parser, ...args);
      return this._self._execute(script.IS_READ_ONLY, (client) => client._executeScript(script, parser, this.commandOptions, transformReply));
    };
  }
  exports.createScriptCommand = createScriptCommand;
});

// node_modules/@redis/client/dist/lib/sentinel/multi-commands.js
var require_multi_commands = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser2();

  class RedisSentinelMultiCommand {
    static _createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(fn.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const scriptArgs = parser.redisArgs;
        scriptArgs.preserve = parser.preserve;
        return this.#addScript(script.IS_READ_ONLY, script, scriptArgs, transformReply);
      };
    }
    static extend(config) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisSentinelMultiCommand,
        commands: commands_1.default,
        createCommand: RedisSentinelMultiCommand._createCommand,
        createModuleCommand: RedisSentinelMultiCommand._createModuleCommand,
        createFunctionCommand: RedisSentinelMultiCommand._createFunctionCommand,
        createScriptCommand: RedisSentinelMultiCommand._createScriptCommand,
        config
      });
    }
    #multi = new multi_command_1.default;
    #sentinel;
    #isReadonly = true;
    constructor(sentinel, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#sentinel = sentinel;
    }
    #setState(isReadonly) {
      this.#isReadonly &&= isReadonly;
    }
    addCommand(isReadonly, args, transformReply) {
      this.#setState(isReadonly);
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(isReadonly, script, args, transformReply) {
      this.#setState(isReadonly);
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#sentinel._executeMulti(this.#isReadonly, this.#multi.queue));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#sentinel._executePipeline(this.#isReadonly, this.#multi.queue));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisSentinelMultiCommand;
});

// node_modules/@redis/client/dist/lib/sentinel/pub-sub-proxy.js
var require_pub_sub_proxy = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PubSubProxy = undefined;
  var node_events_1 = __importDefault(__require("node:events"));
  var pub_sub_1 = require_pub_sub();
  var client_1 = __importDefault(require_client3());

  class PubSubProxy extends node_events_1.default {
    #clientOptions;
    #onError;
    #node;
    #state;
    #subscriptions;
    constructor(clientOptions, onError) {
      super();
      this.#clientOptions = clientOptions;
      this.#onError = onError;
    }
    #createClient() {
      if (this.#node === undefined) {
        throw new Error("pubSubProxy: didn't define node to do pubsub against");
      }
      return new client_1.default({
        ...this.#clientOptions,
        socket: {
          ...this.#clientOptions.socket,
          host: this.#node.host,
          port: this.#node.port
        }
      });
    }
    async#initiatePubSubClient(withSubscriptions = false) {
      const client = this.#createClient().on("error", this.#onError);
      const connectPromise = client.connect().then(async (client2) => {
        if (this.#state?.client !== client2) {
          client2.destroy();
          return this.#state?.connectPromise;
        }
        if (withSubscriptions && this.#subscriptions) {
          await Promise.all([
            client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
            client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.PATTERNS])
          ]);
        }
        if (this.#state.client !== client2) {
          client2.destroy();
          return this.#state?.connectPromise;
        }
        this.#state.connectPromise = undefined;
        return client2;
      }).catch((err) => {
        this.#state = undefined;
        throw err;
      });
      this.#state = {
        client,
        connectPromise
      };
      return connectPromise;
    }
    #getPubSubClient() {
      if (!this.#state)
        return this.#initiatePubSubClient();
      return this.#state.connectPromise ?? this.#state.client;
    }
    async changeNode(node) {
      this.#node = node;
      if (!this.#state)
        return;
      if (this.#state.connectPromise === undefined) {
        this.#subscriptions = {
          [pub_sub_1.PUBSUB_TYPE.CHANNELS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS),
          [pub_sub_1.PUBSUB_TYPE.PATTERNS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS)
        };
        this.#state.client.destroy();
      }
      await this.#initiatePubSubClient(true);
    }
    #executeCommand(fn) {
      const client = this.#getPubSubClient();
      if (client instanceof client_1.default) {
        return fn(client);
      }
      return client.then((client2) => {
        if (client2 === undefined)
          return;
        return fn(client2);
      }).catch((err) => {
        if (this.#state?.client.isPubSubActive) {
          this.#state.client.destroy();
          this.#state = undefined;
        }
        throw err;
      });
    }
    subscribe(channels, listener, bufferMode) {
      return this.#executeCommand((client) => client.SUBSCRIBE(channels, listener, bufferMode));
    }
    #unsubscribe(fn) {
      return this.#executeCommand(async (client) => {
        const reply = await fn(client);
        if (!client.isPubSubActive) {
          client.destroy();
          this.#state = undefined;
        }
        return reply;
      });
    }
    async unsubscribe(channels, listener, bufferMode) {
      return this.#unsubscribe((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    async pSubscribe(patterns, listener, bufferMode) {
      return this.#executeCommand((client) => client.PSUBSCRIBE(patterns, listener, bufferMode));
    }
    async pUnsubscribe(patterns, listener, bufferMode) {
      return this.#unsubscribe((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
    }
    destroy() {
      this.#subscriptions = undefined;
      if (this.#state === undefined)
        return;
      if (!this.#state.connectPromise) {
        this.#state.client.destroy();
      }
      this.#state = undefined;
    }
  }
  exports.PubSubProxy = PubSubProxy;
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_MASTER.js
var require_SENTINEL_MASTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "MASTER", dbname);
    },
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_MONITOR.js
var require_SENTINEL_MONITOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, dbname, host, port, quorum) {
      parser.push("SENTINEL", "MONITOR", dbname, host, port, quorum);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_REPLICAS.js
var require_SENTINEL_REPLICAS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "REPLICAS", dbname);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        const inferred = reply;
        const initial = [];
        return inferred.reduce((sentinels, x) => {
          sentinels.push((0, generic_transformers_1.transformTuplesReply)(x, undefined, typeMapping));
          return sentinels;
        }, initial);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_SENTINELS.js
var require_SENTINEL_SENTINELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "SENTINELS", dbname);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        const inferred = reply;
        const initial = [];
        return inferred.reduce((sentinels, x) => {
          sentinels.push((0, generic_transformers_1.transformTuplesReply)(x, undefined, typeMapping));
          return sentinels;
        }, initial);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_SET.js
var require_SENTINEL_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, dbname, options) {
      parser.push("SENTINEL", "SET", dbname);
      for (const option of options) {
        parser.push(option.option, option.value);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/index.js
var require_commands2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SENTINEL_MASTER_1 = __importDefault(require_SENTINEL_MASTER());
  var SENTINEL_MONITOR_1 = __importDefault(require_SENTINEL_MONITOR());
  var SENTINEL_REPLICAS_1 = __importDefault(require_SENTINEL_REPLICAS());
  var SENTINEL_SENTINELS_1 = __importDefault(require_SENTINEL_SENTINELS());
  var SENTINEL_SET_1 = __importDefault(require_SENTINEL_SET());
  exports.default = {
    SENTINEL_SENTINELS: SENTINEL_SENTINELS_1.default,
    sentinelSentinels: SENTINEL_SENTINELS_1.default,
    SENTINEL_MASTER: SENTINEL_MASTER_1.default,
    sentinelMaster: SENTINEL_MASTER_1.default,
    SENTINEL_REPLICAS: SENTINEL_REPLICAS_1.default,
    sentinelReplicas: SENTINEL_REPLICAS_1.default,
    SENTINEL_MONITOR: SENTINEL_MONITOR_1.default,
    sentinelMonitor: SENTINEL_MONITOR_1.default,
    SENTINEL_SET: SENTINEL_SET_1.default,
    sentinelSet: SENTINEL_SET_1.default
  };
});

// node_modules/@redis/client/dist/lib/sentinel/module.js
var require_module = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands2());
  exports.default = {
    sentinel: commands_1.default
  };
});

// node_modules/@redis/client/dist/lib/sentinel/wait-queue.js
var require_wait_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitQueue = undefined;
  var linked_list_1 = require_linked_list();

  class WaitQueue {
    #list = new linked_list_1.SinglyLinkedList;
    #queue = new linked_list_1.SinglyLinkedList;
    push(value) {
      const resolve = this.#queue.shift();
      if (resolve !== undefined) {
        resolve(value);
        return;
      }
      this.#list.push(value);
    }
    shift() {
      return this.#list.shift();
    }
    wait() {
      return new Promise((resolve) => this.#queue.push(resolve));
    }
  }
  exports.WaitQueue = WaitQueue;
});

// node_modules/@redis/client/dist/lib/sentinel/index.js
var require_sentinel = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisSentinelFactory = exports.RedisSentinelClient = undefined;
  var node_events_1 = __require("node:events");
  var client_1 = __importDefault(require_client3());
  var commander_1 = require_commander();
  var commands_1 = __importDefault(require_commands());
  var utils_1 = require_utils3();
  var multi_commands_1 = __importDefault(require_multi_commands());
  var pub_sub_proxy_1 = require_pub_sub_proxy();
  var promises_1 = __require("node:timers/promises");
  var module_1 = __importDefault(require_module());
  var wait_queue_1 = require_wait_queue();
  var cache_1 = require_cache();

  class RedisSentinelClient {
    #clientInfo;
    #internal;
    _self;
    get isOpen() {
      return this._self.#internal.isOpen;
    }
    get isReady() {
      return this._self.#internal.isReady;
    }
    get commandOptions() {
      return this._self.#commandOptions;
    }
    #commandOptions;
    constructor(internal, clientInfo, commandOptions) {
      this._self = this;
      this.#internal = internal;
      this.#clientInfo = clientInfo;
      this.#commandOptions = commandOptions;
    }
    static factory(config) {
      const SentinelClient = (0, commander_1.attachConfig)({
        BaseClass: RedisSentinelClient,
        commands: commands_1.default,
        createCommand: utils_1.createCommand,
        createModuleCommand: utils_1.createModuleCommand,
        createFunctionCommand: utils_1.createFunctionCommand,
        createScriptCommand: utils_1.createScriptCommand,
        config
      });
      SentinelClient.prototype.Multi = multi_commands_1.default.extend(config);
      return (internal, clientInfo, commandOptions) => {
        return Object.create(new SentinelClient(internal, clientInfo, commandOptions));
      };
    }
    static create(options, internal, clientInfo, commandOptions) {
      return RedisSentinelClient.factory(options)(internal, clientInfo, commandOptions);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._commandOptions = Object.create(this._self.#commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    async _execute(isReadonly, fn) {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return await this._self.#internal.execute(fn, this._self.#clientInfo);
    }
    async sendCommand(isReadonly, args, options) {
      return this._execute(isReadonly, (client) => client.sendCommand(args, options));
    }
    async _executePipeline(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executePipeline(commands));
    }
    async _executeMulti(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executeMulti(commands));
    }
    MULTI() {
      return new this.Multi(this);
    }
    multi = this.MULTI;
    WATCH(key) {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return this._execute(false, (client) => client.watch(key));
    }
    watch = this.WATCH;
    UNWATCH() {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return this._execute(false, (client) => client.unwatch());
    }
    unwatch = this.UNWATCH;
    release() {
      if (this._self.#clientInfo === undefined) {
        throw new Error("RedisSentinelClient lease already released");
      }
      const result = this._self.#internal.releaseClientLease(this._self.#clientInfo);
      this._self.#clientInfo = undefined;
      return result;
    }
  }
  exports.RedisSentinelClient = RedisSentinelClient;

  class RedisSentinel extends node_events_1.EventEmitter {
    _self;
    #internal;
    #options;
    get isOpen() {
      return this._self.#internal.isOpen;
    }
    get isReady() {
      return this._self.#internal.isReady;
    }
    get commandOptions() {
      return this._self.#commandOptions;
    }
    #commandOptions;
    #trace = () => {};
    #reservedClientInfo;
    #masterClientCount = 0;
    #masterClientInfo;
    get clientSideCache() {
      return this._self.#internal.clientSideCache;
    }
    constructor(options) {
      super();
      this._self = this;
      this.#options = options;
      if (options.commandOptions) {
        this.#commandOptions = options.commandOptions;
      }
      this.#internal = new RedisSentinelInternal(options);
      this.#internal.on("error", (err) => this.emit("error", err));
      this.#internal.on("topology-change", (event) => {
        if (!this.emit("topology-change", event)) {
          this._self.#trace(`RedisSentinel: re-emit for topology-change for ${event.type} event returned false`);
        }
      });
    }
    static factory(config) {
      const Sentinel = (0, commander_1.attachConfig)({
        BaseClass: RedisSentinel,
        commands: commands_1.default,
        createCommand: utils_1.createCommand,
        createModuleCommand: utils_1.createModuleCommand,
        createFunctionCommand: utils_1.createFunctionCommand,
        createScriptCommand: utils_1.createScriptCommand,
        config
      });
      Sentinel.prototype.Multi = multi_commands_1.default.extend(config);
      return (options) => {
        return Object.create(new Sentinel(options));
      };
    }
    static create(options) {
      return RedisSentinel.factory(options)(options);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._self.#commandOptions = {
        ...this._self.#commandOptions || {},
        [key]: value
      };
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    async connect() {
      await this._self.#internal.connect();
      if (this._self.#options.reserveClient) {
        this._self.#reservedClientInfo = await this._self.#internal.getClientLease();
      }
      return this;
    }
    async _execute(isReadonly, fn) {
      let clientInfo;
      if (!isReadonly || !this._self.#internal.useReplicas) {
        if (this._self.#reservedClientInfo) {
          clientInfo = this._self.#reservedClientInfo;
        } else {
          this._self.#masterClientInfo ??= await this._self.#internal.getClientLease();
          clientInfo = this._self.#masterClientInfo;
          this._self.#masterClientCount++;
        }
      }
      try {
        return await this._self.#internal.execute(fn, clientInfo);
      } finally {
        if (clientInfo !== undefined && clientInfo === this._self.#masterClientInfo && --this._self.#masterClientCount === 0) {
          const promise = this._self.#internal.releaseClientLease(clientInfo);
          this._self.#masterClientInfo = undefined;
          if (promise)
            await promise;
        }
      }
    }
    async use(fn) {
      const clientInfo = await this._self.#internal.getClientLease();
      try {
        return await fn(RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions));
      } finally {
        const promise = this._self.#internal.releaseClientLease(clientInfo);
        if (promise)
          await promise;
      }
    }
    async sendCommand(isReadonly, args, options) {
      return this._execute(isReadonly, (client) => client.sendCommand(args, options));
    }
    async _executePipeline(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executePipeline(commands));
    }
    async _executeMulti(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executeMulti(commands));
    }
    MULTI() {
      return new this.Multi(this);
    }
    multi = this.MULTI;
    async close() {
      return this._self.#internal.close();
    }
    destroy() {
      return this._self.#internal.destroy();
    }
    async SUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#internal.subscribe(channels, listener, bufferMode);
    }
    subscribe = this.SUBSCRIBE;
    async UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#internal.unsubscribe(channels, listener, bufferMode);
    }
    unsubscribe = this.UNSUBSCRIBE;
    async PSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#internal.pSubscribe(patterns, listener, bufferMode);
    }
    pSubscribe = this.PSUBSCRIBE;
    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#internal.pUnsubscribe(patterns, listener, bufferMode);
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    async acquire() {
      const clientInfo = await this._self.#internal.getClientLease();
      return RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions);
    }
    getSentinelNode() {
      return this._self.#internal.getSentinelNode();
    }
    getMasterNode() {
      return this._self.#internal.getMasterNode();
    }
    getReplicaNodes() {
      return this._self.#internal.getReplicaNodes();
    }
    setTracer(tracer) {
      if (tracer) {
        this._self.#trace = (msg) => {
          tracer.push(msg);
        };
      } else {
        this._self.#trace = () => {};
      }
      this._self.#internal.setTracer(tracer);
    }
  }
  exports.default = RedisSentinel;

  class RedisSentinelInternal extends node_events_1.EventEmitter {
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #isReady = false;
    get isReady() {
      return this.#isReady;
    }
    #name;
    #nodeClientOptions;
    #sentinelClientOptions;
    #scanInterval;
    #passthroughClientErrorEvents;
    #anotherReset = false;
    #configEpoch = 0;
    #sentinelRootNodes;
    #sentinelClient;
    #masterClients = [];
    #masterClientQueue;
    #masterPoolSize;
    #replicaClients = [];
    #replicaClientsIdx = 0;
    #replicaPoolSize;
    get useReplicas() {
      return this.#replicaPoolSize > 0;
    }
    #connectPromise;
    #maxCommandRediscovers;
    #pubSubProxy;
    #scanTimer;
    #destroy = false;
    #trace = () => {};
    #clientSideCache;
    get clientSideCache() {
      return this.#clientSideCache;
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    constructor(options) {
      super();
      this.#validateOptions(options);
      this.#name = options.name;
      this.#sentinelRootNodes = Array.from(options.sentinelRootNodes);
      this.#maxCommandRediscovers = options.maxCommandRediscovers ?? 16;
      this.#masterPoolSize = options.masterPoolSize ?? 1;
      this.#replicaPoolSize = options.replicaPoolSize ?? 0;
      this.#scanInterval = options.scanInterval ?? 0;
      this.#passthroughClientErrorEvents = options.passthroughClientErrorEvents ?? false;
      this.#nodeClientOptions = options.nodeClientOptions ? { ...options.nodeClientOptions } : {};
      if (this.#nodeClientOptions.url !== undefined) {
        throw new Error("invalid nodeClientOptions for Sentinel");
      }
      if (options.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.#clientSideCache = this.#nodeClientOptions.clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = this.#nodeClientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
        }
      }
      this.#sentinelClientOptions = options.sentinelClientOptions ? Object.assign({}, options.sentinelClientOptions) : {};
      this.#sentinelClientOptions.modules = module_1.default;
      if (this.#sentinelClientOptions.url !== undefined) {
        throw new Error("invalid sentinelClientOptions for Sentinel");
      }
      this.#masterClientQueue = new wait_queue_1.WaitQueue;
      for (let i = 0;i < this.#masterPoolSize; i++) {
        this.#masterClientQueue.push(i);
      }
      this.#pubSubProxy = new pub_sub_proxy_1.PubSubProxy(this.#nodeClientOptions, (err) => this.emit("error", err));
    }
    #createClient(node, clientOptions, reconnectStrategy) {
      return client_1.default.create({
        ...clientOptions,
        socket: {
          ...clientOptions.socket,
          host: node.host,
          port: node.port,
          reconnectStrategy
        }
      });
    }
    getClientLease() {
      const id = this.#masterClientQueue.shift();
      if (id !== undefined) {
        return { id };
      }
      return this.#masterClientQueue.wait().then((id2) => ({ id: id2 }));
    }
    releaseClientLease(clientInfo) {
      const client = this.#masterClients[clientInfo.id];
      if (client !== undefined) {
        const dirtyPromise = client.resetIfDirty();
        if (dirtyPromise) {
          return dirtyPromise.then(() => this.#masterClientQueue.push(clientInfo.id));
        }
      }
      this.#masterClientQueue.push(clientInfo.id);
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("already attempting to open");
      }
      try {
        this.#isOpen = true;
        this.#connectPromise = this.#connect();
        await this.#connectPromise;
        this.#isReady = true;
      } finally {
        this.#connectPromise = undefined;
        if (this.#scanInterval > 0) {
          this.#scanTimer = setInterval(this.#reset.bind(this), this.#scanInterval);
        }
      }
    }
    async#connect() {
      let count = 0;
      while (true) {
        this.#trace("starting connect loop");
        count += 1;
        if (this.#destroy) {
          this.#trace("in #connect and want to destroy");
          return;
        }
        try {
          this.#anotherReset = false;
          await this.transform(this.analyze(await this.observe()));
          if (this.#anotherReset) {
            this.#trace("#connect: anotherReset is true, so continuing");
            continue;
          }
          this.#trace("#connect: returning");
          return;
        } catch (e) {
          this.#trace(`#connect: exception ${e.message}`);
          if (!this.#isReady && count > this.#maxCommandRediscovers) {
            throw e;
          }
          if (e.message !== "no valid master node") {
            console.log(e);
          }
          await (0, promises_1.setTimeout)(1000);
        } finally {
          this.#trace("finished connect");
        }
      }
    }
    async execute(fn, clientInfo) {
      let iter = 0;
      while (true) {
        if (this.#connectPromise !== undefined) {
          await this.#connectPromise;
        }
        const client = this.#getClient(clientInfo);
        if (!client.isReady) {
          await this.#reset();
          continue;
        }
        const sockOpts = client.options?.socket;
        this.#trace("attemping to send command to " + sockOpts?.host + ":" + sockOpts?.port);
        try {
          return await fn(client);
        } catch (err) {
          if (++iter > this.#maxCommandRediscovers || !(err instanceof Error)) {
            throw err;
          }
          if (clientInfo !== undefined && (err.message.startsWith("READONLY") || !client.isReady)) {
            await this.#reset();
            continue;
          }
          throw err;
        }
      }
    }
    async#createPubSub(client) {
      await client.pSubscribe(["switch-master", "[-+]sdown", "+slave", "+sentinel", "[-+]odown", "+slave-reconf-done"], (message, channel) => {
        this.#handlePubSubControlChannel(channel, message);
      }, true);
      return client;
    }
    async#handlePubSubControlChannel(channel, message) {
      this.#trace("pubsub control channel message on " + channel);
      this.#reset();
    }
    #getClient(clientInfo) {
      if (clientInfo !== undefined) {
        return this.#masterClients[clientInfo.id];
      }
      if (this.#replicaClientsIdx >= this.#replicaClients.length) {
        this.#replicaClientsIdx = 0;
      }
      if (this.#replicaClients.length == 0) {
        throw new Error("no replicas available for read");
      }
      return this.#replicaClients[this.#replicaClientsIdx++];
    }
    async#reset() {
      if (this.#isReady == false || this.#destroy == true) {
        return;
      }
      if (this.#connectPromise !== undefined) {
        this.#anotherReset = true;
        return await this.#connectPromise;
      }
      try {
        this.#connectPromise = this.#connect();
        return await this.#connectPromise;
      } finally {
        this.#trace("finished reconfgure");
        this.#connectPromise = undefined;
      }
    }
    async close() {
      this.#destroy = true;
      if (this.#connectPromise != null) {
        await this.#connectPromise;
      }
      this.#isReady = false;
      this.#clientSideCache?.onPoolClose();
      if (this.#scanTimer) {
        clearInterval(this.#scanTimer);
        this.#scanTimer = undefined;
      }
      const promises = [];
      if (this.#sentinelClient !== undefined) {
        if (this.#sentinelClient.isOpen) {
          promises.push(this.#sentinelClient.close());
        }
        this.#sentinelClient = undefined;
      }
      for (const client of this.#masterClients) {
        if (client.isOpen) {
          promises.push(client.close());
        }
      }
      this.#masterClients = [];
      for (const client of this.#replicaClients) {
        if (client.isOpen) {
          promises.push(client.close());
        }
      }
      this.#replicaClients = [];
      await Promise.all(promises);
      this.#pubSubProxy.destroy();
      this.#isOpen = false;
    }
    async destroy() {
      this.#destroy = true;
      if (this.#connectPromise != null) {
        await this.#connectPromise;
      }
      this.#isReady = false;
      this.#clientSideCache?.onPoolClose();
      if (this.#scanTimer) {
        clearInterval(this.#scanTimer);
        this.#scanTimer = undefined;
      }
      if (this.#sentinelClient !== undefined) {
        if (this.#sentinelClient.isOpen) {
          this.#sentinelClient.destroy();
        }
        this.#sentinelClient = undefined;
      }
      for (const client of this.#masterClients) {
        if (client.isOpen) {
          client.destroy();
        }
      }
      this.#masterClients = [];
      for (const client of this.#replicaClients) {
        if (client.isOpen) {
          client.destroy();
        }
      }
      this.#replicaClients = [];
      this.#pubSubProxy.destroy();
      this.#isOpen = false;
      this.#destroy = false;
    }
    async subscribe(channels, listener, bufferMode) {
      return this.#pubSubProxy.subscribe(channels, listener, bufferMode);
    }
    async unsubscribe(channels, listener, bufferMode) {
      return this.#pubSubProxy.unsubscribe(channels, listener, bufferMode);
    }
    async pSubscribe(patterns, listener, bufferMode) {
      return this.#pubSubProxy.pSubscribe(patterns, listener, bufferMode);
    }
    async pUnsubscribe(patterns, listener, bufferMode) {
      return this.#pubSubProxy.pUnsubscribe(patterns, listener, bufferMode);
    }
    async observe() {
      for (const node of this.#sentinelRootNodes) {
        let client;
        try {
          this.#trace(`observe: trying to connect to sentinel: ${node.host}:${node.port}`);
          client = this.#createClient(node, this.#sentinelClientOptions, false);
          client.on("error", (err) => this.emit("error", `obseve client error: ${err}`));
          await client.connect();
          this.#trace(`observe: connected to sentinel`);
          const [sentinelData, masterData, replicaData] = await Promise.all([
            client.sentinel.sentinelSentinels(this.#name),
            client.sentinel.sentinelMaster(this.#name),
            client.sentinel.sentinelReplicas(this.#name)
          ]);
          this.#trace("observe: got all sentinel data");
          const ret = {
            sentinelConnected: node,
            sentinelData,
            masterData,
            replicaData,
            currentMaster: this.getMasterNode(),
            currentReplicas: this.getReplicaNodes(),
            currentSentinel: this.getSentinelNode(),
            replicaPoolSize: this.#replicaPoolSize,
            useReplicas: this.useReplicas
          };
          return ret;
        } catch (err) {
          this.#trace(`observe: error ${err}`);
          this.emit("error", err);
        } finally {
          if (client !== undefined && client.isOpen) {
            this.#trace(`observe: destroying sentinel client`);
            client.destroy();
          }
        }
      }
      this.#trace(`observe: none of the sentinels are available`);
      throw new Error("None of the sentinels are available");
    }
    analyze(observed) {
      let master = (0, utils_1.parseNode)(observed.masterData);
      if (master === undefined) {
        this.#trace(`analyze: no valid master node because ${observed.masterData.flags}`);
        throw new Error("no valid master node");
      }
      if (master.host === observed.currentMaster?.host && master.port === observed.currentMaster?.port) {
        this.#trace(`analyze: master node hasn't changed from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
        master = undefined;
      } else {
        this.#trace(`analyze: master node has changed to ${master.host}:${master.port} from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
      }
      let sentinel = observed.sentinelConnected;
      if (sentinel.host === observed.currentSentinel?.host && sentinel.port === observed.currentSentinel.port) {
        this.#trace(`analyze: sentinel node hasn't changed`);
        sentinel = undefined;
      } else {
        this.#trace(`analyze: sentinel node has changed to ${sentinel.host}:${sentinel.port}`);
      }
      const replicasToClose = [];
      const replicasToOpen = new Map;
      const desiredSet = new Set;
      const seen = new Set;
      if (observed.useReplicas) {
        const replicaList = (0, utils_1.createNodeList)(observed.replicaData);
        for (const node of replicaList) {
          desiredSet.add(JSON.stringify(node));
        }
        for (const [node, value] of observed.currentReplicas) {
          if (!desiredSet.has(JSON.stringify(node))) {
            replicasToClose.push(node);
            this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToClose`);
          } else {
            seen.add(JSON.stringify(node));
            if (value != observed.replicaPoolSize) {
              replicasToOpen.set(node, observed.replicaPoolSize - value);
              this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
            }
          }
        }
        for (const node of replicaList) {
          if (!seen.has(JSON.stringify(node))) {
            replicasToOpen.set(node, observed.replicaPoolSize);
            this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
          }
        }
      }
      const ret = {
        sentinelList: [observed.sentinelConnected].concat((0, utils_1.createNodeList)(observed.sentinelData)),
        epoch: Number(observed.masterData["config-epoch"]),
        sentinelToOpen: sentinel,
        masterToOpen: master,
        replicasToClose,
        replicasToOpen
      };
      return ret;
    }
    async transform(analyzed) {
      this.#trace("transform: enter");
      let promises = [];
      if (analyzed.sentinelToOpen) {
        this.#trace(`transform: opening a new sentinel`);
        if (this.#sentinelClient !== undefined && this.#sentinelClient.isOpen) {
          this.#trace(`transform: destroying old sentinel as open`);
          this.#sentinelClient.destroy();
          this.#sentinelClient = undefined;
        } else {
          this.#trace(`transform: not destroying old sentinel as not open`);
        }
        this.#trace(`transform: creating new sentinel to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
        const node = analyzed.sentinelToOpen;
        const client = this.#createClient(analyzed.sentinelToOpen, this.#sentinelClientOptions, false);
        client.on("error", (err) => {
          if (this.#passthroughClientErrorEvents) {
            this.emit("error", new Error(`Sentinel Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
          }
          const event2 = {
            type: "SENTINEL",
            node: (0, utils_1.clientSocketToNode)(client.options.socket),
            error: err
          };
          this.emit("client-error", event2);
          this.#reset();
        });
        this.#sentinelClient = client;
        this.#trace(`transform: adding sentinel client connect() to promise list`);
        const promise = this.#sentinelClient.connect().then((client2) => {
          return this.#createPubSub(client2);
        });
        promises.push(promise);
        this.#trace(`created sentinel client to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
        const event = {
          type: "SENTINEL_CHANGE",
          node: analyzed.sentinelToOpen
        };
        this.#trace(`transform: emiting topology-change event for sentinel_change`);
        if (!this.emit("topology-change", event)) {
          this.#trace(`transform: emit for topology-change for sentinel_change returned false`);
        }
      }
      if (analyzed.masterToOpen) {
        this.#trace(`transform: opening a new master`);
        const masterPromises = [];
        const masterWatches = [];
        this.#trace(`transform: destroying old masters if open`);
        for (const client of this.#masterClients) {
          masterWatches.push(client.isWatching || client.isDirtyWatch);
          if (client.isOpen) {
            client.destroy();
          }
        }
        this.#masterClients = [];
        this.#trace(`transform: creating all master clients and adding connect promises`);
        for (let i = 0;i < this.#masterPoolSize; i++) {
          const node = analyzed.masterToOpen;
          const client = this.#createClient(analyzed.masterToOpen, this.#nodeClientOptions);
          client.on("error", (err) => {
            if (this.#passthroughClientErrorEvents) {
              this.emit("error", new Error(`Master Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
            }
            const event2 = {
              type: "MASTER",
              node: (0, utils_1.clientSocketToNode)(client.options.socket),
              error: err
            };
            this.emit("client-error", event2);
          });
          if (masterWatches[i]) {
            client.setDirtyWatch("sentinel config changed in middle of a WATCH Transaction");
          }
          this.#masterClients.push(client);
          masterPromises.push(client.connect());
          this.#trace(`created master client to ${analyzed.masterToOpen.host}:${analyzed.masterToOpen.port}`);
        }
        this.#trace(`transform: adding promise to change #pubSubProxy node`);
        masterPromises.push(this.#pubSubProxy.changeNode(analyzed.masterToOpen));
        promises.push(...masterPromises);
        const event = {
          type: "MASTER_CHANGE",
          node: analyzed.masterToOpen
        };
        this.#trace(`transform: emiting topology-change event for master_change`);
        if (!this.emit("topology-change", event)) {
          this.#trace(`transform: emit for topology-change for master_change returned false`);
        }
        this.#configEpoch++;
      }
      const replicaCloseSet = new Set;
      for (const node of analyzed.replicasToClose) {
        const str = JSON.stringify(node);
        replicaCloseSet.add(str);
      }
      const newClientList = [];
      const removedSet = new Set;
      for (const replica of this.#replicaClients) {
        const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
        const str = JSON.stringify(node);
        if (replicaCloseSet.has(str) || !replica.isOpen) {
          if (replica.isOpen) {
            const sockOpts = replica.options?.socket;
            this.#trace(`destroying replica client to ${sockOpts?.host}:${sockOpts?.port}`);
            replica.destroy();
          }
          if (!removedSet.has(str)) {
            const event = {
              type: "REPLICA_REMOVE",
              node
            };
            this.emit("topology-change", event);
            removedSet.add(str);
          }
        } else {
          newClientList.push(replica);
        }
      }
      this.#replicaClients = newClientList;
      if (analyzed.replicasToOpen.size != 0) {
        for (const [node, size] of analyzed.replicasToOpen) {
          for (let i = 0;i < size; i++) {
            const client = this.#createClient(node, this.#nodeClientOptions);
            client.on("error", (err) => {
              if (this.#passthroughClientErrorEvents) {
                this.emit("error", new Error(`Replica Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
              }
              const event2 = {
                type: "REPLICA",
                node: (0, utils_1.clientSocketToNode)(client.options.socket),
                error: err
              };
              this.emit("client-error", event2);
            });
            this.#replicaClients.push(client);
            promises.push(client.connect());
            this.#trace(`created replica client to ${node.host}:${node.port}`);
          }
          const event = {
            type: "REPLICA_ADD",
            node
          };
          this.emit("topology-change", event);
        }
      }
      if (analyzed.sentinelList.length != this.#sentinelRootNodes.length) {
        this.#sentinelRootNodes = analyzed.sentinelList;
        const event = {
          type: "SENTINE_LIST_CHANGE",
          size: analyzed.sentinelList.length
        };
        this.emit("topology-change", event);
      }
      await Promise.all(promises);
      this.#trace("transform: exit");
    }
    getMasterNode() {
      if (this.#masterClients.length == 0) {
        return;
      }
      for (const master of this.#masterClients) {
        if (master.isReady) {
          return (0, utils_1.clientSocketToNode)(master.options.socket);
        }
      }
      return;
    }
    getSentinelNode() {
      if (this.#sentinelClient === undefined) {
        return;
      }
      return (0, utils_1.clientSocketToNode)(this.#sentinelClient.options.socket);
    }
    getReplicaNodes() {
      const ret = new Map;
      const initialMap = new Map;
      for (const replica of this.#replicaClients) {
        const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
        const hash = JSON.stringify(node);
        if (replica.isReady) {
          initialMap.set(hash, (initialMap.get(hash) ?? 0) + 1);
        } else {
          if (!initialMap.has(hash)) {
            initialMap.set(hash, 0);
          }
        }
      }
      for (const [key, value] of initialMap) {
        ret.set(JSON.parse(key), value);
      }
      return ret;
    }
    setTracer(tracer) {
      if (tracer) {
        this.#trace = (msg) => {
          tracer.push(msg);
        };
      } else {
        this.#trace = () => {};
      }
    }
  }

  class RedisSentinelFactory extends node_events_1.EventEmitter {
    options;
    #sentinelRootNodes;
    #replicaIdx = -1;
    constructor(options) {
      super();
      this.options = options;
      this.#sentinelRootNodes = options.sentinelRootNodes;
    }
    async updateSentinelRootNodes() {
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`updateSentinelRootNodes: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        try {
          const sentinelData = await client.sentinel.sentinelSentinels(this.options.name);
          this.#sentinelRootNodes = [node].concat((0, utils_1.createNodeList)(sentinelData));
          return;
        } finally {
          client.destroy();
        }
      }
      throw new Error("Couldn't connect to any sentinel node");
    }
    async getMasterNode() {
      let connected = false;
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`getMasterNode: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        connected = true;
        try {
          const masterData = await client.sentinel.sentinelMaster(this.options.name);
          let master = (0, utils_1.parseNode)(masterData);
          if (master === undefined) {
            continue;
          }
          return master;
        } finally {
          client.destroy();
        }
      }
      if (connected) {
        throw new Error("Master Node Not Enumerated");
      }
      throw new Error("couldn't connect to any sentinels");
    }
    async getMasterClient() {
      const master = await this.getMasterNode();
      return client_1.default.create({
        ...this.options.nodeClientOptions,
        socket: {
          ...this.options.nodeClientOptions?.socket,
          host: master.host,
          port: master.port
        }
      });
    }
    async getReplicaNodes() {
      let connected = false;
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`getReplicaNodes: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        connected = true;
        try {
          const replicaData = await client.sentinel.sentinelReplicas(this.options.name);
          const replicas = (0, utils_1.createNodeList)(replicaData);
          if (replicas.length == 0) {
            continue;
          }
          return replicas;
        } finally {
          client.destroy();
        }
      }
      if (connected) {
        throw new Error("No Replicas Nodes Enumerated");
      }
      throw new Error("couldn't connect to any sentinels");
    }
    async getReplicaClient() {
      const replicas = await this.getReplicaNodes();
      if (replicas.length == 0) {
        throw new Error("no available replicas");
      }
      this.#replicaIdx++;
      if (this.#replicaIdx >= replicas.length) {
        this.#replicaIdx = 0;
      }
      return client_1.default.create({
        ...this.options.nodeClientOptions,
        socket: {
          ...this.options.nodeClientOptions?.socket,
          host: replicas[this.#replicaIdx].host,
          port: replicas[this.#replicaIdx].port
        }
      });
    }
  }
  exports.RedisSentinelFactory = RedisSentinelFactory;
});

// node_modules/@redis/client/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicPooledClientSideCache = exports.BasicClientSideCache = exports.REDIS_FLUSH_MODES = exports.GEO_REPLY_WITH = exports.createSentinel = exports.createCluster = exports.createClientPool = exports.createClient = exports.defineScript = exports.VerbatimString = exports.RESP_TYPES = undefined;
  var decoder_1 = require_decoder();
  Object.defineProperty(exports, "RESP_TYPES", { enumerable: true, get: function() {
    return decoder_1.RESP_TYPES;
  } });
  var verbatim_string_1 = require_verbatim_string();
  Object.defineProperty(exports, "VerbatimString", { enumerable: true, get: function() {
    return verbatim_string_1.VerbatimString;
  } });
  var lua_script_1 = require_lua_script();
  Object.defineProperty(exports, "defineScript", { enumerable: true, get: function() {
    return lua_script_1.defineScript;
  } });
  __exportStar(require_errors(), exports);
  var client_1 = __importDefault(require_client3());
  exports.createClient = client_1.default.create;
  var pool_1 = require_pool();
  exports.createClientPool = pool_1.RedisClientPool.create;
  var cluster_1 = __importDefault(require_cluster());
  exports.createCluster = cluster_1.default.create;
  var sentinel_1 = __importDefault(require_sentinel());
  exports.createSentinel = sentinel_1.default.create;
  var GEOSEARCH_WITH_1 = require_GEOSEARCH_WITH();
  Object.defineProperty(exports, "GEO_REPLY_WITH", { enumerable: true, get: function() {
    return GEOSEARCH_WITH_1.GEO_REPLY_WITH;
  } });
  var FLUSHALL_1 = require_FLUSHALL();
  Object.defineProperty(exports, "REDIS_FLUSH_MODES", { enumerable: true, get: function() {
    return FLUSHALL_1.REDIS_FLUSH_MODES;
  } });
  var cache_1 = require_cache();
  Object.defineProperty(exports, "BasicClientSideCache", { enumerable: true, get: function() {
    return cache_1.BasicClientSideCache;
  } });
  Object.defineProperty(exports, "BasicPooledClientSideCache", { enumerable: true, get: function() {
    return cache_1.BasicPooledClientSideCache;
  } });
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/ADD.js
var require_ADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("BF.ADD");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/CARD.js
var require_CARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("BF.CARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/EXISTS.js
var require_EXISTS2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, item) {
      parser.push("BF.EXISTS");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformInfoV2Reply = undefined;
  var client_1 = require_dist3();
  function transformInfoV2Reply(reply, typeMapping) {
    const mapType = typeMapping ? typeMapping[client_1.RESP_TYPES.MAP] : undefined;
    switch (mapType) {
      case Array: {
        return reply;
      }
      case Map: {
        const ret = new Map;
        for (let i = 0;i < reply.length; i += 2) {
          ret.set(reply[i].toString(), reply[i + 1]);
        }
        return ret;
      }
      default: {
        const ret = Object.create(null);
        for (let i = 0;i < reply.length; i += 2) {
          ret[reply[i].toString()] = reply[i + 1];
        }
        return ret;
      }
    }
  }
  exports.transformInfoV2Reply = transformInfoV2Reply;
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/INFO.js
var require_INFO2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("BF.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, helpers_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/INSERT.js
var require_INSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items, options) {
      parser.push("BF.INSERT");
      parser.pushKey(key);
      if (options?.CAPACITY !== undefined) {
        parser.push("CAPACITY", options.CAPACITY.toString());
      }
      if (options?.ERROR !== undefined) {
        parser.push("ERROR", options.ERROR.toString());
      }
      if (options?.EXPANSION !== undefined) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
      if (options?.NOCREATE) {
        parser.push("NOCREATE");
      }
      if (options?.NONSCALING) {
        parser.push("NONSCALING");
      }
      parser.push("ITEMS");
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/LOADCHUNK.js
var require_LOADCHUNK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, iterator, chunk) {
      parser.push("BF.LOADCHUNK");
      parser.pushKey(key);
      parser.push(iterator.toString(), chunk);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/MADD.js
var require_MADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("BF.MADD");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/MEXISTS.js
var require_MEXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("BF.MEXISTS");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/RESERVE.js
var require_RESERVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, errorRate, capacity, options) {
      parser.push("BF.RESERVE");
      parser.pushKey(key);
      parser.push(errorRate.toString(), capacity.toString());
      if (options?.EXPANSION) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
      if (options?.NONSCALING) {
        parser.push("NONSCALING");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/SCANDUMP.js
var require_SCANDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, iterator) {
      parser.push("BF.SCANDUMP");
      parser.pushKey(key);
      parser.push(iterator.toString());
    },
    transformReply(reply) {
      return {
        iterator: reply[0],
        chunk: reply[1]
      };
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/index.js
var require_bloom = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD());
  var CARD_1 = __importDefault(require_CARD());
  var EXISTS_1 = __importDefault(require_EXISTS2());
  var INFO_1 = __importDefault(require_INFO2());
  var INSERT_1 = __importDefault(require_INSERT());
  var LOADCHUNK_1 = __importDefault(require_LOADCHUNK());
  var MADD_1 = __importDefault(require_MADD());
  var MEXISTS_1 = __importDefault(require_MEXISTS());
  var RESERVE_1 = __importDefault(require_RESERVE());
  var SCANDUMP_1 = __importDefault(require_SCANDUMP());
  __exportStar(require_helpers(), exports);
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    CARD: CARD_1.default,
    card: CARD_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INSERT: INSERT_1.default,
    insert: INSERT_1.default,
    LOADCHUNK: LOADCHUNK_1.default,
    loadChunk: LOADCHUNK_1.default,
    MADD: MADD_1.default,
    mAdd: MADD_1.default,
    MEXISTS: MEXISTS_1.default,
    mExists: MEXISTS_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default,
    SCANDUMP: SCANDUMP_1.default,
    scanDump: SCANDUMP_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INCRBY.js
var require_INCRBY2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("CMS.INCRBY");
      parser.pushKey(key);
      if (Array.isArray(items)) {
        for (const item of items) {
          pushIncrByItem(parser, item);
        }
      } else {
        pushIncrByItem(parser, items);
      }
    },
    transformReply: undefined
  };
  function pushIncrByItem(parser, { item, incrementBy }) {
    parser.push(item, incrementBy.toString());
  }
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INFO.js
var require_INFO3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CMS.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INITBYDIM.js
var require_INITBYDIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, width, depth) {
      parser.push("CMS.INITBYDIM");
      parser.pushKey(key);
      parser.push(width.toString(), depth.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INITBYPROB.js
var require_INITBYPROB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, error, probability) {
      parser.push("CMS.INITBYPROB");
      parser.pushKey(key);
      parser.push(error.toString(), probability.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/MERGE.js
var require_MERGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source) {
      parser.push("CMS.MERGE");
      parser.pushKey(destination);
      parser.push(source.length.toString());
      if (isPlainSketches(source)) {
        parser.pushVariadic(source);
      } else {
        for (let i = 0;i < source.length; i++) {
          parser.push(source[i].name);
        }
        parser.push("WEIGHTS");
        for (let i = 0;i < source.length; i++) {
          parser.push(source[i].weight.toString());
        }
      }
    },
    transformReply: undefined
  };
  function isPlainSketches(src) {
    return typeof src[0] === "string" || src[0] instanceof Buffer;
  }
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/QUERY.js
var require_QUERY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("CMS.QUERY");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/index.js
var require_count_min_sketch = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INCRBY_1 = __importDefault(require_INCRBY2());
  var INFO_1 = __importDefault(require_INFO3());
  var INITBYDIM_1 = __importDefault(require_INITBYDIM());
  var INITBYPROB_1 = __importDefault(require_INITBYPROB());
  var MERGE_1 = __importDefault(require_MERGE());
  var QUERY_1 = __importDefault(require_QUERY());
  exports.default = {
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INITBYDIM: INITBYDIM_1.default,
    initByDim: INITBYDIM_1.default,
    INITBYPROB: INITBYPROB_1.default,
    initByProb: INITBYPROB_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    QUERY: QUERY_1.default,
    query: QUERY_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/ADD.js
var require_ADD2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.ADD");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/ADDNX.js
var require_ADDNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.ADDNX");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/COUNT.js
var require_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, item) {
      parser.push("CF.COUNT");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/DEL.js
var require_DEL2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.DEL");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/EXISTS.js
var require_EXISTS3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.EXISTS");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/INFO.js
var require_INFO4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CF.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/INSERT.js
var require_INSERT2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseCfInsertArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseCfInsertArguments(parser, key, items, options) {
    parser.pushKey(key);
    if (options?.CAPACITY !== undefined) {
      parser.push("CAPACITY", options.CAPACITY.toString());
    }
    if (options?.NOCREATE) {
      parser.push("NOCREATE");
    }
    parser.push("ITEMS");
    parser.pushVariadic(items);
  }
  exports.parseCfInsertArguments = parseCfInsertArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("CF.INSERT");
      parseCfInsertArguments(...args);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/INSERTNX.js
var require_INSERTNX = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INSERT_1 = __importStar(require_INSERT2());
  exports.default = {
    IS_READ_ONLY: INSERT_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("CF.INSERTNX");
      (0, INSERT_1.parseCfInsertArguments)(...args);
    },
    transformReply: INSERT_1.default.transformReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/LOADCHUNK.js
var require_LOADCHUNK2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, iterator, chunk) {
      parser.push("CF.LOADCHUNK");
      parser.pushKey(key);
      parser.push(iterator.toString(), chunk);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/RESERVE.js
var require_RESERVE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, capacity, options) {
      parser.push("CF.RESERVE");
      parser.pushKey(key);
      parser.push(capacity.toString());
      if (options?.BUCKETSIZE !== undefined) {
        parser.push("BUCKETSIZE", options.BUCKETSIZE.toString());
      }
      if (options?.MAXITERATIONS !== undefined) {
        parser.push("MAXITERATIONS", options.MAXITERATIONS.toString());
      }
      if (options?.EXPANSION !== undefined) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/SCANDUMP.js
var require_SCANDUMP2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, iterator) {
      parser.push("CF.SCANDUMP");
      parser.pushKey(key);
      parser.push(iterator.toString());
    },
    transformReply(reply) {
      return {
        iterator: reply[0],
        chunk: reply[1]
      };
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/index.js
var require_cuckoo = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD2());
  var ADDNX_1 = __importDefault(require_ADDNX());
  var COUNT_1 = __importDefault(require_COUNT());
  var DEL_1 = __importDefault(require_DEL2());
  var EXISTS_1 = __importDefault(require_EXISTS3());
  var INFO_1 = __importDefault(require_INFO4());
  var INSERT_1 = __importDefault(require_INSERT2());
  var INSERTNX_1 = __importDefault(require_INSERTNX());
  var LOADCHUNK_1 = __importDefault(require_LOADCHUNK2());
  var RESERVE_1 = __importDefault(require_RESERVE2());
  var SCANDUMP_1 = __importDefault(require_SCANDUMP2());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    ADDNX: ADDNX_1.default,
    addNX: ADDNX_1.default,
    COUNT: COUNT_1.default,
    count: COUNT_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INSERT: INSERT_1.default,
    insert: INSERT_1.default,
    INSERTNX: INSERTNX_1.default,
    insertNX: INSERTNX_1.default,
    LOADCHUNK: LOADCHUNK_1.default,
    loadChunk: LOADCHUNK_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default,
    SCANDUMP: SCANDUMP_1.default,
    scanDump: SCANDUMP_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/ADD.js
var require_ADD3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, values) {
      parser.push("TDIGEST.ADD");
      parser.pushKey(key);
      for (const value of values) {
        parser.push(value.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/BYRANK.js
var require_BYRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformByRankArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function transformByRankArguments(parser, key, ranks) {
    parser.pushKey(key);
    for (const rank of ranks) {
      parser.push(rank.toString());
    }
  }
  exports.transformByRankArguments = transformByRankArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("TDIGEST.BYRANK");
      transformByRankArguments(...args);
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/BYREVRANK.js
var require_BYREVRANK = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BYRANK_1 = __importStar(require_BYRANK());
  exports.default = {
    IS_READ_ONLY: BYRANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("TDIGEST.BYREVRANK");
      (0, BYRANK_1.transformByRankArguments)(...args);
    },
    transformReply: BYRANK_1.default.transformReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/CDF.js
var require_CDF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, values) {
      parser.push("TDIGEST.CDF");
      parser.pushKey(key);
      for (const item of values) {
        parser.push(item.toString());
      }
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/CREATE.js
var require_CREATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TDIGEST.CREATE");
      parser.pushKey(key);
      if (options?.COMPRESSION !== undefined) {
        parser.push("COMPRESSION", options.COMPRESSION.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/INFO.js
var require_INFO5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/MAX.js
var require_MAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.MAX");
      parser.pushKey(key);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/MERGE.js
var require_MERGE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, options) {
      parser.push("TDIGEST.MERGE");
      parser.pushKey(destination);
      parser.pushKeysLength(source);
      if (options?.COMPRESSION !== undefined) {
        parser.push("COMPRESSION", options.COMPRESSION.toString());
      }
      if (options?.OVERRIDE) {
        parser.push("OVERRIDE");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/MIN.js
var require_MIN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.MIN");
      parser.pushKey(key);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/QUANTILE.js
var require_QUANTILE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, quantiles) {
      parser.push("TDIGEST.QUANTILE");
      parser.pushKey(key);
      for (const quantile of quantiles) {
        parser.push(quantile.toString());
      }
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/RANK.js
var require_RANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRankArguments = undefined;
  function transformRankArguments(parser, key, values) {
    parser.pushKey(key);
    for (const value of values) {
      parser.push(value.toString());
    }
  }
  exports.transformRankArguments = transformRankArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("TDIGEST.RANK");
      transformRankArguments(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/RESET.js
var require_RESET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("TDIGEST.RESET");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/REVRANK.js
var require_REVRANK = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var RANK_1 = __importStar(require_RANK());
  exports.default = {
    IS_READ_ONLY: RANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("TDIGEST.REVRANK");
      (0, RANK_1.transformRankArguments)(...args);
    },
    transformReply: RANK_1.default.transformReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/TRIMMED_MEAN.js
var require_TRIMMED_MEAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, lowCutPercentile, highCutPercentile) {
      parser.push("TDIGEST.TRIMMED_MEAN");
      parser.pushKey(key);
      parser.push(lowCutPercentile.toString(), highCutPercentile.toString());
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/index.js
var require_t_digest = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD3());
  var BYRANK_1 = __importDefault(require_BYRANK());
  var BYREVRANK_1 = __importDefault(require_BYREVRANK());
  var CDF_1 = __importDefault(require_CDF());
  var CREATE_1 = __importDefault(require_CREATE());
  var INFO_1 = __importDefault(require_INFO5());
  var MAX_1 = __importDefault(require_MAX());
  var MERGE_1 = __importDefault(require_MERGE2());
  var MIN_1 = __importDefault(require_MIN());
  var QUANTILE_1 = __importDefault(require_QUANTILE());
  var RANK_1 = __importDefault(require_RANK());
  var RESET_1 = __importDefault(require_RESET());
  var REVRANK_1 = __importDefault(require_REVRANK());
  var TRIMMED_MEAN_1 = __importDefault(require_TRIMMED_MEAN());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    BYRANK: BYRANK_1.default,
    byRank: BYRANK_1.default,
    BYREVRANK: BYREVRANK_1.default,
    byRevRank: BYREVRANK_1.default,
    CDF: CDF_1.default,
    cdf: CDF_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    MAX: MAX_1.default,
    max: MAX_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    MIN: MIN_1.default,
    min: MIN_1.default,
    QUANTILE: QUANTILE_1.default,
    quantile: QUANTILE_1.default,
    RANK: RANK_1.default,
    rank: RANK_1.default,
    RESET: RESET_1.default,
    reset: RESET_1.default,
    REVRANK: REVRANK_1.default,
    revRank: REVRANK_1.default,
    TRIMMED_MEAN: TRIMMED_MEAN_1.default,
    trimmedMean: TRIMMED_MEAN_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/ADD.js
var require_ADD4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.ADD");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/COUNT.js
var require_COUNT2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("TOPK.COUNT");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/INCRBY.js
var require_INCRBY3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function pushIncrByItem(parser, { item, incrementBy }) {
    parser.push(item, incrementBy.toString());
  }
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.INCRBY");
      parser.pushKey(key);
      if (Array.isArray(items)) {
        for (const item of items) {
          pushIncrByItem(parser, item);
        }
      } else {
        pushIncrByItem(parser, items);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/INFO.js
var require_INFO6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        reply[7] = generic_transformers_1.transformDoubleReply[2](reply[7], preserve, typeMapping);
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/LIST_WITHCOUNT.js
var require_LIST_WITHCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.LIST");
      parser.pushKey(key);
      parser.push("WITHCOUNT");
    },
    transformReply(rawReply) {
      const reply = [];
      for (let i = 0;i < rawReply.length; i++) {
        reply.push({
          item: rawReply[i],
          count: rawReply[++i]
        });
      }
      return reply;
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/LIST.js
var require_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.LIST");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/QUERY.js
var require_QUERY2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.QUERY");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/RESERVE.js
var require_RESERVE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, topK, options) {
      parser.push("TOPK.RESERVE");
      parser.pushKey(key);
      parser.push(topK.toString());
      if (options) {
        parser.push(options.width.toString(), options.depth.toString(), options.decay.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/index.js
var require_top_k = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD4());
  var COUNT_1 = __importDefault(require_COUNT2());
  var INCRBY_1 = __importDefault(require_INCRBY3());
  var INFO_1 = __importDefault(require_INFO6());
  var LIST_WITHCOUNT_1 = __importDefault(require_LIST_WITHCOUNT());
  var LIST_1 = __importDefault(require_LIST());
  var QUERY_1 = __importDefault(require_QUERY2());
  var RESERVE_1 = __importDefault(require_RESERVE3());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    COUNT: COUNT_1.default,
    count: COUNT_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    LIST_WITHCOUNT: LIST_WITHCOUNT_1.default,
    listWithCount: LIST_WITHCOUNT_1.default,
    LIST: LIST_1.default,
    list: LIST_1.default,
    QUERY: QUERY_1.default,
    query: QUERY_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/index.js
var require_commands3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = __importDefault(require_bloom());
  var count_min_sketch_1 = __importDefault(require_count_min_sketch());
  var cuckoo_1 = __importDefault(require_cuckoo());
  var t_digest_1 = __importDefault(require_t_digest());
  var top_k_1 = __importDefault(require_top_k());
  exports.default = {
    bf: bloom_1.default,
    cms: count_min_sketch_1.default,
    cf: cuckoo_1.default,
    tDigest: t_digest_1.default,
    topK: top_k_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands3();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
});

// node_modules/@redis/json/dist/lib/commands/helpers.js
var require_helpers2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRedisJsonReply = exports.transformRedisJsonArgument = exports.transformRedisJsonNullReply = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function transformRedisJsonNullReply(json) {
    return (0, generic_transformers_1.isNullReply)(json) ? json : transformRedisJsonReply(json);
  }
  exports.transformRedisJsonNullReply = transformRedisJsonNullReply;
  function transformRedisJsonArgument(json) {
    return JSON.stringify(json);
  }
  exports.transformRedisJsonArgument = transformRedisJsonArgument;
  function transformRedisJsonReply(json) {
    const res = JSON.parse(json.toString());
    return res;
  }
  exports.transformRedisJsonReply = transformRedisJsonReply;
});

// node_modules/@redis/json/dist/lib/commands/ARRAPPEND.js
var require_ARRAPPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path2, json, ...jsons) {
      parser.push("JSON.ARRAPPEND");
      parser.pushKey(key);
      parser.push(path2, (0, helpers_1.transformRedisJsonArgument)(json));
      for (let i = 0;i < jsons.length; i++) {
        parser.push((0, helpers_1.transformRedisJsonArgument)(jsons[i]));
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRINDEX.js
var require_ARRINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, path2, json, options) {
      parser.push("JSON.ARRINDEX");
      parser.pushKey(key);
      parser.push(path2, (0, helpers_1.transformRedisJsonArgument)(json));
      if (options?.range) {
        parser.push(options.range.start.toString());
        if (options.range.stop !== undefined) {
          parser.push(options.range.stop.toString());
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRINSERT.js
var require_ARRINSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path2, index, json, ...jsons) {
      parser.push("JSON.ARRINSERT");
      parser.pushKey(key);
      parser.push(path2, index.toString(), (0, helpers_1.transformRedisJsonArgument)(json));
      for (let i = 0;i < jsons.length; i++) {
        parser.push((0, helpers_1.transformRedisJsonArgument)(jsons[i]));
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRLEN.js
var require_ARRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.ARRLEN");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRPOP.js
var require_ARRPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.ARRPOP");
      parser.pushKey(key);
      if (options) {
        parser.push(options.path);
        if (options.index !== undefined) {
          parser.push(options.index.toString());
        }
      }
    },
    transformReply(reply) {
      return (0, generic_transformers_1.isArrayReply)(reply) ? reply.map((item) => (0, helpers_1.transformRedisJsonNullReply)(item)) : (0, helpers_1.transformRedisJsonNullReply)(reply);
    }
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRTRIM.js
var require_ARRTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path2, start, stop) {
      parser.push("JSON.ARRTRIM");
      parser.pushKey(key);
      parser.push(path2, start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/CLEAR.js
var require_CLEAR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.CLEAR");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/DEBUG_MEMORY.js
var require_DEBUG_MEMORY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.DEBUG", "MEMORY");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/DEL.js
var require_DEL3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.DEL");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/FORGET.js
var require_FORGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.FORGET");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/GET.js
var require_GET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.GET");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.pushVariadic(options.path);
      }
    },
    transformReply: helpers_1.transformRedisJsonNullReply
  };
});

// node_modules/@redis/json/dist/lib/commands/MERGE.js
var require_MERGE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path2, value) {
      parser.push("JSON.MERGE");
      parser.pushKey(key);
      parser.push(path2, (0, helpers_1.transformRedisJsonArgument)(value));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/MGET.js
var require_MGET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, path2) {
      parser.push("JSON.MGET");
      parser.pushKeys(keys);
      parser.push(path2);
    },
    transformReply(reply) {
      return reply.map((json) => (0, helpers_1.transformRedisJsonNullReply)(json));
    }
  };
});

// node_modules/@redis/json/dist/lib/commands/MSET.js
var require_MSET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, items) {
      parser.push("JSON.MSET");
      for (let i = 0;i < items.length; i++) {
        parser.pushKey(items[i].key);
        parser.push(items[i].path, (0, helpers_1.transformRedisJsonArgument)(items[i].value));
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/NUMINCRBY.js
var require_NUMINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path2, by) {
      parser.push("JSON.NUMINCRBY");
      parser.pushKey(key);
      parser.push(path2, by.toString());
    },
    transformReply: {
      2: (reply) => {
        return JSON.parse(reply.toString());
      },
      3: undefined
    }
  };
});

// node_modules/@redis/json/dist/lib/commands/NUMMULTBY.js
var require_NUMMULTBY = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var NUMINCRBY_1 = __importDefault(require_NUMINCRBY());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path2, by) {
      parser.push("JSON.NUMMULTBY");
      parser.pushKey(key);
      parser.push(path2, by.toString());
    },
    transformReply: NUMINCRBY_1.default.transformReply
  };
});

// node_modules/@redis/json/dist/lib/commands/OBJKEYS.js
var require_OBJKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.OBJKEYS");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/OBJLEN.js
var require_OBJLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.OBJLEN");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/SET.js
var require_SET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path2, json, options) {
      parser.push("JSON.SET");
      parser.pushKey(key);
      parser.push(path2, (0, helpers_1.transformRedisJsonArgument)(json));
      if (options?.condition) {
        parser.push(options?.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/STRAPPEND.js
var require_STRAPPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, append, options) {
      parser.push("JSON.STRAPPEND");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
      parser.push((0, helpers_1.transformRedisJsonArgument)(append));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/STRLEN.js
var require_STRLEN2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.STRLEN");
      parser.pushKey(key);
      if (options?.path) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/TOGGLE.js
var require_TOGGLE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path2) {
      parser.push("JSON.TOGGLE");
      parser.pushKey(key);
      parser.push(path2);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/TYPE.js
var require_TYPE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.TYPE");
      parser.pushKey(key);
      if (options?.path) {
        parser.push(options.path);
      }
    },
    transformReply: {
      2: undefined,
      3: (reply) => {
        return reply[0];
      }
    }
  };
});

// node_modules/@redis/json/dist/lib/commands/index.js
var require_commands4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ARRAPPEND_1 = __importDefault(require_ARRAPPEND());
  var ARRINDEX_1 = __importDefault(require_ARRINDEX());
  var ARRINSERT_1 = __importDefault(require_ARRINSERT());
  var ARRLEN_1 = __importDefault(require_ARRLEN());
  var ARRPOP_1 = __importDefault(require_ARRPOP());
  var ARRTRIM_1 = __importDefault(require_ARRTRIM());
  var CLEAR_1 = __importDefault(require_CLEAR());
  var DEBUG_MEMORY_1 = __importDefault(require_DEBUG_MEMORY());
  var DEL_1 = __importDefault(require_DEL3());
  var FORGET_1 = __importDefault(require_FORGET());
  var GET_1 = __importDefault(require_GET2());
  var MERGE_1 = __importDefault(require_MERGE3());
  var MGET_1 = __importDefault(require_MGET2());
  var MSET_1 = __importDefault(require_MSET2());
  var NUMINCRBY_1 = __importDefault(require_NUMINCRBY());
  var NUMMULTBY_1 = __importDefault(require_NUMMULTBY());
  var OBJKEYS_1 = __importDefault(require_OBJKEYS());
  var OBJLEN_1 = __importDefault(require_OBJLEN());
  var SET_1 = __importDefault(require_SET2());
  var STRAPPEND_1 = __importDefault(require_STRAPPEND());
  var STRLEN_1 = __importDefault(require_STRLEN2());
  var TOGGLE_1 = __importDefault(require_TOGGLE());
  var TYPE_1 = __importDefault(require_TYPE2());
  __exportStar(require_helpers2(), exports);
  exports.default = {
    ARRAPPEND: ARRAPPEND_1.default,
    arrAppend: ARRAPPEND_1.default,
    ARRINDEX: ARRINDEX_1.default,
    arrIndex: ARRINDEX_1.default,
    ARRINSERT: ARRINSERT_1.default,
    arrInsert: ARRINSERT_1.default,
    ARRLEN: ARRLEN_1.default,
    arrLen: ARRLEN_1.default,
    ARRPOP: ARRPOP_1.default,
    arrPop: ARRPOP_1.default,
    ARRTRIM: ARRTRIM_1.default,
    arrTrim: ARRTRIM_1.default,
    CLEAR: CLEAR_1.default,
    clear: CLEAR_1.default,
    DEBUG_MEMORY: DEBUG_MEMORY_1.default,
    debugMemory: DEBUG_MEMORY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    FORGET: FORGET_1.default,
    forget: FORGET_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MSET: MSET_1.default,
    mSet: MSET_1.default,
    NUMINCRBY: NUMINCRBY_1.default,
    numIncrBy: NUMINCRBY_1.default,
    NUMMULTBY: NUMMULTBY_1.default,
    numMultBy: NUMMULTBY_1.default,
    OBJKEYS: OBJKEYS_1.default,
    objKeys: OBJKEYS_1.default,
    OBJLEN: OBJLEN_1.default,
    objLen: OBJLEN_1.default,
    SET: SET_1.default,
    set: SET_1.default,
    STRAPPEND: STRAPPEND_1.default,
    strAppend: STRAPPEND_1.default,
    STRLEN: STRLEN_1.default,
    strLen: STRLEN_1.default,
    TOGGLE: TOGGLE_1.default,
    toggle: TOGGLE_1.default,
    TYPE: TYPE_1.default,
    type: TYPE_1.default
  };
});

// node_modules/@redis/json/dist/lib/index.js
var require_lib5 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands4();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
});

// node_modules/@redis/search/dist/lib/commands/_LIST.js
var require__LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FT._LIST");
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/CREATE.js
var require_CREATE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.REDISEARCH_LANGUAGE = exports.parseSchema = exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.SCHEMA_FIELD_TYPE = {
    TEXT: "TEXT",
    NUMERIC: "NUMERIC",
    GEO: "GEO",
    TAG: "TAG",
    VECTOR: "VECTOR",
    GEOSHAPE: "GEOSHAPE"
  };
  exports.SCHEMA_TEXT_FIELD_PHONETIC = {
    DM_EN: "dm:en",
    DM_FR: "dm:fr",
    FM_PT: "dm:pt",
    DM_ES: "dm:es"
  };
  exports.SCHEMA_VECTOR_FIELD_ALGORITHM = {
    FLAT: "FLAT",
    HNSW: "HNSW"
  };
  exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = {
    SPHERICAL: "SPHERICAL",
    FLAT: "FLAT"
  };
  function parseCommonSchemaFieldOptions(parser, fieldOptions) {
    if (fieldOptions.SORTABLE) {
      parser.push("SORTABLE");
      if (fieldOptions.SORTABLE === "UNF") {
        parser.push("UNF");
      }
    }
    if (fieldOptions.NOINDEX) {
      parser.push("NOINDEX");
    }
  }
  function parseSchema(parser, schema) {
    for (const [field, fieldOptions] of Object.entries(schema)) {
      parser.push(field);
      if (typeof fieldOptions === "string") {
        parser.push(fieldOptions);
        continue;
      }
      if (fieldOptions.AS) {
        parser.push("AS", fieldOptions.AS);
      }
      parser.push(fieldOptions.type);
      if (fieldOptions.INDEXMISSING) {
        parser.push("INDEXMISSING");
      }
      switch (fieldOptions.type) {
        case exports.SCHEMA_FIELD_TYPE.TEXT:
          if (fieldOptions.NOSTEM) {
            parser.push("NOSTEM");
          }
          if (fieldOptions.WEIGHT) {
            parser.push("WEIGHT", fieldOptions.WEIGHT.toString());
          }
          if (fieldOptions.PHONETIC) {
            parser.push("PHONETIC", fieldOptions.PHONETIC);
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            parser.push("WITHSUFFIXTRIE");
          }
          if (fieldOptions.INDEXEMPTY) {
            parser.push("INDEXEMPTY");
          }
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.NUMERIC:
        case exports.SCHEMA_FIELD_TYPE.GEO:
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.TAG:
          if (fieldOptions.SEPARATOR) {
            parser.push("SEPARATOR", fieldOptions.SEPARATOR);
          }
          if (fieldOptions.CASESENSITIVE) {
            parser.push("CASESENSITIVE");
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            parser.push("WITHSUFFIXTRIE");
          }
          if (fieldOptions.INDEXEMPTY) {
            parser.push("INDEXEMPTY");
          }
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.VECTOR:
          parser.push(fieldOptions.ALGORITHM);
          const args = [];
          args.push("TYPE", fieldOptions.TYPE, "DIM", fieldOptions.DIM.toString(), "DISTANCE_METRIC", fieldOptions.DISTANCE_METRIC);
          if (fieldOptions.INITIAL_CAP) {
            args.push("INITIAL_CAP", fieldOptions.INITIAL_CAP.toString());
          }
          switch (fieldOptions.ALGORITHM) {
            case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.FLAT:
              if (fieldOptions.BLOCK_SIZE) {
                args.push("BLOCK_SIZE", fieldOptions.BLOCK_SIZE.toString());
              }
              break;
            case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.HNSW:
              if (fieldOptions.M) {
                args.push("M", fieldOptions.M.toString());
              }
              if (fieldOptions.EF_CONSTRUCTION) {
                args.push("EF_CONSTRUCTION", fieldOptions.EF_CONSTRUCTION.toString());
              }
              if (fieldOptions.EF_RUNTIME) {
                args.push("EF_RUNTIME", fieldOptions.EF_RUNTIME.toString());
              }
              break;
          }
          parser.pushVariadicWithLength(args);
          break;
        case exports.SCHEMA_FIELD_TYPE.GEOSHAPE:
          if (fieldOptions.COORD_SYSTEM !== undefined) {
            parser.push("COORD_SYSTEM", fieldOptions.COORD_SYSTEM);
          }
          break;
      }
    }
  }
  exports.parseSchema = parseSchema;
  exports.REDISEARCH_LANGUAGE = {
    ARABIC: "Arabic",
    BASQUE: "Basque",
    CATALANA: "Catalan",
    DANISH: "Danish",
    DUTCH: "Dutch",
    ENGLISH: "English",
    FINNISH: "Finnish",
    FRENCH: "French",
    GERMAN: "German",
    GREEK: "Greek",
    HUNGARIAN: "Hungarian",
    INDONESAIN: "Indonesian",
    IRISH: "Irish",
    ITALIAN: "Italian",
    LITHUANIAN: "Lithuanian",
    NEPALI: "Nepali",
    NORWEIGAN: "Norwegian",
    PORTUGUESE: "Portuguese",
    ROMANIAN: "Romanian",
    RUSSIAN: "Russian",
    SPANISH: "Spanish",
    SWEDISH: "Swedish",
    TAMIL: "Tamil",
    TURKISH: "Turkish",
    CHINESE: "Chinese"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, schema, options) {
      parser.push("FT.CREATE", index);
      if (options?.ON) {
        parser.push("ON", options.ON);
      }
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "PREFIX", options?.PREFIX);
      if (options?.FILTER) {
        parser.push("FILTER", options.FILTER);
      }
      if (options?.LANGUAGE) {
        parser.push("LANGUAGE", options.LANGUAGE);
      }
      if (options?.LANGUAGE_FIELD) {
        parser.push("LANGUAGE_FIELD", options.LANGUAGE_FIELD);
      }
      if (options?.SCORE) {
        parser.push("SCORE", options.SCORE.toString());
      }
      if (options?.SCORE_FIELD) {
        parser.push("SCORE_FIELD", options.SCORE_FIELD);
      }
      if (options?.MAXTEXTFIELDS) {
        parser.push("MAXTEXTFIELDS");
      }
      if (options?.TEMPORARY) {
        parser.push("TEMPORARY", options.TEMPORARY.toString());
      }
      if (options?.NOOFFSETS) {
        parser.push("NOOFFSETS");
      }
      if (options?.NOHL) {
        parser.push("NOHL");
      }
      if (options?.NOFIELDS) {
        parser.push("NOFIELDS");
      }
      if (options?.NOFREQS) {
        parser.push("NOFREQS");
      }
      if (options?.SKIPINITIALSCAN) {
        parser.push("SKIPINITIALSCAN");
      }
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "STOPWORDS", options?.STOPWORDS);
      parser.push("SCHEMA");
      parseSchema(parser, schema);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/ALTER.js
var require_ALTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CREATE_1 = require_CREATE2();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, schema) {
      parser.push("FT.ALTER", index, "SCHEMA", "ADD");
      (0, CREATE_1.parseSchema)(parser, schema);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/dialect/default.js
var require_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_DIALECT = undefined;
  exports.DEFAULT_DIALECT = "2";
});

// node_modules/@redis/search/dist/lib/commands/SEARCH.js
var require_SEARCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseSearchOptions = exports.parseParamsArgument = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var default_1 = require_default();
  function parseParamsArgument(parser, params) {
    if (params) {
      parser.push("PARAMS");
      const args = [];
      for (const key in params) {
        if (!Object.hasOwn(params, key))
          continue;
        const value = params[key];
        args.push(key, typeof value === "number" ? value.toString() : value);
      }
      parser.pushVariadicWithLength(args);
    }
  }
  exports.parseParamsArgument = parseParamsArgument;
  function parseSearchOptions(parser, options) {
    if (options?.VERBATIM) {
      parser.push("VERBATIM");
    }
    if (options?.NOSTOPWORDS) {
      parser.push("NOSTOPWORDS");
    }
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "INKEYS", options?.INKEYS);
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "INFIELDS", options?.INFIELDS);
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "RETURN", options?.RETURN);
    if (options?.SUMMARIZE) {
      parser.push("SUMMARIZE");
      if (typeof options.SUMMARIZE === "object") {
        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "FIELDS", options.SUMMARIZE.FIELDS);
        if (options.SUMMARIZE.FRAGS !== undefined) {
          parser.push("FRAGS", options.SUMMARIZE.FRAGS.toString());
        }
        if (options.SUMMARIZE.LEN !== undefined) {
          parser.push("LEN", options.SUMMARIZE.LEN.toString());
        }
        if (options.SUMMARIZE.SEPARATOR !== undefined) {
          parser.push("SEPARATOR", options.SUMMARIZE.SEPARATOR);
        }
      }
    }
    if (options?.HIGHLIGHT) {
      parser.push("HIGHLIGHT");
      if (typeof options.HIGHLIGHT === "object") {
        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "FIELDS", options.HIGHLIGHT.FIELDS);
        if (options.HIGHLIGHT.TAGS) {
          parser.push("TAGS", options.HIGHLIGHT.TAGS.open, options.HIGHLIGHT.TAGS.close);
        }
      }
    }
    if (options?.SLOP !== undefined) {
      parser.push("SLOP", options.SLOP.toString());
    }
    if (options?.TIMEOUT !== undefined) {
      parser.push("TIMEOUT", options.TIMEOUT.toString());
    }
    if (options?.INORDER) {
      parser.push("INORDER");
    }
    if (options?.LANGUAGE) {
      parser.push("LANGUAGE", options.LANGUAGE);
    }
    if (options?.EXPANDER) {
      parser.push("EXPANDER", options.EXPANDER);
    }
    if (options?.SCORER) {
      parser.push("SCORER", options.SCORER);
    }
    if (options?.SORTBY) {
      parser.push("SORTBY");
      if (typeof options.SORTBY === "string" || options.SORTBY instanceof Buffer) {
        parser.push(options.SORTBY);
      } else {
        parser.push(options.SORTBY.BY);
        if (options.SORTBY.DIRECTION) {
          parser.push(options.SORTBY.DIRECTION);
        }
      }
    }
    if (options?.LIMIT) {
      parser.push("LIMIT", options.LIMIT.from.toString(), options.LIMIT.size.toString());
    }
    parseParamsArgument(parser, options?.PARAMS);
    if (options?.DIALECT) {
      parser.push("DIALECT", options.DIALECT.toString());
    } else {
      parser.push("DIALECT", default_1.DEFAULT_DIALECT);
    }
  }
  exports.parseSearchOptions = parseSearchOptions;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.SEARCH", index, query);
      parseSearchOptions(parser, options);
    },
    transformReply: {
      2: (reply) => {
        const withoutDocuments = reply[0] + 1 == reply.length;
        const documents = [];
        let i = 1;
        while (i < reply.length) {
          documents.push({
            id: reply[i++],
            value: withoutDocuments ? Object.create(null) : documentValue(reply[i++])
          });
        }
        return {
          total: reply[0],
          documents
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
  function documentValue(tuples) {
    const message = Object.create(null);
    if (!tuples) {
      return message;
    }
    let i = 0;
    while (i < tuples.length) {
      const key = tuples[i++], value = tuples[i++];
      if (key === "$") {
        try {
          Object.assign(message, JSON.parse(value));
          continue;
        } catch {}
      }
      message[key] = value;
    }
    return message;
  }
});

// node_modules/@redis/search/dist/lib/commands/AGGREGATE.js
var require_AGGREGATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAggregateOptions = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.FT_AGGREGATE_STEPS = undefined;
  var SEARCH_1 = require_SEARCH();
  var generic_transformers_1 = require_generic_transformers();
  var default_1 = require_default();
  exports.FT_AGGREGATE_STEPS = {
    GROUPBY: "GROUPBY",
    SORTBY: "SORTBY",
    APPLY: "APPLY",
    LIMIT: "LIMIT",
    FILTER: "FILTER"
  };
  exports.FT_AGGREGATE_GROUP_BY_REDUCERS = {
    COUNT: "COUNT",
    COUNT_DISTINCT: "COUNT_DISTINCT",
    COUNT_DISTINCTISH: "COUNT_DISTINCTISH",
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    STDDEV: "STDDEV",
    QUANTILE: "QUANTILE",
    TOLIST: "TOLIST",
    FIRST_VALUE: "FIRST_VALUE",
    RANDOM_SAMPLE: "RANDOM_SAMPLE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, index, query, options) {
      parser.push("FT.AGGREGATE", index, query);
      return parseAggregateOptions(parser, options);
    },
    transformReply: {
      2: (rawReply, preserve, typeMapping) => {
        const results = [];
        for (let i = 1;i < rawReply.length; i++) {
          results.push((0, generic_transformers_1.transformTuplesReply)(rawReply[i], preserve, typeMapping));
        }
        return {
          total: Number(rawReply[0]),
          results
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
  function parseAggregateOptions(parser, options) {
    if (options?.VERBATIM) {
      parser.push("VERBATIM");
    }
    if (options?.ADDSCORES) {
      parser.push("ADDSCORES");
    }
    if (options?.LOAD) {
      const args = [];
      if (Array.isArray(options.LOAD)) {
        for (const load of options.LOAD) {
          pushLoadField(args, load);
        }
      } else {
        pushLoadField(args, options.LOAD);
      }
      parser.push("LOAD");
      parser.pushVariadicWithLength(args);
    }
    if (options?.TIMEOUT !== undefined) {
      parser.push("TIMEOUT", options.TIMEOUT.toString());
    }
    if (options?.STEPS) {
      for (const step of options.STEPS) {
        parser.push(step.type);
        switch (step.type) {
          case exports.FT_AGGREGATE_STEPS.GROUPBY:
            if (!step.properties) {
              parser.push("0");
            } else {
              parser.pushVariadicWithLength(step.properties);
            }
            if (Array.isArray(step.REDUCE)) {
              for (const reducer of step.REDUCE) {
                parseGroupByReducer(parser, reducer);
              }
            } else {
              parseGroupByReducer(parser, step.REDUCE);
            }
            break;
          case exports.FT_AGGREGATE_STEPS.SORTBY:
            const args = [];
            if (Array.isArray(step.BY)) {
              for (const by of step.BY) {
                pushSortByProperty(args, by);
              }
            } else {
              pushSortByProperty(args, step.BY);
            }
            if (step.MAX) {
              args.push("MAX", step.MAX.toString());
            }
            parser.pushVariadicWithLength(args);
            break;
          case exports.FT_AGGREGATE_STEPS.APPLY:
            parser.push(step.expression, "AS", step.AS);
            break;
          case exports.FT_AGGREGATE_STEPS.LIMIT:
            parser.push(step.from.toString(), step.size.toString());
            break;
          case exports.FT_AGGREGATE_STEPS.FILTER:
            parser.push(step.expression);
            break;
        }
      }
    }
    (0, SEARCH_1.parseParamsArgument)(parser, options?.PARAMS);
    if (options?.DIALECT) {
      parser.push("DIALECT", options.DIALECT.toString());
    } else {
      parser.push("DIALECT", default_1.DEFAULT_DIALECT);
    }
  }
  exports.parseAggregateOptions = parseAggregateOptions;
  function pushLoadField(args, toLoad) {
    if (typeof toLoad === "string" || toLoad instanceof Buffer) {
      args.push(toLoad);
    } else {
      args.push(toLoad.identifier);
      if (toLoad.AS) {
        args.push("AS", toLoad.AS);
      }
    }
  }
  function parseGroupByReducer(parser, reducer) {
    parser.push("REDUCE", reducer.type);
    switch (reducer.type) {
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT:
        parser.push("0");
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCT:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCTISH:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.SUM:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MIN:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MAX:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.AVG:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.STDDEV:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.TOLIST:
        parser.push("1", reducer.property);
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.QUANTILE:
        parser.push("2", reducer.property, reducer.quantile.toString());
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.FIRST_VALUE: {
        const args = [reducer.property];
        if (reducer.BY) {
          args.push("BY");
          if (typeof reducer.BY === "string" || reducer.BY instanceof Buffer) {
            args.push(reducer.BY);
          } else {
            args.push(reducer.BY.property);
            if (reducer.BY.direction) {
              args.push(reducer.BY.direction);
            }
          }
        }
        parser.pushVariadicWithLength(args);
        break;
      }
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.RANDOM_SAMPLE:
        parser.push("2", reducer.property, reducer.sampleSize.toString());
        break;
    }
    if (reducer.AS) {
      parser.push("AS", reducer.AS);
    }
  }
  function pushSortByProperty(args, sortBy) {
    if (typeof sortBy === "string" || sortBy instanceof Buffer) {
      args.push(sortBy);
    } else {
      args.push(sortBy.BY);
      if (sortBy.DIRECTION) {
        args.push(sortBy.DIRECTION);
      }
    }
  }
});

// node_modules/@redis/search/dist/lib/commands/AGGREGATE_WITHCURSOR.js
var require_AGGREGATE_WITHCURSOR = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_1 = __importDefault(require_AGGREGATE());
  exports.default = {
    IS_READ_ONLY: AGGREGATE_1.default.IS_READ_ONLY,
    parseCommand(parser, index, query, options) {
      AGGREGATE_1.default.parseCommand(parser, index, query, options);
      parser.push("WITHCURSOR");
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.MAXIDLE !== undefined) {
        parser.push("MAXIDLE", options.MAXIDLE.toString());
      }
    },
    transformReply: {
      2: (reply) => {
        return {
          ...AGGREGATE_1.default.transformReply[2](reply[0]),
          cursor: reply[1]
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/ALIASADD.js
var require_ALIASADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias, index) {
      parser.push("FT.ALIASADD", alias, index);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/ALIASDEL.js
var require_ALIASDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias) {
      parser.push("FT.ALIASDEL", alias);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/ALIASUPDATE.js
var require_ALIASUPDATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias, index) {
      parser.push("FT.ALIASUPDATE", alias, index);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/CONFIG_GET.js
var require_CONFIG_GET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, option) {
      parser.push("FT.CONFIG", "GET", option);
    },
    transformReply(reply) {
      const transformedReply = Object.create(null);
      for (const item of reply) {
        const [key, value] = item;
        transformedReply[key.toString()] = value;
      }
      return transformedReply;
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/CONFIG_SET.js
var require_CONFIG_SET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, property, value) {
      parser.push("FT.CONFIG", "SET", property, value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/CURSOR_DEL.js
var require_CURSOR_DEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, cursorId) {
      parser.push("FT.CURSOR", "DEL", index, cursorId.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/CURSOR_READ.js
var require_CURSOR_READ = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_WITHCURSOR_1 = __importDefault(require_AGGREGATE_WITHCURSOR());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, cursor, options) {
      parser.push("FT.CURSOR", "READ", index, cursor.toString());
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
    },
    transformReply: AGGREGATE_WITHCURSOR_1.default.transformReply,
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/DICTADD.js
var require_DICTADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary, term) {
      parser.push("FT.DICTADD", dictionary);
      parser.pushVariadic(term);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/DICTDEL.js
var require_DICTDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary, term) {
      parser.push("FT.DICTDEL", dictionary);
      parser.pushVariadic(term);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/DICTDUMP.js
var require_DICTDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary) {
      parser.push("FT.DICTDUMP", dictionary);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/DROPINDEX.js
var require_DROPINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, options) {
      parser.push("FT.DROPINDEX", index);
      if (options?.DD) {
        parser.push("DD");
      }
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/EXPLAIN.js
var require_EXPLAIN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = require_SEARCH();
  var default_1 = require_default();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.EXPLAIN", index, query);
      (0, SEARCH_1.parseParamsArgument)(parser, options?.PARAMS);
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/EXPLAINCLI.js
var require_EXPLAINCLI = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var default_1 = require_default();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.EXPLAINCLI", index, query);
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/INFO.js
var require_INFO7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index) {
      parser.push("FT.INFO", index);
    },
    transformReply: {
      2: transformV2Reply,
      3: undefined
    },
    unstableResp3: true
  };
  function transformV2Reply(reply, preserve, typeMapping) {
    const myTransformFunc = (0, generic_transformers_1.createTransformTuplesReplyFunc)(preserve, typeMapping);
    const ret = {};
    for (let i = 0;i < reply.length; i += 2) {
      const key = reply[i].toString();
      switch (key) {
        case "index_name":
        case "index_options":
        case "num_docs":
        case "max_doc_id":
        case "num_terms":
        case "num_records":
        case "total_inverted_index_blocks":
        case "hash_indexing_failures":
        case "indexing":
        case "number_of_uses":
        case "cleaning":
        case "stopwords_list":
          ret[key] = reply[i + 1];
          break;
        case "inverted_sz_mb":
        case "vector_index_sz_mb":
        case "offset_vectors_sz_mb":
        case "doc_table_size_mb":
        case "sortable_values_size_mb":
        case "key_table_size_mb":
        case "text_overhead_sz_mb":
        case "tag_overhead_sz_mb":
        case "total_index_memory_sz_mb":
        case "geoshapes_sz_mb":
        case "records_per_doc_avg":
        case "bytes_per_record_avg":
        case "offsets_per_term_avg":
        case "offset_bits_per_record_avg":
        case "total_indexing_time":
        case "percent_indexed":
          ret[key] = generic_transformers_1.transformDoubleReply[2](reply[i + 1], undefined, typeMapping);
          break;
        case "index_definition":
          ret[key] = myTransformFunc(reply[i + 1]);
          break;
        case "attributes":
          ret[key] = reply[i + 1].map((attribute) => myTransformFunc(attribute));
          break;
        case "gc_stats": {
          const innerRet = {};
          const array = reply[i + 1];
          for (let i2 = 0;i2 < array.length; i2 += 2) {
            const innerKey = array[i2].toString();
            switch (innerKey) {
              case "bytes_collected":
              case "total_ms_run":
              case "total_cycles":
              case "average_cycle_time_ms":
              case "last_run_time_ms":
              case "gc_numeric_trees_missed":
              case "gc_blocks_denied":
                innerRet[innerKey] = generic_transformers_1.transformDoubleReply[2](array[i2 + 1], undefined, typeMapping);
                break;
            }
          }
          ret[key] = innerRet;
          break;
        }
        case "cursor_stats": {
          const innerRet = {};
          const array = reply[i + 1];
          for (let i2 = 0;i2 < array.length; i2 += 2) {
            const innerKey = array[i2].toString();
            switch (innerKey) {
              case "global_idle":
              case "global_total":
              case "index_capacity":
              case "index_total":
                innerRet[innerKey] = array[i2 + 1];
                break;
            }
          }
          ret[key] = innerRet;
          break;
        }
      }
    }
    return ret;
  }
});

// node_modules/@redis/search/dist/lib/commands/PROFILE_SEARCH.js
var require_PROFILE_SEARCH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = __importStar(require_SEARCH());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.PROFILE", index, "SEARCH");
      if (options?.LIMITED) {
        parser.push("LIMITED");
      }
      parser.push("QUERY", query);
      (0, SEARCH_1.parseSearchOptions)(parser, options);
    },
    transformReply: {
      2: (reply) => {
        return {
          results: SEARCH_1.default.transformReply[2](reply[0]),
          profile: reply[1]
        };
      },
      3: (reply) => reply
    },
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/PROFILE_AGGREGATE.js
var require_PROFILE_AGGREGATE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_1 = __importStar(require_AGGREGATE());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.PROFILE", index, "AGGREGATE");
      if (options?.LIMITED) {
        parser.push("LIMITED");
      }
      parser.push("QUERY", query);
      (0, AGGREGATE_1.parseAggregateOptions)(parser, options);
    },
    transformReply: {
      2: (reply) => {
        return {
          results: AGGREGATE_1.default.transformReply[2](reply[0]),
          profile: reply[1]
        };
      },
      3: (reply) => reply
    },
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/SEARCH_NOCONTENT.js
var require_SEARCH_NOCONTENT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = __importDefault(require_SEARCH());
  exports.default = {
    NOT_KEYED_COMMAND: SEARCH_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: SEARCH_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SEARCH_1.default.parseCommand(...args);
      args[0].push("NOCONTENT");
    },
    transformReply: {
      2: (reply) => {
        return {
          total: reply[0],
          documents: reply.slice(1)
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/SPELLCHECK.js
var require_SPELLCHECK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var default_1 = require_default();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.SPELLCHECK", index, query);
      if (options?.DISTANCE) {
        parser.push("DISTANCE", options.DISTANCE.toString());
      }
      if (options?.TERMS) {
        if (Array.isArray(options.TERMS)) {
          for (const term of options.TERMS) {
            parseTerms(parser, term);
          }
        } else {
          parseTerms(parser, options.TERMS);
        }
      }
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: {
      2: (rawReply) => {
        return rawReply.map(([, term, suggestions]) => ({
          term,
          suggestions: suggestions.map(([score, suggestion]) => ({
            score: Number(score),
            suggestion
          }))
        }));
      },
      3: undefined
    },
    unstableResp3: true
  };
  function parseTerms(parser, { mode, dictionary }) {
    parser.push("TERMS", mode, dictionary);
  }
});

// node_modules/@redis/search/dist/lib/commands/SUGADD.js
var require_SUGADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, string, score, options) {
      parser.push("FT.SUGADD");
      parser.pushKey(key);
      parser.push(string, score.toString());
      if (options?.INCR) {
        parser.push("INCR");
      }
      if (options?.PAYLOAD) {
        parser.push("PAYLOAD", options.PAYLOAD);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGDEL.js
var require_SUGDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, string) {
      parser.push("FT.SUGDEL");
      parser.pushKey(key);
      parser.push(string);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGGET.js
var require_SUGGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, prefix, options) {
      parser.push("FT.SUGGET");
      parser.pushKey(key);
      parser.push(prefix);
      if (options?.FUZZY) {
        parser.push("FUZZY");
      }
      if (options?.MAX !== undefined) {
        parser.push("MAX", options.MAX.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGGET_WITHPAYLOADS.js
var require_SUGGET_WITHPAYLOADS = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHPAYLOADS");
    },
    transformReply(reply) {
      if ((0, generic_transformers_1.isNullReply)(reply))
        return null;
      const transformedReply = new Array(reply.length / 2);
      let replyIndex = 0, arrIndex = 0;
      while (replyIndex < reply.length) {
        transformedReply[arrIndex++] = {
          suggestion: reply[replyIndex++],
          payload: reply[replyIndex++]
        };
      }
      return transformedReply;
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGGET_WITHSCORES_WITHPAYLOADS.js
var require_SUGGET_WITHSCORES_WITHPAYLOADS = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHSCORES", "WITHPAYLOADS");
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 3);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping),
            payload: reply[replyIndex++]
          };
        }
        return transformedReply;
      },
      3: (reply) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 3);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: reply[replyIndex++],
            payload: reply[replyIndex++]
          };
        }
        return transformedReply;
      }
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGGET_WITHSCORES.js
var require_SUGGET_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHSCORES");
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 2);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping)
          };
        }
        return transformedReply;
      },
      3: (reply) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 2);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: reply[replyIndex++]
          };
        }
        return transformedReply;
      }
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGLEN.js
var require_SUGLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("FT.SUGLEN", key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/SYNDUMP.js
var require_SYNDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index) {
      parser.push("FT.SYNDUMP", index);
    },
    transformReply: {
      2: (reply) => {
        const result = {};
        let i = 0;
        while (i < reply.length) {
          const key = reply[i++].toString(), value = reply[i++];
          result[key] = value;
        }
        return result;
      },
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/SYNUPDATE.js
var require_SYNUPDATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, groupId, terms, options) {
      parser.push("FT.SYNUPDATE", index, groupId);
      if (options?.SKIPINITIALSCAN) {
        parser.push("SKIPINITIALSCAN");
      }
      parser.pushVariadic(terms);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/TAGVALS.js
var require_TAGVALS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, fieldName) {
      parser.push("FT.TAGVALS", index, fieldName);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/index.js
var require_commands5 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var _LIST_1 = __importDefault(require__LIST());
  var ALTER_1 = __importDefault(require_ALTER());
  var AGGREGATE_WITHCURSOR_1 = __importDefault(require_AGGREGATE_WITHCURSOR());
  var AGGREGATE_1 = __importDefault(require_AGGREGATE());
  var ALIASADD_1 = __importDefault(require_ALIASADD());
  var ALIASDEL_1 = __importDefault(require_ALIASDEL());
  var ALIASUPDATE_1 = __importDefault(require_ALIASUPDATE());
  var CONFIG_GET_1 = __importDefault(require_CONFIG_GET2());
  var CONFIG_SET_1 = __importDefault(require_CONFIG_SET2());
  var CREATE_1 = __importDefault(require_CREATE2());
  var CURSOR_DEL_1 = __importDefault(require_CURSOR_DEL());
  var CURSOR_READ_1 = __importDefault(require_CURSOR_READ());
  var DICTADD_1 = __importDefault(require_DICTADD());
  var DICTDEL_1 = __importDefault(require_DICTDEL());
  var DICTDUMP_1 = __importDefault(require_DICTDUMP());
  var DROPINDEX_1 = __importDefault(require_DROPINDEX());
  var EXPLAIN_1 = __importDefault(require_EXPLAIN());
  var EXPLAINCLI_1 = __importDefault(require_EXPLAINCLI());
  var INFO_1 = __importDefault(require_INFO7());
  var PROFILE_SEARCH_1 = __importDefault(require_PROFILE_SEARCH());
  var PROFILE_AGGREGATE_1 = __importDefault(require_PROFILE_AGGREGATE());
  var SEARCH_NOCONTENT_1 = __importDefault(require_SEARCH_NOCONTENT());
  var SEARCH_1 = __importDefault(require_SEARCH());
  var SPELLCHECK_1 = __importDefault(require_SPELLCHECK());
  var SUGADD_1 = __importDefault(require_SUGADD());
  var SUGDEL_1 = __importDefault(require_SUGDEL());
  var SUGGET_WITHPAYLOADS_1 = __importDefault(require_SUGGET_WITHPAYLOADS());
  var SUGGET_WITHSCORES_WITHPAYLOADS_1 = __importDefault(require_SUGGET_WITHSCORES_WITHPAYLOADS());
  var SUGGET_WITHSCORES_1 = __importDefault(require_SUGGET_WITHSCORES());
  var SUGGET_1 = __importDefault(require_SUGGET());
  var SUGLEN_1 = __importDefault(require_SUGLEN());
  var SYNDUMP_1 = __importDefault(require_SYNDUMP());
  var SYNUPDATE_1 = __importDefault(require_SYNUPDATE());
  var TAGVALS_1 = __importDefault(require_TAGVALS());
  exports.default = {
    _LIST: _LIST_1.default,
    _list: _LIST_1.default,
    ALTER: ALTER_1.default,
    alter: ALTER_1.default,
    AGGREGATE_WITHCURSOR: AGGREGATE_WITHCURSOR_1.default,
    aggregateWithCursor: AGGREGATE_WITHCURSOR_1.default,
    AGGREGATE: AGGREGATE_1.default,
    aggregate: AGGREGATE_1.default,
    ALIASADD: ALIASADD_1.default,
    aliasAdd: ALIASADD_1.default,
    ALIASDEL: ALIASDEL_1.default,
    aliasDel: ALIASDEL_1.default,
    ALIASUPDATE: ALIASUPDATE_1.default,
    aliasUpdate: ALIASUPDATE_1.default,
    CONFIG_GET: CONFIG_GET_1.default,
    configGet: CONFIG_GET_1.default,
    CONFIG_SET: CONFIG_SET_1.default,
    configSet: CONFIG_SET_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    CURSOR_DEL: CURSOR_DEL_1.default,
    cursorDel: CURSOR_DEL_1.default,
    CURSOR_READ: CURSOR_READ_1.default,
    cursorRead: CURSOR_READ_1.default,
    DICTADD: DICTADD_1.default,
    dictAdd: DICTADD_1.default,
    DICTDEL: DICTDEL_1.default,
    dictDel: DICTDEL_1.default,
    DICTDUMP: DICTDUMP_1.default,
    dictDump: DICTDUMP_1.default,
    DROPINDEX: DROPINDEX_1.default,
    dropIndex: DROPINDEX_1.default,
    EXPLAIN: EXPLAIN_1.default,
    explain: EXPLAIN_1.default,
    EXPLAINCLI: EXPLAINCLI_1.default,
    explainCli: EXPLAINCLI_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    PROFILESEARCH: PROFILE_SEARCH_1.default,
    profileSearch: PROFILE_SEARCH_1.default,
    PROFILEAGGREGATE: PROFILE_AGGREGATE_1.default,
    profileAggregate: PROFILE_AGGREGATE_1.default,
    SEARCH_NOCONTENT: SEARCH_NOCONTENT_1.default,
    searchNoContent: SEARCH_NOCONTENT_1.default,
    SEARCH: SEARCH_1.default,
    search: SEARCH_1.default,
    SPELLCHECK: SPELLCHECK_1.default,
    spellCheck: SPELLCHECK_1.default,
    SUGADD: SUGADD_1.default,
    sugAdd: SUGADD_1.default,
    SUGDEL: SUGDEL_1.default,
    sugDel: SUGDEL_1.default,
    SUGGET_WITHPAYLOADS: SUGGET_WITHPAYLOADS_1.default,
    sugGetWithPayloads: SUGGET_WITHPAYLOADS_1.default,
    SUGGET_WITHSCORES_WITHPAYLOADS: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
    sugGetWithScoresWithPayloads: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
    SUGGET_WITHSCORES: SUGGET_WITHSCORES_1.default,
    sugGetWithScores: SUGGET_WITHSCORES_1.default,
    SUGGET: SUGGET_1.default,
    sugGet: SUGGET_1.default,
    SUGLEN: SUGLEN_1.default,
    sugLen: SUGLEN_1.default,
    SYNDUMP: SYNDUMP_1.default,
    synDump: SYNDUMP_1.default,
    SYNUPDATE: SYNUPDATE_1.default,
    synUpdate: SYNUPDATE_1.default,
    TAGVALS: TAGVALS_1.default,
    tagVals: TAGVALS_1.default
  };
});

// node_modules/@redis/search/dist/lib/index.js
var require_lib6 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FT_AGGREGATE_STEPS = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = exports.REDISEARCH_LANGUAGE = exports.default = undefined;
  var commands_1 = require_commands5();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
  var CREATE_1 = require_CREATE2();
  Object.defineProperty(exports, "REDISEARCH_LANGUAGE", { enumerable: true, get: function() {
    return CREATE_1.REDISEARCH_LANGUAGE;
  } });
  Object.defineProperty(exports, "SCHEMA_FIELD_TYPE", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_FIELD_TYPE;
  } });
  Object.defineProperty(exports, "SCHEMA_TEXT_FIELD_PHONETIC", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_TEXT_FIELD_PHONETIC;
  } });
  Object.defineProperty(exports, "SCHEMA_VECTOR_FIELD_ALGORITHM", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_VECTOR_FIELD_ALGORITHM;
  } });
  var AGGREGATE_1 = require_AGGREGATE();
  Object.defineProperty(exports, "FT_AGGREGATE_GROUP_BY_REDUCERS", { enumerable: true, get: function() {
    return AGGREGATE_1.FT_AGGREGATE_GROUP_BY_REDUCERS;
  } });
  Object.defineProperty(exports, "FT_AGGREGATE_STEPS", { enumerable: true, get: function() {
    return AGGREGATE_1.FT_AGGREGATE_STEPS;
  } });
});

// node_modules/@redis/time-series/dist/lib/commands/helpers.js
var require_helpers3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRESP2LabelsWithSources = exports.transformRESP2Labels = exports.parseSelectedLabelsArguments = exports.resp3MapToValue = exports.resp2MapToValue = exports.transformSamplesReply = exports.transformSampleReply = exports.parseLabelsArgument = exports.transformTimestampArgument = exports.parseDuplicatePolicy = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.parseChunkSizeArgument = exports.parseEncodingArgument = exports.TIME_SERIES_ENCODING = exports.parseRetentionArgument = exports.parseIgnoreArgument = undefined;
  var client_1 = require_dist3();
  function parseIgnoreArgument(parser, ignore) {
    if (ignore !== undefined) {
      parser.push("IGNORE", ignore.maxTimeDiff.toString(), ignore.maxValDiff.toString());
    }
  }
  exports.parseIgnoreArgument = parseIgnoreArgument;
  function parseRetentionArgument(parser, retention) {
    if (retention !== undefined) {
      parser.push("RETENTION", retention.toString());
    }
  }
  exports.parseRetentionArgument = parseRetentionArgument;
  exports.TIME_SERIES_ENCODING = {
    COMPRESSED: "COMPRESSED",
    UNCOMPRESSED: "UNCOMPRESSED"
  };
  function parseEncodingArgument(parser, encoding) {
    if (encoding !== undefined) {
      parser.push("ENCODING", encoding);
    }
  }
  exports.parseEncodingArgument = parseEncodingArgument;
  function parseChunkSizeArgument(parser, chunkSize) {
    if (chunkSize !== undefined) {
      parser.push("CHUNK_SIZE", chunkSize.toString());
    }
  }
  exports.parseChunkSizeArgument = parseChunkSizeArgument;
  exports.TIME_SERIES_DUPLICATE_POLICIES = {
    BLOCK: "BLOCK",
    FIRST: "FIRST",
    LAST: "LAST",
    MIN: "MIN",
    MAX: "MAX",
    SUM: "SUM"
  };
  function parseDuplicatePolicy(parser, duplicatePolicy) {
    if (duplicatePolicy !== undefined) {
      parser.push("DUPLICATE_POLICY", duplicatePolicy);
    }
  }
  exports.parseDuplicatePolicy = parseDuplicatePolicy;
  function transformTimestampArgument(timestamp) {
    if (typeof timestamp === "string")
      return timestamp;
    return (typeof timestamp === "number" ? timestamp : timestamp.getTime()).toString();
  }
  exports.transformTimestampArgument = transformTimestampArgument;
  function parseLabelsArgument(parser, labels) {
    if (labels) {
      parser.push("LABELS");
      for (const [label, value] of Object.entries(labels)) {
        parser.push(label, value);
      }
    }
  }
  exports.parseLabelsArgument = parseLabelsArgument;
  exports.transformSampleReply = {
    2(reply) {
      const [timestamp, value] = reply;
      return {
        timestamp,
        value: Number(value)
      };
    },
    3(reply) {
      const [timestamp, value] = reply;
      return {
        timestamp,
        value
      };
    }
  };
  exports.transformSamplesReply = {
    2(reply) {
      return reply.map((sample) => exports.transformSampleReply[2](sample));
    },
    3(reply) {
      return reply.map((sample) => exports.transformSampleReply[3](sample));
    }
  };
  function resp2MapToValue(wrappedReply, parseFunc, typeMapping) {
    const reply = wrappedReply;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map: {
        const ret = new Map;
        for (const wrappedTuple of reply) {
          const tuple = wrappedTuple;
          const key = tuple[0];
          ret.set(key.toString(), parseFunc(tuple));
        }
        return ret;
      }
      case Array: {
        for (const wrappedTuple of reply) {
          const tuple = wrappedTuple;
          tuple[1] = parseFunc(tuple);
        }
        return reply;
      }
      default: {
        const ret = Object.create(null);
        for (const wrappedTuple of reply) {
          const tuple = wrappedTuple;
          const key = tuple[0];
          ret[key.toString()] = parseFunc(tuple);
        }
        return ret;
      }
    }
  }
  exports.resp2MapToValue = resp2MapToValue;
  function resp3MapToValue(wrappedReply, parseFunc) {
    const reply = wrappedReply;
    if (reply instanceof Array) {
      for (let i = 1;i < reply.length; i += 2) {
        reply[i] = parseFunc(reply[i]);
      }
    } else if (reply instanceof Map) {
      for (const [key, value] of reply.entries()) {
        reply.set(key, parseFunc(value));
      }
    } else {
      for (const [key, value] of Object.entries(reply)) {
        reply[key] = parseFunc(value);
      }
    }
    return reply;
  }
  exports.resp3MapToValue = resp3MapToValue;
  function parseSelectedLabelsArguments(parser, selectedLabels) {
    parser.push("SELECTED_LABELS");
    parser.pushVariadic(selectedLabels);
  }
  exports.parseSelectedLabelsArguments = parseSelectedLabelsArguments;
  function transformRESP2Labels(labels, typeMapping) {
    const unwrappedLabels = labels;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map:
        const map = new Map;
        for (const tuple of unwrappedLabels) {
          const [key, value] = tuple;
          const unwrappedKey = key;
          map.set(unwrappedKey.toString(), value);
        }
        return map;
      case Array:
        return unwrappedLabels.flat();
      case Object:
      default:
        const labelsObject = Object.create(null);
        for (const tuple of unwrappedLabels) {
          const [key, value] = tuple;
          const unwrappedKey = key;
          labelsObject[unwrappedKey.toString()] = value;
        }
        return labelsObject;
    }
  }
  exports.transformRESP2Labels = transformRESP2Labels;
  function transformRESP2LabelsWithSources(labels, typeMapping) {
    const unwrappedLabels = labels;
    const to = unwrappedLabels.length - 2;
    let transformedLabels;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map:
        const map = new Map;
        for (let i = 0;i < to; i++) {
          const [key, value] = unwrappedLabels[i];
          const unwrappedKey = key;
          map.set(unwrappedKey.toString(), value);
        }
        transformedLabels = map;
        break;
      case Array:
        transformedLabels = unwrappedLabels.slice(0, to).flat();
        break;
      case Object:
      default:
        const labelsObject = Object.create(null);
        for (let i = 0;i < to; i++) {
          const [key, value] = unwrappedLabels[i];
          const unwrappedKey = key;
          labelsObject[unwrappedKey.toString()] = value;
        }
        transformedLabels = labelsObject;
        break;
    }
    const sourcesTuple = unwrappedLabels[unwrappedLabels.length - 1];
    const unwrappedSourcesTuple = sourcesTuple;
    const transformedSources = transformRESP2Sources(unwrappedSourcesTuple[1]);
    return {
      labels: transformedLabels,
      sources: transformedSources
    };
  }
  exports.transformRESP2LabelsWithSources = transformRESP2LabelsWithSources;
  function transformRESP2Sources(sourcesRaw) {
    const unwrappedSources = sourcesRaw;
    if (typeof unwrappedSources === "string") {
      return unwrappedSources.split(",");
    }
    const indexOfComma = unwrappedSources.indexOf(",");
    if (indexOfComma === -1) {
      return [unwrappedSources];
    }
    const sourcesArray = [
      unwrappedSources.subarray(0, indexOfComma)
    ];
    let previousComma = indexOfComma + 1;
    while (true) {
      const indexOf = unwrappedSources.indexOf(",", previousComma);
      if (indexOf === -1) {
        sourcesArray.push(unwrappedSources.subarray(previousComma));
        break;
      }
      const source = unwrappedSources.subarray(previousComma, indexOf);
      sourcesArray.push(source);
      previousComma = indexOf + 1;
    }
    return sourcesArray;
  }
});

// node_modules/@redis/time-series/dist/lib/commands/ADD.js
var require_ADD5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers3();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, timestamp, value, options) {
      parser.push("TS.ADD");
      parser.pushKey(key);
      parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseEncodingArgument)(parser, options?.ENCODING);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      if (options?.ON_DUPLICATE) {
        parser.push("ON_DUPLICATE", options.ON_DUPLICATE);
      }
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/ALTER.js
var require_ALTER2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers3();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TS.ALTER");
      parser.pushKey(key);
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      (0, helpers_1.parseDuplicatePolicy)(parser, options?.DUPLICATE_POLICY);
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/CREATE.js
var require_CREATE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers3();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TS.CREATE");
      parser.pushKey(key);
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseEncodingArgument)(parser, options?.ENCODING);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      (0, helpers_1.parseDuplicatePolicy)(parser, options?.DUPLICATE_POLICY);
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/CREATERULE.js
var require_CREATERULE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TIME_SERIES_AGGREGATION_TYPE = undefined;
  exports.TIME_SERIES_AGGREGATION_TYPE = {
    AVG: "AVG",
    FIRST: "FIRST",
    LAST: "LAST",
    MIN: "MIN",
    MAX: "MAX",
    SUM: "SUM",
    RANGE: "RANGE",
    COUNT: "COUNT",
    STD_P: "STD.P",
    STD_S: "STD.S",
    VAR_P: "VAR.P",
    VAR_S: "VAR.S",
    TWA: "TWA"
  };
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, sourceKey, destinationKey, aggregationType, bucketDuration, alignTimestamp) {
      parser.push("TS.CREATERULE");
      parser.pushKeys([sourceKey, destinationKey]);
      parser.push("AGGREGATION", aggregationType, bucketDuration.toString());
      if (alignTimestamp !== undefined) {
        parser.push(alignTimestamp.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/INCRBY.js
var require_INCRBY4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseIncrByArguments = undefined;
  var helpers_1 = require_helpers3();
  function parseIncrByArguments(parser, key, value, options) {
    parser.pushKey(key);
    parser.push(value.toString());
    if (options?.TIMESTAMP !== undefined && options?.TIMESTAMP !== null) {
      parser.push("TIMESTAMP", (0, helpers_1.transformTimestampArgument)(options.TIMESTAMP));
    }
    (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
    if (options?.UNCOMPRESSED) {
      parser.push("UNCOMPRESSED");
    }
    (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
    (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
    (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
  }
  exports.parseIncrByArguments = parseIncrByArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.INCRBY");
      parseIncrByArguments(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/DECRBY.js
var require_DECRBY2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INCRBY_1 = __importStar(require_INCRBY4());
  exports.default = {
    IS_READ_ONLY: INCRBY_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.DECRBY");
      (0, INCRBY_1.parseIncrByArguments)(...args);
    },
    transformReply: INCRBY_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/DEL.js
var require_DEL4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers3();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, fromTimestamp, toTimestamp) {
      parser.push("TS.DEL");
      parser.pushKey(key);
      parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/DELETERULE.js
var require_DELETERULE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, sourceKey, destinationKey) {
      parser.push("TS.DELETERULE");
      parser.pushKeys([sourceKey, destinationKey]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/GET.js
var require_GET3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("TS.GET");
      parser.pushKey(key);
      if (options?.LATEST) {
        parser.push("LATEST");
      }
    },
    transformReply: {
      2(reply) {
        return reply.length === 0 ? null : {
          timestamp: reply[0],
          value: Number(reply[1])
        };
      },
      3(reply) {
        return reply.length === 0 ? null : {
          timestamp: reply[0],
          value: reply[1]
        };
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/INFO.js
var require_INFO8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TS.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        const ret = {};
        for (let i = 0;i < reply.length; i += 2) {
          const key = reply[i].toString();
          switch (key) {
            case "totalSamples":
            case "memoryUsage":
            case "firstTimestamp":
            case "lastTimestamp":
            case "retentionTime":
            case "chunkCount":
            case "chunkSize":
            case "chunkType":
            case "duplicatePolicy":
            case "sourceKey":
            case "ignoreMaxTimeDiff":
              ret[key] = reply[i + 1];
              break;
            case "labels":
              ret[key] = reply[i + 1].map(([name, value]) => ({
                name,
                value
              }));
              break;
            case "rules":
              ret[key] = reply[i + 1].map(([key2, timeBucket, aggregationType]) => ({
                key: key2,
                timeBucket,
                aggregationType
              }));
              break;
            case "ignoreMaxValDiff":
              ret[key] = generic_transformers_1.transformDoubleReply[2](reply[27], undefined, typeMapping);
              break;
          }
        }
        return ret;
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/time-series/dist/lib/commands/INFO_DEBUG.js
var require_INFO_DEBUG = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INFO_1 = __importDefault(require_INFO8());
  exports.default = {
    IS_READ_ONLY: INFO_1.default.IS_READ_ONLY,
    parseCommand(parser, key) {
      INFO_1.default.parseCommand(parser, key);
      parser.push("DEBUG");
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        const ret = INFO_1.default.transformReply[2](reply, _, typeMapping);
        for (let i = 0;i < reply.length; i += 2) {
          const key = reply[i].toString();
          switch (key) {
            case "keySelfName": {
              ret[key] = reply[i + 1];
              break;
            }
            case "Chunks": {
              ret["chunks"] = reply[i + 1].map((chunk) => ({
                startTimestamp: chunk[1],
                endTimestamp: chunk[3],
                samples: chunk[5],
                size: chunk[7],
                bytesPerSample: chunk[9]
              }));
              break;
            }
          }
        }
        return ret;
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MADD.js
var require_MADD2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers3();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, toAdd) {
      parser.push("TS.MADD");
      for (const { key, timestamp, value } of toAdd) {
        parser.pushKey(key);
        parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MGET.js
var require_MGET3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseFilterArgument = exports.parseLatestArgument = undefined;
  var helpers_1 = require_helpers3();
  function parseLatestArgument(parser, latest) {
    if (latest) {
      parser.push("LATEST");
    }
  }
  exports.parseLatestArgument = parseLatestArgument;
  function parseFilterArgument(parser, filter) {
    parser.push("FILTER");
    parser.pushVariadic(filter);
  }
  exports.parseFilterArgument = parseFilterArgument;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter, options) {
      parser.push("TS.MGET");
      parseLatestArgument(parser, options?.LATEST);
      parseFilterArgument(parser, filter);
    },
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([, , sample]) => {
          return {
            sample: helpers_1.transformSampleReply[2](sample)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([, sample]) => {
          return {
            sample: helpers_1.transformSampleReply[3](sample)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MGET_WITHLABELS.js
var require_MGET_WITHLABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMGetLabelsReply = undefined;
  var MGET_1 = require_MGET3();
  var helpers_1 = require_helpers3();
  function createTransformMGetLabelsReply() {
    return {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([, labels, sample]) => {
          return {
            labels: (0, helpers_1.transformRESP2Labels)(labels),
            sample: helpers_1.transformSampleReply[2](sample)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, sample]) => {
          return {
            labels,
            sample: helpers_1.transformSampleReply[3](sample)
          };
        });
      }
    };
  }
  exports.createTransformMGetLabelsReply = createTransformMGetLabelsReply;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, filter, options) {
      parser.push("TS.MGET");
      (0, MGET_1.parseLatestArgument)(parser, options?.LATEST);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter);
    },
    transformReply: createTransformMGetLabelsReply()
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MGET_SELECTED_LABELS.js
var require_MGET_SELECTED_LABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MGET_1 = require_MGET3();
  var helpers_1 = require_helpers3();
  var MGET_WITHLABELS_1 = require_MGET_WITHLABELS();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, filter, selectedLabels, options) {
      parser.push("TS.MGET");
      (0, MGET_1.parseLatestArgument)(parser, options?.LATEST);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter);
    },
    transformReply: (0, MGET_WITHLABELS_1.createTransformMGetLabelsReply)()
  };
});

// node_modules/@redis/time-series/dist/lib/commands/RANGE.js
var require_RANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRangeArguments = exports.parseRangeArguments = exports.TIME_SERIES_BUCKET_TIMESTAMP = undefined;
  var helpers_1 = require_helpers3();
  exports.TIME_SERIES_BUCKET_TIMESTAMP = {
    LOW: "-",
    MIDDLE: "~",
    END: "+"
  };
  function parseRangeArguments(parser, fromTimestamp, toTimestamp, options) {
    parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
    if (options?.LATEST) {
      parser.push("LATEST");
    }
    if (options?.FILTER_BY_TS) {
      parser.push("FILTER_BY_TS");
      for (const timestamp of options.FILTER_BY_TS) {
        parser.push((0, helpers_1.transformTimestampArgument)(timestamp));
      }
    }
    if (options?.FILTER_BY_VALUE) {
      parser.push("FILTER_BY_VALUE", options.FILTER_BY_VALUE.min.toString(), options.FILTER_BY_VALUE.max.toString());
    }
    if (options?.COUNT !== undefined) {
      parser.push("COUNT", options.COUNT.toString());
    }
    if (options?.AGGREGATION) {
      if (options?.ALIGN !== undefined) {
        parser.push("ALIGN", (0, helpers_1.transformTimestampArgument)(options.ALIGN));
      }
      parser.push("AGGREGATION", options.AGGREGATION.type, (0, helpers_1.transformTimestampArgument)(options.AGGREGATION.timeBucket));
      if (options.AGGREGATION.BUCKETTIMESTAMP) {
        parser.push("BUCKETTIMESTAMP", options.AGGREGATION.BUCKETTIMESTAMP);
      }
      if (options.AGGREGATION.EMPTY) {
        parser.push("EMPTY");
      }
    }
  }
  exports.parseRangeArguments = parseRangeArguments;
  function transformRangeArguments(parser, key, fromTimestamp, toTimestamp, options) {
    parser.pushKey(key);
    parseRangeArguments(parser, fromTimestamp, toTimestamp, options);
  }
  exports.transformRangeArguments = transformRangeArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.RANGE");
      transformRangeArguments(...args);
    },
    transformReply: {
      2(reply) {
        return helpers_1.transformSamplesReply[2](reply);
      },
      3(reply) {
        return helpers_1.transformSamplesReply[3](reply);
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_GROUPBY.js
var require_MRANGE_GROUPBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extractResp3MRangeSources = exports.createTransformMRangeGroupByArguments = exports.parseGroupByArguments = exports.TIME_SERIES_REDUCERS = undefined;
  var helpers_1 = require_helpers3();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  exports.TIME_SERIES_REDUCERS = {
    AVG: "AVG",
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    RANGE: "RANGE",
    COUNT: "COUNT",
    STD_P: "STD.P",
    STD_S: "STD.S",
    VAR_P: "VAR.P",
    VAR_S: "VAR.S"
  };
  function parseGroupByArguments(parser, groupBy) {
    parser.push("GROUPBY", groupBy.label, "REDUCE", groupBy.REDUCE);
  }
  exports.parseGroupByArguments = parseGroupByArguments;
  function createTransformMRangeGroupByArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, MGET_1.parseFilterArgument)(parser, filter);
      parseGroupByArguments(parser, groupBy);
    };
  }
  exports.createTransformMRangeGroupByArguments = createTransformMRangeGroupByArguments;
  function extractResp3MRangeSources(raw) {
    const unwrappedMetadata2 = raw;
    if (unwrappedMetadata2 instanceof Map) {
      return unwrappedMetadata2.get("sources");
    } else if (unwrappedMetadata2 instanceof Array) {
      return unwrappedMetadata2[1];
    } else {
      return unwrappedMetadata2.sources;
    }
  }
  exports.extractResp3MRangeSources = extractResp3MRangeSources;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeGroupByArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, _labels, samples]) => {
          return {
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata1, metadata2, samples]) => {
          return {
            sources: extractResp3MRangeSources(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_SELECTED_LABELS.js
var require_MRANGE_SELECTED_LABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeSelectedLabelsArguments = undefined;
  var helpers_1 = require_helpers3();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeSelectedLabelsArguments(command) {
    return (parser, fromTimestamp, toTimestamp, selectedLabels, filter, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter);
    };
  }
  exports.createTransformMRangeSelectedLabelsArguments = createTransformMRangeSelectedLabelsArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeSelectedLabelsArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
          return {
            labels: (0, helpers_1.transformRESP2Labels)(labels, typeMapping),
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_key, labels, samples]) => {
          return {
            labels,
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_SELECTED_LABELS_GROUPBY.js
var require_MRANGE_SELECTED_LABELS_GROUPBY = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMRangeSelectedLabelsGroupByTransformArguments = undefined;
  var helpers_1 = require_helpers3();
  var RANGE_1 = require_RANGE();
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  var MGET_1 = require_MGET3();
  var MRANGE_SELECTED_LABELS_1 = __importDefault(require_MRANGE_SELECTED_LABELS());
  function createMRangeSelectedLabelsGroupByTransformArguments(command) {
    return (parser, fromTimestamp, toTimestamp, selectedLabels, filter, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter);
      (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
    };
  }
  exports.createMRangeSelectedLabelsGroupByTransformArguments = createMRangeSelectedLabelsGroupByTransformArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createMRangeSelectedLabelsGroupByTransformArguments("TS.MRANGE"),
    transformReply: {
      2: MRANGE_SELECTED_LABELS_1.default.transformReply[2],
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
          return {
            labels,
            sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_WITHLABELS_GROUPBY.js
var require_MRANGE_WITHLABELS_GROUPBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMRangeWithLabelsGroupByTransformArguments = undefined;
  var helpers_1 = require_helpers3();
  var RANGE_1 = require_RANGE();
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  var MGET_1 = require_MGET3();
  function createMRangeWithLabelsGroupByTransformArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter);
      (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
    };
  }
  exports.createMRangeWithLabelsGroupByTransformArguments = createMRangeWithLabelsGroupByTransformArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createMRangeWithLabelsGroupByTransformArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
          const transformed = (0, helpers_1.transformRESP2LabelsWithSources)(labels);
          return {
            labels: transformed.labels,
            sources: transformed.sources,
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
          return {
            labels,
            sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_WITHLABELS.js
var require_MRANGE_WITHLABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeWithLabelsArguments = undefined;
  var helpers_1 = require_helpers3();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeWithLabelsArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter);
    };
  }
  exports.createTransformMRangeWithLabelsArguments = createTransformMRangeWithLabelsArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeWithLabelsArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
          const unwrappedLabels = labels;
          const labelsObject = Object.create(null);
          for (const tuple of unwrappedLabels) {
            const [key, value] = tuple;
            const unwrappedKey = key;
            labelsObject[unwrappedKey.toString()] = value;
          }
          return {
            labels: labelsObject,
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, samples]) => {
          return {
            labels,
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE.js
var require_MRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeArguments = undefined;
  var helpers_1 = require_helpers3();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, MGET_1.parseFilterArgument)(parser, filter);
    };
  }
  exports.createTransformMRangeArguments = createTransformMRangeArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, _labels, samples]) => {
          return helpers_1.transformSamplesReply[2](samples);
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata, samples]) => {
          return helpers_1.transformSamplesReply[3](samples);
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_GROUPBY.js
var require_MREVRANGE_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_GROUPBY_1 = __importStar(require_MRANGE_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_GROUPBY_1.createTransformMRangeGroupByArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_GROUPBY_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_SELECTED_LABELS_GROUPBY.js
var require_MREVRANGE_SELECTED_LABELS_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_SELECTED_LABELS_GROUPBY_1 = __importStar(require_MRANGE_SELECTED_LABELS_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_SELECTED_LABELS_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_SELECTED_LABELS_GROUPBY_1.createMRangeSelectedLabelsGroupByTransformArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_SELECTED_LABELS_GROUPBY_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_SELECTED_LABELS.js
var require_MREVRANGE_SELECTED_LABELS = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_SELECTED_LABELS_1 = __importStar(require_MRANGE_SELECTED_LABELS());
  exports.default = {
    IS_READ_ONLY: MRANGE_SELECTED_LABELS_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_SELECTED_LABELS_1.createTransformMRangeSelectedLabelsArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_SELECTED_LABELS_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_WITHLABELS_GROUPBY.js
var require_MREVRANGE_WITHLABELS_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_WITHLABELS_GROUPBY_1 = __importStar(require_MRANGE_WITHLABELS_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_WITHLABELS_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_WITHLABELS_GROUPBY_1.createMRangeWithLabelsGroupByTransformArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_WITHLABELS_GROUPBY_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_WITHLABELS.js
var require_MREVRANGE_WITHLABELS = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_WITHLABELS_1 = __importStar(require_MRANGE_WITHLABELS());
  exports.default = {
    NOT_KEYED_COMMAND: MRANGE_WITHLABELS_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: MRANGE_WITHLABELS_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_WITHLABELS_1.createTransformMRangeWithLabelsArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_WITHLABELS_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE.js
var require_MREVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_1 = __importStar(require_MRANGE());
  exports.default = {
    NOT_KEYED_COMMAND: MRANGE_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: MRANGE_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_1.createTransformMRangeArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/QUERYINDEX.js
var require_QUERYINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter) {
      parser.push("TS.QUERYINDEX");
      parser.pushVariadic(filter);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/REVRANGE.js
var require_REVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var RANGE_1 = __importStar(require_RANGE());
  exports.default = {
    IS_READ_ONLY: RANGE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.REVRANGE");
      (0, RANGE_1.transformRangeArguments)(...args);
    },
    transformReply: RANGE_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/index.js
var require_commands6 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD5());
  var ALTER_1 = __importDefault(require_ALTER2());
  var CREATE_1 = __importDefault(require_CREATE3());
  var CREATERULE_1 = __importDefault(require_CREATERULE());
  var DECRBY_1 = __importDefault(require_DECRBY2());
  var DEL_1 = __importDefault(require_DEL4());
  var DELETERULE_1 = __importDefault(require_DELETERULE());
  var GET_1 = __importDefault(require_GET3());
  var INCRBY_1 = __importDefault(require_INCRBY4());
  var INFO_DEBUG_1 = __importDefault(require_INFO_DEBUG());
  var INFO_1 = __importDefault(require_INFO8());
  var MADD_1 = __importDefault(require_MADD2());
  var MGET_SELECTED_LABELS_1 = __importDefault(require_MGET_SELECTED_LABELS());
  var MGET_WITHLABELS_1 = __importDefault(require_MGET_WITHLABELS());
  var MGET_1 = __importDefault(require_MGET3());
  var MRANGE_GROUPBY_1 = __importDefault(require_MRANGE_GROUPBY());
  var MRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(require_MRANGE_SELECTED_LABELS_GROUPBY());
  var MRANGE_SELECTED_LABELS_1 = __importDefault(require_MRANGE_SELECTED_LABELS());
  var MRANGE_WITHLABELS_GROUPBY_1 = __importDefault(require_MRANGE_WITHLABELS_GROUPBY());
  var MRANGE_WITHLABELS_1 = __importDefault(require_MRANGE_WITHLABELS());
  var MRANGE_1 = __importDefault(require_MRANGE());
  var MREVRANGE_GROUPBY_1 = __importDefault(require_MREVRANGE_GROUPBY());
  var MREVRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(require_MREVRANGE_SELECTED_LABELS_GROUPBY());
  var MREVRANGE_SELECTED_LABELS_1 = __importDefault(require_MREVRANGE_SELECTED_LABELS());
  var MREVRANGE_WITHLABELS_GROUPBY_1 = __importDefault(require_MREVRANGE_WITHLABELS_GROUPBY());
  var MREVRANGE_WITHLABELS_1 = __importDefault(require_MREVRANGE_WITHLABELS());
  var MREVRANGE_1 = __importDefault(require_MREVRANGE());
  var QUERYINDEX_1 = __importDefault(require_QUERYINDEX());
  var RANGE_1 = __importDefault(require_RANGE());
  var REVRANGE_1 = __importDefault(require_REVRANGE());
  __exportStar(require_helpers3(), exports);
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    ALTER: ALTER_1.default,
    alter: ALTER_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    CREATERULE: CREATERULE_1.default,
    createRule: CREATERULE_1.default,
    DECRBY: DECRBY_1.default,
    decrBy: DECRBY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    DELETERULE: DELETERULE_1.default,
    deleteRule: DELETERULE_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO_DEBUG: INFO_DEBUG_1.default,
    infoDebug: INFO_DEBUG_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    MADD: MADD_1.default,
    mAdd: MADD_1.default,
    MGET_SELECTED_LABELS: MGET_SELECTED_LABELS_1.default,
    mGetSelectedLabels: MGET_SELECTED_LABELS_1.default,
    MGET_WITHLABELS: MGET_WITHLABELS_1.default,
    mGetWithLabels: MGET_WITHLABELS_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MRANGE_GROUPBY: MRANGE_GROUPBY_1.default,
    mRangeGroupBy: MRANGE_GROUPBY_1.default,
    MRANGE_SELECTED_LABELS_GROUPBY: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
    mRangeSelectedLabelsGroupBy: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
    MRANGE_SELECTED_LABELS: MRANGE_SELECTED_LABELS_1.default,
    mRangeSelectedLabels: MRANGE_SELECTED_LABELS_1.default,
    MRANGE_WITHLABELS_GROUPBY: MRANGE_WITHLABELS_GROUPBY_1.default,
    mRangeWithLabelsGroupBy: MRANGE_WITHLABELS_GROUPBY_1.default,
    MRANGE_WITHLABELS: MRANGE_WITHLABELS_1.default,
    mRangeWithLabels: MRANGE_WITHLABELS_1.default,
    MRANGE: MRANGE_1.default,
    mRange: MRANGE_1.default,
    MREVRANGE_GROUPBY: MREVRANGE_GROUPBY_1.default,
    mRevRangeGroupBy: MREVRANGE_GROUPBY_1.default,
    MREVRANGE_SELECTED_LABELS_GROUPBY: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
    mRevRangeSelectedLabelsGroupBy: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
    MREVRANGE_SELECTED_LABELS: MREVRANGE_SELECTED_LABELS_1.default,
    mRevRangeSelectedLabels: MREVRANGE_SELECTED_LABELS_1.default,
    MREVRANGE_WITHLABELS_GROUPBY: MREVRANGE_WITHLABELS_GROUPBY_1.default,
    mRevRangeWithLabelsGroupBy: MREVRANGE_WITHLABELS_GROUPBY_1.default,
    MREVRANGE_WITHLABELS: MREVRANGE_WITHLABELS_1.default,
    mRevRangeWithLabels: MREVRANGE_WITHLABELS_1.default,
    MREVRANGE: MREVRANGE_1.default,
    mRevRange: MREVRANGE_1.default,
    QUERYINDEX: QUERYINDEX_1.default,
    queryIndex: QUERYINDEX_1.default,
    RANGE: RANGE_1.default,
    range: RANGE_1.default,
    REVRANGE: REVRANGE_1.default,
    revRange: REVRANGE_1.default
  };
});

// node_modules/@redis/time-series/dist/lib/index.js
var require_lib7 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TIME_SERIES_REDUCERS = exports.TIME_SERIES_BUCKET_TIMESTAMP = exports.TIME_SERIES_AGGREGATION_TYPE = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.TIME_SERIES_ENCODING = exports.default = undefined;
  var commands_1 = require_commands6();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
  Object.defineProperty(exports, "TIME_SERIES_ENCODING", { enumerable: true, get: function() {
    return commands_1.TIME_SERIES_ENCODING;
  } });
  Object.defineProperty(exports, "TIME_SERIES_DUPLICATE_POLICIES", { enumerable: true, get: function() {
    return commands_1.TIME_SERIES_DUPLICATE_POLICIES;
  } });
  var CREATERULE_1 = require_CREATERULE();
  Object.defineProperty(exports, "TIME_SERIES_AGGREGATION_TYPE", { enumerable: true, get: function() {
    return CREATERULE_1.TIME_SERIES_AGGREGATION_TYPE;
  } });
  var RANGE_1 = require_RANGE();
  Object.defineProperty(exports, "TIME_SERIES_BUCKET_TIMESTAMP", { enumerable: true, get: function() {
    return RANGE_1.TIME_SERIES_BUCKET_TIMESTAMP;
  } });
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  Object.defineProperty(exports, "TIME_SERIES_REDUCERS", { enumerable: true, get: function() {
    return MRANGE_GROUPBY_1.TIME_SERIES_REDUCERS;
  } });
});

// node_modules/redis/dist/index.js
var require_dist4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createSentinel = exports.createCluster = exports.createClient = undefined;
  var client_1 = require_dist3();
  var bloom_1 = __importDefault(require_lib4());
  var json_1 = __importDefault(require_lib5());
  var search_1 = __importDefault(require_lib6());
  var time_series_1 = __importDefault(require_lib7());
  __exportStar(require_dist3(), exports);
  __exportStar(require_lib4(), exports);
  __exportStar(require_lib5(), exports);
  __exportStar(require_lib6(), exports);
  __exportStar(require_lib7(), exports);
  var modules = {
    ...bloom_1.default,
    json: json_1.default,
    ft: search_1.default,
    ts: time_series_1.default
  };
  function createClient(options) {
    return (0, client_1.createClient)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createClient = createClient;
  function createCluster(options) {
    return (0, client_1.createCluster)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createCluster = createCluster;
  function createSentinel(options) {
    return (0, client_1.createSentinel)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createSentinel = createSentinel;
});

// node_modules/@hapi/hoek/lib/assertError.js
var require_assertError = __commonJS((exports, module) => {
  module.exports = class AssertError extends Error {
    name = "AssertError";
    constructor(message, ctor) {
      super(message || "Unknown error");
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, ctor);
      }
    }
  };
});

// node_modules/@hapi/hoek/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  module.exports = function(...args) {
    try {
      return JSON.stringify(...args);
    } catch (err) {
      return "[Cannot display object: " + err.message + "]";
    }
  };
});

// node_modules/@hapi/hoek/lib/assert.js
var require_assert = __commonJS((exports, module) => {
  var AssertError = require_assertError();
  var Stringify = require_stringify();
  var assert = module.exports = function(condition, ...args) {
    if (condition) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Error) {
      throw args[0];
    }
    const msgs = args.filter((arg) => arg !== "").map((arg) => {
      return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
    });
    throw new AssertError(msgs.join(" "), assert);
  };
});

// node_modules/@hapi/hoek/lib/reach.js
var require_reach = __commonJS((exports, module) => {
  var Assert = require_assert();
  var internals = {};
  module.exports = function(obj, chain, options) {
    if (chain === false || chain === null || chain === undefined) {
      return obj;
    }
    options = options || {};
    if (typeof options === "string") {
      options = { separator: options };
    }
    const isChainArray = Array.isArray(chain);
    Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
    const path2 = isChainArray ? chain : chain.split(options.separator || ".");
    let ref = obj;
    for (let i = 0;i < path2.length; ++i) {
      let key = path2[i];
      const type = options.iterables && internals.iterables(ref);
      if (Array.isArray(ref) || type === "set") {
        const number = Number(key);
        if (Number.isInteger(number)) {
          key = number < 0 ? ref.length + number : number;
        }
      }
      if (!ref || typeof ref === "function" && options.functions === false || !type && ref[key] === undefined) {
        Assert(!options.strict || i + 1 === path2.length, "Missing segment", key, "in reach path ", chain);
        Assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
        ref = options.default;
        break;
      }
      if (!type) {
        ref = ref[key];
      } else if (type === "set") {
        ref = [...ref][key];
      } else {
        ref = ref.get(key);
      }
    }
    return ref;
  };
  internals.iterables = function(ref) {
    if (ref instanceof Set) {
      return "set";
    }
    if (ref instanceof Map) {
      return "map";
    }
  };
});

// node_modules/@hapi/hoek/lib/types.js
var require_types = __commonJS((exports, module) => {
  var internals = {};
  exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer && Buffer.prototype,
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    url: URL.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
  };
  internals.typeMap = new Map([
    ["[object Error]", exports.error],
    ["[object Map]", exports.map],
    ["[object Promise]", exports.promise],
    ["[object Set]", exports.set],
    ["[object URL]", exports.url],
    ["[object WeakMap]", exports.weakMap],
    ["[object WeakSet]", exports.weakSet]
  ]);
  exports.getInternalProto = function(obj) {
    if (Array.isArray(obj)) {
      return exports.array;
    }
    if (Buffer && obj instanceof Buffer) {
      return exports.buffer;
    }
    if (obj instanceof Date) {
      return exports.date;
    }
    if (obj instanceof RegExp) {
      return exports.regex;
    }
    if (obj instanceof Error) {
      return exports.error;
    }
    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
  };
});

// node_modules/@hapi/hoek/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  exports.keys = function(obj, options = {}) {
    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
  };
});

// node_modules/@hapi/hoek/lib/clone.js
var require_clone = __commonJS((exports, module) => {
  var Reach = require_reach();
  var Types = require_types();
  var Utils = require_utils4();
  var internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap]),
    structuredCloneExists: typeof structuredClone === "function"
  };
  module.exports = internals.clone = function(obj, options = {}, _seen = null) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    let clone = internals.clone;
    let seen = _seen;
    if (options.shallow) {
      if (options.shallow !== true) {
        return internals.cloneWithShallow(obj, options);
      }
      clone = (value) => value;
    } else if (seen) {
      const lookup = seen.get(obj);
      if (lookup) {
        return lookup;
      }
    } else {
      seen = new Map;
    }
    const baseProto = Types.getInternalProto(obj);
    switch (baseProto) {
      case Types.buffer:
        return Buffer?.from(obj);
      case Types.date:
        return new Date(obj.getTime());
      case Types.regex:
      case Types.url:
        return new baseProto.constructor(obj);
    }
    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
      return obj;
    }
    if (seen) {
      seen.set(obj, newObj);
    }
    if (baseProto === Types.set) {
      for (const value of obj) {
        newObj.add(clone(value, options, seen));
      }
    } else if (baseProto === Types.map) {
      for (const [key, value] of obj) {
        newObj.set(key, clone(value, options, seen));
      }
    }
    const keys = Utils.keys(obj, options);
    for (const key of keys) {
      if (key === "__proto__") {
        continue;
      }
      if (baseProto === Types.array && key === "length") {
        newObj.length = obj.length;
        continue;
      }
      if (internals.structuredCloneExists && baseProto === Types.error && key === "stack") {
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj, key);
      if (descriptor) {
        if (descriptor.get || descriptor.set) {
          Object.defineProperty(newObj, key, descriptor);
        } else if (descriptor.enumerable) {
          newObj[key] = clone(obj[key], options, seen);
        } else {
          Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
        }
      } else {
        Object.defineProperty(newObj, key, {
          enumerable: true,
          writable: true,
          configurable: true,
          value: clone(obj[key], options, seen)
        });
      }
    }
    return newObj;
  };
  internals.cloneWithShallow = function(source, options) {
    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;
    const seen = new Map;
    for (const key of keys) {
      const ref = Reach(source, key);
      if (typeof ref === "object" || typeof ref === "function") {
        seen.set(ref, ref);
      }
    }
    return internals.clone(source, options, seen);
  };
  internals.base = function(obj, baseProto, options) {
    if (options.prototype === false) {
      if (internals.needsProtoHack.has(baseProto)) {
        return new baseProto.constructor;
      }
      return baseProto === Types.array ? [] : {};
    }
    const proto2 = Object.getPrototypeOf(obj);
    if (proto2 && proto2.isImmutable) {
      return obj;
    }
    if (baseProto === Types.array) {
      const newObj = [];
      if (proto2 !== baseProto) {
        Object.setPrototypeOf(newObj, proto2);
      }
      return newObj;
    } else if (baseProto === Types.error && internals.structuredCloneExists && (proto2 === baseProto || Error.isPrototypeOf(proto2.constructor))) {
      const err = structuredClone(obj);
      if (Object.getPrototypeOf(err) !== proto2) {
        Object.setPrototypeOf(err, proto2);
      }
      return err;
    }
    if (internals.needsProtoHack.has(baseProto)) {
      const newObj = new proto2.constructor;
      if (proto2 !== baseProto) {
        Object.setPrototypeOf(newObj, proto2);
      }
      return newObj;
    }
    return Object.create(proto2);
  };
});

// node_modules/@hapi/hoek/lib/merge.js
var require_merge = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Utils = require_utils4();
  var internals = {};
  module.exports = internals.merge = function(target, source, options) {
    Assert(target && typeof target === "object", "Invalid target value: must be an object");
    Assert(source === null || source === undefined || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
    if (!source) {
      return target;
    }
    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
    if (Array.isArray(source)) {
      Assert(Array.isArray(target), "Cannot merge array onto an object");
      if (!options.mergeArrays) {
        target.length = 0;
      }
      for (let i = 0;i < source.length; ++i) {
        target.push(Clone(source[i], { symbols: options.symbols }));
      }
      return target;
    }
    const keys = Utils.keys(source, options);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
        continue;
      }
      const value = source[key];
      if (value && typeof value === "object") {
        if (target[key] === value) {
          continue;
        }
        if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || value instanceof RegExp) {
          target[key] = Clone(value, { symbols: options.symbols });
        } else {
          internals.merge(target[key], value, options);
        }
      } else {
        if (value !== null && value !== undefined) {
          target[key] = value;
        } else if (options.nullOverride) {
          target[key] = value;
        }
      }
    }
    return target;
  };
});

// node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Merge = require_merge();
  var Reach = require_reach();
  var internals = {};
  module.exports = function(defaults2, source, options = {}) {
    Assert(defaults2 && typeof defaults2 === "object", "Invalid defaults value: must be an object");
    Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
    Assert(typeof options === "object", "Invalid options: must be an object");
    if (!source) {
      return null;
    }
    if (options.shallow) {
      return internals.applyToDefaultsWithShallow(defaults2, source, options);
    }
    const copy = Clone(defaults2);
    if (source === true) {
      return copy;
    }
    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.applyToDefaultsWithShallow = function(defaults2, source, options) {
    const keys = options.shallow;
    Assert(Array.isArray(keys), "Invalid keys");
    const seen = new Map;
    const merge = source === true ? null : new Set;
    for (let key of keys) {
      key = Array.isArray(key) ? key : key.split(".");
      const ref = Reach(defaults2, key);
      if (ref && typeof ref === "object") {
        seen.set(ref, merge && Reach(source, key) || ref);
      } else if (merge) {
        merge.add(key);
      }
    }
    const copy = Clone(defaults2, {}, seen);
    if (!merge) {
      return copy;
    }
    for (const key of merge) {
      internals.reachCopy(copy, source, key);
    }
    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.reachCopy = function(dst, src, path2) {
    for (const segment of path2) {
      if (!(segment in src)) {
        return;
      }
      const val = src[segment];
      if (typeof val !== "object" || val === null) {
        return;
      }
      src = val;
    }
    const value = src;
    let ref = dst;
    for (let i = 0;i < path2.length - 1; ++i) {
      const segment = path2[i];
      if (typeof ref[segment] !== "object") {
        ref[segment] = {};
      }
      ref = ref[segment];
    }
    ref[path2[path2.length - 1]] = value;
  };
});

// node_modules/@hapi/hoek/lib/bench.js
var require_bench = __commonJS((exports, module) => {
  var internals = {};
  module.exports = internals.Bench = class {
    constructor() {
      this.ts = 0;
      this.reset();
    }
    reset() {
      this.ts = internals.Bench.now();
    }
    elapsed() {
      return internals.Bench.now() - this.ts;
    }
    static now() {
      const ts = process.hrtime();
      return ts[0] * 1000 + ts[1] / 1e6;
    }
  };
});

// node_modules/@hapi/hoek/lib/ignore.js
var require_ignore = __commonJS((exports, module) => {
  module.exports = function() {};
});

// node_modules/@hapi/hoek/lib/block.js
var require_block = __commonJS((exports, module) => {
  var Ignore = require_ignore();
  module.exports = function() {
    return new Promise(Ignore);
  };
});

// node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual = __commonJS((exports, module) => {
  var Types = require_types();
  var internals = {
    mismatched: null
  };
  module.exports = function(obj, ref, options) {
    options = Object.assign({ prototype: true }, options);
    return !!internals.isDeepEqual(obj, ref, options, []);
  };
  internals.isDeepEqual = function(obj, ref, options, seen) {
    if (obj === ref) {
      return obj !== 0 || 1 / obj === 1 / ref;
    }
    const type = typeof obj;
    if (type !== typeof ref) {
      return false;
    }
    if (obj === null || ref === null) {
      return false;
    }
    if (type === "function") {
      if (!options.deepFunction || obj.toString() !== ref.toString()) {
        return false;
      }
    } else if (type !== "object") {
      return obj !== obj && ref !== ref;
    }
    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
      case Types.buffer:
        return Buffer && Buffer.prototype.equals.call(obj, ref);
      case Types.promise:
        return obj === ref;
      case Types.regex:
      case Types.url:
        return obj.toString() === ref.toString();
      case internals.mismatched:
        return false;
    }
    for (let i = seen.length - 1;i >= 0; --i) {
      if (seen[i].isSame(obj, ref)) {
        return true;
      }
    }
    seen.push(new internals.SeenEntry(obj, ref));
    try {
      return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    } finally {
      seen.pop();
    }
  };
  internals.getSharedType = function(obj, ref, checkPrototype) {
    if (checkPrototype) {
      if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
        return internals.mismatched;
      }
      return Types.getInternalProto(obj);
    }
    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
      return internals.mismatched;
    }
    return type;
  };
  internals.valueOf = function(obj) {
    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
      return obj;
    }
    try {
      return objValueOf.call(obj);
    } catch (err) {
      return err;
    }
  };
  internals.hasOwnEnumerableProperty = function(obj, key) {
    return Object.prototype.propertyIsEnumerable.call(obj, key);
  };
  internals.isSetSimpleEqual = function(obj, ref) {
    for (const entry of Set.prototype.values.call(obj)) {
      if (!Set.prototype.has.call(ref, entry)) {
        return false;
      }
    }
    return true;
  };
  internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;
    if (instanceType === Types.array) {
      if (options.part) {
        for (const objValue of obj) {
          for (const refValue of ref) {
            if (isDeepEqual(objValue, refValue, options, seen)) {
              return true;
            }
          }
        }
      } else {
        if (obj.length !== ref.length) {
          return false;
        }
        for (let i = 0;i < obj.length; ++i) {
          if (!isDeepEqual(obj[i], ref[i], options, seen)) {
            return false;
          }
        }
        return true;
      }
    } else if (instanceType === Types.set) {
      if (obj.size !== ref.size) {
        return false;
      }
      if (!internals.isSetSimpleEqual(obj, ref)) {
        const ref2 = new Set(Set.prototype.values.call(ref));
        for (const objEntry of Set.prototype.values.call(obj)) {
          if (ref2.delete(objEntry)) {
            continue;
          }
          let found = false;
          for (const refEntry of ref2) {
            if (isDeepEqual(objEntry, refEntry, options, seen)) {
              ref2.delete(refEntry);
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
      }
    } else if (instanceType === Types.map) {
      if (obj.size !== ref.size) {
        return false;
      }
      for (const [key, value] of Map.prototype.entries.call(obj)) {
        if (value === undefined && !Map.prototype.has.call(ref, key)) {
          return false;
        }
        if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
          return false;
        }
      }
    } else if (instanceType === Types.error) {
      if (obj.name !== ref.name || obj.message !== ref.message) {
        return false;
      }
    }
    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
      return false;
    }
    const objKeys = keys(obj);
    if (!options.part && objKeys.length !== keys(ref).length && !options.skip) {
      return false;
    }
    let skipped = 0;
    for (const key of objKeys) {
      if (options.skip && options.skip.includes(key)) {
        if (ref[key] === undefined) {
          ++skipped;
        }
        continue;
      }
      if (!hasOwnEnumerableProperty(ref, key)) {
        return false;
      }
      if (!isDeepEqual(obj[key], ref[key], options, seen)) {
        return false;
      }
    }
    if (!options.part && objKeys.length - skipped !== keys(ref).length) {
      return false;
    }
    if (options.symbols !== false) {
      const objSymbols = getOwnPropertySymbols(obj);
      const refSymbols = new Set(getOwnPropertySymbols(ref));
      for (const key of objSymbols) {
        if (!options.skip?.includes(key)) {
          if (hasOwnEnumerableProperty(obj, key)) {
            if (!hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
            if (!isDeepEqual(obj[key], ref[key], options, seen)) {
              return false;
            }
          } else if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
        refSymbols.delete(key);
      }
      for (const key of refSymbols) {
        if (hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
      }
    }
    return true;
  };
  internals.SeenEntry = class {
    constructor(obj, ref) {
      this.obj = obj;
      this.ref = ref;
    }
    isSame(obj, ref) {
      return this.obj === obj && this.ref === ref;
    }
  };
});

// node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex = __commonJS((exports, module) => {
  module.exports = function(string) {
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
  };
});

// node_modules/@hapi/hoek/lib/contain.js
var require_contain = __commonJS((exports, module) => {
  var Assert = require_assert();
  var DeepEqual = require_deepEqual();
  var EscapeRegex = require_escapeRegex();
  var Utils = require_utils4();
  var internals = {};
  module.exports = function(ref, values, options = {}) {
    if (typeof values !== "object") {
      values = [values];
    }
    Assert(!Array.isArray(values) || values.length, "Values array cannot be empty");
    if (typeof ref === "string") {
      return internals.string(ref, values, options);
    }
    if (Array.isArray(ref)) {
      return internals.array(ref, values, options);
    }
    Assert(typeof ref === "object", "Reference must be string or an object");
    return internals.object(ref, values, options);
  };
  internals.array = function(ref, values, options) {
    if (!Array.isArray(values)) {
      values = [values];
    }
    if (!ref.length) {
      return false;
    }
    if (options.only && options.once && ref.length !== values.length) {
      return false;
    }
    let compare;
    const map = new Map;
    for (const value of values) {
      if (!options.deep || !value || typeof value !== "object") {
        const existing = map.get(value);
        if (existing) {
          ++existing.allowed;
        } else {
          map.set(value, { allowed: 1, hits: 0 });
        }
      } else {
        compare = compare ?? internals.compare(options);
        let found = false;
        for (const [key, existing] of map.entries()) {
          if (compare(key, value)) {
            ++existing.allowed;
            found = true;
            break;
          }
        }
        if (!found) {
          map.set(value, { allowed: 1, hits: 0 });
        }
      }
    }
    let hits = 0;
    for (const item of ref) {
      let match;
      if (!options.deep || !item || typeof item !== "object") {
        match = map.get(item);
      } else {
        compare = compare ?? internals.compare(options);
        for (const [key, existing] of map.entries()) {
          if (compare(key, item)) {
            match = existing;
            break;
          }
        }
      }
      if (match) {
        ++match.hits;
        ++hits;
        if (options.once && match.hits > match.allowed) {
          return false;
        }
      }
    }
    if (options.only && hits !== ref.length) {
      return false;
    }
    for (const match of map.values()) {
      if (match.hits === match.allowed) {
        continue;
      }
      if (match.hits < match.allowed && !options.part) {
        return false;
      }
    }
    return !!hits;
  };
  internals.object = function(ref, values, options) {
    Assert(options.once === undefined, "Cannot use option once with object");
    const keys = Utils.keys(ref, options);
    if (!keys.length) {
      return false;
    }
    if (Array.isArray(values)) {
      return internals.array(keys, values, options);
    }
    const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
    const targets = [...Object.keys(values), ...symbols];
    const compare = internals.compare(options);
    const set = new Set(targets);
    for (const key of keys) {
      if (!set.has(key)) {
        if (options.only) {
          return false;
        }
        continue;
      }
      if (!compare(values[key], ref[key])) {
        return false;
      }
      set.delete(key);
    }
    if (set.size) {
      return options.part ? set.size < targets.length : false;
    }
    return true;
  };
  internals.string = function(ref, values, options) {
    if (ref === "") {
      return values.length === 1 && values[0] === "" || !options.once && !values.some((v) => v !== "");
    }
    const map = new Map;
    const patterns = [];
    for (const value of values) {
      Assert(typeof value === "string", "Cannot compare string reference to non-string value");
      if (value) {
        const existing = map.get(value);
        if (existing) {
          ++existing.allowed;
        } else {
          map.set(value, { allowed: 1, hits: 0 });
          patterns.push(EscapeRegex(value));
        }
      } else if (options.once || options.only) {
        return false;
      }
    }
    if (!patterns.length) {
      return true;
    }
    const regex = new RegExp(`(${patterns.join("|")})`, "g");
    const leftovers = ref.replace(regex, ($0, $1) => {
      ++map.get($1).hits;
      return "";
    });
    if (options.only && leftovers) {
      return false;
    }
    let any = false;
    for (const match of map.values()) {
      if (match.hits) {
        any = true;
      }
      if (match.hits === match.allowed) {
        continue;
      }
      if (match.hits < match.allowed && !options.part) {
        return false;
      }
      if (options.once) {
        return false;
      }
    }
    return !!any;
  };
  internals.compare = function(options) {
    if (!options.deep) {
      return internals.shallow;
    }
    const hasOnly = options.only !== undefined;
    const hasPart = options.part !== undefined;
    const flags = {
      prototype: hasOnly ? options.only : hasPart ? !options.part : false,
      part: hasOnly ? !options.only : hasPart ? options.part : false
    };
    return (a, b) => DeepEqual(a, b, flags);
  };
  internals.shallow = function(a, b) {
    return a === b;
  };
});

// node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js
var require_escapeHeaderAttribute = __commonJS((exports, module) => {
  var Assert = require_assert();
  module.exports = function(attribute) {
    Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
    return attribute.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"");
  };
});

// node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml = __commonJS((exports, module) => {
  var internals = {};
  module.exports = function(input) {
    if (!input) {
      return "";
    }
    let escaped = "";
    for (let i = 0;i < input.length; ++i) {
      const charCode = input.charCodeAt(i);
      if (internals.isSafe(charCode)) {
        escaped += input[i];
      } else {
        escaped += internals.escapeHtmlChar(charCode);
      }
    }
    return escaped;
  };
  internals.escapeHtmlChar = function(charCode) {
    const namedEscape = internals.namedHtml.get(charCode);
    if (namedEscape) {
      return namedEscape;
    }
    if (charCode >= 256) {
      return "&#" + charCode + ";";
    }
    const hexValue = charCode.toString(16).padStart(2, "0");
    return `&#x${hexValue};`;
  };
  internals.isSafe = function(charCode) {
    return internals.safeCharCodes.has(charCode);
  };
  internals.namedHtml = new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [34, "&quot;"],
    [160, "&nbsp;"],
    [162, "&cent;"],
    [163, "&pound;"],
    [164, "&curren;"],
    [169, "&copy;"],
    [174, "&reg;"]
  ]);
  internals.safeCharCodes = function() {
    const safe = new Set;
    for (let i = 32;i < 123; ++i) {
      if (i >= 97 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 32 || i === 46 || i === 44 || i === 45 || i === 58 || i === 95) {
        safe.add(i);
      }
    }
    return safe;
  }();
});

// node_modules/@hapi/hoek/lib/escapeJson.js
var require_escapeJson = __commonJS((exports, module) => {
  var internals = {};
  module.exports = function(input) {
    if (!input) {
      return "";
    }
    return input.replace(/[<>&\u2028\u2029]/g, internals.escape);
  };
  internals.escape = function(char) {
    return internals.replacements.get(char);
  };
  internals.replacements = new Map([
    ["<", "\\u003c"],
    [">", "\\u003e"],
    ["&", "\\u0026"],
    ["\u2028", "\\u2028"],
    ["\u2029", "\\u2029"]
  ]);
});

// node_modules/@hapi/hoek/lib/flatten.js
var require_flatten = __commonJS((exports, module) => {
  var internals = {};
  module.exports = internals.flatten = function(array, target) {
    const result = target || [];
    for (const entry of array) {
      if (Array.isArray(entry)) {
        internals.flatten(entry, result);
      } else {
        result.push(entry);
      }
    }
    return result;
  };
});

// node_modules/@hapi/hoek/lib/intersect.js
var require_intersect = __commonJS((exports, module) => {
  var internals = {};
  module.exports = function(array1, array2, options = {}) {
    if (!array1 || !array2) {
      return options.first ? null : [];
    }
    const common = [];
    const hash = Array.isArray(array1) ? new Set(array1) : array1;
    const found = new Set;
    for (const value of array2) {
      if (internals.has(hash, value) && !found.has(value)) {
        if (options.first) {
          return value;
        }
        common.push(value);
        found.add(value);
      }
    }
    return options.first ? null : common;
  };
  internals.has = function(ref, key) {
    if (typeof ref.has === "function") {
      return ref.has(key);
    }
    return ref[key] !== undefined;
  };
});

// node_modules/@hapi/hoek/lib/isPromise.js
var require_isPromise = __commonJS((exports, module) => {
  module.exports = function(promise) {
    return typeof promise?.then === "function";
  };
});

// node_modules/@hapi/hoek/lib/once.js
var require_once = __commonJS((exports, module) => {
  var internals = {
    wrapped: Symbol("wrapped")
  };
  module.exports = function(method) {
    if (method[internals.wrapped]) {
      return method;
    }
    let once = false;
    const wrappedFn = function(...args) {
      if (!once) {
        once = true;
        method(...args);
      }
    };
    wrappedFn[internals.wrapped] = true;
    return wrappedFn;
  };
});

// node_modules/@hapi/hoek/lib/reachTemplate.js
var require_reachTemplate = __commonJS((exports, module) => {
  var Reach = require_reach();
  module.exports = function(obj, template, options) {
    return template.replace(/{([^{}]+)}/g, ($0, chain) => {
      const value = Reach(obj, chain, options);
      return value ?? "";
    });
  };
});

// node_modules/@hapi/hoek/lib/wait.js
var require_wait = __commonJS((exports, module) => {
  var internals = {
    maxTimer: 2 ** 31 - 1
  };
  module.exports = function(timeout, returnValue, options) {
    if (typeof timeout === "bigint") {
      timeout = Number(timeout);
    }
    if (timeout >= Number.MAX_SAFE_INTEGER) {
      timeout = Infinity;
    }
    if (typeof timeout !== "number" && timeout !== undefined) {
      throw new TypeError("Timeout must be a number or bigint");
    }
    return new Promise((resolve) => {
      const _setTimeout = options ? options.setTimeout : setTimeout;
      const activate = () => {
        const time = Math.min(timeout, internals.maxTimer);
        timeout -= time;
        _setTimeout(() => timeout > 0 ? activate() : resolve(returnValue), time);
      };
      if (timeout !== Infinity) {
        activate();
      }
    });
  };
});

// node_modules/@hapi/hoek/lib/index.js
var require_lib8 = __commonJS((exports) => {
  exports.applyToDefaults = require_applyToDefaults();
  exports.assert = require_assert();
  exports.AssertError = require_assertError();
  exports.Bench = require_bench();
  exports.block = require_block();
  exports.clone = require_clone();
  exports.contain = require_contain();
  exports.deepEqual = require_deepEqual();
  exports.escapeHeaderAttribute = require_escapeHeaderAttribute();
  exports.escapeHtml = require_escapeHtml();
  exports.escapeJson = require_escapeJson();
  exports.escapeRegex = require_escapeRegex();
  exports.flatten = require_flatten();
  exports.ignore = require_ignore();
  exports.intersect = require_intersect();
  exports.isPromise = require_isPromise();
  exports.merge = require_merge();
  exports.once = require_once();
  exports.reach = require_reach();
  exports.reachTemplate = require_reachTemplate();
  exports.stringify = require_stringify();
  exports.wait = require_wait();
});

// node_modules/@hapi/validate/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "@hapi/validate",
    description: "Object schema validation",
    version: "2.0.1",
    repository: "git://github.com/hapijs/validate",
    main: "lib/index.js",
    files: [
      "lib/**/*"
    ],
    eslintConfig: {
      extends: [
        "plugin:@hapi/module"
      ]
    },
    dependencies: {
      "@hapi/hoek": "^11.0.2",
      "@hapi/topo": "^6.0.1"
    },
    devDependencies: {
      "@hapi/bourne": "^3.0.0",
      "@hapi/code": "^9.0.3",
      "@hapi/eslint-plugin": "*",
      "@hapi/lab": "^25.1.2"
    },
    scripts: {
      test: "lab -t 100 -a @hapi/code -L",
      "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
    },
    license: "BSD-3-Clause"
  };
});

// node_modules/@hapi/validate/lib/schemas.js
var require_schemas = __commonJS((exports) => {
  var Joi = require_lib10();
  var internals = {};
  internals.wrap = Joi.string().min(1).max(2).allow(false);
  exports.preferences = Joi.object({
    allowUnknown: Joi.boolean(),
    abortEarly: Joi.boolean(),
    context: Joi.object(),
    convert: Joi.boolean(),
    dateFormat: Joi.valid("date", "iso", "string", "time", "utc"),
    errors: {
      escapeHtml: Joi.boolean(),
      label: Joi.valid("path", "key", false),
      language: [
        Joi.string(),
        Joi.object().ref()
      ],
      render: Joi.boolean(),
      stack: Joi.boolean(),
      wrap: {
        label: internals.wrap,
        array: internals.wrap
      }
    },
    messages: Joi.object(),
    noDefaults: Joi.boolean(),
    nonEnumerables: Joi.boolean(),
    presence: Joi.valid("required", "optional", "forbidden"),
    skipFunctions: Joi.boolean(),
    stripUnknown: Joi.object({
      arrays: Joi.boolean(),
      objects: Joi.boolean()
    }).or("arrays", "objects").allow(true, false)
  }).strict();
});

// node_modules/@hapi/validate/lib/ref.js
var require_ref = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Reach = require_reach();
  var Common = require_common();
  var internals = {
    symbol: Symbol("ref"),
    defaults: {
      adjust: null,
      in: false,
      iterables: null,
      map: null,
      separator: ".",
      type: "value"
    }
  };
  exports.create = function(key, options = {}) {
    Assert(typeof key === "string", "Invalid reference key:", key);
    Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "separator"]);
    Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
    const ref = Object.assign({}, internals.defaults, options);
    delete ref.prefix;
    const separator = ref.separator;
    const context = internals.context(key, separator, options.prefix);
    ref.type = context.type;
    key = context.key;
    if (ref.type === "value") {
      if (context.root) {
        Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
        ref.ancestor = "root";
        if (!key) {
          key = null;
        }
      }
      if (separator && separator === key) {
        key = null;
        ref.ancestor = 0;
      } else {
        if (ref.ancestor !== undefined) {
          Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
        } else {
          const [ancestor, slice] = internals.ancestor(key, separator);
          if (slice) {
            key = key.slice(slice);
            if (key === "") {
              key = null;
            }
          }
          ref.ancestor = ancestor;
        }
      }
    }
    ref.path = separator ? key === null ? [] : key.split(separator) : [key];
    return new internals.Ref(ref);
  };
  exports.in = function(key, options = {}) {
    return exports.create(key, Object.assign({}, options, { in: true }));
  };
  exports.isRef = function(ref) {
    return ref ? !!ref[Common.symbols.ref] : false;
  };
  internals.Ref = class {
    constructor(options) {
      Assert(typeof options === "object", "Invalid reference construction");
      Common.assertOptions(options, [
        "adjust",
        "ancestor",
        "in",
        "iterables",
        "map",
        "path",
        "separator",
        "type",
        "depth",
        "key",
        "root",
        "display"
      ]);
      Assert([false, undefined].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
      Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
      Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
      Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
      Object.assign(this, internals.defaults, options);
      Assert(this.type === "value" || this.ancestor === undefined, "Non-value references cannot reference ancestors");
      if (Array.isArray(this.map)) {
        this.map = new Map(this.map);
      }
      this.depth = this.path.length;
      this.key = this.path.length ? this.path.join(this.separator) : null;
      this.root = this.path[0];
      this.updateDisplay();
    }
    resolve(value, state, prefs, local, options = {}) {
      Assert(!this.in || options.in, "Invalid in() reference usage");
      if (this.type === "global") {
        return this._resolve(prefs.context, state, options);
      }
      if (this.type === "local") {
        return this._resolve(local, state, options);
      }
      if (!this.ancestor) {
        return this._resolve(value, state, options);
      }
      if (this.ancestor === "root") {
        return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
      }
      Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
      return this._resolve(state.ancestors[this.ancestor - 1], state, options);
    }
    _resolve(target, state, options) {
      let resolved;
      if (this.type === "value" && state.mainstay.shadow && options.shadow !== false) {
        resolved = state.mainstay.shadow.get(this.absolute(state));
      }
      if (resolved === undefined) {
        resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
      }
      if (this.adjust) {
        resolved = this.adjust(resolved);
      }
      if (this.map) {
        const mapped = this.map.get(resolved);
        if (mapped !== undefined) {
          resolved = mapped;
        }
      }
      return resolved;
    }
    toString() {
      return this.display;
    }
    absolute(state) {
      return [...state.path.slice(0, -this.ancestor), ...this.path];
    }
    clone() {
      return new internals.Ref(this);
    }
    updateDisplay() {
      const key = this.key !== null ? this.key : "";
      if (this.type !== "value") {
        this.display = `ref:${this.type}:${key}`;
        return;
      }
      if (!this.separator) {
        this.display = `ref:${key}`;
        return;
      }
      if (!this.ancestor) {
        this.display = `ref:${this.separator}${key}`;
        return;
      }
      if (this.ancestor === "root") {
        this.display = `ref:root:${key}`;
        return;
      }
      if (this.ancestor === 1) {
        this.display = `ref:${key || ".."}`;
        return;
      }
      const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
      this.display = `ref:${lead}${key || ""}`;
    }
  };
  internals.Ref.prototype[Common.symbols.ref] = true;
  internals.context = function(key, separator, prefix = {}) {
    key = key.trim();
    if (prefix) {
      const globalp = prefix.global === undefined ? "$" : prefix.global;
      if (globalp !== separator && key.startsWith(globalp)) {
        return { key: key.slice(globalp.length), type: "global" };
      }
      const local = prefix.local === undefined ? "#" : prefix.local;
      if (local !== separator && key.startsWith(local)) {
        return { key: key.slice(local.length), type: "local" };
      }
      const root = prefix.root === undefined ? "/" : prefix.root;
      if (root !== separator && key.startsWith(root)) {
        return { key: key.slice(root.length), type: "value", root: true };
      }
    }
    return { key, type: "value" };
  };
  internals.ancestor = function(key, separator) {
    if (!separator) {
      return [1, 0];
    }
    if (key[0] !== separator) {
      return [1, 0];
    }
    if (key[1] !== separator) {
      return [0, 1];
    }
    let i = 2;
    while (key[i] === separator) {
      ++i;
    }
    return [i - 1, i];
  };
  exports.toSibling = 0;
  exports.toParent = 1;
  exports.Manager = class {
    constructor() {
      this.refs = [];
    }
    register(source, target) {
      if (!source) {
        return;
      }
      target = target === undefined ? exports.toParent : target;
      if (Array.isArray(source)) {
        for (const ref of source) {
          this.register(ref, target);
        }
        return;
      }
      if (Common.isSchema(source)) {
        for (const item of source._refs.refs) {
          if (item.ancestor - target >= 0) {
            this.refs.push({ ancestor: item.ancestor - target, root: item.root });
          }
        }
        return;
      }
      if (exports.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
        this.refs.push({ ancestor: source.ancestor - target, root: source.root });
      }
    }
    clone() {
      const copy = new exports.Manager;
      copy.refs = Clone(this.refs);
      return copy;
    }
    reset() {
      this.refs = [];
    }
    roots() {
      return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
    }
  };
});

// node_modules/@hapi/validate/lib/template.js
var require_template = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var EscapeHtml = require_escapeHtml();
  var Common = require_common();
  var Ref = require_ref();
  var internals = {
    symbol: Symbol("template"),
    opens: new Array(1000).join("\x00"),
    closes: new Array(1000).join("\x01"),
    dateFormat: {
      date: Date.prototype.toDateString,
      iso: Date.prototype.toISOString,
      string: Date.prototype.toString,
      time: Date.prototype.toTimeString,
      utc: Date.prototype.toUTCString
    }
  };
  module.exports = exports = internals.Template = class {
    constructor(source, options) {
      Assert(typeof source === "string", "Template source must be a string");
      Assert(!source.includes("\x00") && !source.includes("\x01"), "Template source cannot contain reserved control characters");
      this.source = source;
      this.rendered = source;
      this._template = null;
      this._settings = Clone(options);
      this._parse();
    }
    _parse() {
      if (!this.source.includes("{")) {
        return;
      }
      const encoded = internals.encode(this.source);
      const parts = internals.split(encoded);
      const processed = [];
      const head = parts.shift();
      if (head) {
        processed.push(head);
      }
      for (const part of parts) {
        const raw = part[0] !== "{";
        const ender = raw ? "}" : "}}";
        const end = part.indexOf(ender);
        let variable = part.slice(raw ? 0 : 1, end);
        const wrapped = variable[0] === ":";
        if (wrapped) {
          variable = variable.slice(1);
        }
        const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
        processed.push(dynamic);
        const rest = part.slice(end + ender.length);
        if (rest) {
          processed.push(internals.decode(rest));
        }
      }
      this._template = processed;
    }
    static date(date, prefs) {
      return internals.dateFormat[prefs.dateFormat].call(date);
    }
    isDynamic() {
      return !!this._template;
    }
    static isTemplate(template) {
      return template ? !!template[Common.symbols.template] : false;
    }
    render(value, state, prefs, local, options = {}) {
      if (!this.isDynamic()) {
        return this.rendered;
      }
      const parts = [];
      for (const part of this._template) {
        if (typeof part === "string") {
          parts.push(part);
        } else {
          const rendered = part.ref.resolve(value, state, prefs, local, options);
          const string = internals.stringify(rendered, prefs, options.errors);
          const result = part.raw || options.errors?.escapeHtml === false ? string : EscapeHtml(string);
          parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
        }
      }
      return parts.join("");
    }
    _ref(content, { raw, wrapped }) {
      const ref = Ref.create(content, this._settings);
      return { ref, raw, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
    }
    toString() {
      return this.source;
    }
  };
  internals.Template.prototype[Common.symbols.template] = true;
  internals.Template.prototype.isImmutable = true;
  internals.encode = function(string) {
    return string.replace(/\\(\{+)/g, ($0, $1) => {
      return internals.opens.slice(0, $1.length);
    }).replace(/\\(\}+)/g, ($0, $1) => {
      return internals.closes.slice(0, $1.length);
    });
  };
  internals.decode = function(string) {
    return string.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
  };
  internals.split = function(string) {
    const parts = [];
    let current = "";
    for (let i = 0;i < string.length; ++i) {
      const char = string[i];
      if (char === "{") {
        let next = "";
        while (i + 1 < string.length && string[i + 1] === "{") {
          next += "{";
          ++i;
        }
        parts.push(current);
        current = next;
      } else {
        current += char;
      }
    }
    parts.push(current);
    return parts;
  };
  internals.wrap = function(value, ends) {
    if (!ends) {
      return value;
    }
    if (ends.length === 1) {
      return `${ends}${value}${ends}`;
    }
    return `${ends[0]}${value}${ends[1]}`;
  };
  internals.stringify = function(value, prefs, options) {
    const type = typeof value;
    if (value === null) {
      return "null";
    }
    if (value === undefined) {
      return "";
    }
    if (type === "string") {
      return value;
    }
    if (type === "number" || type === "function" || type === "symbol") {
      return value.toString();
    }
    if (type !== "object") {
      return JSON.stringify(value);
    }
    if (value instanceof Date) {
      return internals.Template.date(value, prefs);
    }
    if (value instanceof Map) {
      const pairs = [];
      for (const [key, sym] of value.entries()) {
        pairs.push(`${key.toString()} -> ${sym.toString()}`);
      }
      value = pairs;
    }
    if (!Array.isArray(value)) {
      return value.toString();
    }
    let partial = "";
    for (const item of value) {
      partial = partial + (partial.length ? ", " : "") + internals.stringify(item, prefs, options);
    }
    return internals.wrap(partial, prefs.errors.wrap.array);
  };
});

// node_modules/@hapi/validate/lib/messages.js
var require_messages2 = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Template = require_template();
  exports.compile = function(messages, target) {
    if (typeof messages === "string") {
      Assert(!target, "Cannot set single message string");
      return new Template(messages);
    }
    if (Template.isTemplate(messages)) {
      Assert(!target, "Cannot set single message template");
      return messages;
    }
    Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
    target = target ? Clone(target) : {};
    for (let code in messages) {
      const message = messages[code];
      if (code === "root" || Template.isTemplate(message)) {
        target[code] = message;
        continue;
      }
      if (typeof message === "string") {
        target[code] = new Template(message);
        continue;
      }
      Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
      const language = code;
      target[language] = target[language] || {};
      for (code in message) {
        const localized = message[code];
        if (code === "root" || Template.isTemplate(localized)) {
          target[language][code] = localized;
          continue;
        }
        Assert(typeof localized === "string", "Invalid message for", code, "in", language);
        target[language][code] = new Template(localized);
      }
    }
    return target;
  };
  exports.merge = function(base, extended) {
    if (!base) {
      return exports.compile(extended);
    }
    if (!extended) {
      return base;
    }
    if (typeof extended === "string") {
      return new Template(extended);
    }
    if (Template.isTemplate(extended)) {
      return extended;
    }
    const target = Clone(base);
    for (let code in extended) {
      const message = extended[code];
      if (code === "root" || Template.isTemplate(message)) {
        target[code] = message;
        continue;
      }
      if (typeof message === "string") {
        target[code] = new Template(message);
        continue;
      }
      Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
      const language = code;
      target[language] = target[language] || {};
      for (code in message) {
        const localized = message[code];
        if (code === "root" || Template.isTemplate(localized)) {
          target[language][code] = localized;
          continue;
        }
        Assert(typeof localized === "string", "Invalid message for", code, "in", language);
        target[language][code] = new Template(localized);
      }
    }
    return target;
  };
});

// node_modules/@hapi/validate/lib/common.js
var require_common = __commonJS((exports) => {
  var Assert = require_assert();
  var AssertError = require_assertError();
  var Pkg = require_package2();
  var Messages;
  var Schemas;
  var internals = {
    isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
  };
  exports.version = Pkg.version;
  exports.defaults = {
    abortEarly: true,
    allowUnknown: false,
    context: null,
    convert: true,
    dateFormat: "iso",
    errors: {
      escapeHtml: false,
      label: "path",
      language: null,
      render: true,
      stack: false,
      wrap: {
        label: '"',
        array: "[]"
      }
    },
    messages: {},
    nonEnumerables: false,
    noDefaults: false,
    presence: "optional",
    skipFunctions: false,
    stripUnknown: false
  };
  exports.symbols = {
    any: Symbol.for("@hapi/joi/schema"),
    arraySingle: Symbol("arraySingle"),
    deepDefault: Symbol("deepDefault"),
    errors: Symbol("errors"),
    literal: Symbol("literal"),
    override: Symbol("override"),
    parent: Symbol("parent"),
    prefs: Symbol("prefs"),
    ref: Symbol("ref"),
    template: Symbol("template"),
    values: Symbol("values")
  };
  exports.assertOptions = function(options, keys, name = "Options") {
    Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
  };
  exports.checkPreferences = function(prefs) {
    Schemas = Schemas || require_schemas();
    const result = Schemas.preferences.validate(prefs);
    if (result.error) {
      throw new AssertError([result.error.details[0].message]);
    }
  };
  exports.compare = function(a, b, operator) {
    switch (operator) {
      case "=":
        return a === b;
      case ">":
        return a > b;
      case "<":
        return a < b;
      case ">=":
        return a >= b;
      case "<=":
        return a <= b;
    }
  };
  exports.default = function(value, defaultValue) {
    return value === undefined ? defaultValue : value;
  };
  exports.isIsoDate = function(date) {
    return internals.isoDate.test(date);
  };
  exports.isNumber = function(value) {
    return typeof value === "number" && !isNaN(value);
  };
  exports.isResolvable = function(obj) {
    if (!obj) {
      return false;
    }
    return obj[exports.symbols.ref] || obj[exports.symbols.template];
  };
  exports.isSchema = function(schema, options = {}) {
    const any = schema && schema[exports.symbols.any];
    if (!any) {
      return false;
    }
    return true;
  };
  exports.limit = function(value) {
    return Number.isSafeInteger(value) && value >= 0;
  };
  exports.preferences = function(target, source) {
    Messages = Messages || require_messages2();
    target = target || {};
    source = source || {};
    const merged = Object.assign({}, target, source);
    if (source.errors && target.errors) {
      merged.errors = Object.assign({}, target.errors, source.errors);
      merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
    }
    if (source.messages) {
      merged.messages = Messages.compile(source.messages, target.messages);
    }
    delete merged[exports.symbols.prefs];
    return merged;
  };
  exports.tryWithPath = function(fn, key, options = {}) {
    try {
      return fn();
    } catch (err) {
      if (err.path !== undefined) {
        err.path = key + "." + err.path;
      } else {
        err.path = key;
      }
      if (options.append) {
        err.message = `${err.message} (${err.path})`;
      }
      throw err;
    }
  };
  exports.validateArg = function(value, label, { assert, message }) {
    if (exports.isSchema(assert)) {
      const result = assert.validate(value);
      if (!result.error) {
        return;
      }
      return result.error.message;
    } else if (!assert(value)) {
      return label ? `${label} ${message}` : message;
    }
  };
  exports.verifyFlat = function(args, method) {
    for (const arg of args) {
      Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
    }
  };
});

// node_modules/@hapi/validate/lib/compile.js
var require_compile = __commonJS((exports) => {
  var Assert = require_assert();
  var Common = require_common();
  var Ref = require_ref();
  var internals = {};
  exports.schema = function(Joi, config, options = {}) {
    Common.assertOptions(options, ["appendPath", "override"]);
    try {
      return internals.schema(Joi, config, options);
    } catch (err) {
      if (options.appendPath && err.path !== undefined) {
        err.message = `${err.message} (${err.path})`;
      }
      throw err;
    }
  };
  internals.schema = function(Joi, config, options) {
    Assert(config !== undefined, "Invalid undefined schema");
    if (Array.isArray(config)) {
      Assert(config.length, "Invalid empty array schema");
      if (config.length === 1) {
        config = config[0];
      }
    }
    const valid = (base, ...values) => {
      if (options.override !== false) {
        return base.valid(Joi.override, ...values);
      }
      return base.valid(...values);
    };
    if (internals.simple(config)) {
      return valid(Joi, config);
    }
    if (typeof config === "function") {
      return Joi.custom(config);
    }
    Assert(typeof config === "object", "Invalid schema content:", typeof config);
    if (Common.isResolvable(config)) {
      return valid(Joi, config);
    }
    if (Common.isSchema(config)) {
      return config;
    }
    if (Array.isArray(config)) {
      for (const item of config) {
        if (!internals.simple(item)) {
          return Joi.alternatives().try(...config);
        }
      }
      return valid(Joi, ...config);
    }
    if (config instanceof RegExp) {
      return Joi.string().regex(config);
    }
    if (config instanceof Date) {
      return valid(Joi.date(), config);
    }
    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
    return Joi.object().keys(config);
  };
  exports.ref = function(id, options) {
    return Ref.isRef(id) ? id : Ref.create(id, options);
  };
  exports.compile = function(root, schema) {
    const any = schema && schema[Common.symbols.any];
    if (any) {
      Assert(any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
      return schema;
    }
    return exports.schema(root, schema, { appendPath: true });
  };
  internals.simple = function(value) {
    return value === null || ["boolean", "string", "number"].includes(typeof value);
  };
  exports.when = function(schema, condition, options) {
    if (options === undefined) {
      Assert(condition && typeof condition === "object", "Missing options");
      options = condition;
      condition = Ref.create(".");
    }
    if (Array.isArray(options)) {
      options = { switch: options };
    }
    Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
    if (Common.isSchema(condition)) {
      Assert(options.is === undefined, '"is" can not be used with a schema condition');
      Assert(options.not === undefined, '"not" can not be used with a schema condition');
      Assert(options.switch === undefined, '"switch" can not be used with a schema condition');
      return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
    }
    Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
    Assert(options.not === undefined || options.is === undefined, 'Cannot combine "is" with "not"');
    if (options.switch === undefined) {
      let rule2 = options;
      if (options.not !== undefined) {
        rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
      }
      let is = rule2.is !== undefined ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
      Assert(rule2.then !== undefined || rule2.otherwise !== undefined, 'options must have at least one of "then", "otherwise", or "switch"');
      Assert(rule2.break === undefined || rule2.then === undefined || rule2.otherwise === undefined, "Cannot specify then, otherwise, and break all together");
      if (options.is !== undefined && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
        is = is.required();
      }
      return internals.condition(schema, { ref: exports.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
    }
    Assert(Array.isArray(options.switch), '"switch" must be an array');
    Assert(options.is === undefined, 'Cannot combine "switch" with "is"');
    Assert(options.not === undefined, 'Cannot combine "switch" with "not"');
    Assert(options.then === undefined, 'Cannot combine "switch" with "then"');
    const rule = {
      ref: exports.ref(condition),
      switch: [],
      break: options.break
    };
    for (let i = 0;i < options.switch.length; ++i) {
      const test = options.switch[i];
      const last = i === options.switch.length - 1;
      Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
      Assert(test.is !== undefined, 'Switch statement missing "is"');
      Assert(test.then !== undefined, 'Switch statement missing "then"');
      const item = {
        is: schema.$_compile(test.is),
        then: schema.$_compile(test.then)
      };
      if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
        item.is = item.is.required();
      }
      if (last) {
        Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify "otherwise" inside and outside a "switch"');
        const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;
        if (otherwise !== undefined) {
          Assert(rule.break === undefined, "Cannot specify both otherwise and break");
          item.otherwise = schema.$_compile(otherwise);
        }
      }
      rule.switch.push(item);
    }
    return rule;
  };
  internals.condition = function(schema, condition) {
    for (const key of ["then", "otherwise"]) {
      if (condition[key] === undefined) {
        delete condition[key];
      } else {
        condition[key] = schema.$_compile(condition[key]);
      }
    }
    return condition;
  };
});

// node_modules/@hapi/validate/lib/annotate.js
var require_annotate = __commonJS((exports) => {
  var Clone = require_clone();
  var Common = require_common();
  var internals = {
    annotations: Symbol("annotations")
  };
  exports.error = function(stripColorCodes) {
    if (!this._original || typeof this._original !== "object") {
      return this.details[0].message;
    }
    const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
    const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
    const endColor = stripColorCodes ? "" : "\x1B[0m";
    const obj = Clone(this._original);
    for (let i = this.details.length - 1;i >= 0; --i) {
      const pos = i + 1;
      const error = this.details[i];
      const path2 = error.path;
      let node = obj;
      for (let j = 0;; ++j) {
        const seg = path2[j];
        if (Common.isSchema(node)) {
          node = node.clone();
        }
        if (j + 1 < path2.length && typeof node[seg] !== "string") {
          node = node[seg];
        } else {
          const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
          node[internals.annotations] = refAnnotations;
          const cacheKey = seg || error.context.key;
          if (node[seg] !== undefined) {
            refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
            refAnnotations.errors[cacheKey].push(pos);
          } else {
            refAnnotations.missing[cacheKey] = pos;
          }
          break;
        }
      }
    }
    const replacers = {
      key: /_\$key\$_([, \d]+)_\$end\$_"/g,
      missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
      arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
      specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };
    let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
    message = `${message}
${redFgEscape}`;
    for (let i = 0;i < this.details.length; ++i) {
      const pos = i + 1;
      message = `${message}
[${pos}] ${this.details[i].message}`;
    }
    message = message + endColor;
    return message;
  };
  internals.safeStringify = function(obj, spaces) {
    return JSON.stringify(obj, internals.serializer(), spaces);
  };
  internals.serializer = function() {
    const keys = [];
    const stack = [];
    const cycleReplacer = (key, value) => {
      if (stack[0] === value) {
        return "[Circular ~]";
      }
      return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
    };
    return function(key, value) {
      if (stack.length > 0) {
        const thisPos = stack.indexOf(this);
        if (~thisPos) {
          stack.length = thisPos + 1;
          keys.length = thisPos + 1;
          keys[thisPos] = key;
        } else {
          stack.push(this);
          keys.push(key);
        }
        if (~stack.indexOf(value)) {
          value = cycleReplacer.call(this, key, value);
        }
      } else {
        stack.push(value);
      }
      if (value) {
        const annotations = value[internals.annotations];
        if (annotations) {
          if (Array.isArray(value)) {
            const annotated = [];
            for (let i = 0;i < value.length; ++i) {
              if (annotations.errors[i]) {
                annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
              }
              annotated.push(value[i]);
            }
            value = annotated;
          } else {
            for (const errorKey in annotations.errors) {
              value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
              value[errorKey] = undefined;
            }
            for (const missingKey in annotations.missing) {
              value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
            }
          }
          return value;
        }
      }
      if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
        return "[" + value.toString() + "]";
      }
      return value;
    };
  };
});

// node_modules/@hapi/validate/lib/errors.js
var require_errors2 = __commonJS((exports) => {
  var Annotate = require_annotate();
  var Common = require_common();
  var Template = require_template();
  exports.Report = class {
    constructor(code, value, local, flags, messages, state, prefs) {
      this.code = code;
      this.flags = flags;
      this.messages = messages;
      this.path = state.path;
      this.prefs = prefs;
      this.state = state;
      this.value = value;
      this.message = null;
      this.local = local || {};
      this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);
      if (this.value !== undefined && !this.local.hasOwnProperty("value")) {
        this.local.value = this.value;
      }
      if (this.path.length) {
        const key = this.path[this.path.length - 1];
        if (typeof key !== "object") {
          this.local.key = key;
        }
      }
    }
    toString() {
      if (this.message) {
        return this.message;
      }
      const code = this.code;
      if (!this.prefs.errors.render) {
        return this.code;
      }
      const template = this._template(this.prefs.messages) || this._template(this.messages);
      if (template === undefined) {
        return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
      }
      this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
      if (!this.prefs.errors.label) {
        this.message = this.message.replace(/^"" /, "").trim();
      }
      return this.message;
    }
    _template(messages) {
      return exports.template(this.value, messages, this.code, this.state, this.prefs);
    }
  };
  exports.path = function(path2) {
    let label = "";
    for (const segment of path2) {
      if (typeof segment === "object") {
        continue;
      }
      if (typeof segment === "string") {
        if (label) {
          label += ".";
        }
        label += segment;
      } else {
        label += `[${segment}]`;
      }
    }
    return label;
  };
  exports.template = function(value, messages, code, state, prefs) {
    if (Template.isTemplate(messages)) {
      return code !== "root" ? messages : null;
    }
    let lang = prefs.errors.language;
    if (Common.isResolvable(lang)) {
      lang = lang.resolve(value, state, prefs);
    }
    if (lang && messages[lang] && messages[lang][code] !== undefined) {
      return messages[lang][code];
    }
    return messages[code];
  };
  exports.label = function(flags, state, prefs, messages) {
    if (!prefs.errors.label) {
      return "";
    }
    let path2 = state.path;
    if (prefs.errors.label === "key" && state.path.length > 1) {
      path2 = state.path.slice(-1);
    }
    const normalized = exports.path(path2);
    if (normalized) {
      return normalized;
    }
    return exports.template(null, prefs.messages, "root", state, prefs) || exports.template(null, messages, "root", state, prefs) || "value";
  };
  exports.process = function(errors, original, prefs) {
    if (!errors) {
      return null;
    }
    const { override, message, details } = exports.details(errors);
    if (override) {
      return override;
    }
    if (prefs.errors.stack) {
      return new exports.ValidationError(message, details, original);
    }
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const validationError = new exports.ValidationError(message, details, original);
    Error.stackTraceLimit = limit;
    return validationError;
  };
  exports.details = function(errors, options = {}) {
    let messages = [];
    const details = [];
    for (const item of errors) {
      if (item instanceof Error) {
        if (options.override !== false) {
          return { override: item };
        }
        const message2 = item.toString();
        messages.push(message2);
        details.push({
          message: message2,
          type: "override",
          context: { error: item }
        });
        continue;
      }
      const message = item.toString();
      messages.push(message);
      details.push({
        message,
        path: item.path.filter((v) => typeof v !== "object"),
        type: item.code,
        context: item.local
      });
    }
    if (messages.length > 1) {
      messages = [...new Set(messages)];
    }
    return { message: messages.join(". "), details };
  };
  exports.ValidationError = class extends Error {
    constructor(message, details, original) {
      super(message);
      this._original = original;
      this.details = details;
    }
    static isError(err) {
      return err instanceof exports.ValidationError;
    }
  };
  exports.ValidationError.prototype.isJoi = true;
  exports.ValidationError.prototype.name = "ValidationError";
  exports.ValidationError.prototype.annotate = Annotate.error;
});

// node_modules/@hapi/validate/lib/extend.js
var require_extend = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Common = require_common();
  var Messages = require_messages2();
  exports.type = function(from, options) {
    const base = Object.getPrototypeOf(from);
    const prototype = Clone(base);
    const schema = from._assign(Object.create(prototype));
    const def = Object.assign({}, options);
    delete def.base;
    prototype._definition = def;
    const parent = base._definition || {};
    def.messages = Messages.merge(parent.messages, def.messages);
    def.properties = Object.assign({}, parent.properties, def.properties);
    schema.type = def.type;
    def.flags = Object.assign({}, parent.flags, def.flags);
    const terms = Object.assign({}, parent.terms);
    if (def.terms) {
      for (const name in def.terms) {
        const term = def.terms[name];
        Assert(schema.$_terms[name] === undefined, "Invalid term override for", def.type, name);
        schema.$_terms[name] = term.init;
        terms[name] = term;
      }
    }
    def.terms = terms;
    if (!def.args) {
      def.args = parent.args;
    }
    if (def.coerce) {
      if (typeof def.coerce === "function") {
        def.coerce = { method: def.coerce };
      }
      if (def.coerce.from && !Array.isArray(def.coerce.from)) {
        def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
      }
    }
    def.coerce = def.coerce || parent.coerce;
    def.validate = def.validate || parent.validate;
    const rules = Object.assign({}, parent.rules);
    if (def.rules) {
      for (const name in def.rules) {
        const rule = def.rules[name];
        Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
        const method = rule.method;
        if (method) {
          Assert(!prototype[name], "Rule conflict in", def.type, name);
          prototype[name] = method;
        }
        Assert(!rules[name], "Rule conflict in", def.type, name);
        rules[name] = rule;
        if (rule.alias) {
          const aliases = [].concat(rule.alias);
          for (const alias of aliases) {
            prototype[alias] = rule.method;
          }
        }
        if (rule.args) {
          rule.argsByName = new Map;
          rule.args = rule.args.map((arg) => {
            if (typeof arg === "string") {
              arg = { name: arg };
            }
            Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
            rule.argsByName.set(arg.name, arg);
            return arg;
          });
        }
      }
    }
    def.rules = rules;
    if (def.overrides) {
      prototype._super = base;
      schema.$_super = {};
      for (const override in def.overrides) {
        Assert(base[override], "Cannot override missing", override);
        def.overrides[override][Common.symbols.parent] = base[override];
        schema.$_super[override] = base[override].bind(schema);
      }
      Object.assign(prototype, def.overrides);
    }
    def.cast = Object.assign({}, parent.cast, def.cast);
    def.rebuild = def.rebuild || parent.rebuild;
    return schema;
  };
});

// node_modules/@hapi/validate/lib/modify.js
var require_modify = __commonJS((exports) => {
  var Assert = require_assert();
  var Common = require_common();
  var Ref = require_ref();
  var internals = {};
  exports.Ids = internals.Ids = class {
    constructor() {
      this._byId = new Map;
      this._byKey = new Map;
      this._schemaChain = false;
    }
    clone() {
      const clone = new internals.Ids;
      clone._byId = new Map(this._byId);
      clone._byKey = new Map(this._byKey);
      clone._schemaChain = this._schemaChain;
      return clone;
    }
    concat(source) {
      if (source._schemaChain) {
        this._schemaChain = true;
      }
      for (const [id, value] of source._byId.entries()) {
        Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
        this._byId.set(id, value);
      }
      for (const [key, value] of source._byKey.entries()) {
        Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
        this._byKey.set(key, value);
      }
    }
    reach(path2, behind = []) {
      const current = path2[0];
      const node = this._get(current);
      Assert(node, "Schema does not contain path", [...behind, ...path2].join("."));
      const forward = path2.slice(1);
      if (!forward.length) {
        return node.schema;
      }
      return node.schema._ids.reach(forward, [...behind, current]);
    }
    register(schema, { key } = {}) {
      if (!schema || !Common.isSchema(schema)) {
        return;
      }
      if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
        this._schemaChain = true;
      }
      const id = schema._flags.id;
      if (id) {
        const existing = this._byId.get(id);
        Assert(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
        Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
        this._byId.set(id, { schema, id });
      }
      if (key) {
        Assert(!this._byKey.has(key), "Schema already contains key:", key);
        Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
        this._byKey.set(key, { schema, id: key });
      }
    }
    reset() {
      this._byId = new Map;
      this._byKey = new Map;
      this._schemaChain = false;
    }
    _get(id) {
      return this._byId.get(id) || this._byKey.get(id);
    }
  };
  exports.schema = function(schema, options) {
    let obj;
    for (const name in schema._flags) {
      if (name[0] === "_") {
        continue;
      }
      const result = internals.scan(schema._flags[name], { source: "flags", name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        obj._flags[name] = result;
      }
    }
    for (let i = 0;i < schema._rules.length; ++i) {
      const rule = schema._rules[i];
      const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        const clone = Object.assign({}, rule);
        clone.args = result;
        obj._rules[i] = clone;
        const existingUnique = obj._singleRules.get(rule.name);
        if (existingUnique === rule) {
          obj._singleRules.set(rule.name, clone);
        }
      }
    }
    for (const name in schema.$_terms) {
      if (name[0] === "_") {
        continue;
      }
      const result = internals.scan(schema.$_terms[name], { source: "terms", name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        obj.$_terms[name] = result;
      }
    }
    return obj;
  };
  internals.scan = function(item, source, options, _path, _key) {
    const path2 = _path || [];
    if (item === null || typeof item !== "object") {
      return;
    }
    let clone;
    if (Array.isArray(item)) {
      for (let i = 0;i < item.length; ++i) {
        const key = source.name === "keys" && item[i].key;
        const result = internals.scan(item[i], source, options, [i, ...path2], key);
        if (result !== undefined) {
          clone = clone || item.slice();
          clone[i] = result;
        }
      }
      return clone;
    }
    if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
      const result = options.each(item, { ...source, path: path2, key: _key });
      return result;
    }
    for (const key in item) {
      if (key[0] === "_") {
        continue;
      }
      const result = internals.scan(item[key], source, options, [key, ...path2], _key);
      if (result !== undefined) {
        clone = clone || Object.assign({}, item);
        clone[key] = result;
      }
    }
    return clone;
  };
});

// node_modules/@hapi/validate/lib/state.js
var require_state = __commonJS((exports, module) => {
  var Clone = require_clone();
  var Reach = require_reach();
  var Common = require_common();
  var internals = {
    value: Symbol("value")
  };
  module.exports = internals.State = class {
    constructor(path2, ancestors, state) {
      this.path = path2;
      this.ancestors = ancestors;
      this.mainstay = state.mainstay;
      this.schemas = state.schemas;
    }
    localize(path2, ancestors = null, schema = null) {
      const state = new internals.State(path2, ancestors, this);
      if (schema && state.schemas) {
        state.schemas = [internals.schemas(schema), ...state.schemas];
      }
      return state;
    }
    nest(schema) {
      const state = new internals.State(this.path, this.ancestors, this);
      state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
      return state;
    }
    shadow(value, reason) {
      this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow;
      this.mainstay.shadow.set(this.path, value, reason);
    }
    snapshot() {
      if (this.mainstay.shadow) {
        this._snapshot = Clone(this.mainstay.shadow.node(this.path));
      }
    }
    restore() {
      if (this.mainstay.shadow) {
        this.mainstay.shadow.override(this.path, this._snapshot);
        this._snapshot = undefined;
      }
    }
  };
  internals.schemas = function(schema) {
    if (Common.isSchema(schema)) {
      return { schema };
    }
    return schema;
  };
  internals.Shadow = class {
    constructor() {
      this._values = null;
    }
    set(path2, value, reason) {
      if (!path2.length) {
        return;
      }
      if (reason === "strip" && typeof path2[path2.length - 1] === "number") {
        return;
      }
      this._values = this._values || new Map;
      let node = this._values;
      for (let i = 0;i < path2.length; ++i) {
        const segment = path2[i];
        let next = node.get(segment);
        if (!next) {
          next = new Map;
          node.set(segment, next);
        }
        node = next;
      }
      node[internals.value] = value;
    }
    get(path2) {
      const node = this.node(path2);
      if (node) {
        return node[internals.value];
      }
    }
    node(path2) {
      if (!this._values) {
        return;
      }
      return Reach(this._values, path2, { iterables: true });
    }
    override(path2, node) {
      if (!this._values) {
        return;
      }
      const parents = path2.slice(0, -1);
      const own = path2[path2.length - 1];
      const parent = Reach(this._values, parents, { iterables: true });
      if (node) {
        parent.set(own, node);
        return;
      }
      if (parent) {
        parent.delete(own);
      }
    }
  };
});

// node_modules/@hapi/validate/lib/validator.js
var require_validator = __commonJS((exports) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Common = require_common();
  var Errors = require_errors2();
  var State = require_state();
  var internals = {
    result: Symbol("result")
  };
  exports.entry = function(value, schema, prefs) {
    let settings = Common.defaults;
    if (prefs) {
      settings = Common.preferences(Common.defaults, prefs);
    }
    const result = internals.entry(value, schema, settings);
    const outcome = { value: result.value };
    if (result.error) {
      outcome.error = result.error;
    }
    return outcome;
  };
  internals.entry = function(value, schema, prefs) {
    const links = schema._ids._schemaChain ? new Map : null;
    const mainstay = { links };
    const schemas = schema._ids._schemaChain ? [{ schema }] : null;
    const state = new State([], [], { mainstay, schemas });
    const result = exports.validate(value, schema, state, prefs);
    const error = Errors.process(result.errors, value, prefs);
    return { value: result.value, error, mainstay };
  };
  exports.validate = function(value, schema, state, prefs, overrides = {}) {
    if (schema.$_terms.whens) {
      schema = schema._generate(value, state, prefs).schema;
    }
    if (schema._preferences) {
      prefs = internals.prefs(schema, prefs);
    }
    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);
    const helpers = {
      original: value,
      prefs,
      schema,
      state,
      error: createError,
      errorsArray: internals.errorsArray,
      message: (messages, local) => schema.$_createError("custom", value, local, state, prefs, { messages })
    };
    const def = schema._definition;
    if (def.coerce && value !== undefined && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
      const coerced = def.coerce.method(value, helpers);
      if (coerced) {
        if (coerced.errors) {
          return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
        }
        value = coerced.value;
      }
    }
    const empty = schema._flags.empty;
    if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {
      value = undefined;
    }
    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
    if (value === undefined) {
      if (presence === "forbidden") {
        return internals.finalize(value, null, helpers);
      }
      if (presence === "required") {
        return internals.finalize(value, [schema.$_createError("any.required", value, null, state, prefs)], helpers);
      }
      if (presence === "optional") {
        if (schema._flags.default !== Common.symbols.deepDefault) {
          return internals.finalize(value, null, helpers);
        }
        value = {};
      }
    } else if (presence === "forbidden") {
      return internals.finalize(value, [schema.$_createError("any.unknown", value, null, state, prefs)], helpers);
    }
    const errors = [];
    if (schema._valids) {
      const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
      if (match) {
        if (prefs.convert) {
          value = match.value;
        }
        return internals.finalize(value, null, helpers);
      }
      if (schema._flags.only) {
        const report = schema.$_createError("any.only", value, { valids: schema._valids.values({ display: true }) }, state, prefs);
        if (prefs.abortEarly) {
          return internals.finalize(value, [report], helpers);
        }
        errors.push(report);
      }
    }
    if (schema._invalids) {
      const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
      if (match) {
        const report = schema.$_createError("any.invalid", value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
        if (prefs.abortEarly) {
          return internals.finalize(value, [report], helpers);
        }
        errors.push(report);
      }
    }
    if (def.validate) {
      const base = def.validate(value, helpers);
      if (base) {
        value = base.value;
        if (base.errors) {
          if (!Array.isArray(base.errors)) {
            errors.push(base.errors);
            return internals.finalize(value, errors, helpers);
          }
          if (base.errors.length) {
            errors.push(...base.errors);
            return internals.finalize(value, errors, helpers);
          }
        }
      }
    }
    if (!schema._rules.length) {
      return internals.finalize(value, errors, helpers);
    }
    return internals.rules(value, errors, helpers);
  };
  internals.rules = function(value, errors, helpers) {
    const { schema, state, prefs } = helpers;
    for (const rule of schema._rules) {
      const definition = schema._definition.rules[rule.method];
      if (definition.convert && prefs.convert) {
        continue;
      }
      let ret;
      let args = rule.args;
      if (rule._resolve.length) {
        args = Object.assign({}, args);
        for (const key of rule._resolve) {
          const resolver = definition.argsByName.get(key);
          const resolved = args[key].resolve(value, state, prefs);
          const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
          const invalid = Common.validateArg(normalized, null, resolver);
          if (invalid) {
            ret = schema.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
            break;
          }
          args[key] = normalized;
        }
      }
      ret = ret || definition.validate(value, helpers, args, rule);
      const result = internals.rule(ret, rule);
      if (result.errors) {
        if (prefs.abortEarly) {
          return internals.finalize(value, result.errors, helpers);
        }
        errors.push(...result.errors);
      } else {
        value = result.value;
      }
    }
    return internals.finalize(value, errors, helpers);
  };
  internals.rule = function(ret, rule) {
    if (ret instanceof Errors.Report) {
      return { errors: [ret], value: null };
    }
    if (Array.isArray(ret) && ret[Common.symbols.errors]) {
      return { errors: ret, value: null };
    }
    return { errors: null, value: ret };
  };
  internals.finalize = function(value, errors, helpers) {
    errors = errors || [];
    const { schema, state } = helpers;
    if (errors.length) {
      const failover = internals.default("failover", undefined, errors, helpers);
      if (failover !== undefined) {
        value = failover;
        errors = [];
      }
    }
    if (errors.length && schema._flags.error) {
      if (typeof schema._flags.error === "function") {
        errors = schema._flags.error(errors);
        if (!Array.isArray(errors)) {
          errors = [errors];
        }
        for (const error of errors) {
          Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
        }
      } else {
        errors = [schema._flags.error];
      }
    }
    if (value === undefined) {
      const defaulted = internals.default("default", value, errors, helpers);
      value = defaulted;
    }
    if (schema._flags.cast && value !== undefined) {
      const caster = schema._definition.cast[schema._flags.cast];
      if (caster.from(value)) {
        const casted = caster.to(value, helpers);
        value = casted;
      }
    }
    const result = { value, errors: errors.length ? errors : null };
    if (schema._flags.result) {
      result.value = schema._flags.result === "strip" ? undefined : helpers.original;
      state.shadow(value, schema._flags.result);
    }
    return result;
  };
  internals.prefs = function(schema, prefs) {
    const isDefaultOptions = prefs === Common.defaults;
    if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
      return schema._preferences[Common.symbols.prefs];
    }
    prefs = Common.preferences(prefs, schema._preferences);
    if (isDefaultOptions) {
      schema._preferences[Common.symbols.prefs] = prefs;
    }
    return prefs;
  };
  internals.default = function(flag, value, errors, helpers) {
    const { schema, state, prefs } = helpers;
    const source = schema._flags[flag];
    if (prefs.noDefaults || source === undefined) {
      return value;
    }
    if (!source) {
      return source;
    }
    if (typeof source === "function") {
      const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
      try {
        return source(...args);
      } catch (err) {
        errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
        return;
      }
    }
    if (typeof source !== "object") {
      return source;
    }
    if (source[Common.symbols.literal]) {
      return source.literal;
    }
    if (Common.isResolvable(source)) {
      return source.resolve(value, state, prefs);
    }
    return Clone(source);
  };
  internals.trim = function(value, schema) {
    if (typeof value !== "string") {
      return value;
    }
    const trim = schema.$_getRule("trim");
    if (!trim || !trim.args.enabled) {
      return value;
    }
    return value.trim();
  };
  internals.errorsArray = function() {
    const errors = [];
    errors[Common.symbols.errors] = true;
    return errors;
  };
});

// node_modules/@hapi/validate/lib/values.js
var require_values = __commonJS((exports, module) => {
  var Assert = require_assert();
  var DeepEqual = require_deepEqual();
  var Common = require_common();
  var internals = {};
  module.exports = internals.Values = class {
    constructor(values, refs) {
      this._values = new Set(values);
      this._refs = new Set(refs);
      this._lowercase = internals.lowercases(values);
      this._override = false;
    }
    get length() {
      return this._values.size + this._refs.size;
    }
    add(value, refs) {
      if (Common.isResolvable(value)) {
        if (!this._refs.has(value)) {
          this._refs.add(value);
          if (refs) {
            refs.register(value);
          }
        }
        return;
      }
      if (!this.has(value, null, null, false)) {
        this._values.add(value);
        if (typeof value === "string") {
          this._lowercase.set(value.toLowerCase(), value);
        }
      }
    }
    static merge(target, source, remove) {
      target = target || new internals.Values;
      if (source) {
        if (source._override) {
          return source.clone();
        }
        for (const item of [...source._values, ...source._refs]) {
          target.add(item);
        }
      }
      if (remove) {
        for (const item of [...remove._values, ...remove._refs]) {
          target.remove(item);
        }
      }
      return target.length ? target : null;
    }
    remove(value) {
      if (Common.isResolvable(value)) {
        this._refs.delete(value);
        return;
      }
      this._values.delete(value);
      if (typeof value === "string") {
        this._lowercase.delete(value.toLowerCase());
      }
    }
    has(value, state, prefs, insensitive) {
      return !!this.get(value, state, prefs, insensitive);
    }
    get(value, state, prefs, insensitive) {
      if (!this.length) {
        return false;
      }
      if (this._values.has(value)) {
        return { value };
      }
      if (typeof value === "string" && value && insensitive) {
        const found = this._lowercase.get(value.toLowerCase());
        if (found) {
          return { value: found };
        }
      }
      if (!this._refs.size && typeof value !== "object") {
        return false;
      }
      if (typeof value === "object") {
        for (const item of this._values) {
          if (DeepEqual(item, value)) {
            return { value: item };
          }
        }
      }
      if (state) {
        for (const ref of this._refs) {
          const resolved = ref.resolve(value, state, prefs, null, { in: true });
          if (resolved === undefined) {
            continue;
          }
          const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
          for (const item of items) {
            if (typeof item !== typeof value) {
              continue;
            }
            if (insensitive && value && typeof value === "string") {
              if (item.toLowerCase() === value.toLowerCase()) {
                return { value: item, ref };
              }
            } else {
              if (DeepEqual(item, value)) {
                return { value: item, ref };
              }
            }
          }
        }
      }
      return false;
    }
    override() {
      this._override = true;
    }
    values(options) {
      if (options && options.display) {
        const values = [];
        for (const item of [...this._values, ...this._refs]) {
          if (item !== undefined) {
            values.push(item);
          }
        }
        return values;
      }
      return Array.from([...this._values, ...this._refs]);
    }
    clone() {
      const set = new internals.Values(this._values, this._refs);
      set._override = this._override;
      return set;
    }
    concat(source) {
      Assert(!source._override, "Cannot concat override set of values");
      const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
      set._override = this._override;
      return set;
    }
  };
  internals.Values.prototype[Common.symbols.values] = true;
  internals.Values.prototype.slice = internals.Values.prototype.clone;
  internals.lowercases = function(from) {
    const map = new Map;
    if (from) {
      for (const value of from) {
        if (typeof value === "string") {
          map.set(value.toLowerCase(), value);
        }
      }
    }
    return map;
  };
});

// node_modules/@hapi/validate/lib/base.js
var require_base = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var DeepEqual = require_deepEqual();
  var Merge = require_merge();
  var Common = require_common();
  var Compile = require_compile();
  var Errors = require_errors2();
  var Extend = require_extend();
  var Messages = require_messages2();
  var Modify = require_modify();
  var Ref = require_ref();
  var Validator = require_validator();
  var Values = require_values();
  var internals = {};
  internals.Base = class {
    constructor(type) {
      this.type = type;
      this.$_root = null;
      this._definition = {};
      this._ids = new Modify.Ids;
      this._preferences = null;
      this._refs = new Ref.Manager;
      this._cache = null;
      this._valids = null;
      this._invalids = null;
      this._flags = {};
      this._rules = [];
      this._singleRules = new Map;
      this.$_terms = {};
      this.$_temp = {
        whens: {}
      };
    }
    allow(...values) {
      Common.verifyFlat(values, "allow");
      return this._values(values, "_valids");
    }
    cast(to) {
      Assert(to === false || typeof to === "string", "Invalid to value");
      Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
      return this.$_setFlag("cast", to === false ? undefined : to);
    }
    default(value, options) {
      return this._default("default", value, options);
    }
    empty(schema) {
      const obj = this.clone();
      if (schema !== undefined) {
        schema = obj.$_compile(schema, { override: false });
      }
      return obj.$_setFlag("empty", schema, { clone: false });
    }
    error(err) {
      Assert(err, "Missing error");
      Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
      return this.$_setFlag("error", err);
    }
    failover(value, options) {
      return this._default("failover", value, options);
    }
    forbidden() {
      return this.presence("forbidden");
    }
    id(id) {
      if (!id) {
        return this.$_setFlag("id", undefined);
      }
      Assert(typeof id === "string", "id must be a non-empty string");
      Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
      return this.$_setFlag("id", id);
    }
    invalid(...values) {
      return this._values(values, "_invalids");
    }
    only(mode = true) {
      Assert(typeof mode === "boolean", "Invalid mode:", mode);
      return this.$_setFlag("only", mode);
    }
    optional() {
      return this.presence("optional");
    }
    prefs(prefs) {
      Assert(prefs, "Missing preferences");
      Assert(prefs.context === undefined, "Cannot override context");
      Common.checkPreferences(prefs);
      const obj = this.clone();
      obj._preferences = Common.preferences(obj._preferences, prefs);
      return obj;
    }
    presence(mode) {
      Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
      return this.$_setFlag("presence", mode);
    }
    raw(enabled = true) {
      return this.$_setFlag("result", enabled ? "raw" : undefined);
    }
    required() {
      return this.presence("required");
    }
    strict(enabled) {
      const obj = this.clone();
      const convert = enabled === undefined ? false : !enabled;
      obj._preferences = Common.preferences(obj._preferences, { convert });
      return obj;
    }
    strip(enabled = true) {
      return this.$_setFlag("result", enabled ? "strip" : undefined);
    }
    valid(...values) {
      Common.verifyFlat(values, "valid");
      const obj = this.allow(...values);
      obj.$_setFlag("only", !!obj._valids, { clone: false });
      return obj;
    }
    when(condition, options) {
      const obj = this.clone();
      if (!obj.$_terms.whens) {
        obj.$_terms.whens = [];
      }
      const when = Compile.when(obj, condition, options);
      if (!["any", "link"].includes(obj.type)) {
        const conditions = when.is ? [when] : when.switch;
        for (const item of conditions) {
          Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then?.type);
          Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise?.type);
        }
      }
      obj.$_terms.whens.push(when);
      return obj.$_mutateRebuild();
    }
    clone() {
      const obj = Object.create(Object.getPrototypeOf(this));
      return this._assign(obj);
    }
    concat(source) {
      Assert(Common.isSchema(source), "Invalid schema object");
      Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
      let obj = this.clone();
      if (this.type === "any" && source.type !== "any") {
        const tmpObj = source.clone();
        for (const key of Object.keys(obj)) {
          if (key !== "type") {
            tmpObj[key] = obj[key];
          }
        }
        obj = tmpObj;
      }
      obj._ids.concat(source._ids);
      obj._refs.register(source, Ref.toSibling);
      obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
      obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
      obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
      for (const name of source._singleRules.keys()) {
        if (obj._singleRules.has(name)) {
          obj._rules = obj._rules.filter((target) => target.name !== name);
          obj._singleRules.delete(name);
        }
      }
      for (const test of source._rules) {
        if (!source._definition.rules[test.method].multi) {
          obj._singleRules.set(test.name, test);
        }
        obj._rules.push(test);
      }
      if (obj._flags.empty && source._flags.empty) {
        obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
        const flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else if (source._flags.empty) {
        obj._flags.empty = source._flags.empty;
        const flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else {
        Merge(obj._flags, source._flags);
      }
      for (const key in source.$_terms) {
        const terms = source.$_terms[key];
        if (!terms) {
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms;
          }
          continue;
        }
        if (!obj.$_terms[key]) {
          obj.$_terms[key] = terms.slice();
          continue;
        }
        obj.$_terms[key] = obj.$_terms[key].concat(terms);
      }
      return obj.$_mutateRebuild();
    }
    validate(value, options) {
      return Validator.entry(value, this, options);
    }
    validateAsync(value, options) {
      const result = this.validate(value, options);
      if (result.error) {
        throw result.error;
      }
      return result.value;
    }
    $_addRule(options) {
      if (typeof options === "string") {
        options = { name: options };
      }
      Assert(options && typeof options === "object", "Invalid options");
      Assert(options.name && typeof options.name === "string", "Invalid rule name");
      for (const key in options) {
        Assert(key[0] !== "_", "Cannot set private rule properties");
      }
      const rule = Object.assign({}, options);
      rule._resolve = [];
      rule.method = rule.method || rule.name;
      const definition = this._definition.rules[rule.method];
      const args = rule.args;
      Assert(definition, "Unknown rule", rule.method);
      const obj = this.clone();
      if (args) {
        Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
        for (const key in args) {
          let arg = args[key];
          if (arg === undefined) {
            delete args[key];
            continue;
          }
          if (definition.argsByName) {
            const resolver = definition.argsByName.get(key);
            if (resolver.ref && Common.isResolvable(arg)) {
              rule._resolve.push(key);
              obj.$_mutateRegister(arg);
            } else {
              if (resolver.normalize) {
                arg = resolver.normalize(arg);
                args[key] = arg;
              }
              if (resolver.assert) {
                const error = Common.validateArg(arg, key, resolver);
                Assert(!error, error, "or reference");
              }
            }
          }
          args[key] = arg;
        }
      }
      if (!definition.multi) {
        obj._ruleRemove(rule.name);
        obj._singleRules.set(rule.name, rule);
      }
      if (definition.priority) {
        obj._rules.unshift(rule);
      } else {
        obj._rules.push(rule);
      }
      return obj;
    }
    $_compile(schema, options) {
      return Compile.schema(this.$_root, schema, options);
    }
    $_createError(code, value, local, state, prefs, options = {}) {
      const flags = options.flags !== false ? this._flags : {};
      const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
      return new Errors.Report(code, value, local, flags, messages, state, prefs);
    }
    $_getRule(name) {
      return this._singleRules.get(name);
    }
    $_match(value, state, prefs, overrides) {
      prefs = Object.assign({}, prefs);
      prefs.abortEarly = true;
      prefs._externals = false;
      state.snapshot();
      const result = !Validator.validate(value, this, state, prefs, overrides).errors;
      state.restore();
      return result;
    }
    $_modify(options) {
      Common.assertOptions(options, ["each", "once", "ref", "schema"]);
      return Modify.schema(this, options) || this;
    }
    $_mutateRebuild() {
      this._refs.reset();
      this._ids.reset();
      const each = (item, { source, name, path: path2, key }) => {
        const family = this._definition[source][name]?.register;
        if (family !== false) {
          this.$_mutateRegister(item, { family, key });
        }
      };
      this.$_modify({ each });
      if (this._definition.rebuild) {
        this._definition.rebuild(this);
      }
      return this;
    }
    $_mutateRegister(schema, { family, key } = {}) {
      this._refs.register(schema, family);
      this._ids.register(schema, { key });
    }
    $_property(name) {
      return this._definition.properties[name];
    }
    $_reach(path2) {
      return this._ids.reach(path2);
    }
    $_rootReferences() {
      return this._refs.roots();
    }
    $_setFlag(name, value, options = {}) {
      const flag = this._definition.flags[name] || {};
      if (DeepEqual(value, flag.default)) {
        value = undefined;
      }
      if (DeepEqual(value, this._flags[name])) {
        return this;
      }
      const obj = options.clone !== false ? this.clone() : this;
      if (value !== undefined) {
        obj._flags[name] = value;
        obj.$_mutateRegister(value);
      } else {
        delete obj._flags[name];
      }
      return obj;
    }
    $_parent(method, ...args) {
      return this[method][Common.symbols.parent].call(this, ...args);
    }
    $_validate(value, state, prefs) {
      return Validator.validate(value, this, state, prefs);
    }
    _assign(target) {
      target.type = this.type;
      target.$_root = this.$_root;
      target.$_temp = Object.assign({}, this.$_temp);
      target.$_temp.whens = {};
      target._ids = this._ids.clone();
      target._preferences = this._preferences;
      target._valids = this._valids?.clone();
      target._invalids = this._invalids?.clone();
      target._rules = this._rules.slice();
      target._singleRules = Clone(this._singleRules, { shallow: true });
      target._refs = this._refs.clone();
      target._flags = Object.assign({}, this._flags);
      target._cache = null;
      target.$_terms = {};
      for (const key in this.$_terms) {
        target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
      }
      target.$_super = {};
      for (const override in this.$_super) {
        target.$_super[override] = this._super[override].bind(target);
      }
      return target;
    }
    _default(flag, value, options = {}) {
      Common.assertOptions(options, "literal");
      Assert(value !== undefined, "Missing", flag, "value");
      Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
      if (typeof value === "function" && options.literal) {
        value = {
          [Common.symbols.literal]: true,
          literal: value
        };
      }
      const obj = this.$_setFlag(flag, value);
      return obj;
    }
    _extend(options) {
      Assert(!options.base, "Cannot extend type with another base");
      return Extend.type(this, options);
    }
    _generate(value, state, prefs) {
      if (!this.$_terms.whens) {
        return { schema: this };
      }
      const whens = [];
      const ids = [];
      for (let i = 0;i < this.$_terms.whens.length; ++i) {
        const when = this.$_terms.whens[i];
        if (when.concat) {
          whens.push(when.concat);
          ids.push(`${i}.concat`);
          continue;
        }
        const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
        const tests = when.is ? [when] : when.switch;
        const before = ids.length;
        for (let j = 0;j < tests.length; ++j) {
          const { is, then, otherwise } = tests[j];
          const baseId = `${i}${when.switch ? "." + j : ""}`;
          if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
            if (then) {
              const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
              break;
            }
          } else if (otherwise) {
            const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
            const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
            whens.push(generated);
            ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
            break;
          }
        }
        if (when.break && ids.length > before) {
          break;
        }
      }
      const id = ids.join(", ");
      if (!id) {
        return { schema: this };
      }
      if (this.$_temp.whens[id]) {
        return { schema: this.$_temp.whens[id], id };
      }
      let obj = this;
      if (this._definition.generate) {
        obj = this._definition.generate(this, value, state, prefs);
      }
      for (const when of whens) {
        obj = obj.concat(when);
      }
      this.$_temp.whens[id] = obj;
      return { schema: obj, id };
    }
    _ruleRemove(name) {
      if (!this._singleRules.has(name)) {
        return this;
      }
      this._singleRules.delete(name);
      const filtered = [];
      for (let i = 0;i < this._rules.length; ++i) {
        const test = this._rules[i];
        if (test.name === name) {
          continue;
        }
        filtered.push(test);
      }
      this._rules = filtered;
    }
    _values(values, key) {
      Common.verifyFlat(values, key.slice(1, -1));
      const obj = this.clone();
      const override = values[0] === Common.symbols.override;
      if (override) {
        values = values.slice(1);
      }
      if (!obj[key] && values.length) {
        obj[key] = new Values;
      } else if (override) {
        obj[key] = values.length ? new Values : null;
        obj.$_mutateRebuild();
      }
      if (!obj[key]) {
        return obj;
      }
      if (override) {
        obj[key].override();
      }
      for (const value of values) {
        Assert(value !== undefined, "Cannot call allow/valid/invalid with undefined");
        Assert(value !== Common.symbols.override, "Override must be the first value");
        const other = key === "_invalids" ? "_valids" : "_invalids";
        if (obj[other]) {
          obj[other].remove(value);
          if (!obj[other].length) {
            Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
            obj[other] = null;
          }
        }
        obj[key].add(value, obj._refs);
      }
      return obj;
    }
  };
  internals.Base.prototype[Common.symbols.any] = {
    version: Common.version,
    compile: Compile.compile,
    root: "$_root"
  };
  internals.Base.prototype.isImmutable = true;
  internals.Base.prototype.deny = internals.Base.prototype.invalid;
  internals.Base.prototype.disallow = internals.Base.prototype.invalid;
  internals.Base.prototype.equal = internals.Base.prototype.valid;
  internals.Base.prototype.exist = internals.Base.prototype.required;
  internals.Base.prototype.not = internals.Base.prototype.invalid;
  internals.Base.prototype.options = internals.Base.prototype.prefs;
  internals.Base.prototype.preferences = internals.Base.prototype.prefs;
  module.exports = new internals.Base;
});

// node_modules/@hapi/validate/lib/types/any.js
var require_any = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Base = require_base();
  var Common = require_common();
  module.exports = Base._extend({
    type: "any",
    flags: {
      only: { default: false }
    },
    terms: {
      alterations: { init: null },
      examples: { init: null },
      metas: { init: [] },
      notes: { init: [] },
      shared: { init: null },
      tags: { init: [] },
      whens: { init: null }
    },
    rules: {
      custom: {
        method(method, description) {
          Assert(typeof method === "function", "Method must be a function");
          Assert(description === undefined || description && typeof description === "string", "Description must be a non-empty string");
          return this.$_addRule({ name: "custom", args: { method, description } });
        },
        validate(value, helpers, { method }) {
          try {
            return method(value, helpers);
          } catch (err) {
            return helpers.error("any.custom", { error: err });
          }
        },
        args: ["method", "description"],
        multi: true
      },
      messages: {
        method(messages) {
          return this.prefs({ messages });
        }
      },
      shared: {
        method(schema) {
          Assert(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
          const obj = this.clone();
          obj.$_terms.shared = obj.$_terms.shared || [];
          obj.$_terms.shared.push(schema);
          obj.$_mutateRegister(schema);
          return obj;
        }
      }
    },
    messages: {
      "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
      "any.default": "{{#label}} threw an error when running default method",
      "any.failover": "{{#label}} threw an error when running failover method",
      "any.invalid": "{{#label}} contains an invalid value",
      "any.only": "{{#label}} must be one of {{#valids}}",
      "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
      "any.required": "{{#label}} is required",
      "any.unknown": "{{#label}} is not allowed"
    }
  });
});

// node_modules/@hapi/validate/lib/types/alternatives.js
var require_alternatives = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common();
  var Compile = require_compile();
  var Errors = require_errors2();
  var Ref = require_ref();
  var internals = {};
  module.exports = Any._extend({
    type: "alternatives",
    flags: {
      match: { default: "any" }
    },
    terms: {
      matches: { init: [], register: Ref.toSibling }
    },
    args(schema, ...schemas) {
      if (schemas.length === 1) {
        if (Array.isArray(schemas[0])) {
          return schema.try(...schemas[0]);
        }
      }
      return schema.try(...schemas);
    },
    validate(value, helpers) {
      const { schema, error, state, prefs } = helpers;
      if (schema._flags.match) {
        let hits = 0;
        let matched;
        for (let i = 0;i < schema.$_terms.matches.length; ++i) {
          const item = schema.$_terms.matches[i];
          const localState = state.nest(item.schema, `match.${i}`);
          localState.snapshot();
          const result = item.schema.$_validate(value, localState, prefs);
          if (!result.errors) {
            ++hits;
            matched = result.value;
          } else {
            localState.restore();
          }
        }
        if (!hits) {
          return { errors: error("alternatives.any") };
        }
        if (schema._flags.match === "one") {
          return hits === 1 ? { value: matched } : { errors: error("alternatives.one") };
        }
        return hits === schema.$_terms.matches.length ? { value } : { errors: error("alternatives.all") };
      }
      const errors = [];
      for (let i = 0;i < schema.$_terms.matches.length; ++i) {
        const item = schema.$_terms.matches[i];
        if (item.schema) {
          const localState = state.nest(item.schema, `match.${i}`);
          localState.snapshot();
          const result = item.schema.$_validate(value, localState, prefs);
          if (!result.errors) {
            return result;
          }
          localState.restore();
          errors.push({ schema: item.schema, reports: result.errors });
          continue;
        }
        const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
        const tests = item.is ? [item] : item.switch;
        for (let j = 0;j < tests.length; ++j) {
          const test = tests[j];
          const { is, then, otherwise } = test;
          const id = `match.${i}${item.switch ? "." + j : ""}`;
          if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
            if (otherwise) {
              return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
            }
          } else if (then) {
            return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
          }
        }
      }
      return internals.errors(errors, helpers);
    },
    rules: {
      conditional: {
        method(condition, options) {
          Assert(!this._flags._endedSwitch, "Unreachable condition");
          Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
          Assert(options.break === undefined, "Cannot use break option with alternatives conditional");
          const obj = this.clone();
          const match = Compile.when(obj, condition, options);
          const conditions = match.is ? [match] : match.switch;
          for (const item of conditions) {
            if (item.then && item.otherwise) {
              obj.$_setFlag("_endedSwitch", true, { clone: false });
              break;
            }
          }
          obj.$_terms.matches.push(match);
          return obj.$_mutateRebuild();
        }
      },
      match: {
        method(mode) {
          Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
          if (mode !== "any") {
            for (const match of this.$_terms.matches) {
              Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
            }
          }
          return this.$_setFlag("match", mode);
        }
      },
      try: {
        method(...schemas) {
          Assert(schemas.length, "Missing alternative schemas");
          Common.verifyFlat(schemas, "try");
          Assert(!this._flags._endedSwitch, "Unreachable condition");
          const obj = this.clone();
          for (const schema of schemas) {
            obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
          }
          return obj.$_mutateRebuild();
        }
      }
    },
    rebuild(schema) {
      const each = (item) => {
        if (Common.isSchema(item) && item.type === "array") {
          schema.$_setFlag("_arrayItems", true, { clone: false });
        }
      };
      schema.$_modify({ each });
    },
    messages: {
      "alternatives.all": "{{#label}} does not match all of the required types",
      "alternatives.any": "{{#label}} does not match any of the allowed types",
      "alternatives.match": "{{#label}} does not match any of the allowed types",
      "alternatives.one": "{{#label}} matches more than one allowed type",
      "alternatives.types": "{{#label}} must be one of {{#types}}"
    }
  });
  internals.errors = function(failures, { error, state }) {
    if (!failures.length) {
      return { errors: error("alternatives.any") };
    }
    if (failures.length === 1) {
      return { errors: failures[0].reports };
    }
    const valids = new Set;
    const complex = [];
    for (const { reports, schema } of failures) {
      if (reports.length > 1) {
        return internals.unmatched(failures, error);
      }
      const report = reports[0];
      if (report instanceof Errors.Report === false) {
        return internals.unmatched(failures, error);
      }
      if (report.state.path.length !== state.path.length) {
        complex.push({ type: schema.type, report });
        continue;
      }
      if (report.code === "any.only") {
        for (const valid of report.local.valids) {
          valids.add(valid);
        }
        continue;
      }
      const [type, code] = report.code.split(".");
      if (code !== "base") {
        complex.push({ type: schema.type, report });
        continue;
      }
      valids.add(type);
    }
    if (!complex.length) {
      return { errors: error("alternatives.types", { types: [...valids] }) };
    }
    if (complex.length === 1) {
      return { errors: complex[0].report };
    }
    return internals.unmatched(failures, error);
  };
  internals.unmatched = function(failures, error) {
    const errors = [];
    for (const failure of failures) {
      errors.push(...failure.reports);
    }
    return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
  };
});

// node_modules/@hapi/validate/lib/types/array.js
var require_array = __commonJS((exports, module) => {
  var Assert = require_assert();
  var DeepEqual = require_deepEqual();
  var Reach = require_reach();
  var Any = require_any();
  var Common = require_common();
  var Compile = require_compile();
  var internals = {};
  module.exports = Any._extend({
    type: "array",
    flags: {
      single: { default: false },
      sparse: { default: false }
    },
    terms: {
      items: { init: [] },
      ordered: { init: [] },
      _exclusions: { init: [] },
      _inclusions: { init: [] },
      _requireds: { init: [] }
    },
    coerce: {
      from: "object",
      method(value, { schema, state, prefs }) {
        if (!Array.isArray(value)) {
          return;
        }
        const sort = schema.$_getRule("sort");
        if (!sort) {
          return;
        }
        return internals.sort(schema, value, sort.args.options, state, prefs);
      }
    },
    validate(value, { schema, error }) {
      if (!Array.isArray(value)) {
        if (schema._flags.single) {
          const single = [value];
          single[Common.symbols.arraySingle] = true;
          return { value: single };
        }
        return { errors: error("array.base") };
      }
      if (!schema.$_getRule("items")) {
        return;
      }
      return { value: value.slice() };
    },
    rules: {
      has: {
        method(schema) {
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.$_addRule({ name: "has", args: { schema } });
          obj.$_mutateRegister(schema);
          return obj;
        },
        validate(value, { state, prefs, error }, { schema: has }) {
          const ancestors = [value, ...state.ancestors];
          for (let i = 0;i < value.length; ++i) {
            const localState = state.localize([...state.path, i], ancestors, has);
            if (has.$_match(value[i], localState, prefs)) {
              return value;
            }
          }
          return error("array.hasUnknown", null);
        },
        multi: true
      },
      items: {
        method(...schemas) {
          Common.verifyFlat(schemas, "items");
          const obj = this.$_addRule("items");
          for (let i = 0;i < schemas.length; ++i) {
            const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
            obj.$_terms.items.push(type);
          }
          return obj.$_mutateRebuild();
        },
        validate(value, { schema, error, state, prefs, errorsArray }) {
          const requireds = schema.$_terms._requireds.slice();
          const ordereds = schema.$_terms.ordered.slice();
          const inclusions = [...schema.$_terms._inclusions, ...requireds];
          const wasArray = !value[Common.symbols.arraySingle];
          delete value[Common.symbols.arraySingle];
          const errors = errorsArray();
          let il = value.length;
          for (let i = 0;i < il; ++i) {
            const item = value[i];
            let errored = false;
            let isValid = false;
            const key = wasArray ? i : new Number(i);
            const path2 = [...state.path, key];
            if (!schema._flags.sparse && item === undefined) {
              errors.push(error("array.sparse", { key, path: path2, pos: i, value: undefined }, state.localize(path2)));
              if (prefs.abortEarly) {
                return errors;
              }
              ordereds.shift();
              continue;
            }
            const ancestors = [value, ...state.ancestors];
            for (const exclusion of schema.$_terms._exclusions) {
              if (!exclusion.$_match(item, state.localize(path2, ancestors, exclusion), prefs, { presence: "ignore" })) {
                continue;
              }
              errors.push(error("array.excludes", { pos: i, value: item }, state.localize(path2)));
              if (prefs.abortEarly) {
                return errors;
              }
              errored = true;
              ordereds.shift();
              break;
            }
            if (errored) {
              continue;
            }
            if (schema.$_terms.ordered.length) {
              if (ordereds.length) {
                const ordered = ordereds.shift();
                const res = ordered.$_validate(item, state.localize(path2, ancestors, ordered), prefs);
                if (!res.errors) {
                  if (ordered._flags.result === "strip") {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                  } else if (!schema._flags.sparse && res.value === undefined) {
                    errors.push(error("array.sparse", { key, path: path2, pos: i, value: undefined }, state.localize(path2)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                    continue;
                  } else {
                    value[i] = res.value;
                  }
                } else {
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                }
                continue;
              } else if (!schema.$_terms.items.length) {
                errors.push(error("array.orderedLength", { pos: i, limit: schema.$_terms.ordered.length }));
                if (prefs.abortEarly) {
                  return errors;
                }
                break;
              }
            }
            const requiredChecks = [];
            let jl = requireds.length;
            for (let j = 0;j < jl; ++j) {
              const localState = state.localize(path2, ancestors, requireds[j]);
              localState.snapshot();
              const res = requireds[j].$_validate(item, localState, prefs);
              requiredChecks[j] = res;
              if (!res.errors) {
                value[i] = res.value;
                isValid = true;
                internals.fastSplice(requireds, j);
                --j;
                --jl;
                if (!schema._flags.sparse && res.value === undefined) {
                  errors.push(error("array.sparse", { key, path: path2, pos: i, value: undefined }, state.localize(path2)));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                }
                break;
              }
              localState.restore();
            }
            if (isValid) {
              continue;
            }
            const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
            jl = inclusions.length;
            for (const inclusion of inclusions) {
              let res;
              const previousCheck = requireds.indexOf(inclusion);
              if (previousCheck !== -1) {
                res = requiredChecks[previousCheck];
              } else {
                const localState = state.localize(path2, ancestors, inclusion);
                localState.snapshot();
                res = inclusion.$_validate(item, localState, prefs);
                if (!res.errors) {
                  if (inclusion._flags.result === "strip") {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                  } else if (!schema._flags.sparse && res.value === undefined) {
                    errors.push(error("array.sparse", { key, path: path2, pos: i, value: undefined }, state.localize(path2)));
                    errored = true;
                  } else {
                    value[i] = res.value;
                  }
                  isValid = true;
                  break;
                }
                localState.restore();
              }
              if (jl === 1) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  isValid = true;
                  break;
                }
                errors.push(...res.errors);
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                break;
              }
            }
            if (errored) {
              continue;
            }
            if (schema.$_terms._inclusions.length && !isValid) {
              if (stripUnknown) {
                internals.fastSplice(value, i);
                --i;
                --il;
                continue;
              }
              errors.push(error("array.includes", { pos: i, value: item }, state.localize(path2)));
              if (prefs.abortEarly) {
                return errors;
              }
            }
          }
          if (requireds.length) {
            internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
          }
          if (ordereds.length) {
            internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
          }
          return errors.length ? errors : value;
        },
        priority: true
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value.length, limit, operator)) {
            return value;
          }
          return helpers.error("array." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      },
      ordered: {
        method(...schemas) {
          Common.verifyFlat(schemas, "ordered");
          const obj = this.$_addRule("items");
          for (let i = 0;i < schemas.length; ++i) {
            const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
            internals.validateSingle(type, obj);
            obj.$_mutateRegister(type);
            obj.$_terms.ordered.push(type);
          }
          return obj.$_mutateRebuild();
        }
      },
      single: {
        method(enabled) {
          const value = enabled === undefined ? true : !!enabled;
          Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
          return this.$_setFlag("single", value);
        }
      },
      sort: {
        method(options = {}) {
          Common.assertOptions(options, ["by", "order"]);
          const settings = {
            order: options.order || "ascending"
          };
          if (options.by) {
            settings.by = Compile.ref(options.by, { ancestor: 0 });
            Assert(!settings.by.ancestor, "Cannot sort by ancestor");
          }
          return this.$_addRule({ name: "sort", args: { options: settings } });
        },
        validate(value, { error, state, prefs, schema }, { options }) {
          const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
          if (errors) {
            return errors;
          }
          for (let i = 0;i < value.length; ++i) {
            if (value[i] !== sorted[i]) {
              return error("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
            }
          }
          return value;
        },
        convert: true
      },
      sparse: {
        method(enabled) {
          const value = enabled === undefined ? true : !!enabled;
          if (this._flags.sparse === value) {
            return this;
          }
          const obj = value ? this.clone() : this.$_addRule("items");
          return obj.$_setFlag("sparse", value, { clone: false });
        }
      },
      unique: {
        method(comparator, options = {}) {
          Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
          Common.assertOptions(options, ["ignoreUndefined", "separator"]);
          const rule = { name: "unique", args: { options, comparator } };
          if (comparator) {
            if (typeof comparator === "string") {
              const separator = Common.default(options.separator, ".");
              rule.path = separator ? comparator.split(separator) : [comparator];
            } else {
              rule.comparator = comparator;
            }
          }
          return this.$_addRule(rule);
        },
        validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path: path2 }) {
          const found = {
            string: Object.create(null),
            number: Object.create(null),
            undefined: Object.create(null),
            boolean: Object.create(null),
            object: new Map,
            function: new Map,
            custom: new Map
          };
          const compare = comparator || DeepEqual;
          const ignoreUndefined = options.ignoreUndefined;
          for (let i = 0;i < value.length; ++i) {
            const item = path2 ? Reach(value[i], path2) : value[i];
            const records = comparator ? found.custom : found[typeof item];
            Assert(records, "Failed to find unique map container for type", typeof item);
            if (records instanceof Map) {
              const entries = records.entries();
              let current;
              while (!(current = entries.next()).done) {
                if (compare(current.value[0], item)) {
                  const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: current.value[1],
                    dupeValue: value[current.value[1]]
                  };
                  if (path2) {
                    context.path = raw;
                  }
                  return error("array.unique", context, localState);
                }
              }
              records.set(item, i);
            } else {
              if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {
                const context = {
                  pos: i,
                  value: value[i],
                  dupePos: records[item],
                  dupeValue: value[records[item]]
                };
                if (path2) {
                  context.path = raw;
                }
                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                return error("array.unique", context, localState);
              }
              records[item] = i;
            }
          }
          return value;
        },
        args: ["comparator", "options"],
        multi: true
      }
    },
    cast: {
      set: {
        from: Array.isArray,
        to(value, helpers) {
          return new Set(value);
        }
      }
    },
    rebuild(schema) {
      schema.$_terms._inclusions = [];
      schema.$_terms._exclusions = [];
      schema.$_terms._requireds = [];
      for (const type of schema.$_terms.items) {
        internals.validateSingle(type, schema);
        if (type._flags.presence === "required") {
          schema.$_terms._requireds.push(type);
        } else if (type._flags.presence === "forbidden") {
          schema.$_terms._exclusions.push(type);
        } else {
          schema.$_terms._inclusions.push(type);
        }
      }
      for (const type of schema.$_terms.ordered) {
        internals.validateSingle(type, schema);
      }
    },
    messages: {
      "array.base": "{{#label}} must be an array",
      "array.excludes": "{{#label}} contains an excluded value",
      "array.hasUnknown": "{{#label}} does not contain at least one required match",
      "array.includes": "{{#label}} does not match any of the allowed types",
      "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
      "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
      "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
      "array.length": "{{#label}} must contain {{#limit}} items",
      "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
      "array.min": "{{#label}} must contain at least {{#limit}} items",
      "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
      "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
      "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
      "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
      "array.sparse": "{{#label}} must not be a sparse array item",
      "array.unique": "{{#label}} contains a duplicate value"
    }
  });
  internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
    let unknownMisses = 0;
    for (let i = 0;i < requireds.length; ++i) {
      ++unknownMisses;
    }
    errors.push(schema.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
  };
  internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
    const requiredOrdereds = [];
    for (const ordered of ordereds) {
      if (ordered._flags.presence === "required") {
        requiredOrdereds.push(ordered);
      }
    }
    if (requiredOrdereds.length) {
      internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
    }
  };
  internals.fastSplice = function(arr, i) {
    let pos = i;
    while (pos < arr.length) {
      arr[pos++] = arr[pos];
    }
    --arr.length;
  };
  internals.validateSingle = function(type, obj) {
    if (type.type === "array" || type._flags._arrayItems) {
      Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
      obj.$_setFlag("_arrayItems", true, { clone: false });
    }
  };
  internals.sort = function(schema, value, settings, state, prefs) {
    const order = settings.order === "ascending" ? 1 : -1;
    const aFirst = -1 * order;
    const bFirst = order;
    const sort = (a, b) => {
      let compare = internals.compare(a, b, aFirst, bFirst);
      if (compare !== null) {
        return compare;
      }
      if (settings.by) {
        a = settings.by.resolve(a, state, prefs);
        b = settings.by.resolve(b, state, prefs);
      }
      compare = internals.compare(a, b, aFirst, bFirst);
      if (compare !== null) {
        return compare;
      }
      const type = typeof a;
      if (type !== typeof b) {
        throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
      }
      if (type !== "number" && type !== "string") {
        throw schema.$_createError("array.sort.unsupported", value, { type }, state, prefs);
      }
      if (type === "number") {
        return (a - b) * order;
      }
      return a < b ? aFirst : bFirst;
    };
    try {
      return { value: value.slice().sort(sort) };
    } catch (err) {
      return { errors: err };
    }
  };
  internals.compare = function(a, b, aFirst, bFirst) {
    if (a === b) {
      return 0;
    }
    if (a === undefined) {
      return 1;
    }
    if (b === undefined) {
      return -1;
    }
    if (a === null) {
      return bFirst;
    }
    if (b === null) {
      return aFirst;
    }
    return null;
  };
});

// node_modules/@hapi/validate/lib/types/boolean.js
var require_boolean = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common();
  var Values = require_values();
  var internals = {};
  internals.isBool = function(value) {
    return typeof value === "boolean";
  };
  module.exports = Any._extend({
    type: "boolean",
    flags: {
      sensitive: { default: false }
    },
    terms: {
      falsy: {
        init: null
      },
      truthy: {
        init: null
      }
    },
    coerce(value, { schema }) {
      if (typeof value === "boolean") {
        return;
      }
      if (typeof value === "string") {
        const normalized = schema._flags.sensitive ? value : value.toLowerCase();
        value = normalized === "true" ? true : normalized === "false" ? false : value;
      }
      if (typeof value !== "boolean") {
        value = schema.$_terms.truthy?.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy?.has(value, null, null, !schema._flags.sensitive) ? false : value);
      }
      return { value };
    },
    validate(value, { error }) {
      if (typeof value !== "boolean") {
        return { value, errors: error("boolean.base") };
      }
    },
    rules: {
      truthy: {
        method(...values) {
          Common.verifyFlat(values, "truthy");
          const obj = this.clone();
          obj.$_terms.truthy = obj.$_terms.truthy || new Values;
          for (let i = 0;i < values.length; ++i) {
            const value = values[i];
            Assert(value !== undefined, "Cannot call truthy with undefined");
            obj.$_terms.truthy.add(value);
          }
          return obj;
        }
      },
      falsy: {
        method(...values) {
          Common.verifyFlat(values, "falsy");
          const obj = this.clone();
          obj.$_terms.falsy = obj.$_terms.falsy || new Values;
          for (let i = 0;i < values.length; ++i) {
            const value = values[i];
            Assert(value !== undefined, "Cannot call falsy with undefined");
            obj.$_terms.falsy.add(value);
          }
          return obj;
        }
      },
      sensitive: {
        method(enabled = true) {
          return this.$_setFlag("sensitive", enabled);
        }
      }
    },
    cast: {
      number: {
        from: internals.isBool,
        to(value, helpers) {
          return value ? 1 : 0;
        }
      },
      string: {
        from: internals.isBool,
        to(value, helpers) {
          return value ? "true" : "false";
        }
      }
    },
    messages: {
      "boolean.base": "{{#label}} must be a boolean"
    }
  });
});

// node_modules/@hapi/validate/lib/types/date.js
var require_date = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common();
  var Template = require_template();
  var internals = {};
  internals.isDate = function(value) {
    return value instanceof Date;
  };
  module.exports = Any._extend({
    type: "date",
    coerce: {
      from: ["number", "string"],
      method(value, { schema }) {
        return { value: internals.parse(value, schema._flags.format) || value };
      }
    },
    validate(value, { schema, error, prefs }) {
      if (value instanceof Date && !isNaN(value.getTime())) {
        return;
      }
      const format = schema._flags.format;
      if (!prefs.convert || !format || typeof value !== "string") {
        return { value, errors: error("date.base") };
      }
      return { value, errors: error("date.format", { format }) };
    },
    rules: {
      compare: {
        method: false,
        validate(value, helpers, { date }, { name, operator, args }) {
          const to = date === "now" ? Date.now() : date.getTime();
          if (Common.compare(value.getTime(), to, operator)) {
            return value;
          }
          return helpers.error("date." + name, { limit: args.date, value });
        },
        args: [
          {
            name: "date",
            ref: true,
            normalize: (date) => {
              return date === "now" ? date : internals.parse(date);
            },
            assert: (date) => date !== null,
            message: "must have a valid date format"
          }
        ]
      },
      format: {
        method(format) {
          Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
          return this.$_setFlag("format", format);
        }
      },
      greater: {
        method(date) {
          return this.$_addRule({ name: "greater", method: "compare", args: { date }, operator: ">" });
        }
      },
      iso: {
        method() {
          return this.format("iso");
        }
      },
      less: {
        method(date) {
          return this.$_addRule({ name: "less", method: "compare", args: { date }, operator: "<" });
        }
      },
      max: {
        method(date) {
          return this.$_addRule({ name: "max", method: "compare", args: { date }, operator: "<=" });
        }
      },
      min: {
        method(date) {
          return this.$_addRule({ name: "min", method: "compare", args: { date }, operator: ">=" });
        }
      },
      timestamp: {
        method(type = "javascript") {
          Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
          return this.format(type);
        }
      }
    },
    cast: {
      number: {
        from: internals.isDate,
        to(value, helpers) {
          return value.getTime();
        }
      },
      string: {
        from: internals.isDate,
        to(value, { prefs }) {
          return Template.date(value, prefs);
        }
      }
    },
    messages: {
      "date.base": "{{#label}} must be a valid date",
      "date.format": "{{#label}} must be in {{#format}} format",
      "date.greater": "{{#label}} must be greater than {{:#limit}}",
      "date.less": "{{#label}} must be less than {{:#limit}}",
      "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
      "date.min": "{{#label}} must be greater than or equal to {{:#limit}}"
    }
  });
  internals.parse = function(value, format) {
    if (value instanceof Date) {
      return value;
    }
    if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
      return null;
    }
    if (/^\s*$/.test(value)) {
      return null;
    }
    if (format === "iso") {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      return internals.date(value.toString());
    }
    const original = value;
    if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
      value = parseFloat(value);
    }
    if (format) {
      if (format === "javascript") {
        return internals.date(1 * value);
      }
      if (format === "unix") {
        return internals.date(1000 * value);
      }
      if (typeof original === "string") {
        return null;
      }
    }
    return internals.date(value);
  };
  internals.date = function(value) {
    const date = new Date(value);
    if (!isNaN(date.getTime())) {
      return date;
    }
    return null;
  };
});

// node_modules/@hapi/topo/lib/index.js
var require_lib9 = __commonJS((exports) => {
  var { assert } = require_lib8();
  var internals = {};
  exports.Sorter = class {
    constructor() {
      this._items = [];
      this.nodes = [];
    }
    add(nodes, options) {
      options = options ?? {};
      const before = [].concat(options.before ?? []);
      const after = [].concat(options.after ?? []);
      const group = options.group ?? "?";
      const sort = options.sort ?? 0;
      assert(!before.includes(group), `Item cannot come before itself: ${group}`);
      assert(!before.includes("?"), "Item cannot come before unassociated items");
      assert(!after.includes(group), `Item cannot come after itself: ${group}`);
      assert(!after.includes("?"), "Item cannot come after unassociated items");
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (const node of nodes) {
        const item = {
          seq: this._items.length,
          sort,
          before,
          after,
          group,
          node
        };
        this._items.push(item);
      }
      if (!options.manual) {
        const valid = this._sort();
        assert(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
      }
      return this.nodes;
    }
    merge(others) {
      if (!Array.isArray(others)) {
        others = [others];
      }
      for (const other of others) {
        if (other) {
          for (const item of other._items) {
            this._items.push(Object.assign({}, item));
          }
        }
      }
      this._items.sort(internals.mergeSort);
      for (let i = 0;i < this._items.length; ++i) {
        this._items[i].seq = i;
      }
      const valid = this._sort();
      assert(valid, "merge created a dependencies error");
      return this.nodes;
    }
    sort() {
      const valid = this._sort();
      assert(valid, "sort created a dependencies error");
      return this.nodes;
    }
    _sort() {
      const graph = {};
      const graphAfters = Object.create(null);
      const groups = Object.create(null);
      for (const item of this._items) {
        const seq = item.seq;
        const group = item.group;
        groups[group] = groups[group] ?? [];
        groups[group].push(seq);
        graph[seq] = item.before;
        for (const after of item.after) {
          graphAfters[after] = graphAfters[after] ?? [];
          graphAfters[after].push(seq);
        }
      }
      for (const node in graph) {
        const expandedGroups = [];
        for (const graphNodeItem in graph[node]) {
          const group = graph[node][graphNodeItem];
          groups[group] = groups[group] ?? [];
          expandedGroups.push(...groups[group]);
        }
        graph[node] = expandedGroups;
      }
      for (const group in graphAfters) {
        if (groups[group]) {
          for (const node of groups[group]) {
            graph[node].push(...graphAfters[group]);
          }
        }
      }
      const ancestors = {};
      for (const node in graph) {
        const children = graph[node];
        for (const child of children) {
          ancestors[child] = ancestors[child] ?? [];
          ancestors[child].push(node);
        }
      }
      const visited = {};
      const sorted = [];
      for (let i = 0;i < this._items.length; ++i) {
        let next = i;
        if (ancestors[i]) {
          next = null;
          for (let j = 0;j < this._items.length; ++j) {
            if (visited[j] === true) {
              continue;
            }
            if (!ancestors[j]) {
              ancestors[j] = [];
            }
            const shouldSeeCount = ancestors[j].length;
            let seenCount = 0;
            for (let k = 0;k < shouldSeeCount; ++k) {
              if (visited[ancestors[j][k]]) {
                ++seenCount;
              }
            }
            if (seenCount === shouldSeeCount) {
              next = j;
              break;
            }
          }
        }
        if (next !== null) {
          visited[next] = true;
          sorted.push(next);
        }
      }
      if (sorted.length !== this._items.length) {
        return false;
      }
      const seqIndex = {};
      for (const item of this._items) {
        seqIndex[item.seq] = item;
      }
      this._items = [];
      this.nodes = [];
      for (const value of sorted) {
        const sortedItem = seqIndex[value];
        this.nodes.push(sortedItem.node);
        this._items.push(sortedItem);
      }
      return true;
    }
  };
  internals.mergeSort = (a, b) => {
    return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
  };
});

// node_modules/@hapi/validate/lib/types/keys.js
var require_keys = __commonJS((exports, module) => {
  var ApplyToDefaults = require_applyToDefaults();
  var Assert = require_assert();
  var Clone = require_clone();
  var Topo = require_lib9();
  var Any = require_any();
  var Common = require_common();
  var Compile = require_compile();
  var Errors = require_errors2();
  var Ref = require_ref();
  var internals = {
    renameDefaults: {
      alias: false,
      multiple: false,
      override: false
    }
  };
  module.exports = Any._extend({
    type: "_keys",
    properties: {
      typeof: "object"
    },
    flags: {
      unknown: { default: false }
    },
    terms: {
      dependencies: { init: null },
      keys: { init: null },
      patterns: { init: null },
      renames: { init: null }
    },
    args(schema, keys) {
      return schema.keys(keys);
    },
    validate(value, { schema, error, state, prefs }) {
      if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
        return { value, errors: error("object.base", { type: schema.$_property("typeof") }) };
      }
      if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && !schema.$_terms.patterns) {
        return;
      }
      value = internals.clone(value, prefs);
      const errors = [];
      if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
        return { value, errors };
      }
      if (!schema.$_terms.keys && !schema.$_terms.patterns && !schema.$_terms.dependencies) {
        return { value, errors };
      }
      const unprocessed = new Set(Object.keys(value));
      if (schema.$_terms.keys) {
        const ancestors = [value, ...state.ancestors];
        for (const child of schema.$_terms.keys) {
          const key = child.key;
          const item = value[key];
          unprocessed.delete(key);
          const localState = state.localize([...state.path, key], ancestors, child);
          const result = child.schema.$_validate(item, localState, prefs);
          if (result.errors) {
            if (prefs.abortEarly) {
              return { value, errors: result.errors };
            }
            errors.push(...result.errors);
          } else if (child.schema._flags.result === "strip" || result.value === undefined && item !== undefined) {
            delete value[key];
          } else if (result.value !== undefined) {
            value[key] = result.value;
          }
        }
      }
      if (unprocessed.size || schema._flags._hasPatternMatch) {
        const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
        if (early) {
          return early;
        }
      }
      if (schema.$_terms.dependencies) {
        for (const dep of schema.$_terms.dependencies) {
          if (dep.key && dep.key.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
            continue;
          }
          const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
          if (failed) {
            const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
            if (prefs.abortEarly) {
              return { value, errors: report };
            }
            errors.push(report);
          }
        }
      }
      return { value, errors };
    },
    rules: {
      and: {
        method(...peers) {
          Common.verifyFlat(peers, "and");
          return internals.dependency(this, "and", null, peers);
        }
      },
      append: {
        method(schema) {
          if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
            return this;
          }
          return this.keys(schema);
        }
      },
      assert: {
        method(subject, schema, message) {
          subject = Compile.ref(subject);
          Assert(message === undefined || typeof message === "string", "Message must be a string");
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.$_addRule({ name: "assert", args: { subject, schema, message } });
          obj.$_mutateRegister(subject);
          obj.$_mutateRegister(schema);
          return obj;
        },
        validate(value, { error, prefs, state }, { subject, schema, message }) {
          const about = subject.resolve(value, state, prefs);
          const path2 = subject.absolute(state);
          if (schema.$_match(about, state.localize(path2, [value, ...state.ancestors], schema), prefs)) {
            return value;
          }
          return error("object.assert", { subject, message });
        },
        args: ["subject", "schema", "message"],
        multi: true
      },
      instance: {
        method(constructor, name) {
          Assert(typeof constructor === "function", "constructor must be a function");
          name = name || constructor.name;
          return this.$_addRule({ name: "instance", args: { constructor, name } });
        },
        validate(value, helpers, { constructor, name }) {
          if (value instanceof constructor) {
            return value;
          }
          return helpers.error("object.instance", { type: name, value });
        },
        args: ["constructor", "name"]
      },
      keys: {
        method(schema) {
          Assert(schema === undefined || typeof schema === "object", "Object schema must be a valid object");
          Assert(!Common.isSchema(schema), "Object schema cannot be a joi schema");
          const obj = this.clone();
          if (!schema) {
            obj.$_terms.keys = null;
          } else if (!Object.keys(schema).length) {
            obj.$_terms.keys = new internals.Keys;
          } else {
            obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys;
            for (const key in schema) {
              Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
            }
          }
          return obj.$_mutateRebuild();
        }
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(Object.keys(value).length, limit, operator)) {
            return value;
          }
          return helpers.error("object." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      },
      nand: {
        method(...peers) {
          Common.verifyFlat(peers, "nand");
          return internals.dependency(this, "nand", null, peers);
        }
      },
      or: {
        method(...peers) {
          Common.verifyFlat(peers, "or");
          return internals.dependency(this, "or", null, peers);
        }
      },
      oxor: {
        method(...peers) {
          return internals.dependency(this, "oxor", null, peers);
        }
      },
      pattern: {
        method(pattern, schema, options = {}) {
          const isRegExp = pattern instanceof RegExp;
          if (!isRegExp) {
            pattern = this.$_compile(pattern, { appendPath: true });
          }
          Assert(schema !== undefined, "Invalid rule");
          Common.assertOptions(options, ["fallthrough", "matches"]);
          if (isRegExp) {
            Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
          }
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.clone();
          obj.$_terms.patterns = obj.$_terms.patterns || [];
          const config = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema };
          if (options.matches) {
            config.matches = this.$_compile(options.matches);
            if (config.matches.type !== "array") {
              config.matches = config.matches.$_root.array().items(config.matches);
            }
            obj.$_mutateRegister(config.matches);
            obj.$_setFlag("_hasPatternMatch", true, { clone: false });
          }
          if (options.fallthrough) {
            config.fallthrough = true;
          }
          obj.$_terms.patterns.push(config);
          obj.$_mutateRegister(schema);
          return obj;
        }
      },
      ref: {
        method() {
          return this.$_addRule("ref");
        },
        validate(value, helpers) {
          if (Ref.isRef(value)) {
            return value;
          }
          return helpers.error("object.refType", { value });
        }
      },
      regex: {
        method() {
          return this.$_addRule("regex");
        },
        validate(value, helpers) {
          if (value instanceof RegExp) {
            return value;
          }
          return helpers.error("object.regex", { value });
        }
      },
      rename: {
        method(from, to, options = {}) {
          Assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
          Assert(typeof to === "string", "Invalid rename to argument");
          Assert(to !== from, "Cannot rename key to same name:", from);
          Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
          const obj = this.clone();
          obj.$_terms.renames = obj.$_terms.renames || [];
          for (const rename of obj.$_terms.renames) {
            Assert(rename.from !== from, "Cannot rename the same key multiple times");
          }
          obj.$_terms.renames.push({
            from,
            to,
            options: ApplyToDefaults(internals.renameDefaults, options)
          });
          return obj;
        }
      },
      schema: {
        method(type = "any") {
          return this.$_addRule({ name: "schema", args: { type } });
        },
        validate(value, helpers, { type }) {
          if (Common.isSchema(value) && (type === "any" || value.type === type)) {
            return value;
          }
          return helpers.error("object.schema", { type });
        }
      },
      unknown: {
        method(allow) {
          return this.$_setFlag("unknown", allow !== false);
        }
      },
      with: {
        method(key, peers, options = {}) {
          return internals.dependency(this, "with", key, peers, options);
        }
      },
      without: {
        method(key, peers, options = {}) {
          return internals.dependency(this, "without", key, peers, options);
        }
      },
      xor: {
        method(...peers) {
          Common.verifyFlat(peers, "xor");
          return internals.dependency(this, "xor", null, peers);
        }
      }
    },
    overrides: {
      default(value, options) {
        if (value === undefined) {
          value = Common.symbols.deepDefault;
        }
        return this.$_parent("default", value, options);
      }
    },
    rebuild(schema) {
      if (schema.$_terms.keys) {
        const topo = new Topo.Sorter;
        for (const child of schema.$_terms.keys) {
          Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
        }
        schema.$_terms.keys = new internals.Keys(...topo.nodes);
      }
    },
    messages: {
      "object.and": "{{#label}} contains {{#present}} without its required peers {{#missing}}",
      "object.assert": "{{#label}} is invalid because it failed to pass the assertion test",
      "object.base": "{{#label}} must be of type {{#type}}",
      "object.instance": "{{#label}} must be an instance of {{:#type}}",
      "object.length": "{{#label}} must have {{#limit}} keys",
      "object.max": "{{#label}} must have less than or equal to {{#limit}} keys",
      "object.min": "{{#label}} must have at least {{#limit}} keys",
      "object.missing": "{{#label}} must contain at least one of {{#peers}}",
      "object.nand": "{{:#main}} must not exist simultaneously with {{#peers}}",
      "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peers}}",
      "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
      "object.refType": "{{#label}} must be a Joi reference",
      "object.regex": "{{#label}} must be a RegExp object",
      "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
      "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
      "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
      "object.unknown": "{{#label}} is not allowed",
      "object.with": "{{:#main}} missing required peer {{:#peer}}",
      "object.without": "{{:#main}} conflict with forbidden peer {{:#peer}}",
      "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peers}}"
    }
  });
  internals.clone = function(value, prefs) {
    if (typeof value === "object") {
      if (prefs.nonEnumerables) {
        return Clone(value, { shallow: true });
      }
      const clone2 = Object.create(Object.getPrototypeOf(value));
      Object.assign(clone2, value);
      return clone2;
    }
    const clone = function(...args) {
      return value.apply(this, args);
    };
    clone.prototype = Clone(value.prototype);
    Object.defineProperty(clone, "name", { value: value.name, writable: false });
    Object.defineProperty(clone, "length", { value: value.length, writable: false });
    Object.assign(clone, value);
    return clone;
  };
  internals.dependency = function(schema, rel, key, peers, options) {
    Assert(key === null || typeof key === "string", rel, "key must be a strings");
    if (!options) {
      options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
    }
    Common.assertOptions(options, ["separator"]);
    peers = [].concat(peers);
    const separator = Common.default(options.separator, ".");
    const paths = [];
    for (const peer of peers) {
      Assert(typeof peer === "string", rel, "peers must be a string or a reference");
      paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
    }
    if (key !== null) {
      key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
    }
    const obj = schema.clone();
    obj.$_terms.dependencies = obj.$_terms.dependencies || [];
    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
    return obj;
  };
  internals.dependencies = {
    and(schema, dep, value, state, prefs) {
      const missing = [];
      const present = [];
      const count = dep.peers.length;
      for (const peer of dep.peers) {
        if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
          missing.push(peer.key);
        } else {
          present.push(peer.key);
        }
      }
      if (missing.length !== count && present.length !== count) {
        return {
          code: "object.and",
          context: {
            present,
            missing
          }
        };
      }
    },
    nand(schema, dep, value, state, prefs) {
      const present = [];
      for (const peer of dep.peers) {
        if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
          present.push(peer.key);
        }
      }
      if (present.length !== dep.peers.length) {
        return;
      }
      const main = dep.paths[0];
      const values = dep.paths.slice(1);
      return {
        code: "object.nand",
        context: {
          main,
          peers: values
        }
      };
    },
    or(schema, dep, value, state, prefs) {
      for (const peer of dep.peers) {
        if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
          return;
        }
      }
      return {
        code: "object.missing",
        context: {
          peers: dep.paths
        }
      };
    },
    oxor(schema, dep, value, state, prefs) {
      const present = [];
      for (const peer of dep.peers) {
        if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
          present.push(peer.key);
        }
      }
      if (!present.length || present.length === 1) {
        return;
      }
      const context = { peers: dep.paths };
      context.present = present;
      return { code: "object.oxor", context };
    },
    with(schema, dep, value, state, prefs) {
      for (const peer of dep.peers) {
        if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
          return {
            code: "object.with",
            context: {
              main: dep.key.key,
              peer: peer.key
            }
          };
        }
      }
    },
    without(schema, dep, value, state, prefs) {
      for (const peer of dep.peers) {
        if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
          return {
            code: "object.without",
            context: {
              main: dep.key.key,
              peer: peer.key
            }
          };
        }
      }
    },
    xor(schema, dep, value, state, prefs) {
      const present = [];
      for (const peer of dep.peers) {
        if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
          present.push(peer.key);
        }
      }
      if (present.length === 1) {
        return;
      }
      const context = { peers: dep.paths };
      if (present.length === 0) {
        return { code: "object.missing", context };
      }
      context.present = present;
      return { code: "object.xor", context };
    }
  };
  internals.rename = function(schema, value, state, prefs, errors) {
    const renamed = {};
    for (const rename of schema.$_terms.renames) {
      const matches = [];
      const pattern = typeof rename.from !== "string";
      if (!pattern) {
        if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {
          matches.push(rename);
        }
      } else {
        for (const from in value) {
          if (value[from] === undefined && rename.options.ignoreUndefined) {
            continue;
          }
          if (from === rename.to) {
            continue;
          }
          const match = rename.from.exec(from);
          if (!match) {
            continue;
          }
          matches.push({ from, to: rename.to, match });
        }
      }
      for (const match of matches) {
        const from = match.from;
        const to = match.to;
        if (!rename.options.multiple && renamed[to]) {
          errors.push(schema.$_createError("object.rename.multiple", value, { from, to, pattern }, state, prefs));
          if (prefs.abortEarly) {
            return false;
          }
        }
        if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
          errors.push(schema.$_createError("object.rename.override", value, { from, to, pattern }, state, prefs));
          if (prefs.abortEarly) {
            return false;
          }
        }
        if (value[from] === undefined) {
          delete value[to];
        } else {
          value[to] = value[from];
        }
        renamed[to] = true;
        if (!rename.options.alias) {
          delete value[from];
        }
      }
    }
    return true;
  };
  internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
    if (schema.$_terms.patterns) {
      let hasMatches = false;
      const matches = schema.$_terms.patterns.map((pattern) => {
        if (pattern.matches) {
          hasMatches = true;
          return [];
        }
      });
      const ancestors = [value, ...state.ancestors];
      for (const key of unprocessed) {
        const item = value[key];
        const path2 = [...state.path, key];
        for (let i = 0;i < schema.$_terms.patterns.length; ++i) {
          const pattern = schema.$_terms.patterns[i];
          if (pattern.regex) {
            const match = pattern.regex.test(key);
            if (!match) {
              continue;
            }
          } else {
            if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
              continue;
            }
          }
          unprocessed.delete(key);
          const localState = state.localize(path2, ancestors, { schema: pattern.rule, key });
          const result = pattern.rule.$_validate(item, localState, prefs);
          if (result.errors) {
            if (prefs.abortEarly) {
              return { value, errors: result.errors };
            }
            errors.push(...result.errors);
          }
          if (pattern.matches) {
            matches[i].push(key);
          }
          value[key] = result.value;
          if (!pattern.fallthrough) {
            break;
          }
        }
      }
      if (hasMatches) {
        for (let i = 0;i < matches.length; ++i) {
          const match = matches[i];
          if (!match) {
            continue;
          }
          const stpm = schema.$_terms.patterns[i].matches;
          const localState = state.localize(state.path, ancestors, stpm);
          const result = stpm.$_validate(match, localState, prefs);
          if (result.errors) {
            const details = Errors.details(result.errors, { override: false });
            details.matches = match;
            const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
            if (prefs.abortEarly) {
              return { value, errors: report };
            }
            errors.push(report);
          }
        }
      }
    }
    if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
      return;
    }
    if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {
      const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
      for (const key of unprocessed) {
        if (stripUnknown) {
          delete value[key];
          unprocessed.delete(key);
        } else if (typeof value[key] === "function") {
          unprocessed.delete(key);
        }
      }
    }
    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
    if (forbidUnknown) {
      for (const unprocessedKey of unprocessed) {
        const localState = state.localize([...state.path, unprocessedKey], []);
        const report = schema.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
        if (prefs.abortEarly) {
          return { value, errors: report };
        }
        errors.push(report);
      }
    }
  };
  internals.Dependency = class {
    constructor(rel, key, peers, paths) {
      this.rel = rel;
      this.key = key;
      this.peers = peers;
      this.paths = paths;
    }
  };
  internals.Keys = class extends Array {
    concat(source) {
      const result = this.slice();
      const keys = new Map;
      for (let i = 0;i < result.length; ++i) {
        keys.set(result[i].key, i);
      }
      for (const item of source) {
        const key = item.key;
        const pos = keys.get(key);
        if (pos !== undefined) {
          result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
        } else {
          result.push(item);
        }
      }
      return result;
    }
  };
});

// node_modules/@hapi/validate/lib/types/function.js
var require_function = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Keys = require_keys();
  module.exports = Keys._extend({
    type: "function",
    properties: {
      typeof: "function"
    },
    rules: {
      arity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
          return this.$_addRule({ name: "arity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length === n) {
            return value;
          }
          return helpers.error("function.arity", { n });
        }
      },
      class: {
        method() {
          return this.$_addRule("class");
        },
        validate(value, helpers) {
          if (/^\s*class\s/.test(value.toString())) {
            return value;
          }
          return helpers.error("function.class", { value });
        }
      },
      minArity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
          return this.$_addRule({ name: "minArity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length >= n) {
            return value;
          }
          return helpers.error("function.minArity", { n });
        }
      },
      maxArity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
          return this.$_addRule({ name: "maxArity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length <= n) {
            return value;
          }
          return helpers.error("function.maxArity", { n });
        }
      }
    },
    messages: {
      "function.arity": "{{#label}} must have an arity of {{#n}}",
      "function.class": "{{#label}} must be a class",
      "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
      "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
    }
  });
});

// node_modules/@hapi/validate/lib/types/link.js
var require_link = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common();
  var Compile = require_compile();
  var Errors = require_errors2();
  var internals = {};
  module.exports = Any._extend({
    type: "link",
    properties: {
      schemaChain: true
    },
    terms: {
      link: { init: null, register: false }
    },
    args(schema, ref) {
      return schema.ref(ref);
    },
    validate(value, { schema, state, prefs }) {
      Assert(schema.$_terms.link, "Uninitialized link schema");
      const linked = internals.generate(schema, value, state, prefs);
      const ref = schema.$_terms.link[0].ref;
      return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
    },
    generate(schema, value, state, prefs) {
      return internals.generate(schema, value, state, prefs);
    },
    rules: {
      ref: {
        method(ref) {
          Assert(!this.$_terms.link, "Cannot reinitialize schema");
          ref = Compile.ref(ref);
          Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
          Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
          const obj = this.clone();
          obj.$_terms.link = [{ ref }];
          return obj;
        }
      },
      relative: {
        method(enabled = true) {
          return this.$_setFlag("relative", enabled);
        }
      }
    },
    overrides: {
      concat(source) {
        Assert(this.$_terms.link, "Uninitialized link schema");
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(source.type !== "link", "Cannot merge type link with another link");
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        obj.$_terms.whens.push({ concat: source });
        return obj.$_mutateRebuild();
      }
    }
  });
  internals.generate = function(schema, value, state, prefs) {
    let linked = state.mainstay.links.get(schema);
    if (linked) {
      return linked._generate(value, state, prefs).schema;
    }
    const ref = schema.$_terms.link[0].ref;
    const { perspective, path: path2 } = internals.perspective(ref, state);
    internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
    try {
      linked = path2.length ? perspective.$_reach(path2) : perspective;
    } catch (ignoreErr) {
      internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
    }
    internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
    if (!schema._flags.relative) {
      state.mainstay.links.set(schema, linked);
    }
    return linked._generate(value, state, prefs).schema;
  };
  internals.perspective = function(ref, state) {
    if (ref.type === "local") {
      for (const { schema, key } of state.schemas) {
        const id = schema._flags.id || key;
        if (id === ref.path[0]) {
          return { perspective: schema, path: ref.path.slice(1) };
        }
        if (schema.$_terms.shared) {
          for (const shared of schema.$_terms.shared) {
            if (shared._flags.id === ref.path[0]) {
              return { perspective: shared, path: ref.path.slice(1) };
            }
          }
        }
      }
      return { perspective: null, path: null };
    }
    if (ref.ancestor === "root") {
      return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
    }
    return { perspective: state.schemas[ref.ancestor]?.schema, path: ref.path };
  };
  internals.assert = function(condition, message, ref, schema, state, prefs) {
    if (condition) {
      return;
    }
    Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
  };
});

// node_modules/@hapi/validate/lib/types/number.js
var require_number = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common();
  var internals = {
    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
  };
  module.exports = Any._extend({
    type: "number",
    flags: {
      unsafe: { default: false }
    },
    coerce: {
      from: "string",
      method(value, { schema, error }) {
        const matches = value.match(internals.numberRx);
        if (!matches) {
          return;
        }
        value = value.trim();
        const result = { value: parseFloat(value) };
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe) {
          if (value.match(/e/i)) {
            const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);
            if (constructed !== internals.normalizeExponent(value)) {
              result.errors = error("number.unsafe");
              return result;
            }
          } else {
            const string = result.value.toString();
            if (string.match(/e/i)) {
              return result;
            }
            if (string !== internals.normalizeDecimal(value)) {
              result.errors = error("number.unsafe");
              return result;
            }
          }
        }
        return result;
      }
    },
    validate(value, { schema, error, prefs }) {
      if (value === Infinity || value === -Infinity) {
        return { value, errors: error("number.infinity") };
      }
      if (!Common.isNumber(value)) {
        return { value, errors: error("number.base") };
      }
      const result = { value };
      if (prefs.convert) {
        const rule = schema.$_getRule("precision");
        if (rule) {
          const precision = Math.pow(10, rule.args.limit);
          result.value = Math.round(result.value * precision) / precision;
        }
      }
      if (result.value === 0) {
        result.value = 0;
      }
      if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
        result.errors = error("number.unsafe");
      }
      return result;
    },
    rules: {
      compare: {
        method: false,
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value, limit, operator)) {
            return value;
          }
          return helpers.error("number." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.isNumber,
            message: "must be a number"
          }
        ]
      },
      greater: {
        method(limit) {
          return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
        }
      },
      integer: {
        method() {
          return this.$_addRule("integer");
        },
        validate(value, helpers) {
          if (Math.trunc(value) - value === 0) {
            return value;
          }
          return helpers.error("number.integer");
        }
      },
      less: {
        method(limit) {
          return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
        }
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
        }
      },
      multiple: {
        method(base) {
          return this.$_addRule({ name: "multiple", args: { base } });
        },
        validate(value, helpers, { base }, options) {
          if (value % base === 0) {
            return value;
          }
          return helpers.error("number.multiple", { multiple: options.args.base, value });
        },
        args: [
          {
            name: "base",
            ref: true,
            assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
            message: "must be a positive number"
          }
        ],
        multi: true
      },
      negative: {
        method() {
          return this.sign("negative");
        }
      },
      port: {
        method() {
          return this.$_addRule("port");
        },
        validate(value, helpers) {
          if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
            return value;
          }
          return helpers.error("number.port");
        }
      },
      positive: {
        method() {
          return this.sign("positive");
        }
      },
      precision: {
        method(limit) {
          Assert(Number.isSafeInteger(limit), "limit must be an integer");
          return this.$_addRule({ name: "precision", args: { limit } });
        },
        validate(value, helpers, { limit }) {
          const places = value.toString().match(internals.precisionRx);
          const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
          if (decimals <= limit) {
            return value;
          }
          return helpers.error("number.precision", { limit, value });
        },
        convert: true
      },
      sign: {
        method(sign) {
          Assert(["negative", "positive"].includes(sign), "Invalid sign", sign);
          return this.$_addRule({ name: "sign", args: { sign } });
        },
        validate(value, helpers, { sign }) {
          if (sign === "negative" && value < 0 || sign === "positive" && value > 0) {
            return value;
          }
          return helpers.error(`number.${sign}`);
        }
      },
      unsafe: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_setFlag("unsafe", enabled);
        }
      }
    },
    cast: {
      string: {
        from: (value) => typeof value === "number",
        to(value, helpers) {
          return value.toString();
        }
      }
    },
    messages: {
      "number.base": "{{#label}} must be a number",
      "number.greater": "{{#label}} must be greater than {{#limit}}",
      "number.infinity": "{{#label}} cannot be infinity",
      "number.integer": "{{#label}} must be an integer",
      "number.less": "{{#label}} must be less than {{#limit}}",
      "number.max": "{{#label}} must be less than or equal to {{#limit}}",
      "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
      "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
      "number.negative": "{{#label}} must be a negative number",
      "number.port": "{{#label}} must be a valid port",
      "number.positive": "{{#label}} must be a positive number",
      "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
      "number.unsafe": "{{#label}} must be a safe number"
    }
  });
  internals.normalizeExponent = function(str) {
    return str.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2");
  };
  internals.normalizeDecimal = function(str) {
    str = str.replace(/^\+/, "").replace(/\.0+$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([1-9])/, "$1$2");
    if (str.includes(".") && str.endsWith("0")) {
      str = str.replace(/0+$/, "");
    }
    if (str === "-0") {
      return "0";
    }
    return str;
  };
});

// node_modules/@hapi/validate/lib/types/object.js
var require_object = __commonJS((exports, module) => {
  var Keys = require_keys();
  module.exports = Keys._extend({
    type: "object",
    cast: {
      map: {
        from: (value) => value && typeof value === "object",
        to(value, helpers) {
          return new Map(Object.entries(value));
        }
      }
    }
  });
});

// node_modules/@hapi/validate/lib/types/string.js
var require_string = __commonJS((exports, module) => {
  var Url = __require("url");
  var Assert = require_assert();
  var EscapeRegex = require_escapeRegex();
  var Any = require_any();
  var Common = require_common();
  var internals = {
    base64Regex: {
      true: {
        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
        false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
      },
      false: {
        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
        false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
      }
    },
    dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
    hexRegex: /^[a-f0-9]+$/i,
    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
    guidBrackets: {
      "{": "}",
      "[": "]",
      "(": ")",
      "": ""
    },
    guidVersions: {
      uuidv1: "1",
      uuidv2: "2",
      uuidv3: "3",
      uuidv4: "4",
      uuidv5: "5"
    },
    guidSeparators: new Set([undefined, true, false, "-", ":"]),
    normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"],
    domainControlRx: /[\x00-\x20@\:\/]/,
    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    finalSegmentAdditionalRx: /[^0-9]/
  };
  module.exports = Any._extend({
    type: "string",
    flags: {
      insensitive: { default: false },
      truncate: { default: false }
    },
    terms: {
      replacements: { init: null }
    },
    coerce: {
      from: "string",
      method(value, { schema, state, prefs }) {
        const normalize = schema.$_getRule("normalize");
        if (normalize) {
          value = value.normalize(normalize.args.form);
        }
        const casing = schema.$_getRule("case");
        if (casing) {
          value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
        }
        const trim = schema.$_getRule("trim");
        if (trim && trim.args.enabled) {
          value = value.trim();
        }
        if (schema.$_terms.replacements) {
          for (const replacement of schema.$_terms.replacements) {
            value = value.replace(replacement.pattern, replacement.replacement);
          }
        }
        const hex = schema.$_getRule("hex");
        if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
          value = `0${value}`;
        }
        if (schema.$_getRule("isoDate")) {
          const iso = internals.isoDate(value);
          if (iso) {
            value = iso;
          }
        }
        if (schema._flags.truncate) {
          const rule = schema.$_getRule("max");
          if (rule) {
            let limit = rule.args.limit;
            if (Common.isResolvable(limit)) {
              limit = limit.resolve(value, state, prefs);
              if (!Common.limit(limit)) {
                return { value, errors: schema.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
              }
            }
            value = value.slice(0, limit);
          }
        }
        return { value };
      }
    },
    validate(value, { error }) {
      if (typeof value !== "string") {
        return { value, errors: error("string.base") };
      }
      if (value === "") {
        return { value, errors: error("string.empty") };
      }
    },
    rules: {
      alphanum: {
        method() {
          return this.$_addRule("alphanum");
        },
        validate(value, helpers) {
          if (/^[a-zA-Z0-9]+$/.test(value)) {
            return value;
          }
          return helpers.error("string.alphanum");
        }
      },
      base64: {
        method(options = {}) {
          Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
          options = { urlSafe: false, paddingRequired: true, ...options };
          Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
          Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
          return this.$_addRule({ name: "base64", args: { options } });
        },
        validate(value, helpers, { options }) {
          const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
          if (regex.test(value)) {
            return value;
          }
          return helpers.error("string.base64");
        }
      },
      case: {
        method(direction) {
          Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
          return this.$_addRule({ name: "case", args: { direction } });
        },
        validate(value, helpers, { direction }) {
          if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
            return value;
          }
          return helpers.error(`string.${direction}case`);
        },
        convert: true
      },
      creditCard: {
        method() {
          return this.$_addRule("creditCard");
        },
        validate(value, helpers) {
          let i = value.length;
          let sum = 0;
          let mul = 1;
          while (i--) {
            const char = value.charAt(i) * mul;
            sum = sum + (char - (char > 9) * 9);
            mul = mul ^ 3;
          }
          if (sum > 0 && sum % 10 === 0) {
            return value;
          }
          return helpers.error("string.creditCard");
        }
      },
      dataUri: {
        method(options = {}) {
          Common.assertOptions(options, ["paddingRequired"]);
          options = { paddingRequired: true, ...options };
          Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
          return this.$_addRule({ name: "dataUri", args: { options } });
        },
        validate(value, helpers, { options }) {
          const matches = value.match(internals.dataUriRegex);
          if (matches) {
            if (!matches[2]) {
              return value;
            }
            if (matches[2] !== "base64") {
              return value;
            }
            const base64regex = internals.base64Regex[options.paddingRequired].false;
            if (base64regex.test(matches[3])) {
              return value;
            }
          }
          return helpers.error("string.dataUri");
        }
      },
      guid: {
        alias: "uuid",
        method(options = {}) {
          Common.assertOptions(options, ["version", "separator"]);
          let versionNumbers = "";
          if (options.version) {
            const versions = [].concat(options.version);
            Assert(versions.length >= 1, "version must have at least 1 valid version specified");
            const set = new Set;
            for (let i = 0;i < versions.length; ++i) {
              const version = versions[i];
              Assert(typeof version === "string", "version at position " + i + " must be a string");
              const versionNumber = internals.guidVersions[version.toLowerCase()];
              Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
              Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
              versionNumbers += versionNumber;
              set.add(versionNumber);
            }
          }
          Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
          const separator = options.separator === undefined ? "[:-]?" : options.separator === true ? "[:-]" : options.separator === false ? "[]?" : `\\${options.separator}`;
          const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
          return this.$_addRule({ name: "guid", args: { options }, regex });
        },
        validate(value, helpers, args, { regex }) {
          const results = regex.exec(value);
          if (!results) {
            return helpers.error("string.guid");
          }
          if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
            return helpers.error("string.guid");
          }
          return value;
        }
      },
      hex: {
        method(options = {}) {
          Common.assertOptions(options, ["byteAligned"]);
          options = { byteAligned: false, ...options };
          Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
          return this.$_addRule({ name: "hex", args: { options } });
        },
        validate(value, helpers, { options }) {
          if (!internals.hexRegex.test(value)) {
            return helpers.error("string.hex");
          }
          if (options.byteAligned && value.length % 2 !== 0) {
            return helpers.error("string.hexAlign");
          }
          return value;
        }
      },
      hostname: {
        method() {
          return this.$_addRule("hostname");
        },
        validate(value, helpers) {
          if (internals.isDomainValid(value) || internals.ipRegex.test(value)) {
            return value;
          }
          return helpers.error("string.hostname");
        }
      },
      insensitive: {
        method() {
          return this.$_setFlag("insensitive", true);
        }
      },
      isoDate: {
        method() {
          return this.$_addRule("isoDate");
        },
        validate(value, { error }) {
          if (internals.isoDate(value)) {
            return value;
          }
          return error("string.isoDate");
        }
      },
      isoDuration: {
        method() {
          return this.$_addRule("isoDuration");
        },
        validate(value, helpers) {
          if (internals.isoDurationRegex.test(value)) {
            return value;
          }
          return helpers.error("string.isoDuration");
        }
      },
      length: {
        method(limit, encoding) {
          return internals.length(this, "length", limit, "=", encoding);
        },
        validate(value, helpers, { limit, encoding }, { name, operator, args }) {
          const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
          if (Common.compare(length, limit, operator)) {
            return value;
          }
          return helpers.error("string." + name, { limit: args.limit, value, encoding });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          },
          "encoding"
        ]
      },
      lowercase: {
        method() {
          return this.case("lower");
        }
      },
      max: {
        method(limit, encoding) {
          return internals.length(this, "max", limit, "<=", encoding);
        },
        args: ["limit", "encoding"]
      },
      min: {
        method(limit, encoding) {
          return internals.length(this, "min", limit, ">=", encoding);
        },
        args: ["limit", "encoding"]
      },
      normalize: {
        method(form = "NFC") {
          Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
          return this.$_addRule({ name: "normalize", args: { form } });
        },
        validate(value, { error }, { form }) {
          if (value === value.normalize(form)) {
            return value;
          }
          return error("string.normalize", { value, form });
        },
        convert: true
      },
      pattern: {
        alias: "regex",
        method(regex, options = {}) {
          Assert(regex instanceof RegExp, "regex must be a RegExp");
          Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
          if (typeof options === "string") {
            options = { name: options };
          }
          Common.assertOptions(options, ["invert", "name"]);
          const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
          return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
        },
        validate(value, helpers, { regex, options }, { errorCode }) {
          const patternMatch = regex.test(value);
          if (patternMatch ^ options.invert) {
            return value;
          }
          return helpers.error(errorCode, { name: options.name, regex, value });
        },
        args: ["regex", "options"],
        multi: true
      },
      replace: {
        method(pattern, replacement) {
          if (typeof pattern === "string") {
            pattern = new RegExp(EscapeRegex(pattern), "g");
          }
          Assert(pattern instanceof RegExp, "pattern must be a RegExp");
          Assert(typeof replacement === "string", "replacement must be a String");
          const obj = this.clone();
          if (!obj.$_terms.replacements) {
            obj.$_terms.replacements = [];
          }
          obj.$_terms.replacements.push({ pattern, replacement });
          return obj;
        }
      },
      token: {
        method() {
          return this.$_addRule("token");
        },
        validate(value, helpers) {
          if (/^\w+$/.test(value)) {
            return value;
          }
          return helpers.error("string.token");
        }
      },
      trim: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_addRule({ name: "trim", args: { enabled } });
        },
        validate(value, helpers, { enabled }) {
          if (!enabled || value === value.trim()) {
            return value;
          }
          return helpers.error("string.trim");
        },
        convert: true
      },
      truncate: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_setFlag("truncate", enabled);
        }
      },
      uppercase: {
        method() {
          return this.case("upper");
        }
      }
    },
    messages: {
      "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
      "string.base": "{{#label}} must be a string",
      "string.base64": "{{#label}} must be a valid base64 string",
      "string.creditCard": "{{#label}} must be a credit card",
      "string.dataUri": "{{#label}} must be a valid dataUri string",
      "string.empty": "{{#label}} is not allowed to be empty",
      "string.guid": "{{#label}} must be a valid GUID",
      "string.hex": "{{#label}} must only contain hexadecimal characters",
      "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
      "string.hostname": "{{#label}} must be a valid hostname",
      "string.isoDate": "{{#label}} must be in iso format",
      "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
      "string.length": "{{#label}} length must be {{#limit}} characters long",
      "string.lowercase": "{{#label}} must only contain lowercase characters",
      "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
      "string.min": "{{#label}} length must be at least {{#limit}} characters long",
      "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
      "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
      "string.pattern.base": "{{#label}} with value {:.} fails to match the required pattern: {{#regex}}",
      "string.pattern.name": "{{#label}} with value {:.} fails to match the {{#name}} pattern",
      "string.pattern.invert.base": "{{#label}} with value {:.} matches the inverted pattern: {{#regex}}",
      "string.pattern.invert.name": "{{#label}} with value {:.} matches the inverted {{#name}} pattern",
      "string.trim": "{{#label}} must not have leading or trailing whitespace",
      "string.uppercase": "{{#label}} must only contain uppercase characters"
    }
  });
  internals.isoDate = function(value) {
    if (!Common.isIsoDate(value)) {
      return null;
    }
    const date = new Date(value);
    if (isNaN(date.getTime())) {
      return null;
    }
    return date.toISOString();
  };
  internals.length = function(schema, name, limit, operator, encoding) {
    Assert(!encoding || Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
    return schema.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
  };
  internals.rfc3986 = function() {
    const rfc3986 = {};
    const hexDigit = "\\dA-Fa-f";
    const hexDigitOnly = "[" + hexDigit + "]";
    const unreserved = "\\w-\\.~";
    const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
    const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
    rfc3986.ipv4 = "(?:" + decOctect + "\\.){3}" + decOctect;
    const h16 = hexDigitOnly + "{1,4}";
    const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4 + ")";
    const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
    const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
    const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
    const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
    const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
    const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
    const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
    const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
    const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
    rfc3986.v4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
    rfc3986.v6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
    rfc3986.ipv6 = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
    rfc3986.ipvfuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
    return rfc3986;
  };
  internals.ipRegex = function() {
    const versions = ["ipv4", "ipv6", "ipvfuture"];
    const rfc3986 = internals.rfc3986();
    const parts = versions.map((version) => {
      const cidrpart = `\\/${version === "ipv4" ? rfc3986.v4Cidr : rfc3986.v6Cidr}`;
      return `${rfc3986[version]}(?:${cidrpart})?`;
    });
    const raw = `(?:${parts.join("|")})`;
    return new RegExp(`^${raw}$`);
  }();
  internals.isDomainValid = function(domain) {
    if (domain.length > 256) {
      return false;
    }
    domain = domain.normalize("NFC");
    if (internals.domainControlRx.test(domain)) {
      return false;
    }
    domain = internals.punycode(domain);
    const segments = domain.split(".");
    for (let i = 0;i < segments.length; ++i) {
      const segment = segments[i];
      if (!segment.length) {
        return false;
      }
      if (segment.length > 63) {
        return false;
      }
      if (!internals.domainSegmentRx.test(segment)) {
        return false;
      }
      const isFinalSegment = i === segments.length - 1;
      if (isFinalSegment && !internals.finalSegmentAdditionalRx.test(segment)) {
        return false;
      }
    }
    return true;
  };
  internals.punycode = function(domain) {
    try {
      return new Url.URL(`http://${domain}`).host;
    } catch (err) {
      return domain;
    }
  };
});

// node_modules/@hapi/validate/lib/types/symbol.js
var require_symbol = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var internals = {};
  internals.Map = class extends Map {
    slice() {
      return new internals.Map(this);
    }
  };
  module.exports = Any._extend({
    type: "symbol",
    terms: {
      map: { init: new internals.Map }
    },
    coerce: {
      method(value, { schema, error }) {
        const lookup = schema.$_terms.map.get(value);
        if (lookup) {
          value = lookup;
        }
        if (!schema._flags.only || typeof value === "symbol") {
          return { value };
        }
        return { value, errors: error("symbol.map", { map: schema.$_terms.map }) };
      }
    },
    validate(value, { error }) {
      if (typeof value !== "symbol") {
        return { value, errors: error("symbol.base") };
      }
    },
    rules: {
      map: {
        method(iterable) {
          if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
            iterable = Object.entries(iterable);
          }
          Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
          const obj = this.clone();
          const symbols = [];
          for (const entry of iterable) {
            Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
            const [key, value] = entry;
            Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
            Assert(typeof value === "symbol", "Value must be a Symbol");
            obj.$_terms.map.set(key, value);
            symbols.push(value);
          }
          return obj.valid(...symbols);
        }
      }
    },
    messages: {
      "symbol.base": "{{#label}} must be a symbol",
      "symbol.map": "{{#label}} must be one of {{#map}}"
    }
  });
});

// node_modules/@hapi/validate/lib/types/binary.js
var require_binary = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Any = require_any();
  var Common = require_common();
  module.exports = Any._extend({
    type: "binary",
    coerce: {
      from: "string",
      method(value, { schema }) {
        try {
          return { value: Buffer.from(value, schema._flags.encoding) };
        } catch (ignoreErr) {}
      }
    },
    validate(value, { error }) {
      if (!Buffer.isBuffer(value)) {
        return { value, errors: error("binary.base") };
      }
    },
    rules: {
      encoding: {
        method(encoding) {
          Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
          return this.$_setFlag("encoding", encoding);
        }
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value.length, limit, operator)) {
            return value;
          }
          return helpers.error("binary." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      }
    },
    cast: {
      string: {
        from: (value) => Buffer.isBuffer(value),
        to(value, helpers) {
          return value.toString();
        }
      }
    },
    messages: {
      "binary.base": "{{#label}} must be a buffer or a string",
      "binary.length": "{{#label}} must be {{#limit}} bytes",
      "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
      "binary.min": "{{#label}} must be at least {{#limit}} bytes"
    }
  });
});

// node_modules/@hapi/validate/lib/index.js
var require_lib10 = __commonJS((exports, module) => {
  var Assert = require_assert();
  var Clone = require_clone();
  var Common = require_common();
  var Compile = require_compile();
  var Errors = require_errors2();
  var Ref = require_ref();
  var internals = {
    types: {
      alternatives: require_alternatives(),
      any: require_any(),
      array: require_array(),
      boolean: require_boolean(),
      date: require_date(),
      function: require_function(),
      link: require_link(),
      number: require_number(),
      object: require_object(),
      string: require_string(),
      symbol: require_symbol()
    },
    aliases: {
      alt: "alternatives",
      bool: "boolean",
      func: "function"
    }
  };
  if (Buffer) {
    internals.types.binary = require_binary();
  }
  internals.root = function() {
    const root = {
      _types: new Set(Object.keys(internals.types))
    };
    for (const type of root._types) {
      root[type] = function(...args) {
        Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
        return internals.generate(this, internals.types[type], args);
      };
    }
    for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
      root[method] = function(...args) {
        return this.any()[method](...args);
      };
    }
    Object.assign(root, internals.methods);
    for (const alias in internals.aliases) {
      const target = internals.aliases[alias];
      root[alias] = root[target];
    }
    return root;
  };
  internals.methods = {
    ValidationError: Errors.ValidationError,
    version: Common.version,
    assert(value, schema, ...args) {
      internals.assert(value, schema, true, args);
    },
    attempt(value, schema, ...args) {
      return internals.assert(value, schema, false, args);
    },
    checkPreferences(prefs) {
      Common.checkPreferences(prefs);
    },
    compile(schema, options) {
      return Compile.compile(this, schema, options);
    },
    isError: Errors.ValidationError.isError,
    isRef: Ref.isRef,
    isSchema: Common.isSchema,
    in(...args) {
      return Ref.in(...args);
    },
    override: Common.symbols.override,
    ref(...args) {
      return Ref.create(...args);
    }
  };
  internals.assert = function(value, schema, annotate, args) {
    const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
    const options = message ? args[1] : args[0];
    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
    let error = result.error;
    if (!error) {
      return result.value;
    }
    if (message instanceof Error) {
      throw message;
    }
    const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
    if (error instanceof Errors.ValidationError === false) {
      error = Clone(error);
    }
    error.message = message ? `${message} ${display}` : display;
    throw error;
  };
  internals.generate = function(root, schema, args) {
    Assert(root, "Must be invoked on a Joi instance.");
    schema.$_root = root;
    if (!schema._definition.args || !args.length) {
      return schema;
    }
    return schema._definition.args(schema, ...args);
  };
  module.exports = internals.root();
});

// node_modules/@hapi/shot/lib/symbols.js
var require_symbols = __commonJS((exports) => {
  exports.injection = Symbol("injection");
});

// node_modules/@hapi/shot/lib/request.js
var require_request = __commonJS((exports, module) => {
  var Events = __require("events");
  var Stream = __require("stream");
  var Url = __require("url");
  var Symbols = require_symbols();
  var internals = {};
  exports = module.exports = internals.Request = class extends Stream.Readable {
    constructor(options) {
      super({
        emitClose: !!options.simulate?.close,
        autoDestroy: true
      });
      let url = options.url;
      if (typeof url === "object") {
        url = Url.format(url);
      }
      const uri = Url.parse(url);
      this.url = uri.path;
      this.httpVersion = "1.1";
      this.method = options.method ? options.method.toUpperCase() : "GET";
      this.headers = {};
      const headers = options.headers ?? {};
      const fields = Object.keys(headers);
      fields.forEach((field) => {
        this.headers[field.toLowerCase()] = headers[field];
      });
      this.headers["user-agent"] = this.headers["user-agent"] ?? "shot";
      const hostHeaderFromUri = function() {
        if (uri.port) {
          return uri.host;
        }
        if (uri.protocol) {
          return uri.hostname + (uri.protocol === "https:" ? ":443" : ":80");
        }
        return null;
      };
      this.headers.host = this.headers.host ?? hostHeaderFromUri() ?? options.authority ?? "localhost:80";
      this.socket = this.connection = new internals.MockSocket(options);
      let payload = options.payload ?? null;
      if (payload && typeof payload !== "string" && !(payload instanceof Stream) && !Buffer.isBuffer(payload)) {
        payload = JSON.stringify(payload);
        this.headers["content-type"] = this.headers["content-type"] || "application/json";
      }
      if (payload && !(payload instanceof Stream) && !this.headers.hasOwnProperty("content-length")) {
        this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
      }
      this._shot = {
        payload,
        isDone: false,
        simulate: options.simulate ?? {}
      };
      return this;
    }
    prepare(next) {
      if (this._shot.payload instanceof Stream === false) {
        return next();
      }
      const chunks = [];
      this._shot.payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
      this._shot.payload.on("end", () => {
        const payload = Buffer.concat(chunks);
        this.headers["content-length"] = this.headers["content-length"] || payload.length;
        this._shot.payload = payload;
        return next();
      });
    }
    _read(size) {
      setImmediate(() => {
        if (this._shot.isDone) {
          if (this._shot.simulate.end !== false) {
            this.push(null);
          }
          return;
        }
        this._shot.isDone = true;
        if (this._shot.payload) {
          if (this._shot.simulate.split) {
            this.push(this._shot.payload.slice(0, 1));
            this.push(this._shot.payload.slice(1));
          } else {
            this.push(this._shot.payload);
          }
        }
        if (this._shot.simulate.error) {
          this.destroy(new Error("Simulated"));
        } else if (this._shot.simulate.end !== false) {
          this.push(null);
        } else if (this._shot.simulate.close) {
          this.emit("close");
        }
      });
    }
  };
  internals.Request.prototype[Symbols.injection] = true;
  internals.MockSocket = class MockSocket extends Events.EventEmitter {
    constructor({ remoteAddress }) {
      super();
      this.remoteAddress = remoteAddress ?? "127.0.0.1";
    }
    end() {}
    setTimeout() {}
  };
});

// node_modules/@hapi/shot/lib/response.js
var require_response = __commonJS((exports, module) => {
  var Http = __require("http");
  var Stream = __require("stream");
  var Symbols = require_symbols();
  var internals = {};
  exports = module.exports = internals.Response = class extends Http.ServerResponse {
    constructor(req, onEnd) {
      super({ method: req.method, httpVersionMajor: 1, httpVersionMinor: 1 });
      this._shot = { headers: null, trailers: {}, payloadChunks: [] };
      this.assignSocket(internals.nullSocket());
      if (req._shot.simulate.close) {
        req.once("close", () => {
          process.nextTick(() => this.emit("close"));
        });
      }
      this.once("finish", () => {
        const res = internals.payload(this);
        res.raw.req = req;
        process.nextTick(() => onEnd(res));
      });
    }
    writeHead(...args) {
      const headers = args[args.length - 1];
      if (typeof headers === "object" && headers !== null) {
        const headerNames = Object.keys(headers);
        for (let i = 0;i < headerNames.length; ++i) {
          const name = headerNames[i];
          try {
            this.setHeader(name, headers[name]);
            break;
          } catch (ignoreErr) {}
        }
      }
      const result = super.writeHead(...args);
      this._shot.headers = this.getHeaders();
      ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
        const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
        const field = this._header.match(regex);
        if (field) {
          this._shot.headers[name.toLowerCase()] = field[1];
        }
      });
      return result;
    }
    write(data, encoding, callback) {
      super.write(data, encoding, callback);
      this._shot.payloadChunks.push(Buffer.from(data, encoding));
      return true;
    }
    end(data, encoding, callback) {
      if (data) {
        this.write(data, encoding);
      }
      super.end(callback);
      this.emit("finish");
    }
    addTrailers(trailers) {
      for (const key in trailers) {
        this._shot.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
      }
    }
  };
  internals.Response.prototype[Symbols.injection] = true;
  internals.payload = function(response) {
    const res = {
      raw: {
        res: response
      },
      headers: response._shot.headers,
      statusCode: response.statusCode,
      statusMessage: response.statusMessage,
      trailers: {}
    };
    const rawBuffer = Buffer.concat(response._shot.payloadChunks);
    res.rawPayload = rawBuffer;
    res.payload = rawBuffer.toString();
    res.trailers = response._shot.trailers;
    return res;
  };
  internals.nullSocket = function() {
    return new Stream.Writable({
      write(chunk, encoding, callback) {
        setImmediate(callback);
      }
    });
  };
});

// node_modules/@hapi/shot/lib/index.js
var require_lib11 = __commonJS((exports) => {
  var Hoek = require_lib8();
  var Validate = require_lib10();
  var Request = require_request();
  var Response2 = require_response();
  var Symbols = require_symbols();
  var internals = {};
  internals.options = Validate.object().keys({
    url: Validate.alternatives([
      Validate.string(),
      Validate.object().keys({
        protocol: Validate.string(),
        hostname: Validate.string(),
        port: Validate.any(),
        pathname: Validate.string().required(),
        query: Validate.any()
      })
    ]).required(),
    headers: Validate.object(),
    payload: Validate.any(),
    simulate: {
      end: Validate.boolean(),
      split: Validate.boolean(),
      error: Validate.boolean(),
      close: Validate.boolean()
    },
    authority: Validate.string(),
    remoteAddress: Validate.string(),
    method: Validate.string(),
    validate: Validate.boolean()
  });
  exports.inject = function(dispatchFunc, options) {
    options = typeof options === "string" ? { url: options } : options;
    if (options.validate !== false) {
      try {
        Hoek.assert(typeof dispatchFunc === "function", "Invalid dispatch function");
        Validate.assert(options, internals.options);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    return new Promise((resolve) => {
      const req = new Request(options);
      const res = new Response2(req, resolve);
      req.prepare(() => dispatchFunc(req, res));
    });
  };
  exports.isInjection = function(obj) {
    return !!obj[Symbols.injection];
  };
});

// node_modules/@hapi/teamwork/lib/index.js
var require_lib12 = __commonJS((exports) => {
  var internals = {};
  exports.Team = class {
    #meetings = null;
    #count = null;
    #notes = null;
    #done = false;
    #strict = false;
    constructor(options) {
      this._init(options);
    }
    static _notes(instance) {
      return instance.#notes;
    }
    _init(options = {}) {
      this.work = new Promise((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
      });
      const meetings = options.meetings || 1;
      this.#meetings = meetings;
      this.#count = meetings;
      this.#notes = [];
      this.#done = false;
      this.#strict = options.strict;
    }
    attend(note) {
      if (this.#strict && this.#done) {
        throw new Error("Unscheduled meeting");
      } else if (this.#done) {
        return;
      }
      if (note instanceof Error) {
        this.#done = true;
        this.#notes = null;
        return this._reject(note);
      }
      this.#notes.push(note);
      if (--this.#count) {
        return;
      }
      this.#done = true;
      this._resolve(this.#meetings === 1 ? this.#notes[0] : [...this.#notes]);
      this.#notes = null;
    }
    async regroup(options) {
      await this.work;
      this._init(options);
    }
  };
  exports.Events = class {
    #pending = null;
    #queue = [];
    static isIterator(iterator) {
      return iterator instanceof internals.EventsIterator;
    }
    iterator() {
      return new internals.EventsIterator(this);
    }
    emit(value) {
      this._queue({ value, done: false });
    }
    end() {
      this._queue({ done: true });
    }
    _next() {
      if (this.#queue.length) {
        return Promise.resolve(this.#queue.shift());
      }
      this.#pending = new exports.Team;
      return this.#pending.work;
    }
    _queue(item) {
      if (this.#pending) {
        this.#pending.attend(item);
        this.#pending = null;
      } else {
        this.#queue.push(item);
      }
    }
  };
  internals.EventsIterator = class {
    #events = null;
    constructor(events) {
      this.#events = events;
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next() {
      return this.#events._next();
    }
  };
});

// node_modules/@hapi/boom/lib/index.js
var require_lib13 = __commonJS((exports) => {
  var Hoek = require_lib8();
  var internals = {
    codes: new Map([
      [100, "Continue"],
      [101, "Switching Protocols"],
      [102, "Processing"],
      [200, "OK"],
      [201, "Created"],
      [202, "Accepted"],
      [203, "Non-Authoritative Information"],
      [204, "No Content"],
      [205, "Reset Content"],
      [206, "Partial Content"],
      [207, "Multi-Status"],
      [300, "Multiple Choices"],
      [301, "Moved Permanently"],
      [302, "Moved Temporarily"],
      [303, "See Other"],
      [304, "Not Modified"],
      [305, "Use Proxy"],
      [307, "Temporary Redirect"],
      [400, "Bad Request"],
      [401, "Unauthorized"],
      [402, "Payment Required"],
      [403, "Forbidden"],
      [404, "Not Found"],
      [405, "Method Not Allowed"],
      [406, "Not Acceptable"],
      [407, "Proxy Authentication Required"],
      [408, "Request Time-out"],
      [409, "Conflict"],
      [410, "Gone"],
      [411, "Length Required"],
      [412, "Precondition Failed"],
      [413, "Request Entity Too Large"],
      [414, "Request-URI Too Large"],
      [415, "Unsupported Media Type"],
      [416, "Requested Range Not Satisfiable"],
      [417, "Expectation Failed"],
      [418, "I'm a teapot"],
      [422, "Unprocessable Entity"],
      [423, "Locked"],
      [424, "Failed Dependency"],
      [425, "Too Early"],
      [426, "Upgrade Required"],
      [428, "Precondition Required"],
      [429, "Too Many Requests"],
      [431, "Request Header Fields Too Large"],
      [451, "Unavailable For Legal Reasons"],
      [500, "Internal Server Error"],
      [501, "Not Implemented"],
      [502, "Bad Gateway"],
      [503, "Service Unavailable"],
      [504, "Gateway Time-out"],
      [505, "HTTP Version Not Supported"],
      [506, "Variant Also Negotiates"],
      [507, "Insufficient Storage"],
      [509, "Bandwidth Limit Exceeded"],
      [510, "Not Extended"],
      [511, "Network Authentication Required"]
    ])
  };
  exports.Boom = class extends Error {
    constructor(messageOrError, options = {}) {
      if (messageOrError instanceof Error) {
        return exports.boomify(Hoek.clone(messageOrError), options);
      }
      const { statusCode = 500, data = null, ctor = exports.Boom } = options;
      const error = new Error(messageOrError ? messageOrError : undefined);
      Error.captureStackTrace(error, ctor);
      error.data = data;
      const boom = internals.initialize(error, statusCode);
      Object.defineProperty(boom, "typeof", { value: ctor });
      if (options.decorate) {
        Object.assign(boom, options.decorate);
      }
      return boom;
    }
    static [Symbol.hasInstance](instance) {
      if (this === exports.Boom) {
        return exports.isBoom(instance);
      }
      return this.prototype.isPrototypeOf(instance);
    }
  };
  exports.isBoom = function(err, statusCode) {
    return err instanceof Error && !!err.isBoom && (!statusCode || err.output.statusCode === statusCode);
  };
  exports.boomify = function(err, options) {
    Hoek.assert(err instanceof Error, "Cannot wrap non-Error object");
    options = options || {};
    if (options.data !== undefined) {
      err.data = options.data;
    }
    if (options.decorate) {
      Object.assign(err, options.decorate);
    }
    if (!err.isBoom) {
      return internals.initialize(err, options.statusCode ?? 500, options.message);
    }
    if (options.override === false || !options.statusCode && !options.message) {
      return err;
    }
    return internals.initialize(err, options.statusCode ?? err.output.statusCode, options.message);
  };
  exports.badRequest = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 400, data, ctor: exports.badRequest });
  };
  exports.unauthorized = function(message, scheme, attributes) {
    const err = new exports.Boom(message, { statusCode: 401, ctor: exports.unauthorized });
    if (!scheme) {
      return err;
    }
    if (typeof scheme !== "string") {
      err.output.headers["WWW-Authenticate"] = scheme.join(", ");
      return err;
    }
    let wwwAuthenticate = `${scheme}`;
    if (attributes || message) {
      err.output.payload.attributes = {};
    }
    if (attributes) {
      if (typeof attributes === "string") {
        wwwAuthenticate += " " + Hoek.escapeHeaderAttribute(attributes);
        err.output.payload.attributes = attributes;
      } else {
        wwwAuthenticate += " " + Object.keys(attributes).map((name) => {
          const value = attributes[name] ?? "";
          err.output.payload.attributes[name] = value;
          return `${name}="${Hoek.escapeHeaderAttribute(value.toString())}"`;
        }).join(", ");
      }
    }
    if (message) {
      if (attributes) {
        wwwAuthenticate += ",";
      }
      wwwAuthenticate += ` error="${Hoek.escapeHeaderAttribute(message)}"`;
      err.output.payload.attributes.error = message;
    } else {
      err.isMissing = true;
    }
    err.output.headers["WWW-Authenticate"] = wwwAuthenticate;
    return err;
  };
  exports.paymentRequired = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 402, data, ctor: exports.paymentRequired });
  };
  exports.forbidden = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 403, data, ctor: exports.forbidden });
  };
  exports.notFound = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 404, data, ctor: exports.notFound });
  };
  exports.methodNotAllowed = function(messageOrError, data, allow) {
    const err = new exports.Boom(messageOrError, { statusCode: 405, data, ctor: exports.methodNotAllowed });
    if (typeof allow === "string") {
      allow = [allow];
    }
    if (Array.isArray(allow)) {
      err.output.headers.Allow = allow.join(", ");
    }
    return err;
  };
  exports.notAcceptable = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 406, data, ctor: exports.notAcceptable });
  };
  exports.proxyAuthRequired = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 407, data, ctor: exports.proxyAuthRequired });
  };
  exports.clientTimeout = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 408, data, ctor: exports.clientTimeout });
  };
  exports.conflict = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 409, data, ctor: exports.conflict });
  };
  exports.resourceGone = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 410, data, ctor: exports.resourceGone });
  };
  exports.lengthRequired = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 411, data, ctor: exports.lengthRequired });
  };
  exports.preconditionFailed = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 412, data, ctor: exports.preconditionFailed });
  };
  exports.entityTooLarge = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 413, data, ctor: exports.entityTooLarge });
  };
  exports.uriTooLong = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 414, data, ctor: exports.uriTooLong });
  };
  exports.unsupportedMediaType = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 415, data, ctor: exports.unsupportedMediaType });
  };
  exports.rangeNotSatisfiable = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 416, data, ctor: exports.rangeNotSatisfiable });
  };
  exports.expectationFailed = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 417, data, ctor: exports.expectationFailed });
  };
  exports.teapot = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 418, data, ctor: exports.teapot });
  };
  exports.badData = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 422, data, ctor: exports.badData });
  };
  exports.locked = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 423, data, ctor: exports.locked });
  };
  exports.failedDependency = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 424, data, ctor: exports.failedDependency });
  };
  exports.tooEarly = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 425, data, ctor: exports.tooEarly });
  };
  exports.preconditionRequired = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 428, data, ctor: exports.preconditionRequired });
  };
  exports.tooManyRequests = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 429, data, ctor: exports.tooManyRequests });
  };
  exports.illegal = function(messageOrError, data) {
    return new exports.Boom(messageOrError, { statusCode: 451, data, ctor: exports.illegal });
  };
  exports.internal = function(message, data, statusCode = 500) {
    return internals.serverError(message, data, statusCode, exports.internal);
  };
  exports.notImplemented = function(message, data) {
    return internals.serverError(message, data, 501, exports.notImplemented);
  };
  exports.badGateway = function(message, data) {
    return internals.serverError(message, data, 502, exports.badGateway);
  };
  exports.serverUnavailable = function(message, data) {
    return internals.serverError(message, data, 503, exports.serverUnavailable);
  };
  exports.gatewayTimeout = function(message, data) {
    return internals.serverError(message, data, 504, exports.gatewayTimeout);
  };
  exports.badImplementation = function(message, data) {
    const err = internals.serverError(message, data, 500, exports.badImplementation);
    err.isDeveloperError = true;
    return err;
  };
  internals.initialize = function(err, statusCode, message) {
    const numberCode = parseInt(statusCode, 10);
    Hoek.assert(!isNaN(numberCode) && numberCode >= 400, "First argument must be a number (400+):", statusCode);
    err.isBoom = true;
    err.isServer = numberCode >= 500;
    if (!err.hasOwnProperty("data")) {
      err.data = null;
    }
    err.output = {
      statusCode: numberCode,
      payload: {},
      headers: {}
    };
    Object.defineProperty(err, "reformat", { value: internals.reformat, configurable: true });
    if (!message && !err.message) {
      err.reformat();
      message = err.output.payload.error;
    }
    if (message) {
      const props = Object.getOwnPropertyDescriptor(err, "message") || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(err), "message");
      Hoek.assert(!props || props.configurable && !props.get, "The error is not compatible with boom");
      err.message = message + (err.message ? ": " + err.message : "");
      err.output.payload.message = err.message;
    }
    err.reformat();
    return err;
  };
  internals.reformat = function(debug = false) {
    this.output.payload.statusCode = this.output.statusCode;
    this.output.payload.error = internals.codes.get(this.output.statusCode) || "Unknown";
    if (this.output.statusCode === 500 && debug !== true) {
      this.output.payload.message = "An internal server error occurred";
    } else if (this.message) {
      this.output.payload.message = this.message;
    }
  };
  internals.serverError = function(messageOrError, data, statusCode, ctor) {
    if (data instanceof Error && !data.isBoom) {
      return exports.boomify(data, { statusCode, message: messageOrError });
    }
    return new exports.Boom(messageOrError, { statusCode, data, ctor });
  };
});

// node_modules/@hapi/bounce/lib/index.js
var require_lib14 = __commonJS((exports) => {
  var Assert = __require("assert");
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var internals = {
    system: [
      EvalError,
      RangeError,
      ReferenceError,
      SyntaxError,
      TypeError,
      URIError,
      Assert.AssertionError,
      Hoek.AssertError
    ]
  };
  exports.rethrow = function(err, types2, options = {}) {
    return internals.catch(err, types2, options, true);
  };
  exports.ignore = function(err, types2, options = {}) {
    return internals.catch(err, types2, options, false);
  };
  internals.catch = function(err, types2, options, match) {
    if (internals.match(err, types2) !== match) {
      return;
    }
    if (options.override) {
      err = options.override;
    }
    if (options.decorate) {
      Object.assign(err, options.decorate);
    }
    if (options.return) {
      return err;
    }
    throw err;
  };
  exports.background = async function(operation, action = "rethrow", types2 = "system", options = {}) {
    try {
      if (typeof operation === "function") {
        await operation();
      } else {
        await operation;
      }
    } catch (err) {
      return exports[action](err, types2, options);
    }
  };
  exports.isBoom = function(err) {
    return Boom.isBoom(err);
  };
  exports.isError = function(err) {
    return err instanceof Error;
  };
  exports.isSystem = function(err) {
    if (!err) {
      return false;
    }
    if (err.isBoom) {
      return false;
    }
    for (const system of internals.system) {
      if (err instanceof system) {
        return true;
      }
    }
    return false;
  };
  internals.rules = {
    system: exports.isSystem,
    boom: exports.isBoom
  };
  internals.match = function(err, types2) {
    if (!types2) {
      return true;
    }
    types2 = Array.isArray(types2) ? types2 : [types2];
    for (const type of types2) {
      if (typeof type === "string") {
        if (internals.rules[type](err)) {
          return true;
        }
      } else if (typeof type === "object") {
        if (Hoek.contain(err, type, { deep: true, part: true })) {
          return true;
        }
      } else if (err instanceof type) {
        return true;
      }
    }
    return false;
  };
});

// node_modules/@hapi/somever/lib/index.js
var require_lib15 = __commonJS((exports) => {
  var Bounce = require_lib14();
  var Hoek = require_lib8();
  var internals = {
    maxLength: 256,
    wildcards: ["x", "X", "*"],
    any: Symbol("any")
  };
  internals.versionRx = /^\s*[vV]?(\d+|[xX*])(?:\.(\d+|[xX*])(?:\.(\d+|[xX*])(?:\-?([^+]+))?(?:\+(.+))?)?)?\s*$/;
  internals.strict = {
    tokenRx: /^[-\dA-Za-z]+(?:\.[-\dA-Za-z]+)*$/,
    numberRx: /^((?:0)|(?:[1-9]\d*))$/
  };
  exports.version = function(version, options) {
    return new internals.Version(version, options);
  };
  exports.range = function(range) {
    return new internals.Range(range);
  };
  exports.match = function(version, range, options) {
    try {
      return exports.range(range).match(version, options);
    } catch (err) {
      Bounce.rethrow(err, "system");
      return false;
    }
  };
  exports.compare = function(a, b, options = {}) {
    let aFirst = -1;
    let bFirst = 1;
    a = exports.version(a, options);
    b = exports.version(b, options);
    if (options.range && !options.includePrerelease && a.prerelease.length && (a.major !== b.major || a.minor !== b.minor || a.patch !== b.patch || !b.prerelease.length)) {
      aFirst = -2;
      bFirst = 2;
    }
    for (let i = 0;i < 3; ++i) {
      const av = a.dots[i];
      const bv = b.dots[i];
      if (av === bv || av === internals.any || bv === internals.any) {
        continue;
      }
      return av - bv < 0 ? aFirst : bFirst;
    }
    if (!a.prerelease.length && !b.prerelease.length) {
      return 0;
    } else if (!b.prerelease.length) {
      return options.includePrerelease && b.patch === internals.any ? 0 : aFirst;
    } else if (!a.prerelease.length) {
      return options.includePrerelease && a.patch === internals.any ? 0 : bFirst;
    }
    for (let i = 0;; ++i) {
      const ai = a.prerelease[i];
      const bi = b.prerelease[i];
      if (ai === undefined && bi === undefined) {
        return 0;
      }
      if (ai === bi) {
        continue;
      }
      if (ai === undefined) {
        return aFirst;
      }
      if (bi === undefined) {
        return bFirst;
      }
      const an = Number.isFinite(ai);
      const bn = Number.isFinite(bi);
      if (an !== bn) {
        return an ? aFirst : bFirst;
      }
      return ai < bi ? aFirst : bFirst;
    }
  };
  internals.Version = class {
    constructor(version, options = {}) {
      Hoek.assert(version, "Missing version argument");
      if (version instanceof internals.Version) {
        return version;
      }
      if (typeof version === "object") {
        this._copy(version);
      } else {
        this._parse(version, options);
      }
      this.format();
    }
    _copy(version) {
      this.major = version.major === undefined ? internals.any : version.major;
      this.minor = version.minor === undefined ? internals.any : version.minor;
      this.patch = version.patch === undefined ? internals.any : version.patch;
      this.prerelease = version.prerelease ?? [];
      this.build = version.build ?? [];
    }
    _parse(version, options) {
      Hoek.assert(typeof version === "string", "Version argument must be a string");
      Hoek.assert(version.length <= internals.maxLength, "Version string too long");
      const match = version.match(internals.versionRx);
      if (!match) {
        throw new Error(`Invalid version string format: ${version}`);
      }
      this.major = internals.Version._number(match[1], "major", options);
      this.minor = internals.Version._number(match[2] || "x", "minor", options);
      this.patch = internals.Version._number(match[3] || "x", "patch", options);
      this.prerelease = internals.Version._sub(match[4], "prerelease", options);
      this.build = internals.Version._sub(match[5], "build", options);
    }
    static _number(string, source, options) {
      if (internals.wildcards.includes(string)) {
        return internals.any;
      }
      if (options.strict) {
        Hoek.assert(string.match(internals.strict.numberRx), "Value must be 0 or a number without a leading zero:", source);
      }
      const value = parseInt(string, 10);
      Hoek.assert(value <= Number.MAX_SAFE_INTEGER, "Value must be positive and less than max safe integer:", source);
      return value;
    }
    static _sub(string, source, options) {
      if (!string) {
        return [];
      }
      if (options.strict) {
        Hoek.assert(string.match(internals.strict.tokenRx), "Value can only contain dot-separated hyphens, digits, a-z or A-Z:", source);
      }
      const subs = [];
      const parts = string.split(".");
      for (const part of parts) {
        if (!part) {
          throw new Error(`Invalid empty ${source} segment`);
        }
        subs.push(part.match(/^\d+$/) ? internals.Version._number(part, source, { strict: options.strict }) : part);
      }
      return subs;
    }
    format() {
      this.version = `${internals.dot(this.major)}.${internals.dot(this.minor)}.${internals.dot(this.patch)}${internals.token(this.prerelease, "-")}${internals.token(this.build, "+")}`;
      this.dots = [this.major, this.minor, this.patch];
      this.wildcard = this.major === internals.any && this.minor === internals.any && this.patch === internals.any && !this.prerelease.length;
    }
    toString() {
      return this.version;
    }
    compare(to, options) {
      return internals.Version.compare(this, to, options);
    }
    static compare(a, b, options = {}) {
      return exports.compare(a, b, options);
    }
  };
  internals.dot = (v) => {
    return v === internals.any ? "x" : v;
  };
  internals.token = (v, prefix) => {
    if (!v.length) {
      return "";
    }
    return `${prefix}${v.join(".")}`;
  };
  internals.Range = class {
    constructor(range, options) {
      this._settings = Object.assign({}, options);
      this._anything = false;
      this._or = [];
      this._active = null;
      if (range !== undefined) {
        this.pattern(range);
      }
      this._another();
    }
    _another() {
      if (!this._active || this._active.rules.length) {
        this._active = { rules: [] };
        this._or.push(this._active);
      }
      return this;
    }
    _rule(operator, version) {
      version = exports.version(version, this._settings);
      const compare = internals.operator(operator);
      this._active.rules.push({ compare, version, operator });
      return this;
    }
    get or() {
      return this._another();
    }
    equal(version) {
      return this._rule("=", version);
    }
    above(version) {
      return this._rule(">", version);
    }
    below(version) {
      return this._rule("<", version);
    }
    between(from, to) {
      this._rule(">=", from);
      this._rule("<=", to);
      return this;
    }
    minor(version) {
      version = exports.version(version, this._settings);
      if (version.major === internals.any) {
        this._rule("=", version);
        return this;
      }
      this._rule(">=", version);
      if (version.minor === internals.any) {
        this._rule("<", { major: version.major + 1, minor: 0, patch: 0, prerelease: [0] });
      } else {
        this._rule("<", { major: version.major, minor: version.minor + 1, patch: 0, prerelease: [0] });
      }
      return this;
    }
    compatible(version) {
      version = exports.version(version, this._settings);
      if (version.major === internals.any) {
        this._rule("=", version);
        return this;
      }
      this._rule(">=", version);
      if (version.major === 0 && version.minor !== internals.any) {
        if (version.minor === 0) {
          this._rule("<", { major: 0, minor: 0, patch: version.patch + 1, prerelease: [0] });
        } else {
          this._rule("<", { major: 0, minor: version.minor + 1, patch: 0, prerelease: [0] });
        }
      } else {
        this._rule("<", { major: version.major + 1, minor: 0, patch: 0, prerelease: [0] });
      }
      return this;
    }
    pattern(range) {
      try {
        this._pattern(range);
        return this;
      } catch (err) {
        throw new Error(`Invalid range: "${range}" because: ${err.message}`);
      }
    }
    _pattern(range) {
      if (range === "") {
        this._anything = true;
        return;
      }
      const normalized = internals.normalize(range);
      const ors = normalized.split(/\s*\|\|\s*/);
      for (const condition of ors) {
        if (!condition) {
          this._anything = true;
          return;
        }
        this._another();
        const ands = condition.split(/\s+/);
        for (const and of ands) {
          const hyphen = and.indexOf("@");
          if (hyphen !== -1) {
            const from = and.slice(0, hyphen);
            const to = and.slice(hyphen + 1);
            this.between(from, to);
            continue;
          }
          const parts = and.match(/^(\^|~|<\=|>\=|<|>|\=)?(.+)$/);
          const operator = parts[1];
          const version = exports.version(parts[2], this._settings);
          if (version.wildcard) {
            this._anything = true;
            return;
          }
          if (operator === "~") {
            this.minor(version);
            continue;
          }
          if (operator === "^") {
            this.compatible(version);
            continue;
          }
          if (operator) {
            this._rule(operator, version);
            continue;
          }
          this.equal(version);
        }
      }
    }
    match(version, options = {}) {
      version = exports.version(version, this._settings);
      if (this._anything) {
        return !!options.includePrerelease || !version.prerelease.length;
      }
      for (const { rules } of this._or) {
        if (!rules.length) {
          continue;
        }
        let matches = 0;
        let excludes = 0;
        for (const rule of rules) {
          const compare = version.compare(rule.version, Object.assign(this._settings, options, { range: true }));
          const exclude = Math.abs(compare) === 2;
          if (rule.compare.includes(compare / (exclude ? 2 : 1))) {
            ++matches;
            if (exclude) {
              ++excludes;
            }
          } else {
            break;
          }
        }
        if (matches === rules.length && excludes < matches) {
          return true;
        }
      }
      return false;
    }
    toString() {
      if (this._anything) {
        return "*";
      }
      let string = "";
      for (const { rules } of this._or) {
        if (!rules.length) {
          continue;
        }
        const conditions = [];
        for (const rule of rules) {
          conditions.push(`${rule.operator !== "=" ? rule.operator : ""}${rule.version.version}`);
        }
        string += (string ? "||" : "") + conditions.join(" ");
      }
      return string;
    }
  };
  internals.operator = function(compare) {
    switch (compare) {
      case "=":
        return [0];
      case ">":
        return [1];
      case ">=":
        return [0, 1];
      case "<":
        return [-1];
      case "<=":
        return [0, -1];
    }
  };
  internals.normalize = function(range) {
    return range.replace(/ \- /g, "@").replace(/~>/g, "~").replace(/(\^|~|<\=|>\=|<|>|\=)\s*([^\s]+)/g, ($0, $1, $2) => `${$1}${$2}`);
  };
});

// node_modules/@hapi/hapi/lib/config.js
var require_config = __commonJS((exports) => {
  var Os = __require("os");
  var Somever = require_lib15();
  var Validate = require_lib10();
  var internals = {};
  exports.symbol = Symbol("hapi-response");
  exports.apply = function(type, options, ...message) {
    const result = internals[type].validate(options);
    if (result.error) {
      throw new Error(`Invalid ${type} options ${message.length ? "(" + message.join(" ") + ")" : ""} ${result.error.annotate()}`);
    }
    return result.value;
  };
  exports.enable = function(options) {
    const settings = options ? Object.assign({}, options) : {};
    if (settings.security === true) {
      settings.security = {};
    }
    if (settings.cors === true) {
      settings.cors = {};
    }
    return settings;
  };
  exports.versionMatch = (version, range) => Somever.match(version, range, { includePrerelease: true });
  internals.access = Validate.object({
    entity: Validate.valid("user", "app", "any"),
    scope: [false, Validate.array().items(Validate.string()).single().min(1)]
  });
  internals.auth = Validate.alternatives([
    Validate.string(),
    internals.access.keys({
      mode: Validate.valid("required", "optional", "try"),
      strategy: Validate.string(),
      strategies: Validate.array().items(Validate.string()).min(1),
      access: Validate.array().items(internals.access.min(1)).single().min(1),
      payload: [
        Validate.valid("required", "optional"),
        Validate.boolean()
      ]
    }).without("strategy", "strategies").without("access", ["scope", "entity"])
  ]);
  internals.event = Validate.object({
    method: Validate.array().items(Validate.function()).single(),
    options: Validate.object({
      before: Validate.array().items(Validate.string()).single(),
      after: Validate.array().items(Validate.string()).single(),
      bind: Validate.any(),
      sandbox: Validate.valid("server", "plugin"),
      timeout: Validate.number().integer().min(1)
    }).default({})
  });
  internals.exts = Validate.array().items(internals.event.keys({ type: Validate.string().required() })).single();
  internals.failAction = Validate.alternatives([
    Validate.valid("error", "log", "ignore"),
    Validate.function()
  ]).default("error");
  internals.routeBase = Validate.object({
    app: Validate.object().allow(null),
    auth: internals.auth.allow(false),
    bind: Validate.object().allow(null),
    cache: Validate.object({
      expiresIn: Validate.number(),
      expiresAt: Validate.string(),
      privacy: Validate.valid("default", "public", "private"),
      statuses: Validate.array().items(Validate.number().integer().min(200)).min(1).single().default([200, 204]),
      otherwise: Validate.string().default("no-cache")
    }).allow(false).default(),
    compression: Validate.object().pattern(/.+/, Validate.object()).default(),
    cors: Validate.object({
      origin: Validate.array().min(1).allow("ignore").default(["*"]),
      maxAge: Validate.number().default(86400),
      headers: Validate.array().items(Validate.string()).default(["Accept", "Authorization", "Content-Type", "If-None-Match"]),
      additionalHeaders: Validate.array().items(Validate.string()).default([]),
      exposedHeaders: Validate.array().items(Validate.string()).default(["WWW-Authenticate", "Server-Authorization"]),
      additionalExposedHeaders: Validate.array().items(Validate.string()).default([]),
      credentials: Validate.boolean().when("origin", { is: "ignore", then: false }).default(false),
      preflightStatusCode: Validate.valid(200, 204).default(200)
    }).allow(false, true).default(false),
    ext: Validate.object({
      onPreAuth: Validate.array().items(internals.event).single(),
      onCredentials: Validate.array().items(internals.event).single(),
      onPostAuth: Validate.array().items(internals.event).single(),
      onPreHandler: Validate.array().items(internals.event).single(),
      onPostHandler: Validate.array().items(internals.event).single(),
      onPreResponse: Validate.array().items(internals.event).single(),
      onPostResponse: Validate.array().items(internals.event).single()
    }).default({}),
    files: Validate.object({
      relativeTo: Validate.string().pattern(/^([\/\.])|([A-Za-z]:\\)|(\\\\)/).default(".")
    }).default(),
    json: Validate.object({
      replacer: Validate.alternatives(Validate.function(), Validate.array()).allow(null).default(null),
      space: Validate.number().allow(null).default(null),
      suffix: Validate.string().allow(null).default(null),
      escape: Validate.boolean().default(false)
    }).default(),
    log: Validate.object({
      collect: Validate.boolean().default(false)
    }).default(),
    payload: Validate.object({
      output: Validate.valid("data", "stream", "file").default("data"),
      parse: Validate.boolean().allow("gunzip").default(true),
      multipart: Validate.object({
        output: Validate.valid("data", "stream", "file", "annotated").required()
      }).default(false).allow(true, false),
      allow: Validate.array().items(Validate.string()).single(),
      override: Validate.string(),
      protoAction: Validate.valid("error", "remove", "ignore").default("error"),
      maxBytes: Validate.number().integer().positive().default(1024 * 1024),
      maxParts: Validate.number().integer().positive().default(1000),
      uploads: Validate.string().default(Os.tmpdir()),
      failAction: internals.failAction,
      timeout: Validate.number().integer().positive().allow(false).default(10 * 1000),
      defaultContentType: Validate.string().default("application/json"),
      compression: Validate.object().pattern(/.+/, Validate.object()).default()
    }).default(),
    plugins: Validate.object(),
    response: Validate.object({
      disconnectStatusCode: Validate.number().integer().min(400).default(499),
      emptyStatusCode: Validate.valid(200, 204).default(204),
      failAction: internals.failAction,
      modify: Validate.boolean(),
      options: Validate.object(),
      ranges: Validate.boolean().default(true),
      sample: Validate.number().min(0).max(100).when("modify", { then: Validate.forbidden() }),
      schema: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(true, false),
      status: Validate.object().pattern(/\d\d\d/, Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(true, false))
    }).default(),
    security: Validate.object({
      hsts: Validate.alternatives([
        Validate.object({
          maxAge: Validate.number(),
          includeSubdomains: Validate.boolean(),
          includeSubDomains: Validate.boolean(),
          preload: Validate.boolean()
        }),
        Validate.boolean(),
        Validate.number()
      ]).default(15768000),
      xframe: Validate.alternatives([
        Validate.boolean(),
        Validate.valid("sameorigin", "deny"),
        Validate.object({
          rule: Validate.valid("sameorigin", "deny", "allow-from"),
          source: Validate.string()
        })
      ]).default("deny"),
      xss: Validate.valid("enabled", "disabled", false).default("disabled"),
      noOpen: Validate.boolean().default(true),
      noSniff: Validate.boolean().default(true),
      referrer: Validate.alternatives([
        Validate.boolean().valid(false),
        Validate.valid("", "no-referrer", "no-referrer-when-downgrade", "unsafe-url", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin")
      ]).default(false)
    }).allow(null, false, true).default(false),
    state: Validate.object({
      parse: Validate.boolean().default(true),
      failAction: internals.failAction
    }).default(),
    timeout: Validate.object({
      socket: Validate.number().integer().positive().allow(false),
      server: Validate.number().integer().positive().allow(false).default(false)
    }).default(),
    validate: Validate.object({
      headers: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, true),
      params: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, true),
      query: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
      payload: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
      state: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
      failAction: internals.failAction,
      errorFields: Validate.object(),
      options: Validate.object().default(),
      validator: Validate.object()
    }).default()
  });
  internals.server = Validate.object({
    address: Validate.string().hostname(),
    app: Validate.object().allow(null),
    autoListen: Validate.boolean(),
    cache: Validate.allow(null),
    compression: Validate.object({
      minBytes: Validate.number().min(1).integer().default(1024)
    }).allow(false).default(),
    debug: Validate.object({
      request: Validate.array().items(Validate.string()).single().allow(false).default(["implementation"]),
      log: Validate.array().items(Validate.string()).single().allow(false)
    }).allow(false).default(),
    host: Validate.string().hostname().allow(null),
    info: Validate.object({
      remote: Validate.boolean().default(false)
    }).default({}),
    listener: Validate.any(),
    load: Validate.object({
      sampleInterval: Validate.number().integer().min(0).default(0)
    }).unknown().default(),
    mime: Validate.object().empty(null).default(),
    operations: Validate.object({
      cleanStop: Validate.boolean().default(true)
    }).default(),
    plugins: Validate.object(),
    port: Validate.alternatives([
      Validate.number().integer().min(0),
      Validate.string().pattern(/\//),
      Validate.string().pattern(/^\\\\\.\\pipe\\/)
    ]).allow(null),
    query: Validate.object({
      parser: Validate.function()
    }).default(),
    router: Validate.object({
      isCaseSensitive: Validate.boolean().default(true),
      stripTrailingSlash: Validate.boolean().default(false)
    }).default(),
    routes: internals.routeBase.default(),
    state: Validate.object(),
    tls: Validate.alternatives([
      Validate.object().allow(null),
      Validate.boolean()
    ]),
    uri: Validate.string().pattern(/[^/]$/)
  });
  internals.vhost = Validate.alternatives([
    Validate.string().hostname(),
    Validate.array().items(Validate.string().hostname()).min(1)
  ]);
  internals.handler = Validate.alternatives([
    Validate.function(),
    Validate.object().length(1)
  ]);
  internals.route = Validate.object({
    method: Validate.string().pattern(/^[a-zA-Z0-9!#\$%&'\*\+\-\.^_`\|~]+$/).required(),
    path: Validate.string().required(),
    rules: Validate.object(),
    vhost: internals.vhost,
    handler: Validate.any(),
    options: Validate.any(),
    config: Validate.any()
  }).without("config", "options");
  internals.pre = [
    Validate.function(),
    Validate.object({
      method: Validate.alternatives(Validate.string(), Validate.function()).required(),
      assign: Validate.string(),
      mode: Validate.valid("serial", "parallel"),
      failAction: internals.failAction
    })
  ];
  internals.routeConfig = internals.routeBase.keys({
    description: Validate.string(),
    id: Validate.string(),
    isInternal: Validate.boolean(),
    notes: [
      Validate.string(),
      Validate.array().items(Validate.string())
    ],
    pre: Validate.array().items(...internals.pre.concat(Validate.array().items(...internals.pre).min(1))),
    tags: [
      Validate.string(),
      Validate.array().items(Validate.string())
    ]
  });
  internals.cacheConfig = Validate.alternatives([
    Validate.function(),
    Validate.object({
      name: Validate.string().invalid("_default"),
      shared: Validate.boolean(),
      provider: [
        Validate.function(),
        {
          constructor: Validate.function().required(),
          options: Validate.object({
            partition: Validate.string().default("hapi-cache")
          }).unknown().default({})
        }
      ],
      engine: Validate.object()
    }).xor("provider", "engine")
  ]);
  internals.cache = Validate.array().items(internals.cacheConfig).min(1).single();
  internals.cachePolicy = Validate.object({
    cache: Validate.string().allow(null).allow(""),
    segment: Validate.string(),
    shared: Validate.boolean()
  }).unknown();
  internals.method = Validate.object({
    bind: Validate.object().allow(null),
    generateKey: Validate.function(),
    cache: internals.cachePolicy
  });
  internals.methodObject = Validate.object({
    name: Validate.string().required(),
    method: Validate.function().required(),
    options: Validate.object()
  });
  internals.register = Validate.object({
    once: true,
    routes: Validate.object({
      prefix: Validate.string().pattern(/^\/.+/),
      vhost: internals.vhost
    }).default({})
  });
  internals.semver = Validate.string();
  internals.plugin = internals.register.keys({
    options: Validate.any(),
    plugin: Validate.object({
      register: Validate.function().required(),
      name: Validate.string().when("pkg.name", { is: Validate.exist(), otherwise: Validate.required() }),
      version: Validate.string(),
      multiple: Validate.boolean().default(false),
      dependencies: [
        Validate.array().items(Validate.string()).single(),
        Validate.object().pattern(/.+/, internals.semver)
      ],
      once: true,
      requirements: Validate.object({
        hapi: Validate.string(),
        node: Validate.string()
      }).default(),
      pkg: Validate.object({
        name: Validate.string(),
        version: Validate.string().default("0.0.0")
      }).unknown().default({})
    }).unknown()
  }).without("once", "options").unknown();
  internals.rules = Validate.object({
    validate: Validate.object({
      schema: Validate.alternatives(Validate.object(), Validate.array()).required(),
      options: Validate.object().default({ allowUnknown: true })
    })
  });
});

// node_modules/@hapi/call/lib/decode.js
var require_decode = __commonJS((exports) => {
  var internals = {};
  exports.decode = function(string) {
    let percentPos = string.indexOf("%");
    if (percentPos === -1) {
      return string;
    }
    let decoded = "";
    let last = 0;
    let codepoint = 0;
    let startOfOctets = percentPos;
    let state = internals.utf8.accept;
    while (percentPos > -1 && percentPos < string.length) {
      const high = internals.resolveHex(string[percentPos + 1], 4);
      const low = internals.resolveHex(string[percentPos + 2], 0);
      const byte = high | low;
      const type = internals.utf8.data[byte];
      state = internals.utf8.data[256 + state + type];
      codepoint = codepoint << 6 | byte & internals.utf8.data[364 + type];
      if (state === internals.utf8.accept) {
        decoded += string.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPos + 3;
        percentPos = string.indexOf("%", last);
        startOfOctets = percentPos;
        continue;
      }
      if (state === internals.utf8.reject) {
        return null;
      }
      percentPos += 3;
      if (percentPos >= string.length || string[percentPos] !== "%") {
        return null;
      }
    }
    return decoded + string.slice(last);
  };
  internals.resolveHex = function(char, shift) {
    const i = internals.hex[char];
    return i === undefined ? 255 : i << shift;
  };
  internals.hex = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  internals.utf8 = {
    accept: 12,
    reject: 0,
    data: [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ]
  };
});

// node_modules/@hapi/call/lib/regex.js
var require_regex = __commonJS((exports) => {
  exports.generate = function() {
    const empty = "(?:^\\/$)";
    const legalChars = "[\\w\\!\\$&'\\(\\)\\*\\+\\,;\\=\\:@\\-\\.~]";
    const encoded = "%[A-F0-9]{2}";
    const literalChar = "(?:" + legalChars + "|" + encoded + ")";
    const literal = literalChar + "+";
    const literalOptional = literalChar + "*";
    const midParam = "(?:\\{\\w+(?:\\*[1-9]\\d*)?\\})";
    const endParam = "(?:\\/(?:\\{\\w+(?:(?:\\*(?:[1-9]\\d*)?)|(?:\\?))?\\})?)?";
    const partialParam = "(?:\\{\\w+\\??\\})";
    const mixedParam = "(?:(?:" + literal + partialParam + ")+" + literalOptional + ")|(?:" + partialParam + "(?:" + literal + partialParam + ")+" + literalOptional + ")|(?:" + partialParam + literal + ")";
    const segmentContent = "(?:" + literal + "|" + midParam + "|" + mixedParam + ")";
    const segment = "\\/" + segmentContent;
    const segments = "(?:" + segment + ")*";
    const path2 = "(?:^" + segments + endParam + "$)";
    const parseParam = "(" + literal + ")|(?:\\{(\\w+)(?:(\\*)(\\d+)?)?(\\?)?\\})";
    const expressions = {
      parseParam: new RegExp(parseParam, "g"),
      validatePath: new RegExp(empty + "|" + path2),
      validatePathEncoded: /%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g
    };
    return expressions;
  };
});

// node_modules/@hapi/call/lib/segment.js
var require_segment = __commonJS((exports, module) => {
  var Hoek = require_lib8();
  var internals = {};
  exports = module.exports = internals.Segment = function() {
    this._edge = null;
    this._fulls = null;
    this._literals = null;
    this._param = null;
    this._mixed = null;
    this._wildcard = null;
  };
  internals.Segment.prototype.add = function(segments, record) {
    const current = segments[0];
    const remaining = segments.slice(1);
    const isEdge = !remaining.length;
    const literals = [];
    let isLiteral = true;
    for (let i = 0;i < segments.length && isLiteral; ++i) {
      isLiteral = segments[i].literal !== undefined;
      literals.push(segments[i].literal);
    }
    if (isLiteral) {
      this._fulls = this._fulls ?? new Map;
      let literal = "/" + literals.join("/");
      if (!record.settings.isCaseSensitive) {
        literal = literal.toLowerCase();
      }
      Hoek.assert(!this._fulls.has(literal), "New route", record.path, "conflicts with existing", this._fulls.get(literal)?.record.path);
      this._fulls.set(literal, { segment: current, record });
    } else if (current.literal !== undefined) {
      this._literals = this._literals ?? new Map;
      const currentLiteral = record.settings.isCaseSensitive ? current.literal : current.literal.toLowerCase();
      if (!this._literals.has(currentLiteral)) {
        this._literals.set(currentLiteral, new internals.Segment);
      }
      this._literals.get(currentLiteral).add(remaining, record);
    } else if (current.wildcard) {
      Hoek.assert(!this._wildcard, "New route", record.path, "conflicts with existing", this._wildcard?.record.path);
      Hoek.assert(!this._param || !this._param._wildcard, "New route", record.path, "conflicts with existing", this._param?._wildcard?.record.path);
      this._wildcard = { segment: current, record };
    } else if (current.mixed) {
      this._mixed = this._mixed ?? [];
      let mixed = this._mixedLookup(current);
      if (!mixed) {
        mixed = { segment: current, node: new internals.Segment };
        this._mixed.push(mixed);
        this._mixed.sort(internals.mixed);
      }
      if (isEdge) {
        Hoek.assert(!mixed.node._edge, "New route", record.path, "conflicts with existing", mixed.node._edge?.record.path);
        mixed.node._edge = { segment: current, record };
      } else {
        mixed.node.add(remaining, record);
      }
    } else {
      this._param = this._param ?? new internals.Segment;
      if (isEdge) {
        Hoek.assert(!this._param._edge, "New route", record.path, "conflicts with existing", this._param._edge?.record.path);
        this._param._edge = { segment: current, record };
      } else {
        Hoek.assert(!this._wildcard || !remaining[0].wildcard, "New route", record.path, "conflicts with existing", this._wildcard?.record.path);
        this._param.add(remaining, record);
      }
    }
  };
  internals.Segment.prototype._mixedLookup = function(segment) {
    for (let i = 0;i < this._mixed.length; ++i) {
      if (internals.mixed({ segment }, this._mixed[i]) === 0) {
        return this._mixed[i];
      }
    }
    return null;
  };
  internals.mixed = function(a, b) {
    const aFirst = -1;
    const bFirst = 1;
    const as = a.segment;
    const bs = b.segment;
    if (as.length !== bs.length) {
      return as.length > bs.length ? aFirst : bFirst;
    }
    if (as.first !== bs.first) {
      return as.first ? bFirst : aFirst;
    }
    for (let i = 0;i < as.segments.length; ++i) {
      const am = as.segments[i];
      const bm = bs.segments[i];
      if (am === bm) {
        continue;
      }
      if (am.length === bm.length) {
        return am > bm ? bFirst : aFirst;
      }
      return am.length < bm.length ? bFirst : aFirst;
    }
    return 0;
  };
  internals.Segment.prototype.lookup = function(path2, segments, options) {
    let match = null;
    if (this._fulls) {
      match = this._fulls.get(options.isCaseSensitive ? path2 : path2.toLowerCase());
      if (match) {
        return { record: match.record, array: [] };
      }
    }
    const current = segments[0];
    const nextPath = path2.slice(current.length + 1);
    const remainder = segments.length > 1 ? segments.slice(1) : null;
    if (this._literals) {
      const literal = options.isCaseSensitive ? current : current.toLowerCase();
      match = this._literals.get(literal);
      if (match) {
        const record = internals.deeper(match, nextPath, remainder, [], options);
        if (record) {
          return record;
        }
      }
    }
    if (this._mixed) {
      for (let i = 0;i < this._mixed.length; ++i) {
        match = this._mixed[i];
        const params = current.match(match.segment.mixed);
        if (params) {
          const array = [];
          for (let j = 1;j < params.length; ++j) {
            array.push(params[j]);
          }
          const record = internals.deeper(match.node, nextPath, remainder, array, options);
          if (record) {
            return record;
          }
        }
      }
    }
    if (this._param) {
      if (current || this._param._edge?.segment.empty) {
        const record = internals.deeper(this._param, nextPath, remainder, [current], options);
        if (record) {
          return record;
        }
      }
    }
    if (this._wildcard) {
      return { record: this._wildcard.record, array: [path2.slice(1)] };
    }
    return null;
  };
  internals.deeper = function(match, path2, segments, array, options) {
    if (!segments) {
      if (match._edge) {
        return { record: match._edge.record, array };
      }
      if (match._wildcard) {
        return { record: match._wildcard.record, array };
      }
    } else {
      const result = match.lookup(path2, segments, options);
      if (result) {
        return { record: result.record, array: array.concat(result.array) };
      }
    }
    return null;
  };
});

// node_modules/@hapi/call/lib/index.js
var require_lib16 = __commonJS((exports) => {
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var Decode = require_decode();
  var Regex = require_regex();
  var Segment = require_segment();
  var internals = {
    pathRegex: Regex.generate(),
    defaults: {
      isCaseSensitive: true
    }
  };
  exports.Router = internals.Router = function(options) {
    this.settings = Hoek.applyToDefaults(internals.defaults, options || {});
    this.routes = new Map;
    this.ids = new Map;
    this.vhosts = null;
    this.specials = {
      badRequest: null,
      notFound: null,
      options: null
    };
  };
  internals.Router.prototype.add = function(config, route) {
    const method = config.method.toLowerCase();
    const vhost = config.vhost || "*";
    if (vhost !== "*") {
      this.vhosts = this.vhosts ?? new Map;
      if (!this.vhosts.has(vhost)) {
        this.vhosts.set(vhost, new Map);
      }
    }
    const table = vhost === "*" ? this.routes : this.vhosts.get(vhost);
    if (!table.has(method)) {
      table.set(method, { routes: [], router: new Segment });
    }
    const analysis = config.analysis ?? this.analyze(config.path);
    const record = {
      path: config.path,
      route: route || config.path,
      segments: analysis.segments,
      params: analysis.params,
      fingerprint: analysis.fingerprint,
      settings: this.settings
    };
    const map = table.get(method);
    map.router.add(analysis.segments, record);
    map.routes.push(record);
    map.routes.sort(internals.sort);
    const last = record.segments[record.segments.length - 1];
    if (last.empty) {
      map.router.add(analysis.segments.slice(0, -1), record);
    }
    if (config.id) {
      Hoek.assert(!this.ids.has(config.id), "Route id", config.id, "for path", config.path, "conflicts with existing path", this.ids.has(config.id) && this.ids.get(config.id).path);
      this.ids.set(config.id, record);
    }
    return record;
  };
  internals.Router.prototype.special = function(type, route) {
    Hoek.assert(Object.keys(this.specials).indexOf(type) !== -1, "Unknown special route type:", type);
    this.specials[type] = { route };
  };
  internals.Router.prototype.route = function(method, path2, hostname) {
    const segments = path2.length === 1 ? [""] : path2.split("/").slice(1);
    const vhost = this.vhosts && hostname && this.vhosts.get(hostname);
    const route = vhost && this._lookup(path2, segments, vhost, method) || this._lookup(path2, segments, this.routes, method) || method === "head" && vhost && this._lookup(path2, segments, vhost, "get") || method === "head" && this._lookup(path2, segments, this.routes, "get") || method === "options" && this.specials.options || vhost && this._lookup(path2, segments, vhost, "*") || this._lookup(path2, segments, this.routes, "*") || this.specials.notFound || Boom.notFound();
    return route;
  };
  internals.Router.prototype._lookup = function(path2, segments, table, method) {
    const set = table.get(method);
    if (!set) {
      return null;
    }
    const match = set.router.lookup(path2, segments, this.settings);
    if (!match) {
      return null;
    }
    const assignments = {};
    const array = [];
    for (let i = 0;i < match.array.length; ++i) {
      const name = match.record.params[i];
      const value = Decode.decode(match.array[i]);
      if (value === null) {
        return this.specials.badRequest ?? Boom.badRequest("Invalid request path");
      }
      if (assignments[name] !== undefined) {
        assignments[name] = assignments[name] + "/" + value;
      } else {
        assignments[name] = value;
      }
      if (i + 1 === match.array.length || name !== match.record.params[i + 1]) {
        array.push(assignments[name]);
      }
    }
    return { params: assignments, paramsArray: array, route: match.record.route };
  };
  internals.Router.prototype.normalize = function(path2) {
    if (path2 && path2.indexOf("%") !== -1) {
      const uppercase = path2.replace(/%[0-9a-fA-F][0-9a-fA-F]/g, (encoded) => encoded.toUpperCase());
      const decoded = uppercase.replace(/%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g, (encoded) => String.fromCharCode(parseInt(encoded.substring(1), 16)));
      path2 = decoded;
    }
    if (path2 && (path2.indexOf("/.") !== -1 || path2[0] === ".")) {
      const hasLeadingSlash = path2[0] === "/";
      const segments = path2.split("/");
      const normalized = [];
      let segment;
      for (let i = 0;i < segments.length; ++i) {
        segment = segments[i];
        if (segment === "..") {
          normalized.pop();
        } else if (segment !== ".") {
          normalized.push(segment);
        }
      }
      if (segment === "." || segment === "..") {
        normalized.push("");
      }
      path2 = normalized.join("/");
      if (path2[0] !== "/" && hasLeadingSlash) {
        path2 = "/" + path2;
      }
    }
    return path2;
  };
  internals.Router.prototype.analyze = function(path2) {
    Hoek.assert(internals.pathRegex.validatePath.test(path2), "Invalid path:", path2);
    Hoek.assert(!internals.pathRegex.validatePathEncoded.test(path2), "Path cannot contain encoded non-reserved path characters:", path2);
    const pathParts = path2.split("/");
    const segments = [];
    const params = [];
    const fingers = [];
    for (let i = 1;i < pathParts.length; ++i) {
      let segment = pathParts[i];
      if (segment.indexOf("{") === -1) {
        segment = this.settings.isCaseSensitive ? segment : segment.toLowerCase();
        fingers.push(segment);
        segments.push({ literal: segment });
        continue;
      }
      const parts = internals.parseParams(segment);
      if (parts.length === 1) {
        const item = parts[0];
        Hoek.assert(params.indexOf(item.name) === -1, "Cannot repeat the same parameter name:", item.name, "in:", path2);
        params.push(item.name);
        if (item.wildcard) {
          if (item.count) {
            for (let j = 0;j < item.count; ++j) {
              fingers.push("?");
              segments.push({});
              if (j) {
                params.push(item.name);
              }
            }
          } else {
            fingers.push("#");
            segments.push({ wildcard: true });
          }
        } else {
          fingers.push("?");
          segments.push({ empty: item.empty });
        }
      } else {
        const seg = {
          length: parts.length,
          first: typeof parts[0] !== "string",
          segments: []
        };
        let finger = "";
        let regex = "^";
        for (let j = 0;j < parts.length; ++j) {
          const part = parts[j];
          if (typeof part === "string") {
            finger = finger + part;
            regex = regex + Hoek.escapeRegex(part);
            seg.segments.push(part);
          } else {
            Hoek.assert(params.indexOf(part.name) === -1, "Cannot repeat the same parameter name:", part.name, "in:", path2);
            params.push(part.name);
            finger = finger + "?";
            regex = regex + "(." + (part.empty ? "*" : "+") + ")";
          }
        }
        seg.mixed = new RegExp(regex + "$", !this.settings.isCaseSensitive ? "i" : "");
        fingers.push(finger);
        segments.push(seg);
      }
    }
    return {
      segments,
      fingerprint: "/" + fingers.join("/"),
      params
    };
  };
  internals.parseParams = function(segment) {
    const parts = [];
    segment.replace(internals.pathRegex.parseParam, ($0, literal, name, wildcard, count, empty) => {
      if (literal) {
        parts.push(literal);
      } else {
        parts.push({
          name,
          wildcard: !!wildcard,
          count: count && parseInt(count, 10),
          empty: !!empty
        });
      }
      return "";
    });
    return parts;
  };
  internals.Router.prototype.table = function(host) {
    const result = [];
    const collect = (table) => {
      if (!table) {
        return;
      }
      for (const map of table.values()) {
        for (const record of map.routes) {
          result.push(record.route);
        }
      }
    };
    if (this.vhosts) {
      const vhosts = host ? [].concat(host) : [...this.vhosts.keys()];
      for (const vhost of vhosts) {
        collect(this.vhosts.get(vhost));
      }
    }
    collect(this.routes);
    return result;
  };
  internals.sort = function(a, b) {
    const aFirst = -1;
    const bFirst = 1;
    const as = a.segments;
    const bs = b.segments;
    if (as.length !== bs.length) {
      return as.length > bs.length ? bFirst : aFirst;
    }
    for (let i = 0;; ++i) {
      if (as[i].literal) {
        if (bs[i].literal) {
          if (as[i].literal === bs[i].literal) {
            continue;
          }
          return as[i].literal > bs[i].literal ? bFirst : aFirst;
        }
        return aFirst;
      }
      if (bs[i].literal) {
        return bFirst;
      }
      return as[i].wildcard ? bFirst : aFirst;
    }
  };
});

// node_modules/@hapi/catbox/lib/client.js
var require_client4 = __commonJS((exports, module) => {
  var Hoek = require_lib8();
  var Boom = require_lib13();
  var internals = {
    validate: Symbol("validate")
  };
  internals.defaults = {
    partition: "catbox"
  };
  module.exports = class {
    constructor(engine, options) {
      Hoek.assert(engine, "Missing catbox client engine");
      Hoek.assert(typeof engine === "object" && typeof engine.start === "function" || typeof engine === "function", "engine must be an engine object or engine prototype (function)");
      Hoek.assert(typeof engine === "function" || !options, "Can only specify options with function engine config");
      const settings = Object.assign({}, internals.defaults, options);
      Hoek.assert(settings.partition.match(/^[\w\-]+$/), "Invalid partition name:" + settings.partition);
      this.connection = typeof engine === "object" ? engine : new engine(settings);
    }
    async start() {
      await this.connection.start();
    }
    async stop() {
      await this.connection.stop();
    }
    isReady() {
      return this.connection.isReady();
    }
    validateSegmentName(name) {
      return this.connection.validateSegmentName(name);
    }
    async get(key) {
      this[internals.validate](key, null);
      if (key === null) {
        return null;
      }
      const result = await this.connection.get(key);
      if (!result || result.item === undefined || result.item === null) {
        return null;
      }
      const now = Date.now();
      const expires = result.stored + result.ttl;
      const ttl = expires - now;
      if (ttl <= 0) {
        return null;
      }
      const cached = {
        item: result.item,
        stored: result.stored,
        ttl
      };
      return cached;
    }
    async set(key, value, ttl) {
      this[internals.validate](key);
      if (ttl <= 0) {
        return;
      }
      await this.connection.set(key, value, ttl);
    }
    async drop(key) {
      this[internals.validate](key);
      await this.connection.drop(key);
    }
    [internals.validate](key, allow = {}) {
      if (!this.isReady()) {
        throw Boom.internal("Disconnected");
      }
      const isValidKey = key && typeof key.id === "string" && key.segment && typeof key.segment === "string";
      if (!isValidKey && key !== allow) {
        throw Boom.internal("Invalid key");
      }
    }
  };
});

// node_modules/@hapi/podium/lib/index.js
var require_lib17 = __commonJS((exports) => {
  var Hoek = require_lib8();
  var Teamwork = require_lib12();
  var Validate = require_lib10();
  var internals = {
    schema: {
      base: Validate.object({
        name: Validate.string().required(),
        clone: Validate.boolean(),
        tags: Validate.boolean(),
        spread: Validate.boolean(),
        channels: Validate.array().items(Validate.string()).single().unique().min(1).cast("set")
      })
    }
  };
  internals.schema.event = internals.schema.base.keys({
    shared: Validate.boolean()
  });
  internals.schema.listener = internals.schema.base.keys({
    listener: Validate.func().required(),
    context: Validate.object(),
    count: Validate.number().integer().min(1),
    filter: {
      tags: Validate.array().items(Validate.string()).single().unique().min(1).required(),
      all: Validate.boolean()
    }
  });
  exports.validate = function(events) {
    const normalized = [];
    events = [].concat(events);
    for (let event of events) {
      if (typeof event === "string") {
        event = { name: event };
      }
      normalized.push(Validate.attempt(event, internals.schema.event, "Invalid event options"));
    }
    return normalized;
  };
  exports.Podium = class {
    #listeners = new Map;
    constructor(events, options) {
      if (events) {
        this.registerEvent(events, options);
      }
    }
    registerEvent(events, options) {
      events = [].concat(events);
      for (let event of events) {
        if (typeof event === "string") {
          event = { name: event };
        }
        if (options?.validate !== false) {
          event = Validate.attempt(event, internals.schema.event, "Invalid event options");
        }
        const name = event.name;
        if (this.#listeners.has(name)) {
          Hoek.assert(event.shared, `Event ${name} exists`);
          continue;
        }
        this.#listeners.set(name, new internals.EventListener(event));
      }
    }
    emit(criteria, data) {
      let thrownErr;
      this.#emitToEachListener(criteria, data, ([err]) => {
        thrownErr = thrownErr ?? err;
      });
      if (thrownErr) {
        throw thrownErr;
      }
    }
    async gauge(criteria, data) {
      const promises = [];
      this.#emitToEachListener(criteria, data, ([err, result]) => {
        promises.push(err ? Promise.reject(err) : result);
      });
      return await Promise.allSettled(promises);
    }
    #emitToEachListener(criteria, data, fn) {
      criteria = internals.criteria(criteria);
      const name = criteria.name;
      Hoek.assert(name, "Criteria missing event name");
      const event = this.#listeners.get(name);
      Hoek.assert(event, `Unknown event ${name}`);
      if (!event.handlers) {
        return;
      }
      Hoek.assert(!criteria.channel || typeof criteria.channel === "string", "Invalid channel name");
      Hoek.assert(!criteria.channel || !event.flags.channels || event.flags.channels.has(criteria.channel), `Unknown ${criteria.channel} channel`);
      Hoek.assert(!event.flags.spread || Array.isArray(data) || typeof data === "function", "Data must be an array for spread event");
      if (typeof criteria.tags === "string") {
        criteria = { ...criteria };
        criteria.tags = { [criteria.tags]: true };
      }
      if (criteria.tags && Array.isArray(criteria.tags)) {
        const tags = {};
        for (const tag of criteria.tags) {
          tags[tag] = true;
        }
        criteria = { ...criteria };
        criteria.tags = tags;
      }
      let generated = false;
      for (const handler of event.handlers) {
        if (handler.channels && !(criteria.channel && handler.channels.has(criteria.channel))) {
          continue;
        }
        if (handler.filter) {
          if (!criteria.tags) {
            continue;
          }
          const match = Hoek.intersect(criteria.tags, handler.filter.tags, { first: !handler.filter.all });
          if (!match || handler.filter.all && match.length !== handler.filter.tags.length) {
            continue;
          }
        }
        if (handler.count) {
          --handler.count;
          if (handler.count < 1) {
            event.removeListener(handler.listener);
          }
        }
        if (!generated && typeof data === "function") {
          data = data();
          generated = true;
        }
        const update = event.flagged("clone", handler) ? Hoek.clone(data) : data;
        const args = event.flagged("spread", handler) && Array.isArray(update) ? update.slice(0) : [update];
        if (event.flagged("tags", handler) && criteria.tags) {
          args.push(criteria.tags);
        }
        try {
          if (handler.context) {
            fn([null, handler.listener.apply(handler.context, args)]);
          } else {
            fn([null, handler.listener(...args)]);
          }
        } catch (err) {
          fn([err, null]);
        }
      }
    }
    addListener(criteria, listener, context) {
      criteria = internals.criteria(criteria);
      criteria.listener = listener;
      criteria.context = context;
      if (criteria.filter && (typeof criteria.filter === "string" || Array.isArray(criteria.filter))) {
        criteria = { ...criteria };
        criteria.filter = { tags: criteria.filter };
      }
      criteria = Validate.attempt(criteria, internals.schema.listener, "Invalid event listener options");
      const name = criteria.name;
      const event = this.#listeners.get(name);
      Hoek.assert(event, `Unknown event ${name}`);
      event.addHandler(criteria);
      return this;
    }
    on(criteria, listener, context) {
      return this.addListener(criteria, listener, context);
    }
    once(criteria, listener, context) {
      criteria = { ...internals.criteria(criteria), count: 1 };
      if (listener) {
        return this.addListener(criteria, listener, context);
      }
      return new Promise((resolve) => {
        this.addListener(criteria, (...args) => resolve(args));
      });
    }
    few(criteria) {
      Hoek.assert(typeof criteria === "object", "Criteria must be an object");
      Hoek.assert(criteria.count, "Criteria must include a count limit");
      const team = new Teamwork.Team({ meetings: criteria.count });
      this.addListener(criteria, (...args) => team.attend(args));
      return team.work;
    }
    removeListener(name, listener) {
      Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
      Hoek.assert(typeof listener === "function", "Listener must be a function");
      this.#listeners.get(name).removeListener(listener);
      return this;
    }
    off(name, listener) {
      return this.removeListener(name, listener);
    }
    removeAllListeners(name) {
      Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
      this.#listeners.get(name).handlers = null;
      return this;
    }
    hasListeners(name) {
      Hoek.assert(this.#listeners.has(name), `Unknown event ${name}`);
      return !!this.#listeners.get(name).handlers;
    }
  };
  internals.EventListener = class {
    constructor(flags) {
      this.flags = flags;
      this.handlers = null;
    }
    addHandler(handler) {
      Hoek.assert(!handler.channels || !this.flags.channels || Hoek.intersect(this.flags.channels, handler.channels).length === handler.channels.size, `Unknown event channels ${handler.channels && [...handler.channels].join(", ")}`);
      this.handlers = this.handlers ? [...this.handlers, handler] : [handler];
    }
    removeListener(listener) {
      const filtered = this.handlers?.filter((item) => item.listener !== listener);
      this.handlers = filtered?.length ? filtered : null;
    }
    flagged(name, handler) {
      return handler[name] ?? this.flags[name] ?? false;
    }
  };
  internals.criteria = function(criteria) {
    if (typeof criteria === "string") {
      return { name: criteria };
    }
    return criteria;
  };
});

// node_modules/@hapi/catbox/lib/pending.js
var require_pending = __commonJS((exports, module) => {
  exports = module.exports = class {
    id = null;
    timeout = null;
    count = 1;
    rule = null;
    resolve = null;
    reject = null;
    constructor(id, rule) {
      this.id = id;
      this.rule = rule;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
    }
    join() {
      ++this.count;
      return this.promise;
    }
    send(err, value, cached, report) {
      clearTimeout(this.timeout);
      if (err && !cached) {
        this.reject(err);
        return;
      }
      if (!this.rule.getDecoratedValue) {
        this.resolve(value);
        return;
      }
      if (err) {
        report.error = err;
      }
      this.resolve({ value, cached, report });
    }
    setTimeout(fn, timeoutMs) {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(fn, timeoutMs);
    }
  };
});

// node_modules/@hapi/catbox/lib/policy.js
var require_policy = __commonJS((exports, module) => {
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var Podium = require_lib17();
  var Validate = require_lib10();
  var Pending = require_pending();
  var internals = {
    day: 24 * 60 * 60 * 1000,
    events: Podium.validate([
      { name: "error", channels: ["generate", "persist"] }
    ])
  };
  internals.schema = Validate.object({
    expiresIn: Validate.number().integer().min(1),
    expiresAt: Validate.string().regex(/^\d\d?\:\d\d$/),
    staleIn: [
      Validate.number().integer().min(1).when("expiresAt", { is: Validate.required(), then: Validate.number().max(86400000 - 1) }),
      Validate.func()
    ],
    staleTimeout: Validate.number().integer().min(1),
    generateFunc: Validate.func(),
    generateTimeout: Validate.number().integer().min(1).allow(false),
    generateOnReadError: Validate.boolean(),
    generateIgnoreWriteError: Validate.boolean(),
    dropOnError: Validate.boolean(),
    pendingGenerateTimeout: Validate.number().integer().min(1),
    getDecoratedValue: Validate.boolean().default(false),
    privacy: Validate.any(),
    cache: Validate.any(),
    segment: Validate.any(),
    shared: Validate.any()
  }).without("expiresIn", "expiresAt").with("staleIn", "generateFunc").with("generateOnReadError", "generateFunc").with("generateIgnoreWriteError", "generateFunc").with("dropOnError", "generateFunc").and("generateFunc", "generateTimeout").and("staleIn", "staleTimeout");
  exports = module.exports = internals.Policy = class {
    rule = null;
    stats = {
      sets: 0,
      gets: 0,
      hits: 0,
      stales: 0,
      generates: 0,
      errors: 0
    };
    _events = null;
    _cache = null;
    _segment = null;
    _pendings = new Map;
    _pendingGenerateCall = new Map;
    constructor(options, cache, segment) {
      this._cache = cache;
      this.rules(options);
      if (cache) {
        const nameErr = cache.validateSegmentName(segment);
        Hoek.assert(nameErr === null, "Invalid segment name: " + segment + (nameErr ? " (" + nameErr.message + ")" : ""));
        this._segment = segment;
      }
    }
    get client() {
      return this._cache;
    }
    get events() {
      if (!this._events) {
        this._events = new Podium.Podium(internals.events, { validate: false });
      }
      return this._events;
    }
    _error(source, error) {
      if (!this._events) {
        return;
      }
      this._events.emit({ name: "error", channel: source }, { source, error });
    }
    rules(options) {
      this.rule = internals.Policy.compile(options, !!this._cache);
    }
    async get(key) {
      ++this.stats.gets;
      if (!key || typeof key === "string") {
        key = { id: key, string: true };
      }
      let pending = this._pendings.get(key.id);
      if (pending !== undefined) {
        return pending.join();
      }
      pending = new Pending(key.id, this.rule);
      this._pendings.set(key.id, pending);
      try {
        await this._get(pending, key);
      } catch (err) {
        this._send(key, err);
      }
      return pending.promise;
    }
    async _get(pending, key) {
      const report = {};
      const timer = new Hoek.Bench;
      if (this._cache) {
        try {
          var cached = await this._cache.get({ segment: this._segment, id: key.id });
        } catch (err) {
          report.error = err;
          ++this.stats.errors;
          this._error("persist", err);
        }
      }
      report.msec = timer.elapsed();
      if (cached) {
        report.stored = cached.stored;
        report.ttl = cached.ttl;
        const staleIn = typeof this.rule.staleIn === "function" ? this.rule.staleIn(cached.stored, cached.ttl) : this.rule.staleIn;
        cached.isStale = staleIn ? Date.now() - cached.stored >= staleIn : false;
        report.isStale = cached.isStale;
        if (cached.isStale) {
          ++this.stats.stales;
        }
      }
      if (!this.rule.generateFunc || report.error && !this.rule.generateOnReadError) {
        this._send(key, report.error, cached ? cached.item : null, cached, report);
        return;
      }
      if (cached && !cached.isStale) {
        this._send(key, null, cached.item, cached, report);
        return;
      }
      return Promise.race([
        pending.promise,
        this._generate(pending, key, cached, report)
      ]);
    }
    _generate(pending, key, cached, report) {
      if (cached) {
        cached.ttl = cached.ttl - this.rule.staleTimeout;
      }
      if (cached && cached.ttl > 0) {
        pending.setTimeout(() => this._send(key, null, cached.item, cached, report), this.rule.staleTimeout);
      } else if (this.rule.generateTimeout) {
        pending.setTimeout(() => this._send(key, Boom.serverUnavailable(), null, null, report), this.rule.generateTimeout);
      }
      if (this._pendingGenerateCall.has(key.id)) {
        return;
      }
      ++this.stats.generates;
      if (this.rule.pendingGenerateTimeout) {
        const timeout = setTimeout(() => this._pendingGenerateCall.delete(key.id), this.rule.pendingGenerateTimeout);
        this._pendingGenerateCall.set(key.id, timeout);
      }
      return this._callGenerateFunc(key, cached, report);
    }
    async _callGenerateFunc(key, cached, report) {
      const flags = {};
      try {
        var value = await this.rule.generateFunc(key.string ? key.id : key, flags);
      } catch (err) {
        var generateError = err;
        this._error("generate", err);
      }
      const pendingTimeout = this._pendingGenerateCall.get(key.id);
      if (pendingTimeout) {
        clearTimeout(pendingTimeout);
        this._pendingGenerateCall.delete(key.id);
      }
      try {
        if (flags.ttl === 0 || generateError && this.rule.dropOnError) {
          await this.drop(key.id);
        } else if (!generateError) {
          await this.set(key.id, value, flags.ttl);
        }
      } catch (err) {
        var persistError = err;
        this._error("persist", err);
      }
      const error = generateError || (this.rule.generateIgnoreWriteError ? null : persistError);
      if (cached && error && !this.rule.dropOnError) {
        this._send(key, error, cached.item, cached, report);
        return;
      }
      this._send(key, error, value, null, report);
    }
    _send(key, err, value, cached, report) {
      const pending = this._pendings.get(key.id);
      if (!pending) {
        return;
      }
      this._pendings.delete(key.id);
      pending.send(err, value, cached, report);
      if (report?.isStale !== undefined) {
        this.stats.hits = this.stats.hits + pending.count;
      }
    }
    async set(key, value, ttl) {
      ++this.stats.sets;
      if (!this._cache) {
        return;
      }
      try {
        await this._cache.set({ segment: this._segment, id: internals.id(key) }, value, ttl || internals.Policy.ttl(this.rule));
      } catch (err) {
        ++this.stats.errors;
        throw err;
      }
    }
    async drop(key) {
      if (!this._cache) {
        return;
      }
      try {
        await this._cache.drop({ segment: this._segment, id: internals.id(key) });
        return;
      } catch (err) {
        ++this.stats.errors;
        throw err;
      }
    }
    ttl(created) {
      return internals.Policy.ttl(this.rule, created);
    }
    isReady() {
      if (!this._cache) {
        return false;
      }
      return this._cache.connection.isReady();
    }
    static compile(options, serverSide) {
      const rule = {};
      if (!options || !Object.keys(options).length) {
        return rule;
      }
      options = Validate.attempt(options, internals.schema, "Invalid cache policy configuration");
      const hasExpiresIn = options.expiresIn !== undefined && options.expiresIn !== null;
      const hasExpiresAt = options.expiresAt !== undefined && options.expiresAt !== null;
      Hoek.assert(!hasExpiresIn || !options.staleIn || typeof options.staleIn === "function" || options.staleIn < options.expiresIn, "staleIn must be less than expiresIn");
      Hoek.assert(!options.staleIn || serverSide, "Cannot use stale options without server-side caching");
      Hoek.assert(!options.staleTimeout || !hasExpiresIn || options.staleTimeout < options.expiresIn, "staleTimeout must be less than expiresIn");
      Hoek.assert(!options.staleTimeout || !hasExpiresIn || typeof options.staleIn === "function" || options.staleTimeout < options.expiresIn - options.staleIn, "staleTimeout must be less than the delta between expiresIn and staleIn");
      Hoek.assert(!options.staleTimeout || !options.pendingGenerateTimeout || options.staleTimeout < options.pendingGenerateTimeout, "pendingGenerateTimeout must be greater than staleTimeout if specified");
      if (hasExpiresAt) {
        const time = /^(\d\d?):(\d\d)$/.exec(options.expiresAt);
        rule.expiresAt = {
          hours: parseInt(time[1], 10),
          minutes: parseInt(time[2], 10)
        };
      } else {
        rule.expiresIn = options.expiresIn ?? 0;
      }
      if (options.generateFunc) {
        rule.generateFunc = options.generateFunc;
        rule.generateTimeout = options.generateTimeout;
        if (options.staleIn) {
          rule.staleIn = options.staleIn;
          rule.staleTimeout = options.staleTimeout;
        }
        rule.dropOnError = options.dropOnError !== undefined ? options.dropOnError : true;
        rule.pendingGenerateTimeout = options.pendingGenerateTimeout !== undefined ? options.pendingGenerateTimeout : 0;
      }
      rule.generateOnReadError = options.generateOnReadError !== undefined ? options.generateOnReadError : true;
      rule.generateIgnoreWriteError = options.generateIgnoreWriteError !== undefined ? options.generateIgnoreWriteError : true;
      rule.getDecoratedValue = options.getDecoratedValue;
      return rule;
    }
    static ttl(rule, created, now) {
      now = now ?? Date.now();
      created = created ?? now;
      const age = now - created;
      if (age < 0) {
        return 0;
      }
      if (rule.expiresIn) {
        return Math.max(rule.expiresIn - age, 0);
      }
      if (rule.expiresAt) {
        if (age > internals.day) {
          return 0;
        }
        const expiresAt = new Date(created);
        expiresAt.setHours(rule.expiresAt.hours);
        expiresAt.setMinutes(rule.expiresAt.minutes);
        expiresAt.setSeconds(0);
        expiresAt.setMilliseconds(0);
        let expires = expiresAt.getTime();
        if (expires <= created) {
          expires = expires + internals.day;
        }
        if (now >= expires) {
          return 0;
        }
        return expires - now;
      }
      return 0;
    }
  };
  internals.id = function(key) {
    return key && typeof key === "object" ? key.id : key;
  };
});

// node_modules/@hapi/catbox/lib/index.js
var require_lib18 = __commonJS((exports) => {
  var Client2 = require_client4();
  var Policy = require_policy();
  exports.Client = Client2;
  exports.Policy = exports.policy = Policy;
});

// node_modules/@hapi/catbox-memory/lib/index.js
var require_lib19 = __commonJS((exports) => {
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var internals = {
    maxTimer: 2147483647,
    entrySize: 144
  };
  internals.defaults = {
    maxByteSize: 100 * 1024 * 1024,
    minCleanupIntervalMsec: 1000,
    cloneBuffersOnGet: false
  };
  exports.Engine = class CatboxMemoryEngine {
    constructor(options = {}) {
      Hoek.assert(options.maxByteSize === undefined || options.maxByteSize >= 0, "Invalid cache maxByteSize value");
      Hoek.assert(options.allowMixedContent === undefined, "allowMixedContent no longer supported");
      Hoek.assert(options.minCleanupIntervalMsec === undefined || options.minCleanupIntervalMsec < internals.maxTimer, "Invalid cache minCleanupIntervalMsec value");
      Hoek.assert(options.cloneBuffersOnGet === undefined || typeof options.cloneBuffersOnGet === "boolean", "Invalid cloneBuffersOnGet value");
      this.settings = Hoek.applyToDefaults(internals.defaults, options);
      this.cache = null;
      this._timer = null;
      this._timerDue = null;
    }
    start() {
      if (!this.cache) {
        this.cache = new Map;
        this.byteSize = 0;
      }
    }
    _scheduleCleanup(msec) {
      const cleanup = () => {
        this._timer = null;
        this._timerDue = null;
        const now2 = Date.now();
        let next = Infinity;
        for (const [, segment] of this.cache) {
          for (const [id, envelope] of segment) {
            const ttl = envelope.stored + envelope.ttl - now2;
            if (ttl <= 0) {
              segment.delete(id);
              this.byteSize -= envelope.byteSize;
            } else {
              next = Math.min(next, ttl);
            }
          }
        }
        if (next !== Infinity) {
          this._scheduleCleanup(next);
        }
      };
      const now = Date.now();
      const timeout = Math.min(Math.max(this.settings.minCleanupIntervalMsec, msec), internals.maxTimer);
      if (this._timer) {
        if (this._timerDue - now < msec) {
          return;
        }
        clearTimeout(this._timer);
      }
      this._timerDue = now + timeout;
      this._timer = setTimeout(cleanup, timeout);
    }
    stop() {
      clearTimeout(this._timer);
      this._timer = null;
      this._timerDue = null;
      this.cache = null;
      this.byteSize = 0;
    }
    isReady() {
      return !!this.cache;
    }
    validateSegmentName(name) {
      if (!name) {
        throw new Boom.Boom("Empty string");
      }
      if (name.indexOf("\x00") !== -1) {
        throw new Boom.Boom("Includes null character");
      }
      return null;
    }
    get(key) {
      if (!this.cache) {
        throw new Boom.Boom("Connection not started");
      }
      const segment = this.cache.get(key.segment);
      if (!segment) {
        return null;
      }
      const envelope = segment.get(key.id);
      if (!envelope) {
        return null;
      }
      if (envelope.stored + envelope.ttl < Date.now()) {
        this.drop(key);
        return null;
      }
      let item = null;
      if (Buffer.isBuffer(envelope.item)) {
        item = envelope.item;
        if (this.settings.cloneBuffersOnGet) {
          const copy = Buffer.alloc(item.length);
          item.copy(copy);
          item = copy;
        }
      } else {
        try {
          item = JSON.parse(envelope.item);
        } catch (err) {
          throw new Boom.Boom("Bad value content");
        }
      }
      const result = {
        item,
        stored: envelope.stored,
        ttl: envelope.ttl
      };
      return result;
    }
    set(key, value, ttl) {
      if (!this.cache) {
        throw new Boom.Boom("Connection not started");
      }
      const envelope = new internals.MemoryCacheEntry(key, value, ttl);
      let segment = this.cache.get(key.segment);
      if (!segment) {
        segment = new Map;
        this.cache.set(key.segment, segment);
      }
      const cachedItem = segment.get(key.id);
      if (cachedItem) {
        this.byteSize -= cachedItem.byteSize;
      }
      if (this.settings.maxByteSize && this.byteSize + envelope.byteSize > this.settings.maxByteSize) {
        throw new Boom.Boom("Cache size limit reached");
      }
      this._scheduleCleanup(ttl);
      segment.set(key.id, envelope);
      this.byteSize += envelope.byteSize;
    }
    drop(key) {
      if (!this.cache) {
        throw new Boom.Boom("Connection not started");
      }
      const segment = this.cache.get(key.segment);
      if (segment) {
        const item = segment.get(key.id);
        if (item) {
          this.byteSize -= item.byteSize;
          segment.delete(key.id);
        }
      }
    }
  };
  internals.MemoryCacheEntry = class {
    constructor(key, value, ttl) {
      let valueByteSize = 0;
      if (Buffer.isBuffer(value)) {
        this.item = Buffer.alloc(value.length);
        value.copy(this.item);
        valueByteSize = this.item.length;
      } else {
        this.item = JSON.stringify(value);
        valueByteSize = Buffer.byteLength(this.item);
      }
      this.stored = Date.now();
      this.ttl = ttl;
      this.byteSize = internals.entrySize + valueByteSize + Buffer.byteLength(key.segment) + Buffer.byteLength(key.id);
      this.timeoutId = null;
    }
  };
});

// node_modules/@hapi/heavy/lib/index.js
var require_lib20 = __commonJS((exports) => {
  var PerfHooks = __require("perf_hooks");
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var Validate = require_lib10();
  var internals = {};
  internals.schema = Validate.object({
    sampleInterval: Validate.number().min(0),
    maxHeapUsedBytes: Validate.number().min(0),
    maxEventLoopDelay: Validate.number().min(0),
    maxEventLoopUtilization: Validate.number().min(0),
    maxRssBytes: Validate.number().min(0)
  }).unknown();
  internals.defaults = {
    sampleInterval: 0,
    maxHeapUsedBytes: 0,
    maxRssBytes: 0,
    maxEventLoopDelay: 0,
    maxEventLoopUtilization: 0
  };
  exports.Heavy = class Heavy {
    constructor(options) {
      options = options || {};
      Validate.assert(options, internals.schema, "Invalid load monitoring options");
      this.settings = Hoek.applyToDefaults(internals.defaults, options);
      Hoek.assert(this.settings.sampleInterval || !this.settings.maxEventLoopDelay && !this.settings.maxHeapUsedBytes && !this.settings.maxRssBytes && !this.settings.maxEventLoopUtilization, "Load sample interval must be set to enable load limits");
      this._eventLoopTimer = null;
      this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization();
      this._loadBench = new Hoek.Bench;
      this.load = {
        eventLoopDelay: 0,
        eventLoopUtilization: 0,
        heapUsed: 0,
        rss: 0
      };
    }
    start() {
      if (!this.settings.sampleInterval) {
        return;
      }
      const loopSample = () => {
        this._loadBench.reset();
        const measure = () => {
          const mem = process.memoryUsage();
          this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization(this._eventLoopUtilization);
          this.load.eventLoopDelay = this._loadBench.elapsed() - this.settings.sampleInterval;
          this.load.eventLoopUtilization = this._eventLoopUtilization.utilization;
          this.load.heapUsed = mem.heapUsed;
          this.load.rss = mem.rss;
          loopSample();
        };
        this._eventLoopTimer = setTimeout(measure, this.settings.sampleInterval);
      };
      loopSample();
    }
    stop() {
      clearTimeout(this._eventLoopTimer);
      this._eventLoopTimer = null;
    }
    check() {
      if (!this.settings.sampleInterval) {
        return;
      }
      Hoek.assert(this._eventLoopTimer, "Cannot check load when sampler is not started");
      const elapsed = this._loadBench.elapsed();
      const load = this.load;
      if (elapsed > this.settings.sampleInterval) {
        this._eventLoopUtilization = PerfHooks.performance.eventLoopUtilization(this._eventLoopUtilization);
        load.eventLoopDelay = Math.max(load.eventLoopDelay, elapsed - this.settings.sampleInterval);
        load.eventLoopUtilization = this._eventLoopUtilization.utilization;
      }
      if (this.settings.maxEventLoopDelay && load.eventLoopDelay > this.settings.maxEventLoopDelay) {
        throw Boom.serverUnavailable("Server under heavy load (event loop)", load);
      }
      if (this.settings.maxEventLoopUtilization && load.eventLoopUtilization > this.settings.maxEventLoopUtilization) {
        throw Boom.serverUnavailable("Server under heavy load (event loop utilization)", load);
      }
      if (this.settings.maxHeapUsedBytes && load.heapUsed > this.settings.maxHeapUsedBytes) {
        throw Boom.serverUnavailable("Server under heavy load (heap)", load);
      }
      if (this.settings.maxRssBytes && load.rss > this.settings.maxRssBytes) {
        throw Boom.serverUnavailable("Server under heavy load (rss)", load);
      }
    }
  };
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/ace+json": {
      source: "iana",
      compressible: true
    },
    "application/ace-groupcomm+cbor": {
      source: "iana"
    },
    "application/ace-trl+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/aif+cbor": {
      source: "iana"
    },
    "application/aif+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-cdni+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-cdnifilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-propmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-propmapparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-tips+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-tipsparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/appinstaller": {
      compressible: false,
      extensions: ["appinstaller"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/appx": {
      compressible: false,
      extensions: ["appx"]
    },
    "application/appxbundle": {
      compressible: false,
      extensions: ["appxbundle"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/automationml-aml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["aml"]
    },
    "application/automationml-amlx+zip": {
      source: "iana",
      compressible: false,
      extensions: ["amlx"]
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/bufr": {
      source: "iana"
    },
    "application/c2pa": {
      source: "iana"
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/ce+cbor": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/cid-edhoc+cbor-seq": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/city+json-seq": {
      source: "iana"
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-eap": {
      source: "iana"
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/concise-problem-details+cbor": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cose-x509": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwl": {
      source: "iana",
      extensions: ["cwl"]
    },
    "application/cwl+json": {
      source: "iana",
      compressible: true
    },
    "application/cwl+yaml": {
      source: "iana"
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana",
      extensions: ["dcm"]
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dpop+jwt": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/eat+cwt": {
      source: "iana"
    },
    "application/eat+jwt": {
      source: "iana"
    },
    "application/eat-bun+cbor": {
      source: "iana"
    },
    "application/eat-bun+json": {
      source: "iana",
      compressible: true
    },
    "application/eat-ucs+cbor": {
      source: "iana"
    },
    "application/eat-ucs+json": {
      source: "iana",
      compressible: true
    },
    "application/ecmascript": {
      source: "apache",
      compressible: true,
      extensions: ["ecma"]
    },
    "application/edhoc+cbor-seq": {
      source: "iana"
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.legacyesn+json": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/entity-statement+jwt": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geopose+json": {
      source: "iana",
      compressible: true
    },
    "application/geoxacml+json": {
      source: "iana",
      compressible: true
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gnap-binding-jws": {
      source: "iana"
    },
    "application/gnap-binding-jwsd": {
      source: "iana"
    },
    "application/gnap-binding-rotation-jws": {
      source: "iana"
    },
    "application/gnap-binding-rotation-jwsd": {
      source: "iana"
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/grib": {
      source: "iana"
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "iana",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "apache",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/jscontact+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jsonpath": {
      source: "iana"
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+jwt": {
      source: "iana"
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/linkset": {
      source: "iana"
    },
    "application/linkset+json": {
      source: "iana",
      compressible: true
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/logout+jwt": {
      source: "iana"
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4", "mpg4", "mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msix": {
      compressible: false,
      extensions: ["msix"]
    },
    "application/msixbundle": {
      compressible: false,
      extensions: ["msixbundle"]
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: true,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/ohttp-keys": {
      source: "iana"
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["sig", "asc"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/private-token-issuer-directory": {
      source: "iana"
    },
    "application/private-token-request": {
      source: "iana"
    },
    "application/private-token-response": {
      source: "iana"
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/provided-claims+jwt": {
      source: "iana"
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.implied-document+xml": {
      source: "iana",
      compressible: true
    },
    "application/prs.implied-executable": {
      source: "iana"
    },
    "application/prs.implied-object+json": {
      source: "iana",
      compressible: true
    },
    "application/prs.implied-object+json-seq": {
      source: "iana"
    },
    "application/prs.implied-object+yaml": {
      source: "iana"
    },
    "application/prs.implied-structure": {
      source: "iana"
    },
    "application/prs.mayfile": {
      source: "iana"
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.vcfbzip2": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsf"]
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "apache"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resolve-response+jwt": {
      source: "iana"
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-checklist": {
      source: "iana"
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-signed-tal": {
      source: "iana"
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "apache"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana",
      extensions: ["sql"]
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/sslkeylogfile": {
      source: "iana"
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/st2110-41": {
      source: "iana"
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/stratum": {
      source: "iana"
    },
    "application/swid+cbor": {
      source: "iana"
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tm+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/toc+cbor": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      source: "iana",
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/trust-chain+json": {
      source: "iana",
      compressible: true
    },
    "application/trust-mark+jwt": {
      source: "iana"
    },
    "application/trust-mark-delegation+jwt": {
      source: "iana"
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/uccs+cbor": {
      source: "iana"
    },
    "application/ujcs+json": {
      source: "iana",
      compressible: true
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vc": {
      source: "iana"
    },
    "application/vc+cose": {
      source: "iana"
    },
    "application/vc+jwt": {
      source: "iana"
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.1ob": {
      source: "iana"
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3a+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ach+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc8+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.5gsa2x": {
      source: "iana"
    },
    "application/vnd.3gpp.5gsa2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gsv2x": {
      source: "iana"
    },
    "application/vnd.3gpp.5gsv2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.crs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.current-location-discovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-regroup+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-regroup+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-regroup+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.pinapp-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.seal-group-doc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-network-qos-management-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-ue-config-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-unicast-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.seal-user-profile-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.v2x": {
      source: "iana"
    },
    "application/vnd.3gpp.vae-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acm.addressxfer+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.acm.chatbot+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "apache",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "apache"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.parquet": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.apexlang": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "apache"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autodesk.fbx": {
      extensions: ["fbx"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.belightsoft.lhzd+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.belightsoft.lhzl+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bzip3": {
      source: "iana"
    },
    "application/vnd.c3voc.schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.cncf.helm.chart.content.v1.tar+gzip": {
      source: "iana"
    },
    "application/vnd.cncf.helm.chart.provenance.v1.prov": {
      source: "iana"
    },
    "application/vnd.cncf.helm.config.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datalog": {
      source: "iana"
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.dcmp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dcmp"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.eln+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.erofs": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "apache",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.fdsn.stationxml+xml": {
      source: "iana",
      charset: "XML-BASED",
      compressible: true
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.freelog.comic": {
      source: "iana"
    },
    "application/vnd.frogans.fnc": {
      source: "apache",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "apache",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.ga4gh.passport+jwt": {
      source: "iana"
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.genozip": {
      source: "iana"
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gentoo.catmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gentoo.ebuild": {
      source: "iana"
    },
    "application/vnd.gentoo.eclass": {
      source: "iana"
    },
    "application/vnd.gentoo.gpkg": {
      source: "iana"
    },
    "application/vnd.gentoo.manifest": {
      source: "iana"
    },
    "application/vnd.gentoo.pkgmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gentoo.xpak": {
      source: "iana"
    },
    "application/vnd.geo+json": {
      source: "apache",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.pinboard": {
      source: "iana"
    },
    "application/vnd.geogebra.slides": {
      source: "iana",
      extensions: ["ggs"]
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.gnu.taler.exchange+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gnu.taler.merchant+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.google-apps.audio": {},
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.drawing": {
      compressible: false,
      extensions: ["gdraw"]
    },
    "application/vnd.google-apps.drive-sdk": {
      compressible: false
    },
    "application/vnd.google-apps.file": {},
    "application/vnd.google-apps.folder": {
      compressible: false
    },
    "application/vnd.google-apps.form": {
      compressible: false,
      extensions: ["gform"]
    },
    "application/vnd.google-apps.fusiontable": {},
    "application/vnd.google-apps.jam": {
      compressible: false,
      extensions: ["gjam"]
    },
    "application/vnd.google-apps.mail-layout": {},
    "application/vnd.google-apps.map": {
      compressible: false,
      extensions: ["gmap"]
    },
    "application/vnd.google-apps.photo": {},
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.script": {
      compressible: false,
      extensions: ["gscript"]
    },
    "application/vnd.google-apps.shortcut": {},
    "application/vnd.google-apps.site": {
      compressible: false,
      extensions: ["gsite"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-apps.unknown": {},
    "application/vnd.google-apps.video": {},
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdcf"]
    },
    "application/vnd.gpxsee.map+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.hsl": {
      source: "iana"
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "apache"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "apache",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "apache"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.ipfs.ipns-record": {
      source: "iana"
    },
    "application/vnd.ipld.car": {
      source: "iana"
    },
    "application/vnd.ipld.dag-cbor": {
      source: "iana"
    },
    "application/vnd.ipld.dag-json": {
      source: "iana"
    },
    "application/vnd.ipld.raw": {
      source: "iana"
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kdl": {
      source: "iana"
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.keyman.kmp+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.keyman.kmx": {
      source: "iana"
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.ldev.productlicensing": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.mdl": {
      source: "iana"
    },
    "application/vnd.mdl-mbsdf": {
      source: "iana"
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.medicalholodeck.recordxr": {
      source: "iana"
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mermaid": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.modl": {
      source: "iana"
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-visio.viewer": {
      extensions: ["vdx"]
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msgpack": {
      source: "iana"
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nato.bindingdataobject+cbor": {
      source: "iana"
    },
    "application/vnd.nato.bindingdataobject+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nato.bindingdataobject+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bdo"]
    },
    "application/vnd.nato.openxmlformats-package.iepd+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "apache",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oai.workflows": {
      source: "iana"
    },
    "application/vnd.oai.workflows+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oai.workflows+yaml": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.base": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "apache",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-master-template": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.onvif.metadata": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openvpi.dspx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.procrate.brushset": {
      extensions: ["brushset"]
    },
    "application/vnd.procreate.brush": {
      extensions: ["brush"]
    },
    "application/vnd.procreate.dream": {
      extensions: ["drm"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.pt.mundusmundi": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtm"]
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.relpipe": {
      source: "iana"
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sketchometry": {
      source: "iana"
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.smintio.portals.archive": {
      source: "iana"
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sybyl.mol2": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uic.osdm+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml", "uo"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veraison.tsm-report+cbor": {
      source: "iana"
    },
    "application/vnd.veraison.tsm-report+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vocalshaper.vsp4": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.wasmflow.wafl": {
      source: "iana"
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordlift": {
      source: "iana"
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xarin.cpj": {
      source: "iana"
    },
    "application/vnd.xecrets-encrypted": {
      source: "iana"
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/voucher-jws+json": {
      source: "iana",
      compressible: true
    },
    "application/vp": {
      source: "iana"
    },
    "application/vp+cose": {
      source: "iana"
    },
    "application/vp+jwt": {
      source: "iana"
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blender": {
      extensions: ["blend"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-compressed": {
      extensions: ["rar"]
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-ipynb+json": {
      compressible: true,
      extensions: ["ipynb"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zip-compressed": {
      extensions: ["zip"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yaml": {
      source: "iana"
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+cbor": {
      source: "iana"
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-sid+json": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zip+dotlottie": {
      extensions: ["lottie"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana",
      extensions: ["adts", "aac"]
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flac": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/matroska": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/midi-clip": {
      source: "iana"
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a", "m4b"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "apache"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      source: "iana",
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp", "dib"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/dpx": {
      source: "iana",
      extensions: ["dpx"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/j2c": {
      source: "iana"
    },
    "image/jaii": {
      source: "iana",
      extensions: ["jaii"]
    },
    "image/jais": {
      source: "iana",
      extensions: ["jais"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpg", "jpeg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm", "jpgm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxl": {
      source: "iana",
      extensions: ["jxl"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false,
      extensions: ["jfif"]
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif", "btf"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.clip": {
      source: "iana"
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "iana",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-adobe-dng": {
      extensions: ["dng"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-emf": {
      source: "iana"
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-wmf": {
      source: "iana"
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/bhttp": {
      source: "iana"
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/mls": {
      source: "iana"
    },
    "message/news": {
      source: "apache"
    },
    "message/ohttp-req": {
      source: "iana"
    },
    "message/ohttp-res": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime", "mht", "mhtml"]
    },
    "message/s-http": {
      source: "apache"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "apache"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/jt": {
      source: "iana",
      extensions: ["jt"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/prc": {
      source: "iana",
      extensions: ["prc"]
    },
    "model/step": {
      source: "iana",
      extensions: ["step", "stp", "stpnc", "p21", "210"]
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/u3d": {
      source: "iana",
      extensions: ["u3d"]
    },
    "model/vnd.bary": {
      source: "iana",
      extensions: ["bary"]
    },
    "model/vnd.cld": {
      source: "iana",
      extensions: ["cld"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana",
      extensions: ["pyo", "pyox"]
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usda": {
      source: "iana",
      extensions: ["usda"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "apache"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/hl7v2": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["md", "markdown"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/prs.texi": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.exchangeable": {
      source: "iana"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "apache"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.vcf": {
      source: "iana"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vnd.zoo.kcl": {
      source: "iana"
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/wgsl": {
      source: "iana",
      extensions: ["wgsl"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/evc": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/h266": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/lottie+json": {
      source: "iana",
      compressible: true
    },
    "video/matroska": {
      source: "iana"
    },
    "video/matroska-3d": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts", "m2t", "m2ts", "mts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.planar": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "apache"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/@hapi/mimos/lib/index.js
var require_lib21 = __commonJS((exports) => {
  var Path = __require("path");
  var Hoek = require_lib8();
  var MimeDb = require_db();
  var internals = {
    compressibleRx: /^text\/|\+json$|\+text$|\+xml$/
  };
  exports.MimosEntry = class {
    constructor(type, mime) {
      this.type = type;
      this.source = "mime-db";
      this.extensions = [];
      this.compressible = undefined;
      Object.assign(this, mime);
      if (this.compressible === undefined) {
        this.compressible = internals.compressibleRx.test(type);
      }
    }
  };
  internals.insertEntry = function(type, entry, db) {
    db.byType.set(type, entry);
    for (const ext of entry.extensions) {
      db.byExtension.set(ext, entry);
      if (ext.length > db.maxExtLength) {
        db.maxExtLength = ext.length;
      }
    }
  };
  internals.compile = function(mimedb) {
    const db = {
      byType: new Map,
      byExtension: new Map,
      maxExtLength: 0
    };
    for (const type in mimedb) {
      const entry = new exports.MimosEntry(type, mimedb[type]);
      internals.insertEntry(type, entry, db);
    }
    return db;
  };
  internals.getTypePart = function(fulltype) {
    const splitAt = fulltype.indexOf(";");
    return splitAt === -1 ? fulltype : fulltype.slice(0, splitAt);
  };
  internals.applyPredicate = function(mime) {
    if (mime.predicate) {
      return mime.predicate(Hoek.clone(mime));
    }
    return mime;
  };
  exports.Mimos = class Mimos {
    #db = internals.base;
    constructor(options = {}) {
      if (options.override) {
        Hoek.assert(typeof options.override === "object", "overrides option must be an object");
        this.#db = {
          ...this.#db,
          byType: new Map(this.#db.byType),
          byExtension: new Map(this.#db.byExtension)
        };
        for (const type in options.override) {
          const override = options.override[type];
          Hoek.assert(!override.predicate || typeof override.predicate === "function", "predicate option must be a function");
          const from = this.#db.byType.get(type);
          const baseEntry = from ? Hoek.applyToDefaults(from, override) : override;
          const entry = new exports.MimosEntry(type, baseEntry);
          internals.insertEntry(type, entry, this.#db);
        }
      }
    }
    path(path2) {
      const extension = Path.extname(path2).slice(1).toLowerCase();
      const mime = this.#db.byExtension.get(extension) ?? {};
      return internals.applyPredicate(mime);
    }
    type(type) {
      type = internals.getTypePart(type);
      let mime = this.#db.byType.get(type);
      if (!mime) {
        type = type.trim().toLowerCase();
        mime = this.#db.byType.get(type);
      }
      if (!mime) {
        mime = new exports.MimosEntry(type, {
          source: "mimos"
        });
        internals.insertEntry(type, mime, this.#db);
        return mime;
      }
      return internals.applyPredicate(mime);
    }
  };
  internals.base = internals.compile(MimeDb);
});

// node_modules/@hapi/bourne/lib/index.js
var require_lib22 = __commonJS((exports) => {
  var internals = {
    suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
  };
  exports.parse = function(text, ...args) {
    const firstOptions = typeof args[0] === "object" && args[0];
    const reviver = args.length > 1 || !firstOptions ? args[0] : undefined;
    const options = args.length > 1 && args[1] || firstOptions || {};
    const obj = JSON.parse(text, reviver);
    if (options.protoAction === "ignore") {
      return obj;
    }
    if (!obj || typeof obj !== "object") {
      return obj;
    }
    if (!text.match(internals.suspectRx)) {
      return obj;
    }
    exports.scan(obj, options);
    return obj;
  };
  exports.scan = function(obj, options = {}) {
    let next = [obj];
    while (next.length) {
      const nodes = next;
      next = [];
      for (const node of nodes) {
        if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
          if (options.protoAction !== "remove") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.__proto__;
        }
        for (const key in node) {
          const value = node[key];
          if (value && typeof value === "object") {
            next.push(node[key]);
          }
        }
      }
    }
  };
  exports.safeParse = function(text, reviver) {
    try {
      return exports.parse(text, reviver);
    } catch (ignoreError) {
      return null;
    }
  };
});

// node_modules/@hapi/cryptiles/lib/index.js
var require_lib23 = __commonJS((exports) => {
  var Crypto = __require("crypto");
  var Boom = require_lib13();
  var internals = {};
  exports.randomString = function(size) {
    const buffer = exports.randomBits((size + 1) * 6);
    const string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    return string.slice(0, size);
  };
  exports.randomAlphanumString = function(size) {
    let result = "";
    while (result.length < size) {
      const buffer = exports.randomBits((size + 1) * 6);
      result += buffer.toString("base64").replace(/[^a-zA-Z0-9]/g, "");
    }
    return result.slice(0, size);
  };
  exports.randomDigits = function(size) {
    const digits = [];
    let buffer = internals.random(size * 2);
    let pos = 0;
    while (digits.length < size) {
      if (pos >= buffer.length) {
        buffer = internals.random(size * 2);
        pos = 0;
      }
      if (buffer[pos] < 250) {
        digits.push(buffer[pos] % 10);
      }
      ++pos;
    }
    return digits.join("");
  };
  exports.randomBits = function(bits) {
    if (!bits || bits < 0) {
      throw Boom.internal("Invalid random bits count");
    }
    const bytes = Math.ceil(bits / 8);
    return internals.random(bytes);
  };
  exports.fixedTimeComparison = function(a, b) {
    try {
      return Crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));
    } catch (err) {
      return false;
    }
  };
  internals.random = function(bytes) {
    try {
      return Crypto.randomBytes(bytes);
    } catch (err) {
      throw Boom.internal("Failed generating random bits: " + err.message);
    }
  };
});

// node_modules/@hapi/b64/lib/decoder.js
var require_decoder2 = __commonJS((exports) => {
  var Stream = __require("stream");
  var internals = {
    decodeChars: [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      -1,
      -1,
      -1,
      -1,
      -1
    ]
  };
  exports.decode = function(buffer) {
    const decodeChars = internals.decodeChars;
    const len = buffer.length;
    const allocated = Math.ceil(len / 4) * 3;
    const result = Buffer.alloc(allocated);
    let c1;
    let c2;
    let c3;
    let c4;
    let j = 0;
    for (let i = 0;i < len; ) {
      do {
        c1 = decodeChars[buffer[i++] & 255];
      } while (i < len && c1 === -1);
      if (c1 === -1) {
        break;
      }
      do {
        c2 = decodeChars[buffer[i++] & 255];
      } while (i < len && c2 === -1);
      if (c2 === -1) {
        break;
      }
      result[j++] = c1 << 2 | (c2 & 48) >> 4;
      do {
        c3 = buffer[i++] & 255;
        if (c3 === 61) {
          return result.slice(0, j);
        }
        c3 = decodeChars[c3];
      } while (i < len && c3 === -1);
      if (c3 === -1) {
        break;
      }
      result[j++] = (c2 & 15) << 4 | (c3 & 60) >> 2;
      do {
        c4 = buffer[i++] & 255;
        if (c4 === 61) {
          return result.slice(0, j);
        }
        c4 = decodeChars[c4];
      } while (i < len && c4 === -1);
      if (c4 !== -1) {
        result[j++] = (c3 & 3) << 6 | c4;
      }
    }
    return j === allocated ? result : result.slice(0, j);
  };
  exports.Decoder = class Decoder extends Stream.Transform {
    constructor() {
      super();
      this._reminder = null;
    }
    _transform(chunk, encoding, callback) {
      let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
      const remaining = part.length % 4;
      if (remaining) {
        this._reminder = part.slice(part.length - remaining);
        part = part.slice(0, part.length - remaining);
      } else {
        this._reminder = null;
      }
      this.push(exports.decode(part));
      return callback();
    }
    _flush(callback) {
      if (this._reminder) {
        this.push(exports.decode(this._reminder));
      }
      return callback();
    }
  };
});

// node_modules/@hapi/b64/lib/encoder.js
var require_encoder2 = __commonJS((exports) => {
  var Stream = __require("stream");
  exports.encode = function(buffer) {
    return Buffer.from(buffer.toString("base64"));
  };
  exports.Encoder = class Encoder extends Stream.Transform {
    constructor() {
      super();
      this._reminder = null;
    }
    _transform(chunk, encoding, callback) {
      let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
      const remaining = part.length % 3;
      if (remaining) {
        this._reminder = part.slice(part.length - remaining);
        part = part.slice(0, part.length - remaining);
      } else {
        this._reminder = null;
      }
      this.push(exports.encode(part));
      return callback();
    }
    _flush(callback) {
      if (this._reminder) {
        this.push(exports.encode(this._reminder));
      }
      return callback();
    }
  };
});

// node_modules/@hapi/b64/lib/index.js
var require_lib24 = __commonJS((exports) => {
  var Hoek = require_lib8();
  var Decoder = require_decoder2();
  var Encoder = require_encoder2();
  exports.decode = Decoder.decode;
  exports.encode = Encoder.encode;
  exports.Decoder = Decoder.Decoder;
  exports.Encoder = Encoder.Encoder;
  exports.base64urlEncode = function(value, encoding) {
    Hoek.assert(typeof value === "string" || Buffer.isBuffer(value), "value must be string or buffer");
    const buf = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || "binary");
    return buf.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  };
  exports.base64urlDecode = function(value, encoding) {
    if (typeof value !== "string") {
      throw new Error("Value not a string");
    }
    if (!/^[\w\-]*$/.test(value)) {
      throw new Error("Invalid character");
    }
    const buf = Buffer.from(value, "base64");
    return encoding === "buffer" ? buf : buf.toString(encoding || "binary");
  };
});

// node_modules/@hapi/iron/lib/index.js
var require_lib25 = __commonJS((exports) => {
  var Crypto = __require("crypto");
  var B64 = require_lib24();
  var Boom = require_lib13();
  var Bourne = require_lib22();
  var Cryptiles = require_lib23();
  var Hoek = require_lib8();
  var internals = {};
  exports.defaults = {
    encryption: {
      saltBits: 256,
      algorithm: "aes-256-cbc",
      iterations: 1,
      minPasswordlength: 32
    },
    integrity: {
      saltBits: 256,
      algorithm: "sha256",
      iterations: 1,
      minPasswordlength: 32
    },
    ttl: 0,
    timestampSkewSec: 60,
    localtimeOffsetMsec: 0
  };
  exports.algorithms = {
    "aes-128-ctr": { keyBits: 128, ivBits: 128 },
    "aes-256-cbc": { keyBits: 256, ivBits: 128 },
    sha256: { keyBits: 256 }
  };
  exports.macFormatVersion = "2";
  exports.macPrefix = "Fe26." + exports.macFormatVersion;
  exports.generateKey = async function(password, options) {
    if (!password) {
      throw new Boom.Boom("Empty password");
    }
    if (!options || typeof options !== "object") {
      throw new Boom.Boom("Bad options");
    }
    const algorithm = exports.algorithms[options.algorithm];
    if (!algorithm) {
      throw new Boom.Boom("Unknown algorithm: " + options.algorithm);
    }
    const result = {};
    if (Buffer.isBuffer(password)) {
      if (password.length < algorithm.keyBits / 8) {
        throw new Boom.Boom("Key buffer (password) too small");
      }
      result.key = password;
      result.salt = "";
    } else {
      if (password.length < options.minPasswordlength) {
        throw new Boom.Boom("Password string too short (min " + options.minPasswordlength + " characters required)");
      }
      let salt = options.salt;
      if (!salt) {
        if (!options.saltBits) {
          throw new Boom.Boom("Missing salt and saltBits options");
        }
        const randomSalt = Cryptiles.randomBits(options.saltBits);
        salt = randomSalt.toString("hex");
      }
      const derivedKey = await internals.pbkdf2(password, salt, options.iterations, algorithm.keyBits / 8, "sha1");
      result.key = derivedKey;
      result.salt = salt;
    }
    if (options.iv) {
      result.iv = options.iv;
    } else if (algorithm.ivBits) {
      result.iv = Cryptiles.randomBits(algorithm.ivBits);
    }
    return result;
  };
  exports.encrypt = async function(password, options, data) {
    const key = await exports.generateKey(password, options);
    const cipher = Crypto.createCipheriv(options.algorithm, key.key, key.iv);
    const encrypted = Buffer.concat([cipher.update(data, "utf8"), cipher.final()]);
    return { encrypted, key };
  };
  exports.decrypt = async function(password, options, data) {
    const key = await exports.generateKey(password, options);
    const decipher = Crypto.createDecipheriv(options.algorithm, key.key, key.iv);
    let dec = decipher.update(data, null, "utf8");
    dec = dec + decipher.final("utf8");
    return dec;
  };
  exports.hmacWithPassword = async function(password, options, data) {
    const key = await exports.generateKey(password, options);
    const hmac = Crypto.createHmac(options.algorithm, key.key).update(data);
    const digest = hmac.digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    return {
      digest,
      salt: key.salt
    };
  };
  internals.normalizePassword = function(password) {
    if (password && typeof password === "object" && !Buffer.isBuffer(password)) {
      return {
        id: password.id,
        encryption: password.secret ?? password.encryption,
        integrity: password.secret ?? password.integrity
      };
    }
    return {
      encryption: password,
      integrity: password
    };
  };
  exports.seal = async function(object, password, options) {
    options = Object.assign({}, options);
    const now = Date.now() + (options.localtimeOffsetMsec ?? 0);
    const objectString = internals.stringify(object);
    let passwordId = "";
    password = internals.normalizePassword(password);
    if (password.id) {
      if (!/^\w+$/.test(password.id)) {
        throw new Boom.Boom("Invalid password id");
      }
      passwordId = password.id;
    }
    const { encrypted, key } = await exports.encrypt(password.encryption, options.encryption, objectString);
    const encryptedB64 = B64.base64urlEncode(encrypted);
    const iv = B64.base64urlEncode(key.iv);
    const expiration = options.ttl ? now + options.ttl : "";
    const macBaseString = exports.macPrefix + "*" + passwordId + "*" + key.salt + "*" + iv + "*" + encryptedB64 + "*" + expiration;
    const mac = await exports.hmacWithPassword(password.integrity, options.integrity, macBaseString);
    const sealed = macBaseString + "*" + mac.salt + "*" + mac.digest;
    return sealed;
  };
  exports.unseal = async function(sealed, password, options) {
    options = Object.assign({}, options);
    const now = Date.now() + (options.localtimeOffsetMsec ?? 0);
    const parts = sealed.split("*");
    if (parts.length !== 8) {
      throw new Boom.Boom("Incorrect number of sealed components");
    }
    const macPrefix = parts[0];
    const passwordId = parts[1];
    const encryptionSalt = parts[2];
    const encryptionIv = parts[3];
    const encryptedB64 = parts[4];
    const expiration = parts[5];
    const hmacSalt = parts[6];
    const hmac = parts[7];
    const macBaseString = macPrefix + "*" + passwordId + "*" + encryptionSalt + "*" + encryptionIv + "*" + encryptedB64 + "*" + expiration;
    if (macPrefix !== exports.macPrefix) {
      throw new Boom.Boom("Wrong mac prefix");
    }
    if (expiration) {
      if (!expiration.match(/^\d+$/)) {
        throw new Boom.Boom("Invalid expiration");
      }
      const exp = parseInt(expiration, 10);
      if (exp <= now - options.timestampSkewSec * 1000) {
        throw new Boom.Boom("Expired seal");
      }
    }
    if (!password) {
      throw new Boom.Boom("Empty password");
    }
    if (typeof password === "object" && !Buffer.isBuffer(password)) {
      password = password[passwordId || "default"];
      if (!password) {
        throw new Boom.Boom("Cannot find password: " + passwordId);
      }
    }
    password = internals.normalizePassword(password);
    const macOptions = Hoek.clone(options.integrity);
    macOptions.salt = hmacSalt;
    const mac = await exports.hmacWithPassword(password.integrity, macOptions, macBaseString);
    if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
      throw new Boom.Boom("Bad hmac value");
    }
    try {
      var encrypted = B64.base64urlDecode(encryptedB64, "buffer");
    } catch (err) {
      throw Boom.boomify(err);
    }
    const decryptOptions = Hoek.clone(options.encryption);
    decryptOptions.salt = encryptionSalt;
    try {
      decryptOptions.iv = B64.base64urlDecode(encryptionIv, "buffer");
    } catch (err) {
      throw Boom.boomify(err);
    }
    const decrypted = await exports.decrypt(password.encryption, decryptOptions, encrypted);
    try {
      return Bourne.parse(decrypted);
    } catch (err) {
      throw new Boom.Boom("Failed parsing sealed object JSON: " + err.message);
    }
  };
  internals.stringify = function(object) {
    try {
      return JSON.stringify(object);
    } catch (err) {
      throw new Boom.Boom("Failed to stringify object: " + err.message);
    }
  };
  internals.pbkdf2 = function(...args) {
    return new Promise((resolve, reject) => {
      const next = (err, result) => {
        if (err) {
          return reject(Boom.boomify(err));
        }
        resolve(result);
      };
      args.push(next);
      Crypto.pbkdf2(...args);
    });
  };
});

// node_modules/@hapi/statehood/lib/index.js
var require_lib26 = __commonJS((exports) => {
  var Querystring = __require("querystring");
  var Boom = require_lib13();
  var Bounce = require_lib14();
  var Bourne = require_lib22();
  var Cryptiles = require_lib23();
  var Hoek = require_lib8();
  var Iron = require_lib25();
  var Validate = require_lib10();
  var internals = {
    macPrefix: "hapi.signed.cookie.1"
  };
  internals.schema = Validate.object({
    strictHeader: Validate.boolean(),
    ignoreErrors: Validate.boolean(),
    isSecure: Validate.boolean(),
    isHttpOnly: Validate.boolean(),
    isPartitioned: Validate.boolean(),
    isSameSite: Validate.valid("Strict", "Lax", "None", false),
    path: Validate.string().allow(null),
    domain: Validate.string().allow(null),
    ttl: Validate.number().allow(null),
    encoding: Validate.string().valid("base64json", "base64", "form", "iron", "none"),
    sign: Validate.object({
      password: [Validate.string(), Validate.binary(), Validate.object()],
      integrity: Validate.object()
    }),
    iron: Validate.object(),
    password: [Validate.string(), Validate.binary(), Validate.object()],
    contextualize: Validate.function(),
    clearInvalid: Validate.boolean(),
    autoValue: Validate.any(),
    passThrough: Validate.boolean()
  });
  internals.defaults = {
    strictHeader: true,
    ignoreErrors: false,
    isSecure: true,
    isHttpOnly: true,
    isPartitioned: false,
    isSameSite: "Strict",
    path: null,
    domain: null,
    ttl: null,
    encoding: "none"
  };
  internals.validateRx = {
    nameRx: {
      strict: /^[^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+$/,
      loose: /^[^=\s]*$/
    },
    valueRx: {
      strict: /^[^\x00-\x20\"\,\;\\\x7F]*$/,
      loose: /^(?:"([^\"]*)")|(?:[^\;]*)$/
    },
    domainRx: /^\.?[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d]))(?:\.[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d])))*$/,
    domainLabelLenRx: /^\.?[a-z\d\-]{1,63}(?:\.[a-z\d\-]{1,63})*$/,
    pathRx: /^\/[^\x00-\x1F\;]*$/
  };
  internals.pairsRx = /\s*([^=\s]*)\s*=\s*([^\;]*)(?:(?:;\s*)|$)/g;
  exports.Definitions = class {
    constructor(options) {
      this.settings = Hoek.applyToDefaults(internals.defaults, options ?? {});
      Validate.assert(this.settings, internals.schema, "Invalid state definition defaults");
      this.cookies = {};
      this.names = [];
    }
    add(name, options) {
      Hoek.assert(name && typeof name === "string", "Invalid name");
      Hoek.assert(!this.cookies[name], "State already defined:", name);
      const settings = Hoek.applyToDefaults(this.settings, options ?? {}, { nullOverride: true });
      Validate.assert(settings, internals.schema, "Invalid state definition: " + name);
      this.cookies[name] = settings;
      this.names.push(name);
    }
    async parse(cookies) {
      const state = {};
      const names = [];
      const verify = internals.parsePairs(cookies, (name, value) => {
        if (name === "__proto__") {
          throw Boom.badRequest("Invalid cookie header");
        }
        if (state[name]) {
          if (!Array.isArray(state[name])) {
            state[name] = [state[name]];
          }
          state[name].push(value);
        } else {
          state[name] = value;
          names.push(name);
        }
      });
      const failed = [];
      if (verify !== null) {
        if (!this.settings.ignoreErrors) {
          throw Boom.badRequest("Invalid cookie header");
        }
        failed.push({ settings: this.settings, reason: `Header contains unexpected syntax: ${verify}` });
      }
      const errored = [];
      const record = (reason, name, value, definition) => {
        const details = {
          name,
          value,
          settings: definition,
          reason: typeof reason === "string" ? reason : reason.message
        };
        failed.push(details);
        if (!definition.ignoreErrors) {
          errored.push(details);
        }
      };
      const parsed = {};
      for (const name of names) {
        const value = state[name];
        const definition = this.cookies[name] ?? this.settings;
        if (definition.strictHeader) {
          const reason = internals.validate(name, state);
          if (reason) {
            record(reason, name, value, definition);
            continue;
          }
        }
        if (definition.encoding === "none") {
          parsed[name] = value;
          continue;
        }
        if (!Array.isArray(value)) {
          try {
            const unsigned = await internals.unsign(name, value, definition);
            const result = await internals.decode(unsigned, definition);
            parsed[name] = result;
          } catch (err) {
            Bounce.rethrow(err, "system");
            record(err, name, value, definition);
          }
          continue;
        }
        const arrayResult = [];
        for (const arrayValue of value) {
          try {
            const unsigned = await internals.unsign(name, arrayValue, definition);
            const result = await internals.decode(unsigned, definition);
            arrayResult.push(result);
          } catch (err) {
            Bounce.rethrow(err, "system");
            record(err, name, value, definition);
          }
        }
        parsed[name] = arrayResult;
      }
      if (errored.length) {
        const error = Boom.badRequest("Invalid cookie value", errored);
        error.states = parsed;
        error.failed = failed;
        throw error;
      }
      return { states: parsed, failed };
    }
    async format(cookies, context) {
      if (!cookies || Array.isArray(cookies) && !cookies.length) {
        return [];
      }
      if (!Array.isArray(cookies)) {
        cookies = [cookies];
      }
      const header = [];
      for (let i = 0;i < cookies.length; ++i) {
        const cookie = cookies[i];
        const base = this.cookies[cookie.name] ?? this.settings;
        let definition = cookie.options ? Hoek.applyToDefaults(base, cookie.options, { nullOverride: true }) : base;
        if (definition.contextualize) {
          if (definition === base) {
            definition = Hoek.clone(definition);
          }
          await definition.contextualize(definition, context);
        }
        const nameRx = definition.strictHeader ? internals.validateRx.nameRx.strict : internals.validateRx.nameRx.loose;
        if (!nameRx.test(cookie.name)) {
          throw Boom.badImplementation("Invalid cookie name: " + cookie.name);
        }
        const value = await exports.prepareValue(cookie.name, cookie.value, definition);
        const valueRx = definition.strictHeader ? internals.validateRx.valueRx.strict : internals.validateRx.valueRx.loose;
        if (value && (typeof value !== "string" || !value.match(valueRx))) {
          throw Boom.badImplementation("Invalid cookie value: " + cookie.value);
        }
        let segment = cookie.name + "=" + (value || "");
        if (definition.ttl !== null && definition.ttl !== undefined) {
          const expires = new Date(definition.ttl ? Date.now() + definition.ttl : 0);
          segment = segment + "; Max-Age=" + Math.floor(definition.ttl / 1000) + "; Expires=" + expires.toUTCString();
        }
        if (definition.isSecure) {
          segment = segment + "; Secure";
        }
        if (definition.isHttpOnly) {
          segment = segment + "; HttpOnly";
        }
        if (definition.isSameSite) {
          segment = `${segment}; SameSite=${definition.isSameSite}`;
        }
        if (definition.isPartitioned) {
          if (!definition.isSecure) {
            throw Boom.badImplementation("Partitioned cookies must be secure");
          }
          if (definition.isSameSite !== "None") {
            throw Boom.badImplementation("Partitioned cookies must have SameSite=None");
          }
          segment = `${segment}; Partitioned`;
        }
        if (definition.domain) {
          const domain = definition.domain.toLowerCase();
          if (!domain.match(internals.validateRx.domainLabelLenRx)) {
            throw Boom.badImplementation("Cookie domain too long: " + definition.domain);
          }
          if (!domain.match(internals.validateRx.domainRx)) {
            throw Boom.badImplementation("Invalid cookie domain: " + definition.domain);
          }
          segment = segment + "; Domain=" + domain;
        }
        if (definition.path) {
          if (!definition.path.match(internals.validateRx.pathRx)) {
            throw Boom.badImplementation("Invalid cookie path: " + definition.path);
          }
          segment = segment + "; Path=" + definition.path;
        }
        header.push(segment);
      }
      return header;
    }
    passThrough(header, fallback) {
      if (!this.names.length) {
        return header;
      }
      const exclude = [];
      for (let i = 0;i < this.names.length; ++i) {
        const name = this.names[i];
        const definition = this.cookies[name];
        const passCookie = definition.passThrough !== undefined ? definition.passThrough : fallback;
        if (!passCookie) {
          exclude.push(name);
        }
      }
      return exports.exclude(header, exclude);
    }
  };
  internals.parsePairs = function(cookies, eachPairFn) {
    let index = 0;
    while (index < cookies.length) {
      const eqIndex = cookies.indexOf("=", index);
      if (eqIndex === -1) {
        return cookies.slice(index);
      }
      const semiIndex = cookies.indexOf(";", eqIndex);
      const endOfValueIndex = semiIndex !== -1 ? semiIndex : cookies.length;
      const name = cookies.slice(index, eqIndex).trim();
      const value = cookies.slice(eqIndex + 1, endOfValueIndex).trim();
      const unquotedValue = value.startsWith('"') && value.endsWith('"') && value !== '"' ? value.slice(1, -1) : value;
      eachPairFn(name, unquotedValue);
      index = endOfValueIndex + 1;
    }
    return null;
  };
  internals.validate = function(name, state) {
    if (!name.match(internals.validateRx.nameRx.strict)) {
      return "Invalid cookie name";
    }
    const values = [].concat(state[name]);
    for (let i = 0;i < values.length; ++i) {
      if (!values[i].match(internals.validateRx.valueRx.strict)) {
        return "Invalid cookie value";
      }
    }
    return null;
  };
  internals.unsign = async function(name, value, definition) {
    if (!definition.sign) {
      return value;
    }
    const pos = value.lastIndexOf(".");
    if (pos === -1) {
      throw Boom.badRequest("Missing signature separator");
    }
    const unsigned = value.slice(0, pos);
    const sig = value.slice(pos + 1);
    if (!sig) {
      throw Boom.badRequest("Missing signature");
    }
    const sigParts = sig.split("*");
    if (sigParts.length !== 2) {
      throw Boom.badRequest("Invalid signature format");
    }
    const hmacSalt = sigParts[0];
    const hmac = sigParts[1];
    const macOptions = Hoek.clone(definition.sign.integrity ?? Iron.defaults.integrity);
    macOptions.salt = hmacSalt;
    const mac = await Iron.hmacWithPassword(definition.sign.password, macOptions, [internals.macPrefix, name, unsigned].join(`
`));
    if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
      throw Boom.badRequest("Invalid hmac value");
    }
    return unsigned;
  };
  internals.decode = async function(value, definition) {
    if (!value && definition.encoding === "form") {
      return {};
    }
    Hoek.assert(typeof value === "string", "Invalid string");
    if (definition.encoding === "iron") {
      return await Iron.unseal(value, definition.password, definition.iron ?? Iron.defaults);
    }
    if (definition.encoding === "base64json") {
      const decoded = Buffer.from(value, "base64").toString("binary");
      try {
        return Bourne.parse(decoded);
      } catch (err) {
        throw Boom.badRequest("Invalid JSON payload");
      }
    }
    if (definition.encoding === "base64") {
      return Buffer.from(value, "base64").toString("binary");
    }
    return Querystring.parse(value);
  };
  exports.prepareValue = async function(name, value, options) {
    Hoek.assert(options && typeof options === "object", "Missing or invalid options");
    try {
      const encoded = await internals.encode(value, options);
      const signed = await internals.sign(name, encoded, options.sign);
      return signed;
    } catch (err) {
      throw Boom.badImplementation("Failed to encode cookie (" + name + ") value: " + err.message);
    }
  };
  internals.encode = function(value, options) {
    if (value === undefined || options.encoding === "none") {
      return value;
    }
    if (options.encoding === "iron") {
      return Iron.seal(value, options.password, options.iron ?? Iron.defaults);
    }
    if (options.encoding === "base64") {
      return Buffer.from(value, "binary").toString("base64");
    }
    if (options.encoding === "base64json") {
      const stringified = JSON.stringify(value);
      return Buffer.from(stringified, "binary").toString("base64");
    }
    return Querystring.stringify(value);
  };
  internals.sign = async function(name, value, options) {
    if (value === undefined || !options) {
      return value;
    }
    const mac = await Iron.hmacWithPassword(options.password, options.integrity ?? Iron.defaults.integrity, [internals.macPrefix, name, value].join(`
`));
    const signed = value + "." + mac.salt + "*" + mac.digest;
    return signed;
  };
  exports.exclude = function(cookies, excludes) {
    let result = "";
    const verify = cookies.replace(internals.pairsRx, ($0, $1, $2) => {
      if (excludes.indexOf($1) === -1) {
        result = result + (result ? ";" : "") + $1 + "=" + $2;
      }
      return "";
    });
    return verify === "" ? result : Boom.badRequest("Invalid cookie header");
  };
});

// node_modules/@hapi/content/lib/index.js
var require_lib27 = __commonJS((exports) => {
  var Boom = require_lib13();
  var internals = {};
  internals.contentTypeRegex = /^([^\/\s]+\/[^\s;]+)(.*)?$/;
  internals.charsetParamRegex = /;\s*charset=(?:"([^"]+)"|([^;"\s]+))/i;
  internals.boundaryParamRegex = /;\s*boundary=(?:"([^"]+)"|([^;"\s]+))/i;
  exports.type = function(header) {
    if (!header) {
      throw Boom.badRequest("Invalid content-type header");
    }
    const match = header.match(internals.contentTypeRegex);
    if (!match) {
      throw Boom.badRequest("Invalid content-type header");
    }
    const result = {
      mime: match[1].toLowerCase()
    };
    const params = match[2];
    if (params) {
      const param = params.match(internals.charsetParamRegex);
      if (param) {
        result.charset = (param[1] || param[2]).toLowerCase();
      }
    }
    if (result.mime.indexOf("multipart/") === 0) {
      if (params) {
        const param = params.match(internals.boundaryParamRegex);
        if (param) {
          result.boundary = param[1] || param[2];
        }
      }
      if (!result.boundary) {
        throw Boom.badRequest("Invalid content-type header: multipart missing boundary");
      }
    }
    return result;
  };
  internals.contentDispositionRegex = /^\s*form-data\s*(?:;\s*(.+))?$/i;
  internals.contentDispositionParamRegex = /([^\=\*\s]+)(\*)?\s*\=\s*(?:([^;'"\s]+\'[\w-]*\'[^;\s]+)|(?:\"([^"]*)\")|([^;\s]*))(?:\s*(?:;\s*)|$)/g;
  exports.disposition = function(header) {
    if (!header) {
      throw Boom.badRequest("Missing content-disposition header");
    }
    const match = header.match(internals.contentDispositionRegex);
    if (!match) {
      throw Boom.badRequest("Invalid content-disposition header format");
    }
    const parameters = match[1];
    if (!parameters) {
      throw Boom.badRequest("Invalid content-disposition header missing parameters");
    }
    const result = {};
    parameters.replace(internals.contentDispositionParamRegex, ($0, $1, $2, $3, $4, $5) => {
      if ($1 === "__proto__") {
        throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
      }
      let value;
      if ($2) {
        if (!$3) {
          throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
        }
        try {
          value = decodeURIComponent($3.split("'")[2]);
        } catch (err) {
          throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
        }
      } else {
        value = $4 || $5 || "";
      }
      if ($1 === "name" && value === "__proto__") {
        throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
      }
      result[$1] = value;
    });
    if (!result.name) {
      throw Boom.badRequest("Invalid content-disposition header missing name parameter");
    }
    return result;
  };
});

// node_modules/@hapi/file/lib/index.js
var require_lib28 = __commonJS((exports) => {
  var Crypto = __require("crypto");
  var Path = __require("path");
  exports.uniqueFilename = function(path2, extension) {
    if (extension) {
      extension = extension[0] !== "." ? "." + extension : extension;
    } else {
      extension = "";
    }
    path2 = Path.resolve(path2);
    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString("hex")].join("-") + extension;
    return Path.join(path2, name);
  };
});

// node_modules/@hapi/vise/lib/index.js
var require_lib29 = __commonJS((exports) => {
  var Hoek = require_lib8();
  exports.Vise = class Vise {
    constructor(chunks) {
      this.length = 0;
      this._chunks = [];
      this._offset = 0;
      if (chunks) {
        chunks = [].concat(chunks);
        for (let i = 0;i < chunks.length; ++i) {
          this.push(chunks[i]);
        }
      }
    }
    push(chunk) {
      Hoek.assert(Buffer.isBuffer(chunk), "Chunk must be a buffer");
      const item = {
        data: chunk,
        length: chunk.length,
        offset: this.length + this._offset,
        index: this._chunks.length
      };
      this._chunks.push(item);
      this.length += chunk.length;
    }
    shift(length) {
      if (!length) {
        return [];
      }
      const prevOffset = this._offset;
      const item = this.#chunkAt(length);
      let dropTo = this._chunks.length;
      this._offset = 0;
      if (item) {
        dropTo = item.chunk.index;
        this._offset = item.offset;
      }
      const chunks = [];
      for (let i = 0;i < dropTo; ++i) {
        const chunk = this._chunks.shift();
        if (i === 0 && prevOffset) {
          chunks.push(chunk.data.slice(prevOffset));
        } else {
          chunks.push(chunk.data);
        }
      }
      if (this._offset) {
        chunks.push(item.chunk.data.slice(dropTo ? 0 : prevOffset, this._offset));
      }
      this.length = 0;
      for (let i = 0;i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        chunk.offset = this.length, chunk.index = i;
        this.length += chunk.length;
      }
      this.length -= this._offset;
      return chunks;
    }
    readUInt8(pos) {
      const item = this.#chunkAt(pos);
      return item ? item.chunk.data[item.offset] : undefined;
    }
    at(pos) {
      return this.readUInt8(pos);
    }
    #chunkAt(pos) {
      if (pos < 0) {
        return null;
      }
      pos = pos + this._offset;
      for (let i = 0;i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        const offset = pos - chunk.offset;
        if (offset < chunk.length) {
          return { chunk, offset };
        }
      }
      return null;
    }
    chunks() {
      const chunks = [];
      for (let i = 0;i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        if (i === 0 && this._offset) {
          chunks.push(chunk.data.slice(this._offset));
        } else {
          chunks.push(chunk.data);
        }
      }
      return chunks;
    }
    startsWith(value, pos, length) {
      pos = pos ?? 0;
      length = length ? Math.min(value.length, length) : value.length;
      if (pos + length > this.length) {
        return false;
      }
      const start = this.#chunkAt(pos);
      if (!start) {
        return false;
      }
      let j = start.chunk.index;
      for (let i = 0;j < this._chunks.length && i < length; ++j) {
        const chunk = this._chunks[j];
        let k = j === start.chunk.index ? start.offset : 0;
        for (;k < chunk.length && i < length; ++k, ++i) {
          if (chunk.data[k] !== value[i]) {
            return false;
          }
        }
      }
      return true;
    }
  };
});

// node_modules/@hapi/nigel/lib/index.js
var require_lib30 = __commonJS((exports) => {
  var Stream = __require("stream");
  var Hoek = require_lib8();
  var { Vise } = require_lib29();
  var internals = {};
  exports.compile = function(needle) {
    Hoek.assert(needle?.length, "Missing needle");
    Hoek.assert(Buffer.isBuffer(needle), "Needle must be a buffer");
    const profile = {
      value: needle,
      lastPos: needle.length - 1,
      last: needle[needle.length - 1],
      length: needle.length,
      badCharShift: Buffer.alloc(256)
    };
    for (let i = 0;i < 256; ++i) {
      profile.badCharShift[i] = profile.length;
    }
    const last = profile.length - 1;
    for (let i = 0;i < last; ++i) {
      profile.badCharShift[profile.value[i]] = last - i;
    }
    return profile;
  };
  exports.horspool = function(haystack, needle, start) {
    Hoek.assert(haystack, "Missing haystack");
    needle = needle.badCharShift ? needle : exports.compile(needle);
    start = start ?? 0;
    for (let i = start;i <= haystack.length - needle.length; ) {
      const lastChar = haystack.readUInt8(i + needle.lastPos);
      if (lastChar === needle.last && internals.startsWith(haystack, needle, i)) {
        return i;
      }
      i += needle.badCharShift[lastChar];
    }
    return -1;
  };
  internals.startsWith = function(haystack, needle, pos) {
    if (haystack.startsWith) {
      return haystack.startsWith(needle.value, pos, needle.lastPos);
    }
    for (let i = 0;i < needle.lastPos; ++i) {
      if (needle.value[i] !== haystack.readUInt8(pos + i)) {
        return false;
      }
    }
    return true;
  };
  exports.all = function(haystack, needle, start) {
    needle = exports.compile(needle);
    start = start ?? 0;
    const matches = [];
    for (let i = start;i !== -1 && i < haystack.length; ) {
      i = exports.horspool(haystack, needle, i);
      if (i !== -1) {
        matches.push(i);
        i += needle.length;
      }
    }
    return matches;
  };
  internals._indexOf = function(haystack, needle) {
    Hoek.assert(haystack, "Missing haystack");
    for (let i = 0;i <= haystack.length - needle.length; ++i) {
      if (haystack.startsWith(needle.value, i)) {
        return i;
      }
    }
    return -1;
  };
  exports.Stream = class extends Stream.Writable {
    constructor(needle) {
      super();
      this.needle(needle);
      this._haystack = new Vise;
      this._indexOf = this._needle.length > 2 ? exports.horspool : internals._indexOf;
      this.on("finish", () => {
        const chunks = this._haystack.chunks();
        for (let i = 0;i < chunks.length; ++i) {
          this.emit("haystack", chunks[i]);
        }
      });
    }
    needle(needle) {
      this._needle = exports.compile(needle);
    }
    _write(chunk, encoding, next) {
      this._haystack.push(chunk);
      let match = this._indexOf(this._haystack, this._needle);
      if (match === -1 && chunk.length >= this._needle.length) {
        this._flush(this._haystack.length - chunk.length);
      }
      while (match !== -1) {
        this._flush(match);
        this._haystack.shift(this._needle.length);
        this.emit("needle");
        match = this._indexOf(this._haystack, this._needle);
      }
      if (this._haystack.length) {
        const notChecked = this._haystack.length - this._needle.length + 1;
        let i = notChecked;
        for (;i < this._haystack.length; ++i) {
          if (this._haystack.startsWith(this._needle.value, i, this._haystack.length - i)) {
            break;
          }
        }
        this._flush(i);
      }
      return next();
    }
    _flush(pos) {
      const chunks = this._haystack.shift(pos);
      for (let i = 0;i < chunks.length; ++i) {
        this.emit("haystack", chunks[i]);
      }
    }
    flush() {
      const chunks = this._haystack.shift(this._haystack.length);
      for (let i = 0;i < chunks.length; ++i) {
        this.emit("haystack", chunks[i]);
      }
    }
  };
});

// node_modules/@hapi/pez/lib/index.js
var require_lib31 = __commonJS((exports) => {
  var Stream = __require("stream");
  var B64 = require_lib24();
  var Boom = require_lib13();
  var Content = require_lib27();
  var Hoek = require_lib8();
  var Nigel = require_lib30();
  var internals = {};
  internals.state = {
    preamble: 0,
    boundary: 1,
    header: 2,
    payload: 3,
    epilogue: 4
  };
  internals.defaults = {
    maxBytes: Infinity,
    maxParts: Infinity
  };
  exports.Dispenser = class extends Stream.Writable {
    constructor(options) {
      super({ autoDestroy: false });
      Hoek.assert(options !== null && typeof options === "object", "options must be an object");
      const settings = Hoek.applyToDefaults(internals.defaults, options);
      this._boundary = settings.boundary;
      this._state = internals.state.preamble;
      this._held = "";
      this._stream = null;
      this._headers = {};
      this._name = "";
      this._pendingHeader = "";
      this._error = null;
      this._bytesCount = 0;
      this._partsCount = 0;
      this._maxBytes = settings.maxBytes;
      this._maxParts = settings.maxParts;
      this._parts = new Nigel.Stream(Buffer.from("--" + settings.boundary));
      this._lines = new Nigel.Stream(Buffer.from(`\r
`));
      this._parts.on("needle", () => this.#onPartEnd());
      this._parts.on("haystack", (chunk) => this.#onPart(chunk));
      this._lines.on("needle", () => this.#onLineEnd());
      this._lines.on("haystack", (chunk) => this.#onLine(chunk));
      this.once("finish", () => this._parts.end());
      this._parts.once("close", () => this._lines.end());
      let piper = null;
      let finish = (err) => {
        if (piper) {
          piper.removeListener("data", onReqData);
          piper.removeListener("error", finish);
          piper.removeListener("aborted", onReqAborted);
        }
        if (err) {
          return this.#abort(err);
        }
        this.#emit("close");
      };
      finish = Hoek.once(finish);
      this._lines.once("close", () => {
        if (this._state === internals.state.epilogue) {
          if (this._held) {
            this.#emit("epilogue", this._held);
            this._held = "";
          }
        } else if (this._state === internals.state.boundary) {
          if (!this._held) {
            this.#abort(Boom.badRequest("Missing end boundary"));
          } else if (this._held !== "--") {
            this.#abort(Boom.badRequest("Only white space allowed after boundary at end"));
          }
        } else {
          this.#abort(Boom.badRequest("Incomplete multipart payload"));
        }
        setImmediate(finish);
      });
      const onReqAborted = () => {
        finish(Boom.badRequest("Client request aborted"));
      };
      const onReqData = (data) => {
        this._bytesCount += Buffer.byteLength(data);
        if (this._bytesCount > this._maxBytes) {
          finish(Boom.entityTooLarge("Maximum size exceeded"));
        }
      };
      this.once("pipe", (req) => {
        piper = req;
        req.on("data", onReqData);
        req.once("error", finish);
        req.once("aborted", onReqAborted);
      });
    }
    _write(buffer, encoding, next) {
      if (this._error) {
        return next();
      }
      this._parts.write(buffer);
      return next();
    }
    #emit(...args) {
      if (this._error) {
        return;
      }
      this.emit(...args);
    }
    #abort(err) {
      this.#emit("error", err);
      this._error = err;
    }
    #onPartEnd() {
      this._lines.flush();
      if (this._state === internals.state.preamble) {
        if (this._held) {
          const last = this._held.length - 1;
          if (this._held[last] !== `
` || this._held[last - 1] !== "\r") {
            return this.#abort(Boom.badRequest("Preamble missing CRLF terminator"));
          }
          this.#emit("preamble", this._held.slice(0, -2));
          this._held = "";
        }
        this._parts.needle(Buffer.from(`\r
--` + this._boundary));
      } else {
        this._partsCount++;
        if (this._partsCount > this._maxParts) {
          return this.#abort(Boom.badRequest("Maximum parts exceeded"));
        }
      }
      this._state = internals.state.boundary;
      if (this._stream) {
        this._stream.end();
        this._stream = null;
      } else if (this._name) {
        this.#emit("field", this._name, this._held);
        this._name = "";
        this._held = "";
      }
    }
    #onPart(chunk) {
      if (this._state === internals.state.preamble) {
        this._held = this._held + chunk.toString();
      } else if (this._state === internals.state.payload) {
        if (this._stream) {
          this._stream.write(chunk);
        } else {
          this._held = this._held + chunk.toString();
        }
      } else {
        this._lines.write(chunk);
      }
    }
    #onLineEnd() {
      if (this._state === internals.state.boundary) {
        if (this._held) {
          this._held = this._held.replace(/[\t ]/g, "");
          if (this._held) {
            if (this._held === "--") {
              this._state = internals.state.epilogue;
              this._held = "";
              return;
            }
            return this.#abort(Boom.badRequest("Only white space allowed after boundary"));
          }
        }
        this._state = internals.state.header;
        return;
      }
      if (this._state === internals.state.header) {
        if (this._held) {
          if (this._held[0] === " " || this._held[0] === "\t") {
            if (!this._pendingHeader) {
              return this.#abort(Boom.badRequest("Invalid header continuation without valid declaration on previous line"));
            }
            this._pendingHeader = this._pendingHeader + " " + this._held.slice(1);
            this._held = "";
            return;
          }
          this.#flushHeader();
          this._pendingHeader = this._held;
          this._held = "";
          return;
        }
        this.#flushHeader();
        this._state = internals.state.payload;
        let disposition;
        try {
          disposition = Content.disposition(this._headers["content-disposition"]);
        } catch (err) {
          return this.#abort(err);
        }
        if (disposition.filename !== undefined) {
          const stream = new Stream.PassThrough;
          const transferEncoding = this._headers["content-transfer-encoding"];
          if (transferEncoding && transferEncoding.toLowerCase() === "base64") {
            this._stream = new B64.Decoder;
            this._stream.pipe(stream);
          } else {
            this._stream = stream;
          }
          stream.name = disposition.name;
          stream.filename = disposition.filename;
          stream.headers = this._headers;
          this._headers = {};
          this.#emit("part", stream);
        } else {
          this._name = disposition.name;
        }
        this._lines.flush();
        return;
      }
      this._held = this._held + `\r
`;
    }
    #onLine(chunk) {
      if (this._stream) {
        this._stream.write(chunk);
      } else {
        this._held = this._held + chunk.toString();
      }
    }
    #flushHeader() {
      if (!this._pendingHeader) {
        return;
      }
      const sep = this._pendingHeader.indexOf(":");
      if (sep === -1) {
        return this.#abort(Boom.badRequest("Invalid header missing colon separator"));
      }
      if (!sep) {
        return this.#abort(Boom.badRequest("Invalid header missing field name"));
      }
      const name = this._pendingHeader.slice(0, sep).toLowerCase();
      if (name === "__proto__") {
        return this.#abort(Boom.badRequest("Invalid header"));
      }
      this._headers[name] = this._pendingHeader.slice(sep + 1).trim();
      this._pendingHeader = "";
    }
  };
});

// node_modules/@hapi/wreck/lib/payload.js
var require_payload = __commonJS((exports, module) => {
  var Stream = __require("stream");
  var internals = {};
  module.exports = internals.Payload = class extends Stream.Readable {
    constructor(payload, encoding) {
      super();
      const data = [].concat(payload || "");
      let size = 0;
      for (let i = 0;i < data.length; ++i) {
        const chunk = data[i];
        size = size + chunk.length;
        data[i] = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
      this._data = Buffer.concat(data, size);
      this._position = 0;
      this._encoding = encoding || "utf8";
    }
    _read(size) {
      const chunk = this._data.slice(this._position, this._position + size);
      this.push(chunk, this._encoding);
      this._position = this._position + chunk.length;
      if (this._position >= this._data.length) {
        this.push(null);
      }
    }
  };
});

// node_modules/@hapi/wreck/lib/recorder.js
var require_recorder = __commonJS((exports, module) => {
  var Stream = __require("stream");
  var Boom = require_lib13();
  var internals = {};
  module.exports = internals.Recorder = class extends Stream.Writable {
    constructor(options) {
      super();
      this.settings = options;
      this.buffers = [];
      this.length = 0;
    }
    _write(chunk, encoding, next) {
      if (this.settings.maxBytes && this.length + chunk.length > this.settings.maxBytes) {
        return this.emit("error", Boom.entityTooLarge("Payload content length greater than maximum allowed: " + this.settings.maxBytes));
      }
      this.length = this.length + chunk.length;
      this.buffers.push(chunk);
      next();
    }
    collect() {
      const buffer = this.buffers.length === 0 ? Buffer.alloc(0) : this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length);
      return buffer;
    }
  };
});

// node_modules/@hapi/wreck/lib/tap.js
var require_tap = __commonJS((exports, module) => {
  var Stream = __require("stream");
  var Payload = require_payload();
  var internals = {};
  module.exports = internals.Tap = class extends Stream.Transform {
    constructor() {
      super();
      this.buffers = [];
    }
    _transform(chunk, encoding, next) {
      this.buffers.push(chunk);
      next(null, chunk);
    }
    collect() {
      return new Payload(this.buffers);
    }
  };
});

// node_modules/@hapi/wreck/lib/index.js
var require_lib32 = __commonJS((exports, module) => {
  var Events = __require("events");
  var Http = __require("http");
  var Https = __require("https");
  var Stream = __require("stream");
  var Url = __require("url");
  var Zlib = __require("zlib");
  var Boom = require_lib13();
  var Bourne = require_lib22();
  var Hoek = require_lib8();
  var Payload = require_payload();
  var Recorder = require_recorder();
  var Tap = require_tap();
  var internals = {
    jsonRegex: /^application\/([a-z0-9.]*[+-]json|json)$/,
    shallowOptions: ["agent", "agents", "beforeRedirect", "payload", "redirected"],
    httpOptions: ["secureProtocol", "ciphers", "lookup", "family", "hints"]
  };
  internals.Client = class {
    constructor(options = {}) {
      Hoek.assert(!options.agents || options.agents.https && options.agents.http && options.agents.httpsAllowUnauthorized, 'Option agents must include "http", "https", and "httpsAllowUnauthorized"');
      this._defaults = Hoek.clone(options, { shallow: internals.shallowOptions });
      this.agents = this._defaults.agents || {
        https: new Https.Agent({ maxSockets: Infinity }),
        http: new Http.Agent({ maxSockets: Infinity }),
        httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })
      };
      if (this._defaults.events) {
        this.events = new Events.EventEmitter;
      }
    }
    defaults(options) {
      Hoek.assert(options && typeof options === "object", "options must be provided to defaults");
      options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });
      return new internals.Client(options);
    }
    request(method, url, options = {}) {
      try {
        options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });
        Hoek.assert(options.payload === undefined || typeof options.payload === "string" || typeof options.payload === "object", "options.payload must be a string, a Buffer, a Stream, or an Object");
        Hoek.assert(internals.isNullOrUndefined(options.agent) || typeof options.rejectUnauthorized !== "boolean", "options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set");
        Hoek.assert(internals.isNullOrUndefined(options.beforeRedirect) || typeof options.beforeRedirect === "function", "options.beforeRedirect must be a function");
        Hoek.assert(internals.isNullOrUndefined(options.redirected) || typeof options.redirected === "function", "options.redirected must be a function");
        Hoek.assert(options.gunzip === undefined || typeof options.gunzip === "boolean" || options.gunzip === "force", 'options.gunzip must be a boolean or "force"');
      } catch (err) {
        return Promise.reject(err);
      }
      if (options.baseUrl) {
        url = internals.resolveUrl(options.baseUrl, url);
        delete options.baseUrl;
      }
      const relay = {};
      const req = this._request(method, url, options, relay);
      const promise = new Promise((resolve, reject) => {
        relay.callback = (err, res) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(res);
          return;
        };
      });
      promise.req = req;
      return promise;
    }
    _request(method, url, options, relay, _trace) {
      const uri = {};
      if (options.socketPath) {
        uri.socketPath = options.socketPath;
        const parsedUri = new Url.URL(url, `unix://${options.socketPath}`);
        internals.applyUrlToOptions(uri, {
          host: "",
          protocol: "http:",
          hash: parsedUri.hash,
          search: parsedUri.search,
          searchParams: parsedUri.searchParams,
          pathname: parsedUri.pathname,
          href: parsedUri.href
        });
      } else {
        uri.setHost = false;
        const parsedUri = new Url.URL(url);
        internals.applyUrlToOptions(uri, parsedUri);
      }
      uri.method = method.toUpperCase();
      uri.headers = Object.create(null);
      const usedHeaders = new Set;
      if (options.headers) {
        for (const [key, value] of Object.entries(options.headers)) {
          if (value !== undefined) {
            uri.headers[key] = value;
            usedHeaders.add(key.toLowerCase());
          }
        }
      }
      if (!usedHeaders.has("host")) {
        uri.headers.host = uri.host;
      }
      if (options.payload && typeof options.payload === "object" && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {
        options.payload = JSON.stringify(options.payload);
        if (!usedHeaders.has("content-type")) {
          uri.headers["content-type"] = "application/json";
        }
      }
      if (options.gunzip && !usedHeaders.has("accept-encoding")) {
        uri.headers["accept-encoding"] = "gzip";
      }
      const payloadSupported = uri.method !== "GET" && uri.method !== "HEAD" && !internals.isNullOrUndefined(options.payload);
      if (payloadSupported && (typeof options.payload === "string" || Buffer.isBuffer(options.payload)) && !usedHeaders.has("content-length")) {
        uri.headers["content-length"] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);
      }
      let redirects = options.hasOwnProperty("redirects") ? options.redirects : false;
      _trace = _trace ?? [];
      _trace.push({ method: uri.method, url });
      const client = uri.protocol === "https:" ? Https : Http;
      for (const option of internals.httpOptions) {
        if (options[option] !== undefined) {
          uri[option] = options[option];
        }
      }
      if (options.rejectUnauthorized !== undefined && uri.protocol === "https:") {
        uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;
      } else if (options.agent || options.agent === false) {
        uri.agent = options.agent;
      } else {
        uri.agent = uri.protocol === "https:" ? this.agents.https : this.agents.http;
      }
      this._emit("preRequest", uri, options);
      const start = Date.now();
      const req = client.request(uri);
      this._emit("request", req);
      let shadow = null;
      let timeoutId;
      const onError = (err) => {
        err.trace = _trace;
        return finishOnce(Boom.badGateway("Client request error", err));
      };
      const onAbort = () => {
        if (!req.socket) {
          const error = new Error("socket hang up");
          error.code = "ECONNRESET";
          finishOnce(error);
        }
      };
      req.once("error", onError);
      const onResponse = (res) => {
        const statusCode = res.statusCode;
        const redirectMethod = internals.redirectMethod(statusCode, uri.method, options);
        if (redirects === false || !redirectMethod) {
          return finishOnce(null, res);
        }
        res.destroy();
        if (redirects === 0) {
          return finishOnce(Boom.badGateway("Maximum redirections reached", _trace));
        }
        let location = res.headers.location;
        if (!location) {
          return finishOnce(Boom.badGateway("Received redirection without location", _trace));
        }
        if (!/^https?:/i.test(location)) {
          location = Url.resolve(uri.href, location);
        }
        const redirectOptions = Hoek.clone(options, { shallow: internals.shallowOptions });
        redirectOptions.payload = shadow ?? options.payload;
        redirectOptions.redirects = --redirects;
        if (timeoutId) {
          clearTimeout(timeoutId);
          const elapsed = Date.now() - start;
          redirectOptions.timeout = (redirectOptions.timeout - elapsed).toString();
        }
        if (redirectOptions.headers) {
          const parsedLocation = new URL(location);
          if (uri.hostname !== parsedLocation.hostname) {
            for (const header of Object.keys(redirectOptions.headers)) {
              const lowerHeader = header.toLowerCase();
              if (lowerHeader === "authorization" || lowerHeader === "cookie") {
                delete redirectOptions.headers[header];
              }
            }
          }
        }
        const followRedirect = (err) => {
          if (err) {
            err.trace = _trace;
            return finishOnce(Boom.badGateway("Invalid redirect", err));
          }
          const redirectReq = this._request(redirectMethod, location, redirectOptions, { callback: finishOnce }, _trace);
          if (options.redirected) {
            options.redirected(statusCode, location, redirectReq);
          }
        };
        if (!options.beforeRedirect) {
          return followRedirect();
        }
        return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, followRedirect);
      };
      const finish = (err, res) => {
        if (err) {
          req.abort();
        }
        req.removeListener("response", onResponse);
        req.removeListener("error", onError);
        req.removeListener("abort", onAbort);
        req.on("error", Hoek.ignore);
        clearTimeout(timeoutId);
        this._emit("response", err, { req, res, start, uri });
        return relay.callback(err, res);
      };
      const finishOnce = Hoek.once(finish);
      req.once("response", onResponse);
      if (options.timeout) {
        timeoutId = setTimeout(() => finishOnce(Boom.gatewayTimeout("Client request timeout")), options.timeout);
      }
      req.on("abort", onAbort);
      if (payloadSupported) {
        if (options.payload instanceof Stream) {
          let stream = options.payload;
          if (redirects) {
            const collector = new Tap;
            collector.once("finish", () => {
              shadow = collector.collect();
            });
            stream = options.payload.pipe(collector);
          }
          internals.deferPipeUntilSocketConnects(req, stream);
          return req;
        }
        req.write(options.payload);
      }
      req.end();
      return req;
    }
    _emit(...args) {
      if (this.events) {
        this.events.emit(...args);
      }
    }
    read(res, options = {}) {
      return new Promise((resolve, reject) => {
        this._read(res, options, (err, payload) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(payload);
          return;
        });
      });
    }
    _read(res, options, callback) {
      options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });
      let clientTimeoutId = null;
      const finish = (err, buffer) => {
        clearTimeout(clientTimeoutId);
        reader.removeListener("error", onReaderError);
        reader.removeListener("finish", onReaderFinish);
        res.removeListener("error", onResError);
        res.removeListener("close", onResAborted);
        res.removeListener("aborted", onResAborted);
        res.on("error", Hoek.ignore);
        if (err) {
          return callback(err);
        }
        if (!options.json) {
          return callback(null, buffer);
        }
        if (options.json === "force") {
          return internals.tryParseBuffer(buffer, callback);
        }
        const contentType = res.headers?.["content-type"] ?? "";
        const mime = contentType.split(";")[0].trim().toLowerCase();
        if (!internals.jsonRegex.test(mime)) {
          if (options.json === "strict") {
            return callback(Boom.notAcceptable("The content-type is not JSON compatible"));
          }
          return callback(null, buffer);
        }
        return internals.tryParseBuffer(buffer, callback);
      };
      const finishOnce = Hoek.once(finish);
      const clientTimeout = options.timeout;
      if (clientTimeout && clientTimeout > 0) {
        clientTimeoutId = setTimeout(() => finishOnce(Boom.clientTimeout()), clientTimeout);
      }
      const onResError = (err) => {
        return finishOnce(err.isBoom ? err : Boom.internal("Payload stream error", err));
      };
      const onResAborted = () => {
        if (!res.complete) {
          finishOnce(Boom.internal("Payload stream closed prematurely"));
        }
      };
      res.once("error", onResError);
      res.once("close", onResAborted);
      res.once("aborted", onResAborted);
      const reader = new Recorder({ maxBytes: options.maxBytes });
      const onReaderError = (err) => {
        if (res.destroy) {
          res.destroy();
        }
        return finishOnce(err);
      };
      reader.once("error", onReaderError);
      const onReaderFinish = () => {
        return finishOnce(null, reader.collect());
      };
      reader.once("finish", onReaderFinish);
      if (options.gunzip) {
        const contentEncoding = options.gunzip === "force" ? "gzip" : res.headers?.["content-encoding"] ?? "";
        if (/^(x-)?gzip(\s*,\s*identity)?$/.test(contentEncoding)) {
          const gunzip = Zlib.createGunzip();
          gunzip.once("error", onReaderError);
          res.pipe(gunzip).pipe(reader);
          return;
        }
      }
      res.pipe(reader);
    }
    toReadableStream(payload, encoding) {
      return new Payload(payload, encoding);
    }
    parseCacheControl(field) {
      const regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;
      const header = {};
      const error = field.replace(regex, ($0, $1, $2, $3) => {
        const value = $2 || $3;
        header[$1] = value ? value.toLowerCase() : true;
        return "";
      });
      if (header["max-age"]) {
        try {
          const maxAge = parseInt(header["max-age"], 10);
          if (isNaN(maxAge)) {
            return null;
          }
          header["max-age"] = maxAge;
        } catch (err) {}
      }
      return error ? null : header;
    }
    get(uri, options) {
      return this._shortcut("GET", uri, options);
    }
    post(uri, options) {
      return this._shortcut("POST", uri, options);
    }
    patch(uri, options) {
      return this._shortcut("PATCH", uri, options);
    }
    put(uri, options) {
      return this._shortcut("PUT", uri, options);
    }
    delete(uri, options) {
      return this._shortcut("DELETE", uri, options);
    }
    async _shortcut(method, uri, options = {}) {
      const res = await this.request(method, uri, options);
      let payload;
      try {
        payload = await this.read(res, options);
      } catch (err) {
        err.data = err.data ?? {};
        err.data.res = res;
        throw err;
      }
      if (res.statusCode < 400) {
        return { res, payload };
      }
      const data = {
        isResponseError: true,
        headers: res.headers,
        res,
        payload
      };
      throw new Boom.Boom(`Response Error: ${res.statusCode} ${res.statusMessage}`, { statusCode: res.statusCode, data });
    }
  };
  internals.resolveUrl = function(baseUrl, path2) {
    if (!path2) {
      return baseUrl;
    }
    const url = new Url.URL(path2, baseUrl);
    return Url.format(url);
  };
  internals.deferPipeUntilSocketConnects = function(req, stream) {
    const onSocket = (socket) => {
      if (!socket.connecting) {
        return onSocketConnect();
      }
      socket.once("connect", onSocketConnect);
    };
    const onSocketConnect = () => {
      stream.pipe(req);
      stream.removeListener("error", onStreamError);
    };
    const onStreamError = (err) => {
      req.emit("error", err);
    };
    req.once("socket", onSocket);
    stream.on("error", onStreamError);
  };
  internals.redirectMethod = function(code, method, options) {
    switch (code) {
      case 301:
      case 302:
        return options.redirectMethod || method;
      case 303:
        if (options.redirect303) {
          return "GET";
        }
        break;
      case 307:
      case 308:
        return method;
    }
    return null;
  };
  internals.tryParseBuffer = function(buffer, next) {
    if (buffer.length === 0) {
      return next(null, null);
    }
    let payload;
    try {
      payload = Bourne.parse(buffer.toString());
    } catch (err) {
      return next(Boom.badGateway(err.message, { payload: buffer }));
    }
    return next(null, payload);
  };
  internals.applyUrlToOptions = (options, url) => {
    options.host = url.host;
    options.origin = url.origin;
    options.searchParams = url.searchParams;
    options.protocol = url.protocol;
    options.hostname = typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname;
    options.hash = url.hash;
    options.search = url.search;
    options.pathname = url.pathname;
    options.path = `${url.pathname}${url.search}`;
    options.href = url.href;
    if (url.port !== "") {
      options.port = Number(url.port);
    }
    if (url.username || url.password) {
      options.auth = `${url.username}:${url.password}`;
      options.username = url.username;
      options.password = url.password;
    }
    return options;
  };
  internals.isNullOrUndefined = (val) => [null, undefined].includes(val);
  module.exports = new internals.Client;
});

// node_modules/@hapi/subtext/lib/index.js
var require_lib33 = __commonJS((exports) => {
  var Fs = __require("fs");
  var Fsp = __require("fs/promises");
  var Os = __require("os");
  var Querystring = __require("querystring");
  var Stream = __require("stream");
  var Zlib = __require("zlib");
  var Boom = require_lib13();
  var Bourne = require_lib22();
  var Content = require_lib27();
  var File = require_lib28();
  var Hoek = require_lib8();
  var Pez = require_lib31();
  var Wreck = require_lib32();
  var internals = {
    kSubtext: Symbol("subtext"),
    decoders: {
      gzip: (options) => Zlib.createGunzip(options),
      deflate: (options) => Zlib.createInflate(options)
    }
  };
  exports.parse = async function(req, tap, options) {
    Hoek.assert(options, "Missing options");
    Hoek.assert(options.parse !== undefined, "Missing parse option setting");
    Hoek.assert(options.output !== undefined, "Missing output option setting");
    const contentLength = req.headers["content-length"];
    if (options.maxBytes !== undefined && contentLength && parseInt(contentLength, 10) > options.maxBytes) {
      throw Boom.entityTooLarge("Payload content length greater than maximum allowed: " + options.maxBytes);
    }
    const contentType = Content.type(options.override || req.headers["content-type"] || options.defaultContentType || "application/octet-stream");
    try {
      if (options.allow && options.allow.indexOf(contentType.mime) === -1) {
        throw Boom.unsupportedMediaType();
      }
      const parsed = { mime: contentType.mime };
      if (options.parse === true) {
        parsed.payload = await internals.parse(req, tap, options, contentType);
        return parsed;
      }
      parsed.payload = await internals.raw(req, tap, options);
      return parsed;
    } catch (err) {
      err.mime = contentType.mime;
      throw err;
    }
  };
  internals.parse = async function(req, tap, options, contentType) {
    const output = options.output;
    let source = internals.decoder(req, options);
    if (tap) {
      [source] = internals.pipe(source, tap);
    }
    if (contentType.mime === "multipart/form-data") {
      if (options.multipart === false) {
        throw Boom.unsupportedMediaType();
      }
      return await internals.multipart(req, options, source, contentType);
    }
    if (output === "stream") {
      return source;
    }
    if (output === "file") {
      const file = await internals.writeFile(req, options, source);
      return file.item;
    }
    const payload = await Wreck.read(source, { timeout: options.timeout, maxBytes: options.maxBytes });
    return internals.object(options, payload, contentType.mime);
  };
  internals.decoder = function(source, options) {
    const contentEncoding = source.headers["content-encoding"];
    const decoders = options.decoders ?? internals.decoders;
    if (!decoders.hasOwnProperty(contentEncoding)) {
      return source;
    }
    const decoderOptions = options.compression?.[contentEncoding] ?? null;
    const stream = decoders[contentEncoding](decoderOptions);
    const orig = stream.emit;
    stream.emit = (event, ...args) => {
      if (event === "error") {
        args = [Boom.badRequest("Invalid compressed payload", args[0])];
      }
      return orig.call(stream, event, ...args);
    };
    [source] = internals.pipe(source, stream);
    return source;
  };
  internals.raw = async function(req, tap, options) {
    const output = options.output;
    let source = req;
    if (options.parse === "gunzip") {
      source = internals.decoder(source, options);
    }
    if (tap) {
      [source] = internals.pipe(source, tap);
    }
    if (output === "stream") {
      return source;
    }
    if (output === "file") {
      const file = await internals.writeFile(req, options, source);
      return file.item;
    }
    return await Wreck.read(source, { timeout: options.timeout, maxBytes: options.maxBytes });
  };
  internals.object = function(options, payload, mime) {
    if (mime === "application/octet-stream") {
      return payload.length ? payload : null;
    }
    if (mime.match(/^text\/.+$/)) {
      return payload.toString("utf8");
    }
    if (/^application\/(?:.+\+)?json$/.test(mime)) {
      if (!payload.length) {
        return null;
      }
      try {
        return Bourne.parse(payload.toString("utf8"), { protoAction: options.protoAction });
      } catch (err) {
        const error2 = Boom.badRequest("Invalid request payload JSON format", err);
        error2.raw = payload;
        throw error2;
      }
    }
    if (mime === "application/x-www-form-urlencoded") {
      const parse = options.querystring ?? Querystring.parse;
      return payload.length ? parse(payload.toString("utf8")) : {};
    }
    const error = Boom.unsupportedMediaType();
    error.raw = payload;
    throw error;
  };
  internals.multipart = function(req, options, source, contentType) {
    return new Promise((resolve, reject) => {
      const clientTimeout = options.timeout;
      const clientTimeoutId = clientTimeout ? setTimeout(() => reject(Boom.clientTimeout()), clientTimeout) : null;
      const dispenserOptions = Hoek.applyToDefaults(contentType, {
        maxBytes: options.maxBytes,
        maxParts: options.maxParts
      });
      const dispenser = new Pez.Dispenser(dispenserOptions);
      const data = {};
      const pendingFiles = [];
      const onError = (err) => {
        const cleanup = internals.cleanupFiles(pendingFiles);
        cleanup.catch(Hoek.ignore);
        reject(Boom.badRequest("Invalid multipart payload format", err));
      };
      dispenser.once("error", onError);
      const set = (name, value) => {
        if (!data.hasOwnProperty(name)) {
          data[name] = value;
        } else if (Array.isArray(data[name])) {
          data[name].push(value);
        } else {
          data[name] = [data[name], value];
        }
      };
      const finalize = async () => {
        clearTimeout(clientTimeoutId);
        dispenser.removeListener("error", onError);
        dispenser.removeListener("part", onPart);
        dispenser.removeListener("field", onField);
        dispenser.removeListener("close", onClose);
        try {
          const files = await Promise.all(pendingFiles);
          for (const { item, name } of files) {
            set(name, item);
          }
        } catch (err) {
          reject(err);
          return;
        }
        resolve(data);
      };
      const output = typeof options.multipart === "object" ? options.multipart.output : options.output;
      const onPart = (part) => {
        if (output === "file") {
          pendingFiles.push(internals.writeFile(req, options, part));
        } else {
          internals.part(part, output, set, options);
        }
      };
      dispenser.on("part", onPart);
      const onField = (name, value) => set(name, value);
      dispenser.on("field", onField);
      const onClose = () => finalize();
      dispenser.once("close", onClose);
      source.pipe(dispenser);
    });
  };
  internals.writeFile = function(req, options, stream) {
    const promise = new Promise((resolve, reject) => {
      const path2 = File.uniqueFilename(options.uploads ?? Os.tmpdir());
      const file = Fs.createWriteStream(path2, { flags: "wx" });
      const counter = new internals.Counter(options);
      const finalize = (err) => {
        req.removeListener("aborted", onAbort);
        file.removeListener("close", finalize);
        file.removeListener("error", finalize);
        if (err) {
          unpipeStreamToCounter();
          unpipeCounterToFile();
          file.destroy();
          Fs.unlink(path2, () => reject(err));
          return;
        }
        const result = {
          item: {
            path: path2,
            bytes: counter.bytes
          }
        };
        if (stream.name) {
          result.name = stream.name;
          result.item.filename = stream.filename;
          result.item.headers = stream.headers;
        }
        resolve(result);
      };
      file.once("close", finalize);
      file.once("error", finalize);
      const onAbort = () => finalize(Boom.badRequest("Client connection aborted"));
      req.once("aborted", onAbort);
      const [, unpipeStreamToCounter] = internals.pipe(stream, counter);
      const [, unpipeCounterToFile] = internals.pipe(counter, file);
    });
    promise.catch(Hoek.ignore);
    return promise;
  };
  internals.cleanupFiles = async (pendingFiles) => {
    const results = await Promise.allSettled(pendingFiles);
    await Promise.all(results.map(async (result) => {
      if (result.value) {
        await Fsp.unlink(result.value.item.path);
      }
    }));
  };
  internals.part = async function(part, output, set, options) {
    const payload = await Wreck.read(part);
    if (output === "stream") {
      const item = Wreck.toReadableStream(payload);
      item.hapi = {
        filename: part.filename,
        headers: part.headers
      };
      return set(part.name, item);
    }
    const ct = part.headers["content-type"] || "";
    const mime = ct.split(";")[0].trim().toLowerCase();
    const annotate = (value) => set(part.name, output === "annotated" ? { filename: part.filename, headers: part.headers, payload: value } : value);
    if (!mime) {
      return annotate(payload);
    }
    if (!payload.length) {
      return annotate({});
    }
    try {
      const object = internals.object(options, payload, mime);
      annotate(object);
    } catch (err) {
      annotate(payload);
    }
  };
  internals.pipe = function(from, to) {
    const forwardError = (err) => {
      unpipe();
      to.emit("error", err);
    };
    const unpipe = () => {
      from.removeListener("error", forwardError);
      return from.unpipe(to);
    };
    from.once("error", forwardError);
    return [from.pipe(to), unpipe];
  };
  internals.Counter = class extends Stream.Transform {
    constructor(options) {
      super();
      this.bytes = 0;
      this._maxBytes = options.maxBytes;
    }
    _transform(chunk, encoding, next) {
      this.bytes = this.bytes + chunk.length;
      if (this._maxBytes !== undefined && this.bytes > this._maxBytes) {
        return next(Boom.entityTooLarge("Payload content length greater than maximum allowed: " + this._maxBytes));
      }
      return next(null, chunk);
    }
  };
});

// node_modules/@hapi/hapi/lib/ext.js
var require_ext = __commonJS((exports, module) => {
  var Hoek = require_lib8();
  var Topo = require_lib9();
  var internals = {};
  exports = module.exports = internals.Ext = class {
    type = null;
    nodes = null;
    #core = null;
    #routes = [];
    #topo = new Topo.Sorter;
    constructor(type, core) {
      this.#core = core;
      this.type = type;
    }
    add(event) {
      const methods = [].concat(event.method);
      for (const method of methods) {
        const settings = {
          before: event.options.before,
          after: event.options.after,
          group: event.realm.plugin,
          sort: this.#core.extensionsSeq++
        };
        const node = {
          func: method,
          bind: event.options.bind,
          server: event.server,
          realm: event.realm,
          timeout: event.options.timeout
        };
        this.#topo.add(node, settings);
      }
      this.nodes = this.#topo.nodes;
      for (const route of this.#routes) {
        route.rebuild(event);
      }
    }
    merge(others) {
      const merge = [];
      for (const other of others) {
        merge.push(other.#topo);
      }
      this.#topo.merge(merge);
      this.nodes = this.#topo.nodes.length ? this.#topo.nodes : null;
    }
    subscribe(route) {
      this.#routes.push(route);
    }
    static combine(route, type) {
      const ext = new internals.Ext(type, route._core);
      const events = route.settings.ext[type];
      if (events) {
        for (let event of events) {
          event = Object.assign({}, event);
          Hoek.assert(!event.options.sandbox, "Cannot specify sandbox option for route extension");
          event.realm = route.realm;
          ext.add(event);
        }
      }
      const server = route._core.extensions.route[type];
      const realm = route.realm._extensions[type];
      ext.merge([server, realm]);
      server.subscribe(route);
      realm.subscribe(route);
      return ext;
    }
  };
});

// node_modules/@hapi/hapi/lib/handler.js
var require_handler = __commonJS((exports) => {
  var Hoek = require_lib8();
  var internals = {};
  exports.execute = async function(request) {
    if (request._route._prerequisites) {
      for (const set of request._route._prerequisites) {
        const pres = [];
        for (const item of set) {
          pres.push(internals.handler(request, item.method, item));
        }
        const responses = await Promise.all(pres);
        for (const response of responses) {
          if (response !== undefined) {
            return response;
          }
        }
      }
    }
    const result = await internals.handler(request, request.route.settings.handler);
    if (result._takeover || typeof result === "symbol") {
      return result;
    }
    request._setResponse(result);
  };
  internals.handler = async function(request, method, pre) {
    const bind = request.route.settings.bind;
    const realm = request.route.realm;
    let response = await request._core.toolkit.execute(method, request, { bind, realm, continue: "null" });
    if (!pre) {
      if (response.isBoom) {
        request._log(["handler", "error"], response);
        throw response;
      }
      return response;
    }
    if (response.isBoom) {
      response.assign = pre.assign;
      response = await request._core.toolkit.failAction(request, pre.failAction, response, { tags: ["pre", "error"], retain: true });
    }
    if (typeof response === "symbol") {
      return response;
    }
    if (pre.assign) {
      request.pre[pre.assign] = response.isBoom ? response : response.source;
      request.preResponses[pre.assign] = response;
    }
    if (response._takeover) {
      return response;
    }
  };
  exports.defaults = function(method, handler, core) {
    let defaults2 = null;
    if (typeof handler === "object") {
      const type = Object.keys(handler)[0];
      const serverHandler = core.decorations.handler.get(type);
      Hoek.assert(serverHandler, "Unknown handler:", type);
      if (serverHandler.defaults) {
        defaults2 = typeof serverHandler.defaults === "function" ? serverHandler.defaults(method) : serverHandler.defaults;
      }
    }
    return defaults2 ?? {};
  };
  exports.configure = function(handler, route) {
    if (typeof handler === "object") {
      const type = Object.keys(handler)[0];
      const serverHandler = route._core.decorations.handler.get(type);
      Hoek.assert(serverHandler, "Unknown handler:", type);
      return serverHandler(route.public, handler[type]);
    }
    return handler;
  };
  exports.prerequisitesConfig = function(config) {
    if (!config) {
      return null;
    }
    const prerequisites = [];
    for (let pres of config) {
      pres = [].concat(pres);
      const set = [];
      for (let pre of pres) {
        if (typeof pre !== "object") {
          pre = { method: pre };
        }
        const item = {
          method: pre.method,
          assign: pre.assign,
          failAction: pre.failAction ?? "error"
        };
        set.push(item);
      }
      prerequisites.push(set);
    }
    return prerequisites.length ? prerequisites : null;
  };
});

// node_modules/@hapi/hapi/lib/headers.js
var require_headers = __commonJS((exports) => {
  var Stream = __require("stream");
  var Boom = require_lib13();
  var internals = {};
  exports.cache = function(response) {
    const request = response.request;
    if (response.headers["cache-control"]) {
      return;
    }
    const settings = request.route.settings.cache;
    const policy = settings && request._route._cache && (settings._statuses.has(response.statusCode) || response.statusCode === 304 && settings._statuses.has(200));
    if (policy || response.settings.ttl) {
      const ttl = response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl();
      const privacy = request.auth.isAuthenticated || response.headers["set-cookie"] ? "private" : settings.privacy ?? "default";
      response._header("cache-control", "max-age=" + Math.floor(ttl / 1000) + ", must-revalidate" + (privacy !== "default" ? ", " + privacy : ""));
    } else if (settings) {
      response._header("cache-control", settings.otherwise);
    }
  };
  exports.content = async function(response) {
    const request = response.request;
    if (response._isPayloadSupported() || request.method === "head") {
      await response._marshal();
      if (typeof response._payload.size === "function") {
        response._header("content-length", response._payload.size(), { override: false });
      }
      if (!response._isPayloadSupported()) {
        response._close();
        response._payload = new internals.Empty;
      }
      exports.type(response);
    } else {
      response._close();
      response._payload = new internals.Empty;
      delete response.headers["content-length"];
    }
  };
  exports.state = async function(response) {
    const request = response.request;
    const states = [];
    for (const stateName in request._states) {
      states.push(request._states[stateName]);
    }
    try {
      for (const name in request._core.states.cookies) {
        const autoValue = request._core.states.cookies[name].autoValue;
        if (!autoValue || name in request._states || name in request.state) {
          continue;
        }
        if (typeof autoValue !== "function") {
          states.push({ name, value: autoValue });
          continue;
        }
        const value = await autoValue(request);
        states.push({ name, value });
      }
      if (!states.length) {
        return;
      }
      let header = await request._core.states.format(states, request);
      const existing = response.headers["set-cookie"];
      if (existing) {
        header = (Array.isArray(existing) ? existing : [existing]).concat(header);
      }
      response._header("set-cookie", header);
    } catch (err) {
      const error = Boom.boomify(err);
      request._log(["state", "response", "error"], error);
      request._states = {};
      throw error;
    }
  };
  exports.type = function(response) {
    const type = response.contentType;
    if (type !== null && type !== response.headers["content-type"]) {
      response.type(type);
    }
  };
  exports.entity = function(response) {
    const request = response.request;
    if (!request._entity) {
      return;
    }
    if (request._entity.etag && !response.headers.etag) {
      response.etag(request._entity.etag, { vary: request._entity.vary });
    }
    if (request._entity.modified && !response.headers["last-modified"]) {
      response.header("last-modified", request._entity.modified);
    }
  };
  exports.unmodified = function(response) {
    const request = response.request;
    if (response.statusCode === 304) {
      return;
    }
    const entity = {
      etag: response.headers.etag,
      vary: response.settings.varyEtag,
      modified: response.headers["last-modified"]
    };
    const etag = request._core.Response.unmodified(request, entity);
    if (etag) {
      response.code(304);
      if (etag !== true) {
        response.headers.etag = etag;
      }
    }
  };
  internals.Empty = class extends Stream.Readable {
    _read() {
      this.push(null);
    }
    writeToStream(stream) {
      stream.end();
    }
  };
});

// node_modules/@hapi/hapi/lib/security.js
var require_security = __commonJS((exports) => {
  exports.route = function(settings) {
    if (!settings) {
      return null;
    }
    const security = settings;
    if (security.hsts) {
      if (security.hsts === true) {
        security._hsts = "max-age=15768000";
      } else if (typeof security.hsts === "number") {
        security._hsts = "max-age=" + security.hsts;
      } else {
        security._hsts = "max-age=" + (security.hsts.maxAge ?? 15768000);
        if (security.hsts.includeSubdomains || security.hsts.includeSubDomains) {
          security._hsts = security._hsts + "; includeSubDomains";
        }
        if (security.hsts.preload) {
          security._hsts = security._hsts + "; preload";
        }
      }
    }
    if (security.xframe) {
      if (security.xframe === true) {
        security._xframe = "DENY";
      } else if (typeof security.xframe === "string") {
        security._xframe = security.xframe.toUpperCase();
      } else if (security.xframe.rule === "allow-from") {
        if (!security.xframe.source) {
          security._xframe = "SAMEORIGIN";
        } else {
          security._xframe = "ALLOW-FROM " + security.xframe.source;
        }
      } else {
        security._xframe = security.xframe.rule.toUpperCase();
      }
    }
    return security;
  };
  exports.headers = function(response) {
    const security = response.request.route.settings.security;
    if (security._hsts) {
      response._header("strict-transport-security", security._hsts, { override: false });
    }
    if (security._xframe) {
      response._header("x-frame-options", security._xframe, { override: false });
    }
    if (security.xss === "enabled") {
      response._header("x-xss-protection", "1; mode=block", { override: false });
    } else if (security.xss === "disabled") {
      response._header("x-xss-protection", "0", { override: false });
    }
    if (security.noOpen) {
      response._header("x-download-options", "noopen", { override: false });
    }
    if (security.noSniff) {
      response._header("x-content-type-options", "nosniff", { override: false });
    }
    if (security.referrer !== false) {
      response._header("referrer-policy", security.referrer, { override: false });
    }
  };
});

// node_modules/@hapi/hapi/lib/streams.js
var require_streams = __commonJS((exports) => {
  var Stream = __require("stream");
  var Boom = require_lib13();
  var Teamwork = require_lib12();
  var internals = {
    team: Symbol("team")
  };
  exports.isStream = function(stream) {
    const isReadableStream = stream instanceof Stream.Readable;
    if (!isReadableStream && typeof stream?.pipe === "function") {
      throw Boom.badImplementation("Cannot reply with a stream-like object that is not an instance of Stream.Readable");
    }
    if (!isReadableStream) {
      return false;
    }
    if (stream.readableObjectMode) {
      throw Boom.badImplementation("Cannot reply with stream in object mode");
    }
    return true;
  };
  exports.drain = function(stream) {
    const team = new Teamwork.Team;
    stream[internals.team] = team;
    stream.on("readable", internals.read);
    stream.on("error", internals.end);
    stream.on("end", internals.end);
    stream.on("close", internals.end);
    return team.work;
  };
  internals.read = function() {
    while (this.read()) {}
  };
  internals.end = function() {
    this.removeListener("readable", internals.read);
    this.removeListener("error", internals.end);
    this.removeListener("end", internals.end);
    this.removeListener("close", internals.end);
    this[internals.team].attend();
  };
});

// node_modules/@hapi/hapi/lib/validation.js
var require_validation = __commonJS((exports) => {
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var Validate = require_lib10();
  var internals = {};
  exports.validator = function(validator) {
    Hoek.assert(validator, "Missing validator");
    Hoek.assert(typeof validator.compile === "function", "Invalid validator compile method");
    return validator;
  };
  exports.compile = function(rule, validator, realm, core) {
    validator = validator ?? internals.validator(realm, core);
    if (rule === false) {
      return Validate.object({}).allow(null);
    }
    if (typeof rule === "function") {
      return rule;
    }
    if (!rule || rule === true) {
      return null;
    }
    if (typeof rule.validate === "function") {
      return rule;
    }
    Hoek.assert(validator, "Cannot set uncompiled validation rules without configuring a validator");
    return validator.compile(rule);
  };
  internals.validator = function(realm, core) {
    while (realm) {
      if (realm.validator) {
        return realm.validator;
      }
      realm = realm.parent;
    }
    return core.validator;
  };
  exports.headers = function(request) {
    return internals.input("headers", request);
  };
  exports.params = function(request) {
    return internals.input("params", request);
  };
  exports.payload = function(request) {
    if (request.method === "get" || request.method === "head") {
      return;
    }
    return internals.input("payload", request);
  };
  exports.query = function(request) {
    return internals.input("query", request);
  };
  exports.state = function(request) {
    return internals.input("state", request);
  };
  internals.input = async function(source, request) {
    const localOptions = {
      context: {
        headers: request.headers,
        params: request.params,
        query: request.query,
        payload: request.payload,
        state: request.state,
        auth: request.auth,
        app: {
          route: request.route.settings.app,
          request: request.app
        }
      }
    };
    delete localOptions.context[source];
    Hoek.merge(localOptions, request.route.settings.validate.options);
    try {
      const schema = request.route.settings.validate[source];
      const bind = request.route.settings.bind;
      var value = await (typeof schema !== "function" ? internals.validate(request[source], schema, localOptions) : schema.call(bind, request[source], localOptions));
      return;
    } catch (err) {
      var validationError = err;
    } finally {
      request.orig[source] = request[source];
      if (value !== undefined) {
        request[source] = value;
      }
    }
    if (request.route.settings.validate.failAction === "ignore") {
      return;
    }
    const defaultError = validationError.isBoom ? validationError : Boom.badRequest(`Invalid request ${source} input`);
    const detailedError = Boom.boomify(validationError, { statusCode: 400, override: false, data: { defaultError } });
    detailedError.output.payload.validation = { source, keys: [] };
    if (validationError.details) {
      for (const details of validationError.details) {
        const path2 = details.path;
        detailedError.output.payload.validation.keys.push(Hoek.escapeHtml(path2.join(".")));
      }
    }
    if (request.route.settings.validate.errorFields) {
      for (const field in request.route.settings.validate.errorFields) {
        detailedError.output.payload[field] = request.route.settings.validate.errorFields[field];
      }
    }
    return request._core.toolkit.failAction(request, request.route.settings.validate.failAction, defaultError, { details: detailedError, tags: ["validation", "error", source] });
  };
  exports.response = async function(request) {
    if (request.route.settings.response.sample) {
      const currentSample = Math.ceil(Math.random() * 100);
      if (currentSample > request.route.settings.response.sample) {
        return;
      }
    }
    const response = request.response;
    const statusCode = response.isBoom ? response.output.statusCode : response.statusCode;
    const statusSchema = request.route.settings.response.status[statusCode];
    if (statusCode >= 400 && !statusSchema) {
      return;
    }
    const schema = statusSchema !== undefined ? statusSchema : request.route.settings.response.schema;
    if (schema === null) {
      return;
    }
    if (!response.isBoom && request.response.variety !== "plain") {
      throw Boom.badImplementation("Cannot validate non-object response");
    }
    const localOptions = {
      context: {
        headers: request.headers,
        params: request.params,
        query: request.query,
        payload: request.payload,
        state: request.state,
        auth: request.auth,
        app: {
          route: request.route.settings.app,
          request: request.app
        }
      }
    };
    const source = response.isBoom ? response.output.payload : response.source;
    Hoek.merge(localOptions, request.route.settings.response.options);
    try {
      let value;
      if (typeof schema !== "function") {
        value = await internals.validate(source, schema, localOptions);
      } else {
        value = await schema(source, localOptions);
      }
      if (value !== undefined && request.route.settings.response.modify) {
        if (response.isBoom) {
          response.output.payload = value;
        } else {
          response.source = value;
        }
      }
    } catch (err) {
      return request._core.toolkit.failAction(request, request.route.settings.response.failAction, err, { tags: ["validation", "response", "error"] });
    }
  };
  internals.validate = function(value, schema, options) {
    if (typeof schema.validateAsync === "function") {
      return schema.validateAsync(value, options);
    }
    return schema.validate(value, options);
  };
});

// node_modules/@hapi/hapi/lib/route.js
var require_route = __commonJS((exports, module) => {
  var Assert = __require("assert");
  var Bounce = require_lib14();
  var Catbox = require_lib18();
  var Hoek = require_lib8();
  var Subtext = require_lib33();
  var Validate = require_lib10();
  var Auth = require_auth();
  var Config2 = require_config();
  var Cors = require_cors();
  var Ext = require_ext();
  var Handler = require_handler();
  var Headers = require_headers();
  var Security = require_security();
  var Streams = require_streams();
  var Validation = require_validation();
  var internals = {};
  exports = module.exports = internals.Route = class {
    constructor(route, server, options = {}) {
      const core = server._core;
      const realm = server.realm;
      Config2.apply("route", route, route.method, route.path);
      const method = route.method.toLowerCase();
      Hoek.assert(method !== "head", "Cannot set HEAD route:", route.path);
      const path2 = realm.modifiers.route.prefix ? realm.modifiers.route.prefix + (route.path !== "/" ? route.path : "") : route.path;
      Hoek.assert(path2 === "/" || path2[path2.length - 1] !== "/" || !core.settings.router.stripTrailingSlash, "Path cannot end with a trailing slash when configured to strip:", route.method, route.path);
      const vhost = realm.modifiers.route.vhost ?? route.vhost;
      this.method = method;
      this.path = path2;
      let config = route.options ?? route.config ?? {};
      if (typeof config === "function") {
        config = config.call(realm.settings.bind, server);
      }
      config = Config2.enable(config);
      this._assert(method !== "get" || !config.payload, "Cannot set payload settings on HEAD or GET request");
      this._assert(method !== "get" || !config.validate?.payload, "Cannot validate HEAD or GET request payload");
      this._assert(!route.rules || !config.rules, "Route rules can only appear once");
      const rules = route.rules ?? config.rules;
      const rulesConfig = internals.rules(rules, { method, path: path2, vhost }, server);
      delete config.rules;
      this._assert(route.handler || config.handler, "Missing or undefined handler");
      this._assert(!!route.handler ^ !!config.handler, "Handler must only appear once");
      const handler = Config2.apply("handler", route.handler ?? config.handler);
      delete config.handler;
      const handlerDefaults = Handler.defaults(method, handler, core);
      const settings = internals.config([core.settings.routes, handlerDefaults, realm.settings, rulesConfig, config]);
      this.settings = Config2.apply("routeConfig", settings, method, path2);
      this._core = core;
      this.realm = realm;
      this.settings.vhost = vhost;
      this.settings.plugins = this.settings.plugins ?? {};
      this.settings.app = this.settings.app ?? {};
      this._special = !!options.special;
      this._analysis = this._core.router.analyze(this.path);
      this.params = this._analysis.params;
      this.fingerprint = this._analysis.fingerprint;
      this.public = {
        method: this.method,
        path: this.path,
        vhost,
        realm,
        settings: this.settings,
        fingerprint: this.fingerprint,
        auth: {
          access: (request) => Auth.testAccess(request, this.public)
        }
      };
      this._setupValidation();
      if (this.method === "get") {
        this.settings.payload = null;
      } else {
        this.settings.payload.decoders = this._core.compression.decoders;
      }
      this._assert(!this.settings.validate.payload || this.settings.payload.parse, "Route payload must be set to 'parse' when payload validation enabled");
      this._assert(!this.settings.validate.state || this.settings.state.parse, "Route state must be set to 'parse' when state validation enabled");
      this.settings.auth = this._special ? false : this._core.auth._setupRoute(this.settings.auth, path2);
      if (this.method === "get" && typeof this.settings.cache === "object" && (this.settings.cache.expiresIn || this.settings.cache.expiresAt)) {
        this.settings.cache._statuses = new Set(this.settings.cache.statuses);
        this._cache = new Catbox.Policy({ expiresIn: this.settings.cache.expiresIn, expiresAt: this.settings.cache.expiresAt });
      }
      this.settings.cors = Cors.route(this.settings.cors);
      this.settings.security = Security.route(this.settings.security);
      this.settings.handler = Handler.configure(handler, this);
      this._prerequisites = Handler.prerequisitesConfig(this.settings.pre);
      this._extensions = {
        onPreResponse: Ext.combine(this, "onPreResponse"),
        onPostResponse: Ext.combine(this, "onPostResponse")
      };
      if (this._special) {
        this._cycle = [internals.drain, Handler.execute];
        this.rebuild();
        return;
      }
      this._extensions.onPreAuth = Ext.combine(this, "onPreAuth");
      this._extensions.onCredentials = Ext.combine(this, "onCredentials");
      this._extensions.onPostAuth = Ext.combine(this, "onPostAuth");
      this._extensions.onPreHandler = Ext.combine(this, "onPreHandler");
      this._extensions.onPostHandler = Ext.combine(this, "onPostHandler");
      this.rebuild();
    }
    _setupValidation() {
      const validation = this.settings.validate;
      if (this.method === "get") {
        validation.payload = null;
      }
      this._assert(!validation.params || this.params.length, "Cannot set path parameters validations without path parameters");
      for (const type of ["headers", "params", "query", "payload", "state"]) {
        validation[type] = Validation.compile(validation[type], this.settings.validate.validator, this.realm, this._core);
      }
      if (this.settings.response.schema !== undefined || this.settings.response.status) {
        this.settings.response._validate = true;
        const rule = this.settings.response.schema;
        this.settings.response.status = this.settings.response.status ?? {};
        const statuses = Object.keys(this.settings.response.status);
        if (rule === true && !statuses.length) {
          this.settings.response._validate = false;
        } else {
          this.settings.response.schema = Validation.compile(rule, this.settings.validate.validator, this.realm, this._core);
          for (const code of statuses) {
            this.settings.response.status[code] = Validation.compile(this.settings.response.status[code], this.settings.validate.validator, this.realm, this._core);
          }
        }
      }
    }
    rebuild(event) {
      if (event) {
        this._extensions[event.type].add(event);
      }
      if (this._special) {
        this._postCycle = this._extensions.onPreResponse.nodes ? [this._extensions.onPreResponse] : [];
        this._buildMarshalCycle();
        return;
      }
      this._cycle = [];
      if (this.settings.state.parse) {
        this._cycle.push(internals.state);
      }
      if (this._extensions.onPreAuth.nodes) {
        this._cycle.push(this._extensions.onPreAuth);
      }
      if (this._core.auth._enabled(this, "authenticate")) {
        this._cycle.push(Auth.authenticate);
      }
      if (this.method !== "get") {
        this._cycle.push(internals.payload);
        if (this._core.auth._enabled(this, "payload")) {
          this._cycle.push(Auth.payload);
        }
      }
      if (this._core.auth._enabled(this, "authenticate") && this._extensions.onCredentials.nodes) {
        this._cycle.push(this._extensions.onCredentials);
      }
      if (this._core.auth._enabled(this, "access")) {
        this._cycle.push(Auth.access);
      }
      if (this._extensions.onPostAuth.nodes) {
        this._cycle.push(this._extensions.onPostAuth);
      }
      if (this.settings.validate.headers) {
        this._cycle.push(Validation.headers);
      }
      if (this.settings.validate.params) {
        this._cycle.push(Validation.params);
      }
      if (this.settings.validate.query) {
        this._cycle.push(Validation.query);
      }
      if (this.settings.validate.payload) {
        this._cycle.push(Validation.payload);
      }
      if (this.settings.validate.state) {
        this._cycle.push(Validation.state);
      }
      if (this._extensions.onPreHandler.nodes) {
        this._cycle.push(this._extensions.onPreHandler);
      }
      this._cycle.push(Handler.execute);
      if (this._extensions.onPostHandler.nodes) {
        this._cycle.push(this._extensions.onPostHandler);
      }
      this._postCycle = [];
      if (this.settings.response._validate && this.settings.response.sample !== 0) {
        this._postCycle.push(Validation.response);
      }
      if (this._extensions.onPreResponse.nodes) {
        this._postCycle.push(this._extensions.onPreResponse);
      }
      this._buildMarshalCycle();
    }
    _buildMarshalCycle() {
      this._marshalCycle = [Headers.type];
      if (this.settings.cors) {
        this._marshalCycle.push(Cors.headers);
      }
      if (this.settings.security) {
        this._marshalCycle.push(Security.headers);
      }
      this._marshalCycle.push(Headers.entity);
      if (this.method === "get" || this.method === "*") {
        this._marshalCycle.push(Headers.unmodified);
      }
      this._marshalCycle.push(Headers.cache);
      this._marshalCycle.push(Headers.state);
      this._marshalCycle.push(Headers.content);
      if (this._core.auth._enabled(this, "response")) {
        this._marshalCycle.push(Auth.response);
      }
    }
    _assert(condition, message) {
      if (condition) {
        return;
      }
      if (this.method[0] !== "_") {
        message = `${message}: ${this.method.toUpperCase()} ${this.path}`;
      }
      throw new Assert.AssertionError({
        message,
        actual: false,
        expected: true,
        operator: "==",
        stackStartFunction: this._assert
      });
    }
  };
  internals.state = async function(request) {
    request.state = {};
    const req = request.raw.req;
    const cookies = req.headers.cookie;
    if (!cookies) {
      return;
    }
    try {
      var result = await request._core.states.parse(cookies);
    } catch (err) {
      Bounce.rethrow(err, "system");
      var parseError = err;
    }
    const { states, failed = [] } = result ?? parseError;
    request.state = states ?? {};
    for (const item of failed) {
      if (item.settings.clearInvalid) {
        request._clearState(item.name);
      }
    }
    if (!parseError) {
      return;
    }
    parseError.header = cookies;
    return request._core.toolkit.failAction(request, request.route.settings.state.failAction, parseError, { tags: ["state", "error"] });
  };
  internals.payload = async function(request) {
    if (request.method === "get" || request.method === "head") {
      return;
    }
    if (request.payload !== undefined) {
      return internals.drain(request);
    }
    if (request._expectContinue) {
      request._expectContinue = false;
      request.raw.res.writeContinue();
    }
    try {
      const { payload, mime } = await Subtext.parse(request.raw.req, request._tap(), request.route.settings.payload);
      request._isPayloadPending = !!payload?._readableState;
      request.mime = mime;
      request.payload = payload;
    } catch (err) {
      Bounce.rethrow(err, "system");
      await internals.drain(request);
      request.mime = err.mime;
      request.payload = null;
      return request._core.toolkit.failAction(request, request.route.settings.payload.failAction, err, { tags: ["payload", "error"] });
    }
  };
  internals.drain = async function(request) {
    if (request._expectContinue) {
      request._isPayloadPending = false;
      request._expectContinue = false;
    }
    if (request._isPayloadPending) {
      await Streams.drain(request.raw.req);
      request._isPayloadPending = false;
    }
  };
  internals.config = function(chain) {
    if (!chain.length) {
      return {};
    }
    let config = chain[0];
    for (const item of chain) {
      config = Hoek.applyToDefaults(config, item, { shallow: ["bind", "validate.headers", "validate.payload", "validate.params", "validate.query", "validate.state"] });
    }
    return config;
  };
  internals.rules = function(rules, info, server) {
    const configs = [];
    let realm = server.realm;
    while (realm) {
      if (realm._rules) {
        const source = !realm._rules.settings.validate ? rules : Validate.attempt(rules, realm._rules.settings.validate.schema, realm._rules.settings.validate.options);
        const config = realm._rules.processor(source, info);
        if (config) {
          configs.unshift(config);
        }
      }
      realm = realm.parent;
    }
    return internals.config(configs);
  };
});

// node_modules/@hapi/hapi/lib/cors.js
var require_cors = __commonJS((exports) => {
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var Route = null;
  var internals = {};
  exports.route = function(options) {
    if (!options) {
      return false;
    }
    const settings = Hoek.clone(options);
    settings._headers = settings.headers.concat(settings.additionalHeaders);
    settings._headersString = settings._headers.join(",");
    for (let i = 0;i < settings._headers.length; ++i) {
      settings._headers[i] = settings._headers[i].toLowerCase();
    }
    if (settings._headers.indexOf("origin") === -1) {
      settings._headers.push("origin");
    }
    settings._exposedHeaders = settings.exposedHeaders.concat(settings.additionalExposedHeaders).join(",");
    if (settings.origin === "ignore") {
      settings._origin = false;
    } else if (settings.origin.indexOf("*") !== -1) {
      Hoek.assert(settings.origin.length === 1, "Cannot specify cors.origin * together with other values");
      settings._origin = true;
    } else {
      settings._origin = {
        qualified: [],
        wildcards: []
      };
      for (const origin of settings.origin) {
        if (origin.indexOf("*") !== -1) {
          settings._origin.wildcards.push(new RegExp("^" + Hoek.escapeRegex(origin).replace(/\\\*/g, ".*").replace(/\\\?/g, ".") + "$"));
        } else {
          settings._origin.qualified.push(origin);
        }
      }
    }
    return settings;
  };
  exports.options = function(route, server) {
    if (route.method === "options" || !route.settings.cors) {
      return;
    }
    exports.handler(server);
  };
  exports.handler = function(server) {
    Route = Route || require_route();
    if (server._core.router.specials.options) {
      return;
    }
    const definition = {
      method: "_special",
      path: "/{p*}",
      handler: internals.handler,
      options: {
        cors: false
      }
    };
    const route = new Route(definition, server, { special: true });
    server._core.router.special("options", route);
  };
  internals.handler = function(request, h) {
    const method = request.headers["access-control-request-method"];
    if (!method) {
      throw Boom.notFound("CORS error: Missing Access-Control-Request-Method header");
    }
    const route = request.server.match(method, request.path, request.info.hostname);
    if (!route) {
      throw Boom.notFound();
    }
    const settings = route.settings.cors;
    if (!settings) {
      return { message: "CORS is disabled for this route" };
    }
    const origin = request.headers.origin;
    if (!origin && settings._origin !== false) {
      throw Boom.notFound("CORS error: Missing Origin header");
    }
    if (!exports.matchOrigin(origin, settings)) {
      return { message: "CORS error: Origin not allowed" };
    }
    let headers = request.headers["access-control-request-headers"];
    if (headers) {
      headers = headers.toLowerCase().split(/\s*,\s*/);
      if (Hoek.intersect(headers, settings._headers).length !== headers.length) {
        return { message: "CORS error: Some headers are not allowed" };
      }
    }
    const response = h.response();
    response.code(settings.preflightStatusCode);
    response._header("access-control-allow-origin", settings._origin ? origin : "*");
    response._header("access-control-allow-methods", method);
    response._header("access-control-allow-headers", settings._headersString);
    response._header("access-control-max-age", settings.maxAge);
    if (settings.credentials) {
      response._header("access-control-allow-credentials", "true");
    }
    if (settings._exposedHeaders) {
      response._header("access-control-expose-headers", settings._exposedHeaders);
    }
    return response;
  };
  exports.headers = function(response) {
    const request = response.request;
    const settings = request.route.settings.cors;
    if (settings._origin !== false) {
      response.vary("origin");
    }
    if (request.info.cors && !request.info.cors.isOriginMatch || !exports.matchOrigin(request.headers.origin, request.route.settings.cors)) {
      return;
    }
    response._header("access-control-allow-origin", settings._origin ? request.headers.origin : "*");
    if (settings.credentials) {
      response._header("access-control-allow-credentials", "true");
    }
    if (settings._exposedHeaders) {
      response._header("access-control-expose-headers", settings._exposedHeaders, { append: true });
    }
  };
  exports.matchOrigin = function(origin, settings) {
    if (settings._origin === true || settings._origin === false) {
      return true;
    }
    if (!origin) {
      return false;
    }
    if (settings._origin.qualified.indexOf(origin) !== -1) {
      return true;
    }
    for (const wildcard of settings._origin.wildcards) {
      if (origin.match(wildcard)) {
        return true;
      }
    }
    return false;
  };
});

// node_modules/@hapi/hapi/lib/toolkit.js
var require_toolkit = __commonJS((exports) => {
  var Boom = require_lib13();
  var Bounce = require_lib14();
  var Hoek = require_lib8();
  var internals = {};
  exports.reserved = [
    "abandon",
    "authenticated",
    "close",
    "context",
    "continue",
    "entity",
    "redirect",
    "realm",
    "request",
    "response",
    "state",
    "unauthenticated",
    "unstate"
  ];
  exports.symbols = {
    abandon: Symbol("abandon"),
    close: Symbol("close"),
    continue: Symbol("continue")
  };
  exports.Manager = class {
    constructor() {
      this._toolkit = internals.toolkit();
    }
    async execute(method, request, options) {
      const h = new this._toolkit(request, options);
      const bind = options.bind ?? null;
      try {
        let operation;
        if (bind) {
          operation = method.call(bind, request, h);
        } else if (options.args) {
          operation = method(request, h, ...options.args);
        } else {
          operation = method(request, h);
        }
        var response = await exports.timed(operation, options);
      } catch (err) {
        if (Bounce.isSystem(err)) {
          response = Boom.badImplementation(err);
        } else if (!Bounce.isError(err)) {
          response = Boom.badImplementation("Cannot throw non-error object", err);
        } else {
          response = Boom.boomify(err);
        }
      }
      if (options.ignoreResponse) {
        return response;
      }
      if (response === undefined) {
        response = Boom.badImplementation(`${method.name} method did not return a value, a promise, or throw an error`);
      }
      if (options.continue && response === exports.symbols.continue) {
        if (options.continue === "undefined") {
          return;
        }
        response = null;
      }
      if (options.auth && response instanceof internals.Auth) {
        return response;
      }
      if (typeof response !== "symbol") {
        response = request._core.Response.wrap(response, request);
        if (!response.isBoom && response._state === "init") {
          await response._prepare();
        }
      }
      return response;
    }
    decorate(name, method) {
      this._toolkit.prototype[name] = method;
    }
    async failAction(request, failAction, err, options) {
      const retain = options.retain ? err : undefined;
      if (failAction === "ignore") {
        return retain;
      }
      if (failAction === "log") {
        request._log(options.tags, err);
        return retain;
      }
      if (failAction === "error") {
        throw err;
      }
      return await this.execute(failAction, request, { realm: request.route.realm, args: [options.details ?? err] });
    }
  };
  exports.timed = async function(method, options) {
    if (!options.timeout) {
      return method;
    }
    const timer = new Promise((resolve, reject) => {
      const handler = () => {
        reject(Boom.internal(`${options.name} timed out`));
      };
      setTimeout(handler, options.timeout);
    });
    return await Promise.race([timer, method]);
  };
  internals.toolkit = function() {
    const Toolkit = class {
      constructor(request, options) {
        this.context = options.bind;
        this.realm = options.realm;
        this.request = request;
        this._auth = options.auth;
      }
      response(result) {
        Hoek.assert(!result || typeof result !== "object" || typeof result.then !== "function", "Cannot wrap a promise");
        Hoek.assert(result instanceof Error === false, "Cannot wrap an error");
        Hoek.assert(typeof result !== "symbol", "Cannot wrap a symbol");
        return this.request._core.Response.wrap(result, this.request);
      }
      redirect(location) {
        return this.response("").redirect(location);
      }
      entity(options) {
        Hoek.assert(options, "Entity method missing required options");
        Hoek.assert(options.etag || options.modified, "Entity methods missing required options key");
        this.request._entity = options;
        const entity = this.request._core.Response.entity(options.etag, options);
        if (this.request._core.Response.unmodified(this.request, entity)) {
          return this.response().code(304).takeover();
        }
      }
      state(name, value, options) {
        this.request._setState(name, value, options);
      }
      unstate(name, options) {
        this.request._clearState(name, options);
      }
      authenticated(data) {
        Hoek.assert(this._auth, "Method not supported outside of authentication");
        Hoek.assert(data?.credentials, "Authentication data missing credentials information");
        return new internals.Auth(null, data);
      }
      unauthenticated(error, data) {
        Hoek.assert(this._auth, "Method not supported outside of authentication");
        Hoek.assert(!data || data.credentials, "Authentication data missing credentials information");
        return new internals.Auth(error, data);
      }
    };
    Toolkit.prototype.abandon = exports.symbols.abandon;
    Toolkit.prototype.close = exports.symbols.close;
    Toolkit.prototype.continue = exports.symbols.continue;
    return Toolkit;
  };
  internals.Auth = class {
    constructor(error, data) {
      this.isAuth = true;
      this.error = error;
      this.data = data;
    }
  };
});

// node_modules/@hapi/ammo/lib/index.js
var require_lib34 = __commonJS((exports) => {
  var Stream = __require("stream");
  var Hoek = require_lib8();
  var internals = {};
  internals.headerRx = /^bytes=[\s,]*((?:(?:\d+\-\d*)|(?:\-\d+))(?:\s*,\s*(?:(?:\d+\-\d*)|(?:\-\d+)))*)$/i;
  exports.header = function(header, length) {
    const parts = internals.headerRx.exec(header);
    if (!parts) {
      return null;
    }
    const lastPos = length - 1;
    const result = [];
    const ranges = parts[1].match(/\d*\-\d*/g);
    for (let range of ranges) {
      let from;
      let to;
      range = range.split("-");
      if (range[0]) {
        from = parseInt(range[0], 10);
      }
      if (range[1]) {
        to = parseInt(range[1], 10);
        if (from !== undefined) {
          if (to > lastPos) {
            to = lastPos;
          }
        } else {
          from = length - to;
          to = lastPos;
        }
      } else {
        to = lastPos;
      }
      if (from > to) {
        return null;
      }
      result.push(new internals.Range(from, to));
    }
    if (result.length === 1) {
      return result;
    }
    result.sort((a, b) => a.from - b.from);
    const consolidated = [];
    for (let i = result.length - 1;i > 0; --i) {
      const current = result[i];
      const before = result[i - 1];
      if (current.from <= before.to + 1) {
        before.to = current.to;
      } else {
        consolidated.unshift(current);
      }
    }
    consolidated.unshift(result[0]);
    return consolidated;
  };
  internals.Range = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  exports.Clip = class extends Stream.Transform {
    constructor(range) {
      if (!(range instanceof internals.Range)) {
        Hoek.assert(typeof range === "object", 'Expected "range" object');
        const from = range.from ?? 0;
        Hoek.assert(typeof from === "number", '"range.from" must be a number');
        Hoek.assert(from === parseInt(from, 10) && from >= 0, '"range.from" must be a positive integer');
        const to = range.to ?? 0;
        Hoek.assert(typeof to === "number", '"range.to" must be a number');
        Hoek.assert(to === parseInt(to, 10) && to >= 0, '"range.to" must be a positive integer');
        Hoek.assert(to >= from, '"range.to" must be greater than or equal to "range.from"');
        range = new internals.Range(from, to);
      }
      super();
      this._range = range;
      this._next = 0;
      this._pipes = new Set;
      this.on("pipe", (pipe) => this._pipes.add(pipe));
      this.on("unpipe", (pipe) => this._pipes.delete(pipe));
    }
    _transform(chunk, encoding, done) {
      try {
        internals.processChunk(this, chunk);
      } catch (err) {
        return done(err);
      }
      return done();
    }
    _flush(done) {
      this._pipes.clear();
      done();
    }
  };
  internals.processChunk = function(stream, chunk) {
    const pos = stream._next;
    stream._next = stream._next + chunk.length;
    if (stream._next <= stream._range.from) {
      return;
    }
    if (pos > stream._range.to) {
      for (const pipe of stream._pipes) {
        pipe.unpipe(stream);
      }
      stream._pipes.clear();
      stream.end();
      return;
    }
    const from = Math.max(0, stream._range.from - pos);
    const to = Math.min(chunk.length, stream._range.to - pos + 1);
    stream.push(chunk.slice(from, to));
  };
});

// node_modules/@hapi/hapi/lib/transmit.js
var require_transmit = __commonJS((exports) => {
  var Http = __require("http");
  var Ammo = require_lib34();
  var Boom = require_lib13();
  var Bounce = require_lib14();
  var Hoek = require_lib8();
  var Teamwork = require_lib12();
  var Config2 = require_config();
  var internals = {};
  exports.send = async function(request) {
    const response = request.response;
    try {
      if (response.isBoom) {
        await internals.fail(request, response);
        return;
      }
      await internals.marshal(response);
      await internals.transmit(response);
    } catch (err) {
      Bounce.rethrow(err, "system");
      request._setResponse(err);
      return internals.fail(request, err);
    }
  };
  internals.marshal = async function(response) {
    for (const func of response.request._route._marshalCycle) {
      await func(response);
    }
  };
  internals.fail = async function(request, boom) {
    const response = internals.error(request, boom);
    request.response = response;
    try {
      await internals.marshal(response);
    } catch (err) {
      Bounce.rethrow(err, "system");
      const minimal = {
        statusCode: response.statusCode,
        error: Http.STATUS_CODES[response.statusCode],
        message: boom.message
      };
      response._payload = new request._core.Response.Payload(JSON.stringify(minimal), {});
    }
    return internals.transmit(response);
  };
  internals.error = function(request, boom) {
    const error = boom.output;
    const response = new request._core.Response(error.payload, request, { error: boom });
    response.code(error.statusCode);
    response.headers = Hoek.clone(error.headers);
    return response;
  };
  internals.transmit = function(response) {
    const request = response.request;
    const length = internals.length(response);
    const encoding = request._core.compression.encoding(response, length);
    const ranger = encoding ? null : internals.range(response, length);
    const compressor = internals.encoding(response, encoding);
    const isInjection = request.isInjected;
    if (!(isInjection || request._core.started) || request._isPayloadPending && !request.raw.req._readableState.ended) {
      response._header("connection", "close");
    }
    internals.writeHead(response);
    if (isInjection) {
      request.raw.res[Config2.symbol] = { request };
      if (response.variety === "plain") {
        request.raw.res[Config2.symbol].result = response._isPayloadSupported() ? response.source : null;
      }
    }
    const stream = internals.chain([response._payload, response._tap(), compressor, ranger]);
    return internals.pipe(request, stream);
  };
  internals.length = function(response) {
    const request = response.request;
    const header = response.headers["content-length"];
    if (header === undefined) {
      return null;
    }
    let length = header;
    if (typeof length === "string") {
      length = parseInt(header, 10);
      if (!isFinite(length)) {
        delete response.headers["content-length"];
        return null;
      }
    }
    if (length === 0 && !response._statusCode && response.statusCode === 200 && request.route.settings.response.emptyStatusCode !== 200) {
      response.code(204);
      delete response.headers["content-length"];
    }
    return length;
  };
  internals.range = function(response, length) {
    const request = response.request;
    if (!length || !request.route.settings.response.ranges || request.method !== "get" || response.statusCode !== 200) {
      return null;
    }
    response._header("accept-ranges", "bytes");
    if (!request.headers.range) {
      return null;
    }
    if (request.headers["if-range"] && request.headers["if-range"] !== response.headers.etag) {
      return null;
    }
    const ranges = Ammo.header(request.headers.range, length);
    if (!ranges) {
      const error = Boom.rangeNotSatisfiable();
      error.output.headers["content-range"] = "bytes */" + length;
      throw error;
    }
    if (ranges.length !== 1) {
      return null;
    }
    const range = ranges[0];
    response.code(206);
    response.bytes(range.to - range.from + 1);
    response._header("content-range", "bytes " + range.from + "-" + range.to + "/" + length);
    return new Ammo.Clip(range);
  };
  internals.encoding = function(response, encoding) {
    const request = response.request;
    const header = response.headers["content-encoding"] || encoding;
    if (header && response.headers.etag && response.settings.varyEtag) {
      response.headers.etag = response.headers.etag.slice(0, -1) + "-" + header + '"';
    }
    if (!encoding || response.statusCode === 206 || !response._isPayloadSupported()) {
      return null;
    }
    delete response.headers["content-length"];
    response._header("content-encoding", encoding);
    const compressor = request._core.compression.encoder(request, encoding);
    if (response.variety === "stream" && typeof response._payload.setCompressor === "function") {
      response._payload.setCompressor(compressor);
    }
    return compressor;
  };
  internals.pipe = function(request, stream) {
    const team = new Teamwork.Team;
    const env2 = { stream, request, team };
    if (request._closed) {
      internals.end(env2, "aborted");
      return team.work;
    }
    const aborted = internals.end.bind(null, env2, "aborted");
    const close = internals.end.bind(null, env2, "close");
    const end = internals.end.bind(null, env2, null);
    request.raw.req.on("aborted", aborted);
    request.raw.res.on("close", close);
    request.raw.res.on("error", end);
    request.raw.res.on("finish", end);
    if (stream.writeToStream) {
      stream.writeToStream(request.raw.res);
    } else {
      stream.on("error", end);
      stream.pipe(request.raw.res);
    }
    return team.work;
  };
  internals.end = function(env2, event, err) {
    const { request, stream, team } = env2;
    if (!team) {
      return;
    }
    env2.team = null;
    if (request.raw.res.writableEnded) {
      request.info.responded = Date.now();
      team.attend();
      return;
    }
    if (err) {
      request.raw.res.destroy();
      request._core.Response.drain(stream);
    }
    const origResponse = request.response;
    const error = err ? Boom.boomify(err) : new Boom.Boom(`Request ${event}`, { statusCode: request.route.settings.response.disconnectStatusCode, data: origResponse });
    request._setResponse(error);
    if (request.raw.res[Config2.symbol]) {
      request.raw.res[Config2.symbol].error = event ? error : new Boom.Boom(`Response error`, { statusCode: request.route.settings.response.disconnectStatusCode, data: origResponse });
    }
    if (event) {
      request._log(["response", "error", event]);
    } else {
      request._log(["response", "error"], err);
    }
    request.raw.res.end();
    team.attend();
  };
  internals.writeHead = function(response) {
    const res = response.request.raw.res;
    const headers = Object.keys(response.headers);
    let i = 0;
    try {
      for (;i < headers.length; ++i) {
        const header = headers[i];
        const value = response.headers[header];
        if (value !== undefined) {
          res.setHeader(header, value);
        }
      }
    } catch (err) {
      for (--i;i >= 0; --i) {
        res.removeHeader(headers[i]);
      }
      throw Boom.boomify(err);
    }
    if (response.settings.message) {
      res.statusMessage = response.settings.message;
    }
    try {
      res.writeHead(response.statusCode);
    } catch (err) {
      throw Boom.boomify(err);
    }
  };
  internals.chain = function(sources) {
    let from = sources[0];
    for (let i = 1;i < sources.length; ++i) {
      const to = sources[i];
      if (to) {
        from.on("error", internals.errorPipe.bind(from, to));
        from = from.pipe(to);
      }
    }
    return from;
  };
  internals.errorPipe = function(to, err) {
    to.emit("error", err);
  };
});

// node_modules/@hapi/hapi/lib/request.js
var require_request2 = __commonJS((exports, module) => {
  var Querystring = __require("querystring");
  var Url = __require("url");
  var Boom = require_lib13();
  var Bounce = require_lib14();
  var Hoek = require_lib8();
  var Podium = require_lib17();
  var Cors = require_cors();
  var Toolkit = require_toolkit();
  var Transmit = require_transmit();
  var internals = {
    events: Podium.validate(["finish", { name: "peek", spread: true }, "disconnect"]),
    reserved: ["server", "url", "query", "path", "method", "mime", "setUrl", "setMethod", "headers", "id", "app", "plugins", "route", "auth", "pre", "preResponses", "info", "isInjected", "orig", "params", "paramsArray", "payload", "state", "response", "raw", "domain", "log", "logs", "generateResponse"]
  };
  exports = module.exports = internals.Request = class {
    constructor(server, req, res, options) {
      this._allowInternals = !!options.allowInternals;
      this._closed = false;
      this._core = server._core;
      this._entity = null;
      this._eventContext = { request: this };
      this._events = null;
      this._expectContinue = !!options.expectContinue;
      this._isInjected = !!options.isInjected;
      this._isPayloadPending = !!(req.headers["content-length"] || req.headers["transfer-encoding"]);
      this._isReplied = false;
      this._route = this._core.router.specials.notFound.route;
      this._serverTimeoutId = null;
      this._states = {};
      this._url = null;
      this._urlError = null;
      this.app = options.app ? Object.assign({}, options.app) : {};
      this.headers = req.headers;
      this.logs = [];
      this.method = req.method.toLowerCase();
      this.mime = null;
      this.orig = {};
      this.params = null;
      this.paramsArray = null;
      this.path = null;
      this.payload = undefined;
      this.plugins = options.plugins ? Object.assign({}, options.plugins) : {};
      this.pre = {};
      this.preResponses = {};
      this.raw = { req, res };
      this.response = null;
      this.route = this._route.public;
      this.query = null;
      this.server = server;
      this.state = null;
      this.info = new internals.Info(this);
      this.auth = {
        isAuthenticated: false,
        isAuthorized: false,
        isInjected: options.auth ? true : false,
        [internals.Request.symbols.authPayload]: options.auth?.payload ?? true,
        credentials: options.auth?.credentials ?? null,
        artifacts: options.auth?.artifacts ?? null,
        strategy: options.auth?.strategy ?? null,
        mode: null,
        error: null
      };
      this._initializeUrl();
    }
    static generate(server, req, res, options) {
      const request = new server._core.Request(server, req, res, options);
      if (server._core.decorations.requestApply) {
        for (const [property, assignment] of server._core.decorations.requestApply.entries()) {
          request[property] = assignment(request);
        }
      }
      request._listen();
      return request;
    }
    get events() {
      if (!this._events) {
        this._events = new Podium.Podium(internals.events);
      }
      return this._events;
    }
    get isInjected() {
      return this._isInjected;
    }
    get url() {
      if (this._urlError) {
        return null;
      }
      if (this._url) {
        return this._url;
      }
      return this._parseUrl(this.raw.req.url, this._core.settings.router);
    }
    _initializeUrl() {
      try {
        this._setUrl(this.raw.req.url, this._core.settings.router.stripTrailingSlash, { fast: true });
      } catch (err) {
        this.path = this.raw.req.url;
        this.query = {};
        this._urlError = Boom.boomify(err, { statusCode: 400, override: false });
      }
    }
    setUrl(url, stripTrailingSlash) {
      Hoek.assert(this.params === null, "Cannot change request URL after routing");
      if (url instanceof Url.URL) {
        url = url.href;
      }
      Hoek.assert(typeof url === "string", "Url must be a string or URL object");
      this._setUrl(url, stripTrailingSlash, { fast: false });
    }
    _setUrl(source, stripTrailingSlash, { fast }) {
      const url = this._parseUrl(source, { stripTrailingSlash, _fast: fast });
      this.query = this._parseQuery(url.searchParams);
      this.path = url.pathname;
    }
    _parseUrl(source, options) {
      if (source[0] === "/") {
        if (options._fast) {
          const url = {
            pathname: source,
            searchParams: ""
          };
          const q = source.indexOf("?");
          const h = source.indexOf("#");
          if (q !== -1 && (h === -1 || q < h)) {
            url.pathname = source.slice(0, q);
            const query = h === -1 ? source.slice(q + 1) : source.slice(q + 1, h);
            url.searchParams = Querystring.parse(query);
          } else {
            url.pathname = h === -1 ? source : source.slice(0, h);
          }
          this._normalizePath(url, options);
          return url;
        }
        this._url = new Url.URL(`${this._core.info.protocol}://${this.info.host || `${this._core.info.host}:${this._core.info.port}`}${source}`);
      } else {
        this._url = new Url.URL(source);
        this.info.hostname = this._url.hostname;
        this.info.host = this._url.host;
      }
      this._normalizePath(this._url, options);
      this._urlError = null;
      return this._url;
    }
    _normalizePath(url, options) {
      let path2 = this._core.router.normalize(url.pathname);
      if (options.stripTrailingSlash && path2.length > 1 && path2[path2.length - 1] === "/") {
        path2 = path2.slice(0, -1);
      }
      url.pathname = path2;
    }
    _parseQuery(searchParams) {
      let query = Object.create(null);
      if (searchParams instanceof Url.URLSearchParams) {
        for (let [key, value] of searchParams) {
          const entry = query[key];
          if (entry !== undefined) {
            value = [].concat(entry, value);
          }
          query[key] = value;
        }
      } else {
        query = Object.assign(query, searchParams);
      }
      const parser = this._core.settings.query.parser;
      if (parser) {
        query = parser(query);
        if (!query || typeof query !== "object") {
          throw Boom.badImplementation("Parsed query must be an object");
        }
      }
      return query;
    }
    setMethod(method) {
      Hoek.assert(this.params === null, "Cannot change request method after routing");
      Hoek.assert(method && typeof method === "string", "Missing method");
      this.method = method.toLowerCase();
    }
    active() {
      return !!this._eventContext.request;
    }
    async _execute() {
      this.info.acceptEncoding = this._core.compression.accept(this);
      try {
        await this._onRequest();
      } catch (err) {
        Bounce.rethrow(err, "system");
        return this._reply(err);
      }
      this._lookup();
      this._setTimeouts();
      await this._lifecycle();
      this._reply();
    }
    async _onRequest() {
      if (this._core.extensions.route.onRequest.nodes) {
        const response = await this._invoke(this._core.extensions.route.onRequest);
        if (response) {
          if (!internals.skip(response)) {
            throw Boom.badImplementation("onRequest extension methods must return an error, a takeover response, or a continue signal");
          }
          throw response;
        }
      }
      if (this._urlError) {
        throw this._urlError;
      }
    }
    _listen() {
      if (this._isPayloadPending) {
        this.raw.req.on("end", internals.event.bind(this.raw.req, this._eventContext, "end"));
      }
      this.raw.res.on("close", internals.event.bind(this.raw.res, this._eventContext, "close"));
      this.raw.req.on("error", internals.event.bind(this.raw.req, this._eventContext, "error"));
      this.raw.req.on("aborted", internals.event.bind(this.raw.req, this._eventContext, "abort"));
      this.raw.res.once("close", internals.closed.bind(this.raw.res, this));
    }
    _lookup() {
      const match = this._core.router.route(this.method, this.path, this.info.hostname);
      if (!match.route.settings.isInternal || this._allowInternals) {
        this._route = match.route;
        this.route = this._route.public;
      }
      this.params = match.params ?? {};
      this.paramsArray = match.paramsArray ?? [];
      if (this.route.settings.cors) {
        this.info.cors = {
          isOriginMatch: Cors.matchOrigin(this.headers.origin, this.route.settings.cors)
        };
      }
    }
    _setTimeouts() {
      if (this.raw.req.socket && this.route.settings.timeout.socket !== undefined) {
        this.raw.req.socket.setTimeout(this.route.settings.timeout.socket || 0);
      }
      let serverTimeout = this.route.settings.timeout.server;
      if (!serverTimeout) {
        return;
      }
      const elapsed = Date.now() - this.info.received;
      serverTimeout = Math.floor(serverTimeout - elapsed);
      if (serverTimeout <= 0) {
        internals.timeoutReply(this, serverTimeout);
        return;
      }
      this._serverTimeoutId = setTimeout(internals.timeoutReply, serverTimeout, this, serverTimeout);
    }
    async _lifecycle() {
      for (const func of this._route._cycle) {
        if (this._isReplied) {
          return;
        }
        try {
          var response = await (typeof func === "function" ? func(this) : this._invoke(func));
        } catch (err) {
          Bounce.rethrow(err, "system");
          response = this._core.Response.wrap(err, this);
        }
        if (!response || response === Toolkit.symbols.continue) {
          continue;
        }
        if (!internals.skip(response)) {
          response = Boom.badImplementation("Lifecycle methods called before the handler can only return an error, a takeover response, or a continue signal");
        }
        this._setResponse(response);
        return;
      }
    }
    async _invoke(event, options = {}) {
      for (const ext of event.nodes) {
        const realm = ext.realm;
        const bind = ext.bind ?? realm.settings.bind;
        const response = await this._core.toolkit.execute(ext.func, this, { bind, realm, timeout: ext.timeout, name: event.type, ignoreResponse: options.ignoreResponse });
        if (options.ignoreResponse) {
          if (Boom.isBoom(response)) {
            this._log(["ext", "error"], response);
          }
          continue;
        }
        if (response === Toolkit.symbols.continue) {
          continue;
        }
        if (internals.skip(response) || this.response === null) {
          return response;
        }
        this._setResponse(response);
      }
    }
    async _reply(exit) {
      if (this._isReplied) {
        return;
      }
      this._isReplied = true;
      if (this._serverTimeoutId) {
        clearTimeout(this._serverTimeoutId);
      }
      if (exit) {
        this._setResponse(this._core.Response.wrap(exit, this));
      }
      if (!this._eventContext.request) {
        this._finalize();
        return;
      }
      if (typeof this.response === "symbol") {
        this._abort();
        return;
      }
      await this._postCycle();
      if (!this._eventContext.request || typeof this.response === "symbol") {
        this._abort();
        return;
      }
      await Transmit.send(this);
      this._finalize();
    }
    async _postCycle() {
      for (const func of this._route._postCycle) {
        if (!this._eventContext.request) {
          return;
        }
        try {
          var response = await (typeof func === "function" ? func(this) : this._invoke(func));
        } catch (err) {
          Bounce.rethrow(err, "system");
          response = this._core.Response.wrap(err, this);
        }
        if (response && response !== Toolkit.symbols.continue) {
          this._setResponse(response);
        }
      }
    }
    _abort() {
      if (this.response === Toolkit.symbols.close) {
        this.raw.res.end();
      }
      this._finalize();
    }
    _finalize() {
      this._eventContext.request = null;
      if (this.response._close) {
        if (this.response.statusCode === 500 && this.response._error) {
          const tags = this.response._error.isDeveloperError ? ["internal", "implementation", "error"] : ["internal", "error"];
          this._log(tags, this.response._error, "error");
        }
        this.response._close();
      }
      this.info.completed = Date.now();
      this._core.events.emit("response", this);
      if (this._route._extensions.onPostResponse.nodes) {
        this._invoke(this._route._extensions.onPostResponse, { ignoreResponse: true });
      }
    }
    _setResponse(response) {
      if (this.response && !this.response.isBoom && this.response !== response && this.response.source !== response.source) {
        this.response._close?.();
      }
      if (this.info.completed) {
        response._close?.();
        return;
      }
      this.response = response;
    }
    _setState(name, value, options) {
      const state = { name, value };
      if (options) {
        Hoek.assert(!options.autoValue, "Cannot set autoValue directly in a response");
        state.options = Hoek.clone(options);
      }
      this._states[name] = state;
    }
    _clearState(name, options = {}) {
      const state = { name };
      state.options = Hoek.clone(options);
      state.options.ttl = 0;
      this._states[name] = state;
    }
    _tap() {
      if (!this._events) {
        return null;
      }
      if (this._events.hasListeners("peek") || this._events.hasListeners("finish")) {
        return new this._core.Response.Peek(this._events);
      }
      return null;
    }
    log(tags, data) {
      return this._log(tags, data, "app");
    }
    _log(tags, data, channel = "internal") {
      if (!this._core.events.hasListeners("request") && !this.route.settings.log.collect) {
        return;
      }
      if (!Array.isArray(tags)) {
        tags = [tags];
      }
      const timestamp = Date.now();
      const field = data instanceof Error ? "error" : "data";
      let event = [this, { request: this.info.id, timestamp, tags, [field]: data, channel }];
      if (typeof data === "function") {
        event = () => [this, { request: this.info.id, timestamp, tags, data: data(), channel }];
      }
      if (this.route.settings.log.collect) {
        if (typeof data === "function") {
          event = event();
        }
        this.logs.push(event[1]);
      }
      this._core.events.emit({ name: "request", channel, tags }, event);
    }
    generateResponse(source, options) {
      return new this._core.Response(source, this, options);
    }
  };
  internals.Request.reserved = internals.reserved;
  internals.Request.symbols = {
    authPayload: Symbol("auth.payload")
  };
  internals.Info = class {
    constructor(request) {
      this._request = request;
      const req = request.raw.req;
      const host = req.headers.host ? req.headers.host.trim() : "";
      const received = Date.now();
      this.received = received;
      this.referrer = req.headers.referrer || req.headers.referer || "";
      this.host = host;
      this.hostname = host.split(":")[0];
      this.id = `${received}:${request._core.info.id}:${request._core._counter()}`;
      this._remoteAddress = null;
      this._remotePort = null;
      this.acceptEncoding = null;
      this.cors = null;
      this.responded = 0;
      this.completed = 0;
      if (request._core.settings.info.remote) {
        this.remoteAddress;
        this.remotePort;
      }
    }
    get remoteAddress() {
      if (!this._remoteAddress) {
        const ipv6Prefix = "::ffff:";
        const socketAddress = this._request.raw.req.socket.remoteAddress;
        if (socketAddress && socketAddress.startsWith(ipv6Prefix) && socketAddress.includes(".", ipv6Prefix.length)) {
          this._remoteAddress = socketAddress.slice(ipv6Prefix.length);
        } else {
          this._remoteAddress = socketAddress;
        }
      }
      return this._remoteAddress;
    }
    get remotePort() {
      if (this._remotePort === null) {
        this._remotePort = this._request.raw.req.socket.remotePort || "";
      }
      return this._remotePort;
    }
    toJSON() {
      return {
        acceptEncoding: this.acceptEncoding,
        completed: this.completed,
        cors: this.cors,
        host: this.host,
        hostname: this.hostname,
        id: this.id,
        received: this.received,
        referrer: this.referrer,
        remoteAddress: this.remoteAddress,
        remotePort: this.remotePort,
        responded: this.responded
      };
    }
  };
  internals.closed = function(request) {
    request._closed = true;
  };
  internals.event = function({ request }, event, err) {
    if (!request) {
      return;
    }
    request._isPayloadPending = false;
    if (event === "close" && request.raw.res.writableEnded) {
      return;
    }
    if (event === "end") {
      return;
    }
    request._log(err ? ["request", "error"] : ["request", "error", event], err);
    if (event === "error") {
      return;
    }
    request._eventContext.request = null;
    if (event === "abort") {
      request._reply(new Boom.Boom("Request aborted", { statusCode: request.route.settings.response.disconnectStatusCode, data: request.response }));
      if (request._events) {
        request._events.emit("disconnect");
      }
    }
  };
  internals.timeoutReply = function(request, timeout) {
    const elapsed = Date.now() - request.info.received;
    request._log(["request", "server", "timeout", "error"], { timeout, elapsed });
    request._reply(Boom.serverUnavailable());
  };
  internals.skip = function(response) {
    return response.isBoom || response._takeover || typeof response === "symbol";
  };
});

// node_modules/@hapi/hapi/lib/auth.js
var require_auth = __commonJS((exports, module) => {
  var Boom = require_lib13();
  var Bounce = require_lib14();
  var Hoek = require_lib8();
  var Config2 = require_config();
  var Request = require_request2();
  var internals = {
    missing: Symbol("missing")
  };
  exports = module.exports = internals.Auth = class {
    #core = null;
    #schemes = {};
    #strategies = {};
    api = {};
    settings = {
      default: null
    };
    constructor(core) {
      this.#core = core;
    }
    public(server) {
      return {
        api: this.api,
        settings: this.settings,
        scheme: this.scheme.bind(this),
        strategy: this._strategy.bind(this, server),
        default: this.default.bind(this),
        test: this.test.bind(this),
        verify: this.verify.bind(this),
        lookup: this.lookup.bind(this)
      };
    }
    scheme(name, scheme) {
      Hoek.assert(name, "Authentication scheme must have a name");
      Hoek.assert(!this.#schemes[name], "Authentication scheme name already exists:", name);
      Hoek.assert(typeof scheme === "function", "scheme must be a function:", name);
      this.#schemes[name] = scheme;
    }
    _strategy(server, name, scheme, options = {}) {
      Hoek.assert(name, "Authentication strategy must have a name");
      Hoek.assert(typeof options === "object", "options must be an object");
      Hoek.assert(!this.#strategies[name], "Authentication strategy name already exists");
      Hoek.assert(scheme, "Authentication strategy", name, "missing scheme");
      Hoek.assert(this.#schemes[scheme], "Authentication strategy", name, "uses unknown scheme:", scheme);
      server = server._clone();
      const strategy = this.#schemes[scheme](server, options);
      Hoek.assert(strategy.authenticate, "Invalid scheme:", name, "missing authenticate() method");
      Hoek.assert(typeof strategy.authenticate === "function", "Invalid scheme:", name, "invalid authenticate() method");
      Hoek.assert(!strategy.payload || typeof strategy.payload === "function", "Invalid scheme:", name, "invalid payload() method");
      Hoek.assert(!strategy.response || typeof strategy.response === "function", "Invalid scheme:", name, "invalid response() method");
      strategy.options = strategy.options ?? {};
      Hoek.assert(strategy.payload || !strategy.options.payload, "Cannot require payload validation without a payload method");
      this.#strategies[name] = {
        methods: strategy,
        realm: server.realm
      };
      if (strategy.api) {
        this.api[name] = strategy.api;
      }
    }
    default(options) {
      Hoek.assert(!this.settings.default, "Cannot set default strategy more than once");
      options = Config2.apply("auth", options, "default strategy");
      this.settings.default = this._setupRoute(Hoek.clone(options));
      const routes = this.#core.router.table();
      for (const route of routes) {
        route.rebuild();
      }
    }
    async test(name, request) {
      Hoek.assert(name, "Missing authentication strategy name");
      const strategy = this.#strategies[name];
      Hoek.assert(strategy, "Unknown authentication strategy:", name);
      const bind = strategy.methods;
      const realm = strategy.realm;
      const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });
      if (!response.isAuth) {
        throw response;
      }
      if (response.error) {
        throw response.error;
      }
      return response.data;
    }
    async verify(request) {
      const auth = request.auth;
      if (auth.error) {
        throw auth.error;
      }
      if (!auth.isAuthenticated) {
        return;
      }
      const strategy = this.#strategies[auth.strategy];
      Hoek.assert(strategy, "Unknown authentication strategy:", auth.strategy);
      if (!strategy.methods.verify) {
        return;
      }
      const bind = strategy.methods;
      await strategy.methods.verify.call(bind, auth);
    }
    static testAccess(request, route) {
      const auth = request._core.auth;
      try {
        return auth._access(request, route);
      } catch (err) {
        Bounce.rethrow(err, "system");
        return false;
      }
    }
    _setupRoute(options, path2) {
      if (!options) {
        return options;
      }
      if (typeof options === "string") {
        options = { strategies: [options] };
      } else if (options.strategy) {
        options.strategies = [options.strategy];
        delete options.strategy;
      }
      if (path2 && !options.strategies) {
        Hoek.assert(this.settings.default, "Route missing authentication strategy and no default defined:", path2);
        options = Hoek.applyToDefaults(this.settings.default, options);
      }
      path2 = path2 ?? "default strategy";
      Hoek.assert(options.strategies?.length, "Missing authentication strategy:", path2);
      options.mode = options.mode ?? "required";
      if (options.entity !== undefined || options.scope !== undefined) {
        options.access = [{ entity: options.entity, scope: options.scope }];
        delete options.entity;
        delete options.scope;
      }
      if (options.access) {
        for (const access of options.access) {
          access.scope = internals.setupScope(access);
        }
      }
      if (options.payload === true) {
        options.payload = "required";
      }
      let hasAuthenticatePayload = false;
      for (const name of options.strategies) {
        const strategy = this.#strategies[name];
        Hoek.assert(strategy, "Unknown authentication strategy", name, "in", path2);
        Hoek.assert(strategy.methods.payload || options.payload !== "required", "Payload validation can only be required when all strategies support it in", path2);
        hasAuthenticatePayload = hasAuthenticatePayload || strategy.methods.payload;
        Hoek.assert(!strategy.methods.options.payload || options.payload === undefined || options.payload === "required", "Cannot set authentication payload to", options.payload, "when a strategy requires payload validation in", path2);
      }
      Hoek.assert(!options.payload || hasAuthenticatePayload, "Payload authentication requires at least one strategy with payload support in", path2);
      return options;
    }
    lookup(route) {
      if (route.settings.auth === false) {
        return false;
      }
      return route.settings.auth || this.settings.default;
    }
    _enabled(route, type) {
      const config = this.lookup(route);
      if (!config) {
        return false;
      }
      if (type === "authenticate") {
        return true;
      }
      if (type === "access") {
        return !!config.access;
      }
      for (const name of config.strategies) {
        const strategy = this.#strategies[name];
        if (strategy.methods[type]) {
          return true;
        }
      }
      return false;
    }
    static authenticate(request) {
      const auth = request._core.auth;
      return auth._authenticate(request);
    }
    async _authenticate(request) {
      const config = this.lookup(request.route);
      const errors = [];
      request.auth.mode = config.mode;
      if (request.auth.credentials) {
        internals.validate(null, { credentials: request.auth.credentials, artifacts: request.auth.artifacts }, request.auth.strategy, config, request, errors);
        return;
      }
      for (const name of config.strategies) {
        const strategy = this.#strategies[name];
        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });
        const message = response.isAuth ? internals.validate(response.error, response.data, name, config, request, errors) : internals.validate(response, null, name, config, request, errors);
        if (!message) {
          return;
        }
        if (message !== internals.missing) {
          return message;
        }
      }
      const err = Boom.unauthorized("Missing authentication", errors);
      if (config.mode === "required") {
        throw err;
      }
      request.auth.isAuthenticated = false;
      request.auth.credentials = null;
      request.auth.error = err;
      request._log(["auth", "unauthenticated"]);
    }
    static access(request) {
      const auth = request._core.auth;
      request.auth.isAuthorized = auth._access(request);
    }
    _access(request, route) {
      const config = this.lookup(route || request.route);
      if (!config?.access) {
        return true;
      }
      const credentials = request.auth.credentials;
      if (!credentials) {
        if (config.mode !== "required") {
          return false;
        }
        throw Boom.forbidden("Request is unauthenticated");
      }
      const requestEntity = credentials.user ? "user" : "app";
      const scopeErrors = [];
      for (const access of config.access) {
        const entity = access.entity;
        if (entity && entity !== "any" && entity !== requestEntity) {
          continue;
        }
        let scope = access.scope;
        if (scope) {
          if (!credentials.scope) {
            scopeErrors.push(scope);
            continue;
          }
          scope = internals.expandScope(request, scope);
          if (!internals.validateScope(credentials, scope, "required") || !internals.validateScope(credentials, scope, "selection") || !internals.validateScope(credentials, scope, "forbidden")) {
            scopeErrors.push(scope);
            continue;
          }
        }
        return true;
      }
      if (scopeErrors.length) {
        request._log(["auth", "scope", "error"]);
        throw Boom.forbidden("Insufficient scope", { got: credentials.scope, need: scopeErrors });
      }
      if (requestEntity === "app") {
        request._log(["auth", "entity", "user", "error"]);
        throw Boom.forbidden("Application credentials cannot be used on a user endpoint");
      }
      request._log(["auth", "entity", "app", "error"]);
      throw Boom.forbidden("User credentials cannot be used on an application endpoint");
    }
    static async payload(request) {
      if (!request.auth.isAuthenticated || !request.auth[Request.symbols.authPayload]) {
        return;
      }
      const auth = request._core.auth;
      const strategy = auth.#strategies[request.auth.strategy];
      Hoek.assert(strategy, "Unknown authentication strategy:", request.auth.strategy);
      if (!strategy.methods.payload) {
        return;
      }
      const config = auth.lookup(request.route);
      const setting = config.payload ?? (strategy.methods.options.payload ? "required" : false);
      if (!setting) {
        return;
      }
      const bind = strategy.methods;
      const realm = strategy.realm;
      const response = await request._core.toolkit.execute(strategy.methods.payload, request, { bind, realm });
      if (response.isBoom && response.isMissing) {
        return setting === "optional" ? undefined : Boom.unauthorized("Missing payload authentication");
      }
      return response;
    }
    static async response(response) {
      const request = response.request;
      const auth = request._core.auth;
      if (!request.auth.isAuthenticated) {
        return;
      }
      const strategy = auth.#strategies[request.auth.strategy];
      Hoek.assert(strategy, "Unknown authentication strategy:", request.auth.strategy);
      if (!strategy.methods.response) {
        return;
      }
      const bind = strategy.methods;
      const realm = strategy.realm;
      const error = await request._core.toolkit.execute(strategy.methods.response, request, { bind, realm, continue: "undefined" });
      if (error) {
        throw error;
      }
    }
  };
  internals.setupScope = function(access) {
    if (!access.scope) {
      return false;
    }
    if (!Array.isArray(access.scope)) {
      return access.scope;
    }
    const scope = {};
    for (const value of access.scope) {
      const prefix = value[0];
      const type = prefix === "+" ? "required" : prefix === "!" ? "forbidden" : "selection";
      const clean = type === "selection" ? value : value.slice(1);
      scope[type] = scope[type] ?? [];
      scope[type].push(clean);
      if (!scope._hasParameters?.[type] && /{([^}]+)}/.test(clean)) {
        scope._hasParameters = scope._hasParameters ?? {};
        scope._hasParameters[type] = true;
      }
    }
    return scope;
  };
  internals.validate = function(err, result, name, config, request, errors) {
    result = result ?? {};
    request.auth.isAuthenticated = !err;
    if (err) {
      if (err instanceof Error === false) {
        request._log(["auth", "unauthenticated", "response", name], { statusCode: err.statusCode });
        return err;
      }
      if (err.isMissing) {
        request._log(["auth", "unauthenticated", "missing", name], err);
        errors.push(err.output.headers["WWW-Authenticate"]);
        return internals.missing;
      }
    }
    request.auth.strategy = name;
    request.auth.credentials = result.credentials;
    request.auth.artifacts = result.artifacts;
    if (!err) {
      return;
    }
    request.auth.error = err;
    if (config.mode === "try") {
      request._log(["auth", "unauthenticated", "try", name], err);
      return;
    }
    request._log(["auth", "unauthenticated", "error", name], err);
    throw err;
  };
  internals.expandScope = function(request, scope) {
    if (!scope._hasParameters) {
      return scope;
    }
    const expanded = {
      required: internals.expandScopeType(request, scope, "required"),
      selection: internals.expandScopeType(request, scope, "selection"),
      forbidden: internals.expandScopeType(request, scope, "forbidden")
    };
    return expanded;
  };
  internals.expandScopeType = function(request, scope, type) {
    if (!scope._hasParameters[type]) {
      return scope[type];
    }
    const expanded = [];
    const context = {
      params: request.params,
      query: request.query,
      payload: request.payload,
      credentials: request.auth.credentials
    };
    for (const template of scope[type]) {
      expanded.push(Hoek.reachTemplate(context, template));
    }
    return expanded;
  };
  internals.validateScope = function(credentials, scope, type) {
    if (!scope[type]) {
      return true;
    }
    const count = typeof credentials.scope === "string" ? scope[type].indexOf(credentials.scope) !== -1 ? 1 : 0 : Hoek.intersect(scope[type], credentials.scope).length;
    if (type === "forbidden") {
      return count === 0;
    }
    if (type === "required") {
      return count === scope.required.length;
    }
    return !!count;
  };
});

// node_modules/@hapi/accept/lib/header.js
var require_header = __commonJS((exports) => {
  var Hoek = require_lib8();
  var Boom = require_lib13();
  var internals = {};
  exports.selection = function(header, preferences, options) {
    const selections = exports.selections(header, preferences, options);
    return selections.length ? selections[0] : "";
  };
  exports.selections = function(header, preferences, options) {
    Hoek.assert(!preferences || Array.isArray(preferences), "Preferences must be an array");
    return internals.parse(header || "", preferences, options);
  };
  internals.parse = function(raw, preferences, options) {
    const header = raw.replace(/[ \t]/g, "");
    const lowers = new Map;
    if (preferences) {
      let pos = 0;
      for (const preference of preferences) {
        const lower = preference.toLowerCase();
        lowers.set(lower, { orig: preference, pos: pos++ });
        if (options.prefixMatch) {
          const parts2 = lower.split("-");
          while (parts2.pop(), parts2.length > 0) {
            const joined = parts2.join("-");
            if (!lowers.has(joined)) {
              lowers.set(joined, { orig: preference, pos: pos++ });
            }
          }
        }
      }
    }
    const parts = header.split(",");
    const selections = [];
    const map = new Set;
    for (let i = 0;i < parts.length; ++i) {
      const part = parts[i];
      if (!part) {
        continue;
      }
      const params = part.split(";");
      if (params.length > 2) {
        throw Boom.badRequest(`Invalid ${options.type} header`);
      }
      let token = params[0].toLowerCase();
      if (!token) {
        throw Boom.badRequest(`Invalid ${options.type} header`);
      }
      if (options.equivalents?.has(token)) {
        token = options.equivalents.get(token);
      }
      const selection = {
        token,
        pos: i,
        q: 1
      };
      if (preferences && lowers.has(token)) {
        selection.pref = lowers.get(token).pos;
      }
      map.add(selection.token);
      if (params.length === 2) {
        const q = params[1];
        const [key, value] = q.split("=");
        if (!value || key !== "q" && key !== "Q") {
          throw Boom.badRequest(`Invalid ${options.type} header`);
        }
        const score = parseFloat(value);
        if (score === 0) {
          continue;
        }
        if (Number.isFinite(score) && score <= 1 && score >= 0.001) {
          selection.q = score;
        }
      }
      selections.push(selection);
    }
    selections.sort(internals.sort);
    const values = selections.map((selection) => selection.token);
    if (options.default && !map.has(options.default)) {
      values.push(options.default);
    }
    if (!preferences?.length) {
      return values;
    }
    const preferred = [];
    for (const selection of values) {
      if (selection === "*") {
        for (const [preference, value] of lowers) {
          if (!map.has(preference)) {
            preferred.push(value.orig);
          }
        }
      } else {
        const lower = selection.toLowerCase();
        if (lowers.has(lower)) {
          preferred.push(lowers.get(lower).orig);
        }
      }
    }
    return preferred;
  };
  internals.sort = function(a, b) {
    const aFirst = -1;
    const bFirst = 1;
    if (b.q !== a.q) {
      return b.q - a.q;
    }
    if (b.pref !== a.pref) {
      if (a.pref === undefined) {
        return bFirst;
      }
      if (b.pref === undefined) {
        return aFirst;
      }
      return a.pref - b.pref;
    }
    return a.pos - b.pos;
  };
});

// node_modules/@hapi/accept/lib/media.js
var require_media = __commonJS((exports) => {
  var Hoek = require_lib8();
  var Boom = require_lib13();
  var internals = {};
  exports.selection = function(header, preferences) {
    const selections = exports.selections(header, preferences);
    return selections.length ? selections[0] : "";
  };
  exports.selections = function(header, preferences) {
    Hoek.assert(!preferences || Array.isArray(preferences), "Preferences must be an array");
    return internals.parse(header, preferences);
  };
  internals.validMediaRx = /^(?:\*\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/[\w\!#\$%&'\*\+\-\.\^`\|~]+)$/;
  internals.parse = function(raw, preferences) {
    const { header, quoted } = internals.normalize(raw);
    const parts = header.split(",");
    const selections = [];
    const map = {};
    for (let i = 0;i < parts.length; ++i) {
      const part = parts[i];
      if (!part) {
        continue;
      }
      const pairs = part.split(";");
      const token = pairs.shift().toLowerCase();
      if (!internals.validMediaRx.test(token)) {
        continue;
      }
      const selection = {
        token,
        params: {},
        exts: {},
        pos: i
      };
      let target = "params";
      for (const pair of pairs) {
        const kv = pair.split("=");
        if (kv.length !== 2 || !kv[1]) {
          throw Boom.badRequest(`Invalid accept header`);
        }
        const key = kv[0];
        let value = kv[1];
        if (key === "q" || key === "Q") {
          target = "exts";
          value = parseFloat(value);
          if (!Number.isFinite(value) || value > 1 || value < 0.001 && value !== 0) {
            value = 1;
          }
          selection.q = value;
        } else {
          if (value[0] === '"') {
            value = `"${quoted[value]}"`;
          }
          selection[target][kv[0]] = value;
        }
      }
      const params = Object.keys(selection.params);
      selection.original = [""].concat(params.map((key) => `${key}=${selection.params[key]}`)).join(";");
      selection.specificity = params.length;
      if (selection.q === undefined) {
        selection.q = 1;
      }
      const tparts = selection.token.split("/");
      selection.type = tparts[0];
      selection.subtype = tparts[1];
      map[selection.token] = selection;
      if (selection.q) {
        selections.push(selection);
      }
    }
    selections.sort(internals.sort);
    return internals.preferences(map, selections, preferences);
  };
  internals.normalize = function(raw) {
    raw = raw || "*/*";
    const normalized = {
      header: raw,
      quoted: {}
    };
    if (raw.includes('"')) {
      let i = 0;
      normalized.header = raw.replace(/="([^"]*)"/g, ($0, $1) => {
        const key = '"' + ++i;
        normalized.quoted[key] = $1;
        return "=" + key;
      });
    }
    normalized.header = normalized.header.replace(/[ \t]/g, "");
    return normalized;
  };
  internals.sort = function(a, b) {
    if (b.q !== a.q) {
      return b.q - a.q;
    }
    if (a.type !== b.type) {
      return internals.innerSort(a, b, "type");
    }
    if (a.subtype !== b.subtype) {
      return internals.innerSort(a, b, "subtype");
    }
    if (a.specificity !== b.specificity) {
      return b.specificity - a.specificity;
    }
    return a.pos - b.pos;
  };
  internals.innerSort = function(a, b, key) {
    const aFirst = -1;
    const bFirst = 1;
    if (a[key] === "*") {
      return bFirst;
    }
    if (b[key] === "*") {
      return aFirst;
    }
    return a[key] < b[key] ? aFirst : bFirst;
  };
  internals.preferences = function(map, selections, preferences) {
    if (!preferences?.length) {
      return selections.map((selection) => selection.token + selection.original);
    }
    const lowers = Object.create(null);
    const flat = Object.create(null);
    let any = false;
    for (const preference of preferences) {
      const lower = preference.toLowerCase();
      flat[lower] = preference;
      const parts = lower.split("/");
      const type = parts[0];
      const subtype = parts[1];
      if (type === "*") {
        Hoek.assert(subtype === "*", "Invalid media type preference contains wildcard type with a subtype");
        any = true;
        continue;
      }
      lowers[type] = lowers[type] ?? Object.create(null);
      lowers[type][subtype] = preference;
    }
    const preferred = [];
    for (const selection of selections) {
      const token = selection.token;
      const { type, subtype } = map[token];
      const subtypes = lowers[type];
      if (type === "*") {
        for (const preference of Object.keys(flat)) {
          if (!map[preference]) {
            preferred.push(flat[preference]);
          }
        }
        if (any) {
          preferred.push("*/*");
        }
        continue;
      }
      if (any) {
        preferred.push((flat[token] || token) + selection.original);
        continue;
      }
      if (subtype !== "*") {
        const pref = flat[token];
        if (pref || subtypes && subtypes["*"]) {
          preferred.push((pref || token) + selection.original);
        }
        continue;
      }
      if (subtypes) {
        for (const psub of Object.keys(subtypes)) {
          if (!map[`${type}/${psub}`]) {
            preferred.push(subtypes[psub]);
          }
        }
      }
    }
    return preferred;
  };
});

// node_modules/@hapi/accept/lib/index.js
var require_lib35 = __commonJS((exports) => {
  var Header = require_header();
  var Media = require_media();
  var internals = {
    options: {
      charset: {
        type: "accept-charset"
      },
      encoding: {
        type: "accept-encoding",
        default: "identity",
        equivalents: new Map([
          ["x-compress", "compress"],
          ["x-gzip", "gzip"]
        ])
      },
      language: {
        type: "accept-language",
        prefixMatch: true
      }
    }
  };
  for (const type in internals.options) {
    exports[type] = (header, preferences) => Header.selection(header, preferences, internals.options[type]);
    exports[`${type}s`] = (header, preferences) => Header.selections(header, preferences, internals.options[type]);
  }
  exports.mediaType = (header, preferences) => Media.selection(header, preferences);
  exports.mediaTypes = (header, preferences) => Media.selections(header, preferences);
  exports.parseAll = function(requestHeaders) {
    return {
      charsets: exports.charsets(requestHeaders["accept-charset"]),
      encodings: exports.encodings(requestHeaders["accept-encoding"]),
      languages: exports.languages(requestHeaders["accept-language"]),
      mediaTypes: exports.mediaTypes(requestHeaders.accept)
    };
  };
});

// node_modules/@hapi/hapi/lib/compression.js
var require_compression = __commonJS((exports, module) => {
  var Zlib = __require("zlib");
  var Accept = require_lib35();
  var Bounce = require_lib14();
  var Hoek = require_lib8();
  var internals = {
    common: ["gzip, deflate", "deflate, gzip", "gzip", "deflate", "gzip, deflate, br"]
  };
  exports = module.exports = internals.Compression = class {
    decoders = {
      gzip: (options) => Zlib.createGunzip(options),
      deflate: (options) => Zlib.createInflate(options)
    };
    encodings = ["identity", "gzip", "deflate"];
    encoders = {
      identity: null,
      gzip: (options) => Zlib.createGzip(options),
      deflate: (options) => Zlib.createDeflate(options)
    };
    #common = null;
    constructor() {
      this._updateCommons();
    }
    _updateCommons() {
      this.#common = new Map;
      for (const header of internals.common) {
        this.#common.set(header, Accept.encoding(header, this.encodings));
      }
    }
    addEncoder(encoding, encoder) {
      Hoek.assert(this.encoders[encoding] === undefined, `Cannot override existing encoder for ${encoding}`);
      Hoek.assert(typeof encoder === "function", `Invalid encoder function for ${encoding}`);
      this.encoders[encoding] = encoder;
      this.encodings.unshift(encoding);
      this._updateCommons();
    }
    addDecoder(encoding, decoder) {
      Hoek.assert(this.decoders[encoding] === undefined, `Cannot override existing decoder for ${encoding}`);
      Hoek.assert(typeof decoder === "function", `Invalid decoder function for ${encoding}`);
      this.decoders[encoding] = decoder;
    }
    accept(request) {
      const header = request.headers["accept-encoding"];
      if (!header) {
        return "identity";
      }
      const common = this.#common.get(header);
      if (common) {
        return common;
      }
      try {
        return Accept.encoding(header, this.encodings);
      } catch (err) {
        Bounce.rethrow(err, "system");
        err.header = header;
        request._log(["accept-encoding", "error"], err);
        return "identity";
      }
    }
    encoding(response, length) {
      if (response.settings.compressed) {
        response.headers["content-encoding"] = response.settings.compressed;
        return null;
      }
      const request = response.request;
      if (!request._core.settings.compression || length !== null && length < request._core.settings.compression.minBytes) {
        return null;
      }
      const mime = request._core.mime.type(response.headers["content-type"] || "application/octet-stream");
      if (!mime.compressible) {
        return null;
      }
      response.vary("accept-encoding");
      if (response.headers["content-encoding"]) {
        return null;
      }
      return request.info.acceptEncoding === "identity" ? null : request.info.acceptEncoding;
    }
    encoder(request, encoding) {
      const encoder = this.encoders[encoding];
      Hoek.assert(encoder !== undefined, `Unknown encoding ${encoding}`);
      return encoder(request.route.settings.compression[encoding]);
    }
  };
});

// node_modules/@hapi/hapi/lib/methods.js
var require_methods = __commonJS((exports, module) => {
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var Config2 = require_config();
  var internals = {
    methodNameRx: /^[_$a-zA-Z][$\w]*(?:\.[_$a-zA-Z][$\w]*)*$/
  };
  exports = module.exports = internals.Methods = class {
    methods = {};
    #core = null;
    constructor(core) {
      this.#core = core;
    }
    add(name, method, options, realm) {
      if (typeof name !== "object") {
        return this._add(name, method, options, realm);
      }
      const items = [].concat(name);
      for (let item of items) {
        item = Config2.apply("methodObject", item);
        this._add(item.name, item.method, item.options ?? {}, realm);
      }
    }
    _add(name, method, options, realm) {
      Hoek.assert(typeof method === "function", "method must be a function");
      Hoek.assert(typeof name === "string", "name must be a string");
      Hoek.assert(name.match(internals.methodNameRx), "Invalid name:", name);
      Hoek.assert(!Hoek.reach(this.methods, name, { functions: false }), "Server method function name already exists:", name);
      options = Config2.apply("method", options, name);
      const settings = Hoek.clone(options, { shallow: ["bind"] });
      settings.generateKey = settings.generateKey ?? internals.generateKey;
      const bind = settings.bind ?? realm.settings.bind ?? null;
      const bound = !bind ? method : (...args) => method.apply(bind, args);
      if (!settings.cache) {
        return this._assign(name, bound);
      }
      Hoek.assert(!settings.cache.generateFunc, "Cannot set generateFunc with method caching:", name);
      Hoek.assert(settings.cache.generateTimeout !== undefined, "Method caching requires a timeout value in generateTimeout:", name);
      settings.cache.generateFunc = (id, flags) => bound(...id.args, flags);
      const cache = this.#core._cachePolicy(settings.cache, "#" + name);
      const func = function(...args) {
        const key = settings.generateKey.apply(bind, args);
        if (typeof key !== "string") {
          return Promise.reject(Boom.badImplementation("Invalid method key when invoking: " + name, { name, args }));
        }
        return cache.get({ id: key, args });
      };
      func.cache = {
        drop: function(...args) {
          const key = settings.generateKey.apply(bind, args);
          if (typeof key !== "string") {
            return Promise.reject(Boom.badImplementation("Invalid method key when invoking: " + name, { name, args }));
          }
          return cache.drop(key);
        },
        stats: cache.stats
      };
      this._assign(name, func, func);
    }
    _assign(name, method) {
      const path2 = name.split(".");
      let ref = this.methods;
      for (let i = 0;i < path2.length; ++i) {
        if (!ref[path2[i]]) {
          ref[path2[i]] = i + 1 === path2.length ? method : {};
        }
        ref = ref[path2[i]];
      }
    }
  };
  internals.supportedArgs = ["string", "number", "boolean"];
  internals.generateKey = function(...args) {
    let key = "";
    for (let i = 0;i < args.length; ++i) {
      const arg = args[i];
      if (!internals.supportedArgs.includes(typeof arg)) {
        return null;
      }
      key = key + (i ? ":" : "") + encodeURIComponent(arg.toString());
    }
    return key;
  };
});

// node_modules/@hapi/hapi/lib/response.js
var require_response2 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  var Boom = require_lib13();
  var Bounce = require_lib14();
  var Hoek = require_lib8();
  var Podium = require_lib17();
  var Streams = require_streams();
  var internals = {
    events: Podium.validate(["finish", { name: "peek", spread: true }]),
    hopByHop: {
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    },
    reserved: [
      "app",
      "headers",
      "plugins",
      "request",
      "source",
      "statusCode",
      "variety",
      "settings",
      "events",
      "code",
      "message",
      "header",
      "vary",
      "etag",
      "type",
      "contentType",
      "bytes",
      "location",
      "created",
      "compressed",
      "replacer",
      "space",
      "suffix",
      "escape",
      "passThrough",
      "redirect",
      "temporary",
      "permanent",
      "rewritable",
      "encoding",
      "charset",
      "ttl",
      "state",
      "unstate",
      "takeover"
    ]
  };
  exports = module.exports = internals.Response = class {
    constructor(source, request, options = {}) {
      this.app = {};
      this.headers = {};
      this.plugins = {};
      this.request = request;
      this.source = null;
      this.statusCode = null;
      this.variety = null;
      this.settings = {
        charset: "utf-8",
        compressed: null,
        encoding: "utf8",
        message: null,
        passThrough: true,
        stringify: null,
        ttl: null,
        varyEtag: false
      };
      this._events = null;
      this._payload = null;
      this._error = options.error ?? null;
      this._contentType = null;
      this._takeover = false;
      this._statusCode = false;
      this._state = this._error ? "prepare" : "init";
      this._processors = {
        marshal: options.marshal,
        prepare: options.prepare,
        close: options.close
      };
      this._setSource(source, options.variety);
    }
    static wrap(result, request) {
      if (result instanceof request._core.Response || typeof result === "symbol") {
        return result;
      }
      if (result instanceof Error) {
        return Boom.boomify(result);
      }
      return new request._core.Response(result, request);
    }
    _setSource(source, variety) {
      this.variety = variety ?? "plain";
      if (source === null || source === undefined) {
        source = null;
      } else if (Buffer.isBuffer(source)) {
        this.variety = "buffer";
        this._contentType = "application/octet-stream";
      } else if (Streams.isStream(source)) {
        this.variety = "stream";
        this._contentType = "application/octet-stream";
      }
      this.source = source;
      if (this.variety === "plain" && this.source !== null) {
        this._contentType = typeof this.source === "string" ? "text/html" : "application/json";
      }
    }
    get events() {
      if (!this._events) {
        this._events = new Podium.Podium(internals.events);
      }
      return this._events;
    }
    code(statusCode) {
      Hoek.assert(Number.isSafeInteger(statusCode), "Status code must be an integer");
      this.statusCode = statusCode;
      this._statusCode = true;
      return this;
    }
    message(httpMessage) {
      this.settings.message = httpMessage;
      return this;
    }
    header(key, value, options) {
      key = key.toLowerCase();
      if (key === "vary") {
        return this.vary(value);
      }
      return this._header(key, value, options);
    }
    _header(key, value, options = {}) {
      const append = options.append ?? false;
      const separator = options.separator || ",";
      const override = options.override !== false;
      const duplicate = options.duplicate !== false;
      if (!append && override || !this.headers[key]) {
        this.headers[key] = value;
      } else if (override) {
        if (key === "set-cookie") {
          this.headers[key] = [].concat(this.headers[key], value);
        } else {
          const existing = this.headers[key];
          if (!duplicate) {
            const values = existing.split(separator);
            for (const v of values) {
              if (v === value) {
                return this;
              }
            }
          }
          this.headers[key] = existing + separator + value;
        }
      }
      return this;
    }
    vary(value) {
      if (value === "*") {
        this.headers.vary = "*";
      } else if (!this.headers.vary) {
        this.headers.vary = value;
      } else if (this.headers.vary !== "*") {
        this._header("vary", value, { append: true, duplicate: false });
      }
      return this;
    }
    etag(tag, options) {
      const entity = this.request._core.Response.entity(tag, options);
      this._header("etag", entity.etag);
      this.settings.varyEtag = entity.vary;
      return this;
    }
    static entity(tag, options = {}) {
      Hoek.assert(tag !== "*", "ETag cannot be *");
      return {
        etag: (options.weak ? "W/" : "") + '"' + tag + '"',
        vary: options.vary !== false && !options.weak,
        modified: options.modified
      };
    }
    static unmodified(request, entity) {
      if (request.method !== "get" && request.method !== "head") {
        return false;
      }
      if (entity.etag && request.headers["if-none-match"]) {
        const ifNoneMatch = request.headers["if-none-match"].split(/\s*,\s*/);
        for (const etag of ifNoneMatch) {
          if (etag === entity.etag) {
            return true;
          }
          if (!entity.vary) {
            continue;
          }
          if (etag === `W/${entity.etag}`) {
            return etag;
          }
          const etagBase = entity.etag.slice(0, -1);
          const encoders = request._core.compression.encodings;
          for (const encoder of encoders) {
            if (etag === etagBase + `-${encoder}"`) {
              return true;
            }
          }
        }
        return false;
      }
      if (!entity.modified) {
        return false;
      }
      const ifModifiedSinceHeader = request.headers["if-modified-since"];
      if (!ifModifiedSinceHeader) {
        return false;
      }
      const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
      if (!ifModifiedSince) {
        return false;
      }
      const lastModified = internals.parseDate(entity.modified);
      if (!lastModified) {
        return false;
      }
      return ifModifiedSince >= lastModified;
    }
    type(type) {
      this._header("content-type", type);
      return this;
    }
    get contentType() {
      let type = this.headers["content-type"];
      if (type) {
        type = type.trim();
        if (this.settings.charset && type.match(/^(?:text\/)|(?:application\/(?:json)|(?:javascript))/) && !type.match(/; *charset=/)) {
          const semi = type[type.length - 1] === ";";
          return type + (semi ? " " : "; ") + "charset=" + this.settings.charset;
        }
        return type;
      }
      if (this._contentType) {
        const charset = this.settings.charset && this._contentType !== "application/octet-stream" ? "; charset=" + this.settings.charset : "";
        return this._contentType + charset;
      }
      return null;
    }
    bytes(bytes) {
      this._header("content-length", bytes);
      return this;
    }
    location(uri) {
      this._header("location", uri);
      return this;
    }
    created(location) {
      Hoek.assert(this.request.method === "post" || this.request.method === "put" || this.request.method === "patch", "Cannot return 201 status codes for " + this.request.method.toUpperCase());
      this.statusCode = 201;
      this.location(location);
      return this;
    }
    compressed(encoding) {
      Hoek.assert(encoding && typeof encoding === "string", "Invalid content-encoding");
      this.settings.compressed = encoding;
      return this;
    }
    replacer(method) {
      this.settings.stringify = this.settings.stringify ?? {};
      this.settings.stringify.replacer = method;
      return this;
    }
    spaces(count) {
      this.settings.stringify = this.settings.stringify ?? {};
      this.settings.stringify.space = count;
      return this;
    }
    suffix(suffix) {
      this.settings.stringify = this.settings.stringify ?? {};
      this.settings.stringify.suffix = suffix;
      return this;
    }
    escape(escape) {
      this.settings.stringify = this.settings.stringify ?? {};
      this.settings.stringify.escape = escape;
      return this;
    }
    passThrough(enabled) {
      this.settings.passThrough = enabled !== false;
      return this;
    }
    redirect(location) {
      this.statusCode = 302;
      this.location(location);
      return this;
    }
    temporary(isTemporary) {
      Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
      this._setTemporary(isTemporary !== false);
      return this;
    }
    permanent(isPermanent) {
      Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
      this._setTemporary(isPermanent === false);
      return this;
    }
    rewritable(isRewritable) {
      Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
      this._setRewritable(isRewritable !== false);
      return this;
    }
    _isTemporary() {
      return this.statusCode === 302 || this.statusCode === 307;
    }
    _isRewritable() {
      return this.statusCode === 301 || this.statusCode === 302;
    }
    _setTemporary(isTemporary) {
      if (isTemporary) {
        if (this._isRewritable()) {
          this.statusCode = 302;
        } else {
          this.statusCode = 307;
        }
      } else {
        if (this._isRewritable()) {
          this.statusCode = 301;
        } else {
          this.statusCode = 308;
        }
      }
    }
    _setRewritable(isRewritable) {
      if (isRewritable) {
        if (this._isTemporary()) {
          this.statusCode = 302;
        } else {
          this.statusCode = 301;
        }
      } else {
        if (this._isTemporary()) {
          this.statusCode = 307;
        } else {
          this.statusCode = 308;
        }
      }
    }
    encoding(encoding) {
      this.settings.encoding = encoding;
      return this;
    }
    charset(charset) {
      this.settings.charset = charset ?? null;
      return this;
    }
    ttl(ttl) {
      this.settings.ttl = ttl;
      return this;
    }
    state(name, value, options) {
      this.request._setState(name, value, options);
      return this;
    }
    unstate(name, options) {
      this.request._clearState(name, options);
      return this;
    }
    takeover() {
      this._takeover = true;
      return this;
    }
    _prepare() {
      Hoek.assert(this._state === "init");
      this._state = "prepare";
      this._passThrough();
      if (!this._processors.prepare) {
        return this;
      }
      try {
        return this._processors.prepare(this);
      } catch (err) {
        throw Boom.boomify(err);
      }
    }
    _passThrough() {
      if (this.variety === "stream" && this.settings.passThrough) {
        if (this.source.statusCode && !this.statusCode) {
          this.statusCode = this.source.statusCode;
        }
        if (this.source.headers) {
          let headerKeys = Object.keys(this.source.headers);
          if (headerKeys.length) {
            const localHeaders = this.headers;
            this.headers = {};
            const connection = this.source.headers.connection;
            const byHop = {};
            if (connection) {
              connection.split(/\s*,\s*/).forEach((header) => {
                byHop[header] = true;
              });
            }
            for (const key of headerKeys) {
              const lower = key.toLowerCase();
              if (!internals.hopByHop[lower] && !byHop[lower]) {
                this.header(lower, Hoek.clone(this.source.headers[key]));
              }
            }
            headerKeys = Object.keys(localHeaders);
            for (const key of headerKeys) {
              this.header(key, localHeaders[key], { append: key === "set-cookie" });
            }
          }
        }
      }
      this.statusCode = this.statusCode ?? 200;
    }
    async _marshal() {
      Hoek.assert(this._state === "prepare");
      this._state = "marshall";
      let source = this.source;
      if (this._processors.marshal) {
        try {
          source = await this._processors.marshal(this);
        } catch (err) {
          throw Boom.boomify(err);
        }
      }
      if (Streams.isStream(source)) {
        this._payload = source;
        return;
      }
      const jsonify = this.variety === "plain" && source !== null && typeof source !== "string";
      if (!jsonify && this.settings.stringify) {
        throw Boom.badImplementation("Cannot set formatting options on non object response");
      }
      let payload = source;
      if (jsonify) {
        const options = this.settings.stringify ?? {};
        const space = options.space ?? this.request.route.settings.json.space;
        const replacer = options.replacer ?? this.request.route.settings.json.replacer;
        const suffix = options.suffix ?? this.request.route.settings.json.suffix ?? "";
        const escape = this.request.route.settings.json.escape;
        try {
          if (replacer || space) {
            payload = JSON.stringify(payload, replacer, space);
          } else {
            payload = JSON.stringify(payload);
          }
        } catch (err) {
          throw Boom.boomify(err);
        }
        if (suffix) {
          payload = payload + suffix;
        }
        if (escape) {
          payload = Hoek.escapeJson(payload);
        }
      }
      this._payload = new internals.Response.Payload(payload, this.settings);
    }
    _tap() {
      if (!this._events) {
        return null;
      }
      if (this._events.hasListeners("peek") || this._events.hasListeners("finish")) {
        return new internals.Response.Peek(this._events);
      }
      return null;
    }
    _close() {
      if (this._state === "close") {
        return;
      }
      this._state = "close";
      if (this._processors.close) {
        try {
          this._processors.close(this);
        } catch (err) {
          Bounce.rethrow(err, "system");
          this.request._log(["response", "cleanup", "error"], err);
        }
      }
      const stream = this._payload || this.source;
      if (Streams.isStream(stream)) {
        internals.Response.drain(stream);
      }
    }
    _isPayloadSupported() {
      return this.request.method !== "head" && this.statusCode !== 304 && this.statusCode !== 204;
    }
    static drain(stream) {
      stream.destroy();
    }
  };
  internals.Response.reserved = internals.reserved;
  internals.parseDate = function(string) {
    try {
      return Date.parse(string);
    } catch (errIgnore) {}
  };
  internals.Response.Payload = class extends Stream.Readable {
    constructor(payload, options) {
      super();
      this._data = payload;
      this._encoding = options.encoding;
    }
    _read(size) {
      if (this._data) {
        this.push(this._data, this._encoding);
      }
      this.push(null);
    }
    size() {
      if (!this._data) {
        return 0;
      }
      return Buffer.isBuffer(this._data) ? this._data.length : Buffer.byteLength(this._data, this._encoding);
    }
    writeToStream(stream) {
      if (this._data) {
        stream.write(this._data, this._encoding);
      }
      stream.end();
    }
  };
  internals.Response.Peek = class extends Stream.Transform {
    constructor(podium) {
      super();
      this._podium = podium;
      this.on("finish", () => podium.emit("finish"));
    }
    _transform(chunk, encoding, callback) {
      this._podium.emit("peek", [chunk, encoding]);
      this.push(chunk, encoding);
      callback();
    }
  };
});

// node_modules/@hapi/hapi/lib/core.js
var require_core = __commonJS((exports, module) => {
  var Http = __require("http");
  var Https = __require("https");
  var Os = __require("os");
  var Path = __require("path");
  var Boom = require_lib13();
  var Bounce = require_lib14();
  var Call = require_lib16();
  var Catbox = require_lib18();
  var { Engine: CatboxMemory } = require_lib19();
  var { Heavy } = require_lib20();
  var Hoek = require_lib8();
  var { Mimos } = require_lib21();
  var Podium = require_lib17();
  var Statehood = require_lib26();
  var Auth = require_auth();
  var Compression = require_compression();
  var Config2 = require_config();
  var Cors = require_cors();
  var Ext = require_ext();
  var Methods = require_methods();
  var Request = require_request2();
  var Response2 = require_response2();
  var Route = require_route();
  var Toolkit = require_toolkit();
  var Validation = require_validation();
  var internals = {
    counter: {
      min: 1e4,
      max: 99999
    },
    events: [
      { name: "cachePolicy", spread: true },
      { name: "log", channels: ["app", "internal"], tags: true },
      { name: "request", channels: ["app", "internal", "error"], tags: true, spread: true },
      "response",
      "route",
      "start",
      "closing",
      "stop"
    ],
    badRequestResponse: Buffer.from(`HTTP/1.1 400 Bad Request\r
\r
`, "ascii")
  };
  exports = module.exports = internals.Core = class {
    actives = new WeakMap;
    app = {};
    auth = new Auth(this);
    caches = new Map;
    compression = new Compression;
    controlled = null;
    dependencies = [];
    events = new Podium.Podium(internals.events);
    heavy = null;
    info = null;
    instances = new Set;
    listener = null;
    methods = new Methods(this);
    mime = null;
    onConnection = null;
    phase = "stopped";
    plugins = {};
    registrations = {};
    registring = 0;
    Request = class extends Request {
    };
    Response = class extends Response2 {
    };
    requestCounter = { value: internals.counter.min, min: internals.counter.min, max: internals.counter.max };
    root = null;
    router = null;
    settings = null;
    sockets = null;
    started = false;
    states = null;
    toolkit = new Toolkit.Manager;
    type = null;
    validator = null;
    extensionsSeq = 0;
    extensions = {
      server: {
        onPreStart: new Ext("onPreStart", this),
        onPostStart: new Ext("onPostStart", this),
        onPreStop: new Ext("onPreStop", this),
        onPostStop: new Ext("onPostStop", this)
      },
      route: {
        onRequest: new Ext("onRequest", this),
        onPreAuth: new Ext("onPreAuth", this),
        onCredentials: new Ext("onCredentials", this),
        onPostAuth: new Ext("onPostAuth", this),
        onPreHandler: new Ext("onPreHandler", this),
        onPostHandler: new Ext("onPostHandler", this),
        onPreResponse: new Ext("onPreResponse", this),
        onPostResponse: new Ext("onPostResponse", this)
      }
    };
    decorations = {
      handler: new Map,
      request: new Map,
      response: new Map,
      server: new Map,
      toolkit: new Map,
      requestApply: null,
      public: { handler: [], request: [], response: [], server: [], toolkit: [] }
    };
    constructor(options) {
      const { settings, type } = internals.setup(options);
      this.settings = settings;
      this.type = type;
      this.heavy = new Heavy(this.settings.load);
      this.mime = new Mimos(this.settings.mime);
      this.router = new Call.Router(this.settings.router);
      this.states = new Statehood.Definitions(this.settings.state);
      this._debug();
      this._initializeCache();
      if (this.settings.routes.validate.validator) {
        this.validator = Validation.validator(this.settings.routes.validate.validator);
      }
      this.listener = this._createListener();
      this._initializeListener();
      this.info = this._info();
    }
    _debug() {
      const debug = this.settings.debug;
      if (!debug) {
        return;
      }
      const method = (event) => {
        const data = event.error ?? event.data;
        console.error("Debug:", event.tags.join(", "), data ? `
    ` + (data.stack ?? (typeof data === "object" ? Hoek.stringify(data) : data)) : "");
      };
      if (debug.log) {
        const filter = debug.log.some((tag) => tag === "*") ? undefined : debug.log;
        this.events.on({ name: "log", filter }, method);
      }
      if (debug.request) {
        const filter = debug.request.some((tag) => tag === "*") ? undefined : debug.request;
        this.events.on({ name: "request", filter }, (request, event) => method(event));
      }
    }
    _initializeCache() {
      if (this.settings.cache) {
        this._createCache(this.settings.cache);
      }
      if (!this.caches.has("_default")) {
        this._createCache([{ provider: CatboxMemory }]);
      }
    }
    _info() {
      const now = Date.now();
      const protocol = this.type === "tcp" ? this.settings.tls ? "https" : "http" : this.type;
      const host = this.settings.host || Os.hostname() || "localhost";
      const port = this.settings.port;
      const info = {
        created: now,
        started: 0,
        host,
        port,
        protocol,
        id: Os.hostname() + ":" + process.pid + ":" + now.toString(36),
        uri: this.settings.uri ?? protocol + ":" + (this.type === "tcp" ? "//" + host + (port ? ":" + port : "") : port)
      };
      return info;
    }
    _counter() {
      const next = ++this.requestCounter.value;
      if (this.requestCounter.value > this.requestCounter.max) {
        this.requestCounter.value = this.requestCounter.min;
      }
      return next - 1;
    }
    _createCache(configs) {
      Hoek.assert(this.phase !== "initializing", "Cannot provision server cache while server is initializing");
      configs = Config2.apply("cache", configs);
      const added = [];
      for (let config of configs) {
        if (typeof config === "function") {
          config = { provider: { constructor: config } };
        }
        const name = config.name ?? "_default";
        Hoek.assert(!this.caches.has(name), "Cannot configure the same cache more than once: ", name === "_default" ? "default cache" : name);
        let client = null;
        if (config.provider) {
          let provider = config.provider;
          if (typeof provider === "function") {
            provider = { constructor: provider };
          }
          client = new Catbox.Client(provider.constructor, provider.options ?? { partition: "hapi-cache" });
        } else {
          client = new Catbox.Client(config.engine);
        }
        this.caches.set(name, { client, segments: {}, shared: config.shared ?? false });
        added.push(client);
      }
      return added;
    }
    registerServer(server) {
      if (!this.root) {
        this.root = server;
        this._defaultRoutes();
      }
      this.instances.add(server);
    }
    async _start() {
      if (this.phase === "initialized" || this.phase === "started") {
        this._validateDeps();
      }
      if (this.phase === "started") {
        return;
      }
      if (this.phase !== "stopped" && this.phase !== "initialized") {
        throw new Error("Cannot start server while it is in " + this.phase + " phase");
      }
      if (this.phase !== "initialized") {
        await this._initialize();
      }
      this.phase = "starting";
      this.started = true;
      this.info.started = Date.now();
      try {
        await this._listen();
      } catch (err) {
        this.started = false;
        this.phase = "invalid";
        throw err;
      }
      this.phase = "started";
      this.events.emit("start");
      try {
        if (this.controlled) {
          await Promise.all(this.controlled.map((control) => control.start()));
        }
        await this._invoke("onPostStart");
      } catch (err) {
        this.phase = "invalid";
        throw err;
      }
    }
    _listen() {
      return new Promise((resolve, reject) => {
        if (!this.settings.autoListen) {
          resolve();
          return;
        }
        const onError = (err) => {
          reject(err);
          return;
        };
        this.listener.once("error", onError);
        const finalize = () => {
          this.listener.removeListener("error", onError);
          resolve();
          return;
        };
        if (this.type !== "tcp") {
          this.listener.listen(this.settings.port, finalize);
        } else {
          const address = this.settings.address || this.settings.host || null;
          this.listener.listen(this.settings.port, address, finalize);
        }
      });
    }
    async _initialize() {
      if (this.registring) {
        throw new Error("Cannot start server before plugins finished registration");
      }
      if (this.phase === "initialized") {
        return;
      }
      if (this.phase !== "stopped") {
        throw new Error("Cannot initialize server while it is in " + this.phase + " phase");
      }
      this._validateDeps();
      this.phase = "initializing";
      try {
        const caches = [];
        this.caches.forEach((cache) => caches.push(cache.client.start()));
        await Promise.all(caches);
        await this._invoke("onPreStart");
        this.heavy.start();
        this.phase = "initialized";
        if (this.controlled) {
          await Promise.all(this.controlled.map((control) => control.initialize()));
        }
      } catch (err) {
        this.phase = "invalid";
        throw err;
      }
    }
    _validateDeps() {
      for (const { deps, plugin } of this.dependencies) {
        for (const dep in deps) {
          const version = deps[dep];
          Hoek.assert(this.registrations[dep], "Plugin", plugin, "missing dependency", dep);
          Hoek.assert(version === "*" || Config2.versionMatch(this.registrations[dep].version, version), "Plugin", plugin, "requires", dep, "version", version, "but found", this.registrations[dep].version);
        }
      }
    }
    async _stop(options = {}) {
      options.timeout = options.timeout ?? 5000;
      if (["stopped", "initialized", "started", "invalid"].indexOf(this.phase) === -1) {
        throw new Error("Cannot stop server while in " + this.phase + " phase");
      }
      this.phase = "stopping";
      try {
        await this._invoke("onPreStop");
        if (this.started) {
          this.started = false;
          this.info.started = 0;
          await this._unlisten(options.timeout);
        }
        const caches = [];
        this.caches.forEach((cache) => caches.push(cache.client.stop()));
        await Promise.all(caches);
        this.events.emit("stop");
        this.heavy.stop();
        if (this.controlled) {
          await Promise.all(this.controlled.map((control) => control.stop(options)));
        }
        await this._invoke("onPostStop");
        this.phase = "stopped";
      } catch (err) {
        this.phase = "invalid";
        throw err;
      }
    }
    _unlisten(timeout) {
      let timeoutId = null;
      if (this.settings.operations.cleanStop) {
        const destroy = () => {
          for (const connection of this.sockets) {
            connection.destroy();
          }
          this.sockets.clear();
        };
        timeoutId = setTimeout(destroy, timeout);
        for (const connection of this.sockets) {
          if (!this.actives.has(connection)) {
            connection.end();
          }
        }
      }
      return new Promise((resolve) => {
        this.listener.close(() => {
          if (this.settings.operations.cleanStop) {
            this.listener.removeListener(this.settings.tls ? "secureConnection" : "connection", this.onConnection);
            clearTimeout(timeoutId);
          }
          this._initializeListener();
          resolve();
        });
        this.events.emit("closing");
      });
    }
    async _invoke(type) {
      const exts = this.extensions.server[type];
      if (!exts.nodes) {
        return;
      }
      for (const ext of exts.nodes) {
        const bind = ext.bind ?? ext.realm.settings.bind;
        const operation = ext.func.call(bind, ext.server, bind);
        await Toolkit.timed(operation, { timeout: ext.timeout, name: type });
      }
    }
    _defaultRoutes() {
      this.router.special("notFound", new Route({ method: "_special", path: "/{p*}", handler: internals.notFound }, this.root, { special: true }));
      this.router.special("badRequest", new Route({ method: "_special", path: "/{p*}", handler: internals.badRequest }, this.root, { special: true }));
      if (this.settings.routes.cors) {
        Cors.handler(this.root);
      }
    }
    _dispatch(options = {}) {
      return (req, res) => {
        const request = Request.generate(this.root, req, res, options);
        if (this.settings.operations.cleanStop && req.socket) {
          this.actives.set(req.socket, request);
          const env2 = { core: this, req };
          res.on("finish", internals.onFinish.bind(res, env2));
        }
        if (this.settings.load.sampleInterval) {
          try {
            this.heavy.check();
          } catch (err) {
            Bounce.rethrow(err, "system");
            this._log(["load"], this.heavy.load);
            request._reply(err);
            return;
          }
        }
        request._execute();
      };
    }
    _createListener() {
      const listener = this.settings.listener ?? (this.settings.tls ? Https.createServer(this.settings.tls) : Http.createServer());
      listener.on("request", this._dispatch());
      listener.on("checkContinue", this._dispatch({ expectContinue: true }));
      listener.on("clientError", (err, socket) => {
        this._log(["connection", "client", "error"], err);
        if (socket.readable) {
          const request = this.settings.operations.cleanStop && this.actives.get(socket);
          if (request) {
            if (err.code === "HPE_INVALID_METHOD") {
              request.raw.res.once("close", () => {
                if (socket.readable) {
                  socket.end(internals.badRequestResponse);
                } else {
                  socket.destroy(err);
                }
              });
              return;
            }
            const error = Boom.badRequest();
            error.output.headers = { connection: "close" };
            request._reply(error);
          } else {
            socket.end(internals.badRequestResponse);
          }
        } else {
          socket.destroy(err);
        }
      });
      return listener;
    }
    _initializeListener() {
      this.listener.once("listening", () => {
        if (this.type === "tcp") {
          const address = this.listener.address();
          this.info.address = address.address;
          this.info.port = address.port;
          this.info.uri = this.settings.uri ?? this.info.protocol + "://" + this.info.host + ":" + this.info.port;
        }
        if (this.settings.operations.cleanStop) {
          this.sockets = new Set;
          const self2 = this;
          const onClose = function() {
            self2.sockets.delete(this);
          };
          this.onConnection = (connection) => {
            this.sockets.add(connection);
            connection.on("close", onClose);
          };
          this.listener.on(this.settings.tls ? "secureConnection" : "connection", this.onConnection);
        }
      });
    }
    _cachePolicy(options, _segment, realm) {
      options = Config2.apply("cachePolicy", options);
      const plugin = realm?.plugin;
      const segment = options.segment ?? _segment ?? (plugin ? `!${plugin}` : "");
      Hoek.assert(segment, "Missing cache segment name");
      const cacheName = options.cache ?? "_default";
      const cache = this.caches.get(cacheName);
      Hoek.assert(cache, "Unknown cache", cacheName);
      Hoek.assert(!cache.segments[segment] || cache.shared || options.shared, "Cannot provision the same cache segment more than once");
      cache.segments[segment] = true;
      const policy = new Catbox.Policy(options, cache.client, segment);
      this.events.emit("cachePolicy", [policy, options.cache, segment]);
      return policy;
    }
    log(tags, data) {
      return this._log(tags, data, "app");
    }
    _log(tags, data, channel = "internal") {
      if (!this.events.hasListeners("log")) {
        return;
      }
      if (!Array.isArray(tags)) {
        tags = [tags];
      }
      const timestamp = Date.now();
      const field = data instanceof Error ? "error" : "data";
      let event = { timestamp, tags, [field]: data, channel };
      if (typeof data === "function") {
        event = () => ({ timestamp, tags, data: data(), channel });
      }
      this.events.emit({ name: "log", tags, channel }, event);
    }
  };
  internals.setup = function(options = {}) {
    let settings = Hoek.clone(options, { shallow: ["cache", "listener", "routes.bind"] });
    settings.app = settings.app ?? {};
    settings.routes = Config2.enable(settings.routes);
    settings = Config2.apply("server", settings);
    if (settings.port === undefined) {
      settings.port = 0;
    }
    const type = typeof settings.port === "string" ? "socket" : "tcp";
    if (type === "socket") {
      settings.port = settings.port.indexOf("/") !== -1 ? Path.resolve(settings.port) : settings.port.toLowerCase();
    }
    if (settings.autoListen === undefined) {
      settings.autoListen = true;
    }
    Hoek.assert(settings.autoListen || !settings.port, "Cannot specify port when autoListen is false");
    Hoek.assert(settings.autoListen || !settings.address, "Cannot specify address when autoListen is false");
    return { settings, type };
  };
  internals.notFound = function() {
    throw Boom.notFound();
  };
  internals.badRequest = function() {
    throw Boom.badRequest();
  };
  internals.onFinish = function(env2) {
    const { core, req } = env2;
    core.actives.delete(req.socket);
    if (!core.started) {
      req.socket.end();
    }
  };
});

// node_modules/@hapi/hapi/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "@hapi/hapi",
    description: "HTTP Server framework",
    homepage: "https://hapi.dev",
    version: "21.4.0",
    repository: "git://github.com/hapijs/hapi",
    main: "lib/index.js",
    types: "lib/index.d.ts",
    engines: {
      node: ">=14.15.0"
    },
    files: [
      "lib"
    ],
    keywords: [
      "framework",
      "http",
      "api",
      "web"
    ],
    eslintConfig: {
      extends: [
        "plugin:@hapi/module"
      ]
    },
    dependencies: {
      "@hapi/accept": "^6.0.3",
      "@hapi/ammo": "^6.0.1",
      "@hapi/boom": "^10.0.1",
      "@hapi/bounce": "^3.0.2",
      "@hapi/call": "^9.0.1",
      "@hapi/catbox": "^12.1.1",
      "@hapi/catbox-memory": "^6.0.2",
      "@hapi/heavy": "^8.0.1",
      "@hapi/hoek": "^11.0.6",
      "@hapi/mimos": "^7.0.1",
      "@hapi/podium": "^5.0.1",
      "@hapi/shot": "^6.0.1",
      "@hapi/somever": "^4.1.1",
      "@hapi/statehood": "^8.2.0",
      "@hapi/subtext": "^8.1.0",
      "@hapi/teamwork": "^6.0.0",
      "@hapi/topo": "^6.0.2",
      "@hapi/validate": "^2.0.1"
    },
    devDependencies: {
      "@hapi/code": "^9.0.3",
      "@hapi/eslint-plugin": "^6.0.0",
      "@hapi/inert": "^7.1.0",
      "@hapi/joi-legacy-test": "npm:@hapi/joi@^15.0.0",
      "@hapi/lab": "^25.3.2",
      "@hapi/vision": "^7.0.3",
      "@hapi/wreck": "^18.1.0",
      "@types/node": "^18.19.59",
      handlebars: "^4.7.8",
      joi: "^17.13.3",
      "legacy-readable-stream": "npm:readable-stream@^1.0.34",
      typescript: "^4.9.4"
    },
    scripts: {
      test: "lab -a @hapi/code -t 100 -L -m 5000 -Y",
      "test-tap": "lab -a @hapi/code -r tap -o tests.tap -m 5000",
      "test-cov-html": "lab -a @hapi/code -r html -o coverage.html -m 5000"
    },
    license: "BSD-3-Clause"
  };
});

// node_modules/@hapi/hapi/lib/server.js
var require_server = __commonJS((exports, module) => {
  var Hoek = require_lib8();
  var Shot = require_lib11();
  var Teamwork = require_lib12();
  var Config2 = require_config();
  var Core = require_core();
  var Cors = require_cors();
  var Ext = require_ext();
  var Package = require_package3();
  var Route = require_route();
  var Toolkit = require_toolkit();
  var Validation = require_validation();
  var internals = {};
  exports = module.exports = function(options) {
    const core = new Core(options);
    return new internals.Server(core);
  };
  internals.Server = class {
    constructor(core, name, parent) {
      this._core = core;
      this.app = core.app;
      this.auth = core.auth.public(this);
      this.decorations = core.decorations.public;
      this.cache = internals.cache(this);
      this.events = core.events;
      this.info = core.info;
      this.listener = core.listener;
      this.load = core.heavy.load;
      this.methods = core.methods.methods;
      this.mime = core.mime;
      this.plugins = core.plugins;
      this.registrations = core.registrations;
      this.settings = core.settings;
      this.states = core.states;
      this.type = core.type;
      this.version = Package.version;
      this.realm = {
        _extensions: {
          onPreAuth: new Ext("onPreAuth", core),
          onCredentials: new Ext("onCredentials", core),
          onPostAuth: new Ext("onPostAuth", core),
          onPreHandler: new Ext("onPreHandler", core),
          onPostHandler: new Ext("onPostHandler", core),
          onPreResponse: new Ext("onPreResponse", core),
          onPostResponse: new Ext("onPostResponse", core)
        },
        modifiers: {
          route: {}
        },
        parent: parent ? parent.realm : null,
        plugin: name,
        pluginOptions: {},
        plugins: {},
        _rules: null,
        settings: {
          bind: undefined,
          files: {
            relativeTo: undefined
          }
        },
        validator: null
      };
      for (const [property, method] of core.decorations.server.entries()) {
        this[property] = method;
      }
      core.registerServer(this);
    }
    _clone(name) {
      return new internals.Server(this._core, name, this);
    }
    bind(context) {
      Hoek.assert(typeof context === "object", "bind must be an object");
      this.realm.settings.bind = context;
    }
    control(server) {
      Hoek.assert(server instanceof internals.Server, "Can only control Server objects");
      this._core.controlled = this._core.controlled ?? [];
      this._core.controlled.push(server);
    }
    decoder(encoding, decoder) {
      return this._core.compression.addDecoder(encoding, decoder);
    }
    decorate(type, property, method, options = {}) {
      Hoek.assert(this._core.decorations.public[type], "Unknown decoration type:", type);
      Hoek.assert(property, "Missing decoration property name");
      Hoek.assert(typeof property === "string" || typeof property === "symbol", "Decoration property must be a string or a symbol");
      const propertyName = property.toString();
      Hoek.assert(propertyName[0] !== "_", "Property name cannot begin with an underscore:", propertyName);
      const existing = this._core.decorations[type].get(property);
      if (options.extend) {
        Hoek.assert(type !== "handler", "Cannot extend handler decoration:", propertyName);
        Hoek.assert(existing, `Cannot extend missing ${type} decoration: ${propertyName}`);
        Hoek.assert(typeof method === "function", `Extended ${type} decoration method must be a function: ${propertyName}`);
        method = method(existing);
      } else {
        Hoek.assert(existing === undefined, `${type[0].toUpperCase() + type.slice(1)} decoration already defined: ${propertyName}`);
      }
      if (type === "handler") {
        Hoek.assert(typeof method === "function", "Handler must be a function:", propertyName);
        Hoek.assert(!method.defaults || typeof method.defaults === "object" || typeof method.defaults === "function", "Handler defaults property must be an object or function");
        Hoek.assert(!options.extend, "Cannot extend handler decoration:", propertyName);
      } else if (type === "request") {
        Hoek.assert(!this._core.Request.reserved.includes(property), "Cannot override the built-in request interface decoration:", propertyName);
        if (options.apply) {
          this._core.decorations.requestApply = this._core.decorations.requestApply ?? new Map;
          this._core.decorations.requestApply.set(property, method);
        } else {
          this._core.Request.prototype[property] = method;
        }
      } else if (type === "response") {
        Hoek.assert(!this._core.Response.reserved.includes(property), "Cannot override the built-in response interface decoration:", propertyName);
        this._core.Response.prototype[property] = method;
      } else if (type === "toolkit") {
        Hoek.assert(!Toolkit.reserved.includes(property), "Cannot override the built-in toolkit decoration:", propertyName);
        this._core.toolkit.decorate(property, method);
      } else {
        if (typeof property === "string") {
          Hoek.assert(!Object.getOwnPropertyNames(internals.Server.prototype).includes(property), "Cannot override the built-in server interface method:", propertyName);
        } else {
          Hoek.assert(!Object.getOwnPropertySymbols(internals.Server.prototype).includes(property), "Cannot override the built-in server interface method:", propertyName);
        }
        this._core.instances.forEach((server) => {
          server[property] = method;
        });
      }
      this._core.decorations[type].set(property, method);
      this._core.decorations.public[type].push(property);
    }
    dependency(dependencies, after) {
      Hoek.assert(this.realm.plugin, "Cannot call dependency() outside of a plugin");
      Hoek.assert(!after || typeof after === "function", "Invalid after method");
      if (typeof dependencies === "string") {
        dependencies = { [dependencies]: "*" };
      } else if (Array.isArray(dependencies)) {
        const map = {};
        for (const dependency of dependencies) {
          map[dependency] = "*";
        }
        dependencies = map;
      }
      this._core.dependencies.push({ plugin: this.realm.plugin, deps: dependencies });
      if (after) {
        this.ext("onPreStart", after, { after: Object.keys(dependencies) });
      }
    }
    encoder(encoding, encoder) {
      return this._core.compression.addEncoder(encoding, encoder);
    }
    event(event) {
      this._core.events.registerEvent(event);
    }
    expose(key, value, options = {}) {
      Hoek.assert(this.realm.plugin, "Cannot call expose() outside of a plugin");
      let plugin = this.realm.plugin;
      if (plugin[0] === "@" && options.scope !== true) {
        plugin = plugin.replace(/^@([^/]+)\//, ($0, $1) => {
          return !options.scope ? "" : `${$1}__`;
        });
      }
      this._core.plugins[plugin] = this._core.plugins[plugin] ?? {};
      if (typeof key === "string") {
        this._core.plugins[plugin][key] = value;
      } else {
        Hoek.merge(this._core.plugins[plugin], key);
      }
    }
    ext(events, method, options) {
      let promise;
      if (typeof events === "string") {
        if (!method) {
          const team = new Teamwork.Team;
          method = (request, h) => {
            team.attend(request);
            return h.continue;
          };
          promise = team.work;
        }
        events = { type: events, method, options };
      }
      events = Config2.apply("exts", events);
      for (const event of events) {
        this._ext(event);
      }
      return promise;
    }
    _ext(event) {
      event = Object.assign({}, event);
      event.realm = this.realm;
      const type = event.type;
      if (!this._core.extensions.server[type]) {
        if (event.options.sandbox === "plugin") {
          Hoek.assert(this.realm._extensions[type], "Unknown event type", type);
          return this.realm._extensions[type].add(event);
        }
        Hoek.assert(this._core.extensions.route[type], "Unknown event type", type);
        return this._core.extensions.route[type].add(event);
      }
      Hoek.assert(!event.options.sandbox, "Cannot specify sandbox option for server extension");
      Hoek.assert(type !== "onPreStart" || this._core.phase === "stopped", "Cannot add onPreStart (after) extension after the server was initialized");
      event.server = this;
      this._core.extensions.server[type].add(event);
    }
    async inject(options) {
      let settings = options;
      if (typeof settings === "string") {
        settings = { url: settings };
      }
      if (!settings.authority || settings.auth || settings.app || settings.plugins || settings.allowInternals !== undefined) {
        settings = Object.assign({}, settings);
        delete settings.auth;
        delete settings.app;
        delete settings.plugins;
        delete settings.allowInternals;
        settings.authority = settings.authority ?? this._core.info.host + ":" + this._core.info.port;
      }
      Hoek.assert(!options.credentials, "options.credentials no longer supported (use options.auth)");
      if (options.auth) {
        Hoek.assert(typeof options.auth === "object", "options.auth must be an object");
        Hoek.assert(options.auth.credentials, "options.auth.credentials is missing");
        Hoek.assert(options.auth.strategy, "options.auth.strategy is missing");
      }
      const needle = this._core._dispatch({
        auth: options.auth,
        allowInternals: options.allowInternals,
        app: options.app,
        plugins: options.plugins,
        isInjected: true
      });
      const res = await Shot.inject(needle, settings);
      const custom = res.raw.res[Config2.symbol];
      if (custom) {
        delete res.raw.res[Config2.symbol];
        res.request = custom.request;
        if (custom.error) {
          throw custom.error;
        }
        if (custom.result !== undefined) {
          res.result = custom.result;
        }
      }
      if (res.result === undefined) {
        res.result = res.payload;
      }
      return res;
    }
    log(tags, data) {
      return this._core.log(tags, data);
    }
    lookup(id) {
      Hoek.assert(id && typeof id === "string", "Invalid route id:", id);
      const record = this._core.router.ids.get(id);
      if (!record) {
        return null;
      }
      return record.route.public;
    }
    match(method, path2, host) {
      Hoek.assert(method && typeof method === "string", "Invalid method:", method);
      Hoek.assert(path2 && typeof path2 === "string" && path2[0] === "/", "Invalid path:", path2);
      Hoek.assert(!host || typeof host === "string", "Invalid host:", host);
      const match = this._core.router.route(method.toLowerCase(), path2, host);
      Hoek.assert(match !== this._core.router.specials.badRequest, "Invalid path:", path2);
      if (match === this._core.router.specials.notFound) {
        return null;
      }
      return match.route.public;
    }
    method(name, method, options = {}) {
      return this._core.methods.add(name, method, options, this.realm);
    }
    path(relativeTo) {
      Hoek.assert(relativeTo && typeof relativeTo === "string", "relativeTo must be a non-empty string");
      this.realm.settings.files.relativeTo = relativeTo;
    }
    async register(plugins, options = {}) {
      if (this.realm.modifiers.route.prefix || this.realm.modifiers.route.vhost) {
        options = Hoek.clone(options);
        options.routes = options.routes ?? {};
        options.routes.prefix = (this.realm.modifiers.route.prefix ?? "") + (options.routes.prefix ?? "") || undefined;
        options.routes.vhost = this.realm.modifiers.route.vhost ?? options.routes.vhost;
      }
      options = Config2.apply("register", options);
      ++this._core.registring;
      try {
        const items = [].concat(plugins);
        for (let item of items) {
          if (!item.plugin) {
            item = {
              plugin: item
            };
          } else if (!item.plugin.register) {
            item = {
              options: item.options,
              once: item.once,
              routes: item.routes,
              plugin: item.plugin.plugin
            };
          } else if (typeof item === "function") {
            item = Object.assign({}, item);
          }
          item = Config2.apply("plugin", item);
          const name = item.plugin.name ?? item.plugin.pkg.name;
          const clone = this._clone(name);
          clone.realm.modifiers.route.prefix = item.routes.prefix ?? options.routes.prefix;
          clone.realm.modifiers.route.vhost = item.routes.vhost ?? options.routes.vhost;
          clone.realm.pluginOptions = item.options ?? {};
          const requirements = item.plugin.requirements;
          Hoek.assert(!requirements.node || Config2.versionMatch(process.version, requirements.node), "Plugin", name, "requires node version", requirements.node, "but found", process.version);
          Hoek.assert(!requirements.hapi || Config2.versionMatch(this.version, requirements.hapi), "Plugin", name, "requires hapi version", requirements.hapi, "but found", this.version);
          if (this._core.registrations[name]) {
            if (item.plugin.once || item.once || options.once) {
              continue;
            }
            Hoek.assert(item.plugin.multiple, "Plugin", name, "already registered");
          } else {
            this._core.registrations[name] = {
              version: item.plugin.version ?? item.plugin.pkg.version,
              name,
              options: item.options
            };
          }
          if (item.plugin.dependencies) {
            clone.dependency(item.plugin.dependencies);
          }
          await item.plugin.register(clone, item.options ?? {});
        }
      } finally {
        --this._core.registring;
      }
      return this;
    }
    route(options) {
      Hoek.assert(typeof options === "object", "Invalid route options");
      options = [].concat(options);
      for (const config of options) {
        if (Array.isArray(config.method)) {
          for (const method of config.method) {
            const settings = Object.assign({}, config);
            settings.method = method;
            this._addRoute(settings, this);
          }
        } else {
          this._addRoute(config, this);
        }
      }
    }
    _addRoute(config, server) {
      const route = new Route(config, server);
      const vhosts = [].concat(route.settings.vhost ?? "*");
      for (const vhost of vhosts) {
        const record = this._core.router.add({ method: route.method, path: route.path, vhost, analysis: route._analysis, id: route.settings.id }, route);
        route.fingerprint = record.fingerprint;
        route.params = record.params;
      }
      this.events.emit("route", route.public);
      Cors.options(route.public, server);
    }
    rules(processor, options = {}) {
      Hoek.assert(!this.realm._rules, "Server realm rules already defined");
      const settings = Config2.apply("rules", options);
      if (settings.validate) {
        const schema = settings.validate.schema;
        settings.validate.schema = Validation.compile(schema, null, this.realm, this._core);
      }
      this.realm._rules = { processor, settings };
    }
    state(name, options) {
      this.states.add(name, options);
    }
    table(host) {
      return this._core.router.table(host);
    }
    validator(validator) {
      Hoek.assert(!this.realm.validator, "Validator already set");
      this.realm.validator = Validation.validator(validator);
    }
    start() {
      return this._core._start();
    }
    initialize() {
      return this._core._initialize();
    }
    stop(options) {
      return this._core._stop(options);
    }
  };
  internals.cache = (plugin) => {
    const policy = function(options, _segment) {
      return this._core._cachePolicy(options, _segment, plugin.realm);
    };
    policy.provision = async (opts) => {
      const clients = plugin._core._createCache(opts);
      if (["initialized", "starting", "started"].includes(plugin._core.phase)) {
        await Promise.all(clients.map((client) => client.start()));
      }
    };
    return policy;
  };
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __createBinding = function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __exportStar = function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
});

// node_modules/tsyringe/dist/cjs/types/lifecycle.js
var require_lifecycle = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var Lifecycle;
  (function(Lifecycle2) {
    Lifecycle2[Lifecycle2["Transient"] = 0] = "Transient";
    Lifecycle2[Lifecycle2["Singleton"] = 1] = "Singleton";
    Lifecycle2[Lifecycle2["ResolutionScoped"] = 2] = "ResolutionScoped";
    Lifecycle2[Lifecycle2["ContainerScoped"] = 3] = "ContainerScoped";
  })(Lifecycle || (Lifecycle = {}));
  exports.default = Lifecycle;
});

// node_modules/tsyringe/dist/cjs/types/index.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var lifecycle_1 = require_lifecycle();
  Object.defineProperty(exports, "Lifecycle", { enumerable: true, get: function() {
    return lifecycle_1.default;
  } });
});

// node_modules/tsyringe/dist/cjs/reflection-helpers.js
var require_reflection_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineInjectionTokenMetadata = exports.getParamInfo = exports.INJECTION_TOKEN_METADATA_KEY = undefined;
  exports.INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
  function getParamInfo(target) {
    const params = Reflect.getMetadata("design:paramtypes", target) || [];
    const injectionTokens = Reflect.getOwnMetadata(exports.INJECTION_TOKEN_METADATA_KEY, target) || {};
    Object.keys(injectionTokens).forEach((key) => {
      params[+key] = injectionTokens[key];
    });
    return params;
  }
  exports.getParamInfo = getParamInfo;
  function defineInjectionTokenMetadata(data, transform) {
    return function(target, _propertyKey, parameterIndex) {
      const descriptors = Reflect.getOwnMetadata(exports.INJECTION_TOKEN_METADATA_KEY, target) || {};
      descriptors[parameterIndex] = transform ? {
        token: data,
        transform: transform.transformToken,
        transformArgs: transform.args || []
      } : data;
      Reflect.defineMetadata(exports.INJECTION_TOKEN_METADATA_KEY, descriptors, target);
    };
  }
  exports.defineInjectionTokenMetadata = defineInjectionTokenMetadata;
});

// node_modules/tsyringe/dist/cjs/providers/class-provider.js
var require_class_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isClassProvider = undefined;
  function isClassProvider(provider) {
    return !!provider.useClass;
  }
  exports.isClassProvider = isClassProvider;
});

// node_modules/tsyringe/dist/cjs/providers/factory-provider.js
var require_factory_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFactoryProvider = undefined;
  function isFactoryProvider(provider) {
    return !!provider.useFactory;
  }
  exports.isFactoryProvider = isFactoryProvider;
});

// node_modules/tsyringe/dist/cjs/lazy-helpers.js
var require_lazy_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = exports.DelayedConstructor = undefined;

  class DelayedConstructor {
    constructor(wrap) {
      this.wrap = wrap;
      this.reflectMethods = [
        "get",
        "getPrototypeOf",
        "setPrototypeOf",
        "getOwnPropertyDescriptor",
        "defineProperty",
        "has",
        "set",
        "deleteProperty",
        "apply",
        "construct",
        "ownKeys"
      ];
    }
    createProxy(createObject) {
      const target = {};
      let init = false;
      let value;
      const delayedObject = () => {
        if (!init) {
          value = createObject(this.wrap());
          init = true;
        }
        return value;
      };
      return new Proxy(target, this.createHandler(delayedObject));
    }
    createHandler(delayedObject) {
      const handler = {};
      const install = (name) => {
        handler[name] = (...args) => {
          args[0] = delayedObject();
          const method = Reflect[name];
          return method(...args);
        };
      };
      this.reflectMethods.forEach(install);
      return handler;
    }
  }
  exports.DelayedConstructor = DelayedConstructor;
  function delay(wrappedConstructor) {
    if (typeof wrappedConstructor === "undefined") {
      throw new Error("Attempt to `delay` undefined. Constructor must be wrapped in a callback");
    }
    return new DelayedConstructor(wrappedConstructor);
  }
  exports.delay = delay;
});

// node_modules/tsyringe/dist/cjs/providers/injection-token.js
var require_injection_token = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isConstructorToken = exports.isTransformDescriptor = exports.isTokenDescriptor = exports.isNormalToken = undefined;
  var lazy_helpers_1 = require_lazy_helpers();
  function isNormalToken(token) {
    return typeof token === "string" || typeof token === "symbol";
  }
  exports.isNormalToken = isNormalToken;
  function isTokenDescriptor(descriptor) {
    return typeof descriptor === "object" && "token" in descriptor && "multiple" in descriptor;
  }
  exports.isTokenDescriptor = isTokenDescriptor;
  function isTransformDescriptor(descriptor) {
    return typeof descriptor === "object" && "token" in descriptor && "transform" in descriptor;
  }
  exports.isTransformDescriptor = isTransformDescriptor;
  function isConstructorToken(token) {
    return typeof token === "function" || token instanceof lazy_helpers_1.DelayedConstructor;
  }
  exports.isConstructorToken = isConstructorToken;
});

// node_modules/tsyringe/dist/cjs/providers/token-provider.js
var require_token_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTokenProvider = undefined;
  function isTokenProvider(provider) {
    return !!provider.useToken;
  }
  exports.isTokenProvider = isTokenProvider;
});

// node_modules/tsyringe/dist/cjs/providers/value-provider.js
var require_value_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValueProvider = undefined;
  function isValueProvider(provider) {
    return provider.useValue != null;
  }
  exports.isValueProvider = isValueProvider;
});

// node_modules/tsyringe/dist/cjs/providers/index.js
var require_providers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var class_provider_1 = require_class_provider();
  Object.defineProperty(exports, "isClassProvider", { enumerable: true, get: function() {
    return class_provider_1.isClassProvider;
  } });
  var factory_provider_1 = require_factory_provider();
  Object.defineProperty(exports, "isFactoryProvider", { enumerable: true, get: function() {
    return factory_provider_1.isFactoryProvider;
  } });
  var injection_token_1 = require_injection_token();
  Object.defineProperty(exports, "isNormalToken", { enumerable: true, get: function() {
    return injection_token_1.isNormalToken;
  } });
  var token_provider_1 = require_token_provider();
  Object.defineProperty(exports, "isTokenProvider", { enumerable: true, get: function() {
    return token_provider_1.isTokenProvider;
  } });
  var value_provider_1 = require_value_provider();
  Object.defineProperty(exports, "isValueProvider", { enumerable: true, get: function() {
    return value_provider_1.isValueProvider;
  } });
});

// node_modules/tsyringe/dist/cjs/providers/provider.js
var require_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isProvider = undefined;
  var class_provider_1 = require_class_provider();
  var value_provider_1 = require_value_provider();
  var token_provider_1 = require_token_provider();
  var factory_provider_1 = require_factory_provider();
  function isProvider(provider) {
    return class_provider_1.isClassProvider(provider) || value_provider_1.isValueProvider(provider) || token_provider_1.isTokenProvider(provider) || factory_provider_1.isFactoryProvider(provider);
  }
  exports.isProvider = isProvider;
});

// node_modules/tsyringe/dist/cjs/registry-base.js
var require_registry_base = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class RegistryBase {
    constructor() {
      this._registryMap = new Map;
    }
    entries() {
      return this._registryMap.entries();
    }
    getAll(key) {
      this.ensure(key);
      return this._registryMap.get(key);
    }
    get(key) {
      this.ensure(key);
      const value = this._registryMap.get(key);
      return value[value.length - 1] || null;
    }
    set(key, value) {
      this.ensure(key);
      this._registryMap.get(key).push(value);
    }
    setAll(key, value) {
      this._registryMap.set(key, value);
    }
    has(key) {
      this.ensure(key);
      return this._registryMap.get(key).length > 0;
    }
    clear() {
      this._registryMap.clear();
    }
    ensure(key) {
      if (!this._registryMap.has(key)) {
        this._registryMap.set(key, []);
      }
    }
  }
  exports.default = RegistryBase;
});

// node_modules/tsyringe/dist/cjs/registry.js
var require_registry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var registry_base_1 = require_registry_base();

  class Registry extends registry_base_1.default {
  }
  exports.default = Registry;
});

// node_modules/tsyringe/dist/cjs/resolution-context.js
var require_resolution_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class ResolutionContext {
    constructor() {
      this.scopedResolutions = new Map;
    }
  }
  exports.default = ResolutionContext;
});

// node_modules/tsyringe/dist/cjs/error-helpers.js
var require_error_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatErrorCtor = undefined;
  function formatDependency(params, idx) {
    if (params === null) {
      return `at position #${idx}`;
    }
    const argName = params.split(",")[idx].trim();
    return `"${argName}" at position #${idx}`;
  }
  function composeErrorMessage(msg, e, indent = "    ") {
    return [msg, ...e.message.split(`
`).map((l) => indent + l)].join(`
`);
  }
  function formatErrorCtor(ctor, paramIdx, error) {
    const [, params = null] = ctor.toString().match(/constructor\(([\w, ]+)\)/) || [];
    const dep = formatDependency(params, paramIdx);
    return composeErrorMessage(`Cannot inject the dependency ${dep} of "${ctor.name}" constructor. Reason:`, error);
  }
  exports.formatErrorCtor = formatErrorCtor;
});

// node_modules/tsyringe/dist/cjs/types/disposable.js
var require_disposable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDisposable = undefined;
  function isDisposable(value) {
    if (typeof value.dispose !== "function")
      return false;
    const disposeFun = value.dispose;
    if (disposeFun.length > 0) {
      return false;
    }
    return true;
  }
  exports.isDisposable = isDisposable;
});

// node_modules/tsyringe/dist/cjs/interceptors.js
var require_interceptors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PostResolutionInterceptors = exports.PreResolutionInterceptors = undefined;
  var registry_base_1 = require_registry_base();

  class PreResolutionInterceptors extends registry_base_1.default {
  }
  exports.PreResolutionInterceptors = PreResolutionInterceptors;

  class PostResolutionInterceptors extends registry_base_1.default {
  }
  exports.PostResolutionInterceptors = PostResolutionInterceptors;

  class Interceptors {
    constructor() {
      this.preResolution = new PreResolutionInterceptors;
      this.postResolution = new PostResolutionInterceptors;
    }
  }
  exports.default = Interceptors;
});

// node_modules/tsyringe/dist/cjs/dependency-container.js
var require_dependency_container = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.instance = exports.typeInfo = undefined;
  var tslib_1 = require_tslib();
  var providers_1 = require_providers();
  var provider_1 = require_provider();
  var injection_token_1 = require_injection_token();
  var registry_1 = require_registry();
  var lifecycle_1 = require_lifecycle();
  var resolution_context_1 = require_resolution_context();
  var error_helpers_1 = require_error_helpers();
  var lazy_helpers_1 = require_lazy_helpers();
  var disposable_1 = require_disposable();
  var interceptors_1 = require_interceptors();
  exports.typeInfo = new Map;

  class InternalDependencyContainer {
    constructor(parent) {
      this.parent = parent;
      this._registry = new registry_1.default;
      this.interceptors = new interceptors_1.default;
      this.disposed = false;
      this.disposables = new Set;
    }
    register(token, providerOrConstructor, options = { lifecycle: lifecycle_1.default.Transient }) {
      this.ensureNotDisposed();
      let provider;
      if (!provider_1.isProvider(providerOrConstructor)) {
        provider = { useClass: providerOrConstructor };
      } else {
        provider = providerOrConstructor;
      }
      if (providers_1.isTokenProvider(provider)) {
        const path2 = [token];
        let tokenProvider = provider;
        while (tokenProvider != null) {
          const currentToken = tokenProvider.useToken;
          if (path2.includes(currentToken)) {
            throw new Error(`Token registration cycle detected! ${[...path2, currentToken].join(" -> ")}`);
          }
          path2.push(currentToken);
          const registration = this._registry.get(currentToken);
          if (registration && providers_1.isTokenProvider(registration.provider)) {
            tokenProvider = registration.provider;
          } else {
            tokenProvider = null;
          }
        }
      }
      if (options.lifecycle === lifecycle_1.default.Singleton || options.lifecycle == lifecycle_1.default.ContainerScoped || options.lifecycle == lifecycle_1.default.ResolutionScoped) {
        if (providers_1.isValueProvider(provider) || providers_1.isFactoryProvider(provider)) {
          throw new Error(`Cannot use lifecycle "${lifecycle_1.default[options.lifecycle]}" with ValueProviders or FactoryProviders`);
        }
      }
      this._registry.set(token, { provider, options });
      return this;
    }
    registerType(from, to) {
      this.ensureNotDisposed();
      if (providers_1.isNormalToken(to)) {
        return this.register(from, {
          useToken: to
        });
      }
      return this.register(from, {
        useClass: to
      });
    }
    registerInstance(token, instance) {
      this.ensureNotDisposed();
      return this.register(token, {
        useValue: instance
      });
    }
    registerSingleton(from, to) {
      this.ensureNotDisposed();
      if (providers_1.isNormalToken(from)) {
        if (providers_1.isNormalToken(to)) {
          return this.register(from, {
            useToken: to
          }, { lifecycle: lifecycle_1.default.Singleton });
        } else if (to) {
          return this.register(from, {
            useClass: to
          }, { lifecycle: lifecycle_1.default.Singleton });
        }
        throw new Error('Cannot register a type name as a singleton without a "to" token');
      }
      let useClass = from;
      if (to && !providers_1.isNormalToken(to)) {
        useClass = to;
      }
      return this.register(from, {
        useClass
      }, { lifecycle: lifecycle_1.default.Singleton });
    }
    resolve(token, context = new resolution_context_1.default, isOptional = false) {
      this.ensureNotDisposed();
      const registration = this.getRegistration(token);
      if (!registration && providers_1.isNormalToken(token)) {
        if (isOptional) {
          return;
        }
        throw new Error(`Attempted to resolve unregistered dependency token: "${token.toString()}"`);
      }
      this.executePreResolutionInterceptor(token, "Single");
      if (registration) {
        const result = this.resolveRegistration(registration, context);
        this.executePostResolutionInterceptor(token, result, "Single");
        return result;
      }
      if (injection_token_1.isConstructorToken(token)) {
        const result = this.construct(token, context);
        this.executePostResolutionInterceptor(token, result, "Single");
        return result;
      }
      throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
    }
    executePreResolutionInterceptor(token, resolutionType) {
      if (this.interceptors.preResolution.has(token)) {
        const remainingInterceptors = [];
        for (const interceptor of this.interceptors.preResolution.getAll(token)) {
          if (interceptor.options.frequency != "Once") {
            remainingInterceptors.push(interceptor);
          }
          interceptor.callback(token, resolutionType);
        }
        this.interceptors.preResolution.setAll(token, remainingInterceptors);
      }
    }
    executePostResolutionInterceptor(token, result, resolutionType) {
      if (this.interceptors.postResolution.has(token)) {
        const remainingInterceptors = [];
        for (const interceptor of this.interceptors.postResolution.getAll(token)) {
          if (interceptor.options.frequency != "Once") {
            remainingInterceptors.push(interceptor);
          }
          interceptor.callback(token, result, resolutionType);
        }
        this.interceptors.postResolution.setAll(token, remainingInterceptors);
      }
    }
    resolveRegistration(registration, context) {
      this.ensureNotDisposed();
      if (registration.options.lifecycle === lifecycle_1.default.ResolutionScoped && context.scopedResolutions.has(registration)) {
        return context.scopedResolutions.get(registration);
      }
      const isSingleton = registration.options.lifecycle === lifecycle_1.default.Singleton;
      const isContainerScoped = registration.options.lifecycle === lifecycle_1.default.ContainerScoped;
      const returnInstance = isSingleton || isContainerScoped;
      let resolved;
      if (providers_1.isValueProvider(registration.provider)) {
        resolved = registration.provider.useValue;
      } else if (providers_1.isTokenProvider(registration.provider)) {
        resolved = returnInstance ? registration.instance || (registration.instance = this.resolve(registration.provider.useToken, context)) : this.resolve(registration.provider.useToken, context);
      } else if (providers_1.isClassProvider(registration.provider)) {
        resolved = returnInstance ? registration.instance || (registration.instance = this.construct(registration.provider.useClass, context)) : this.construct(registration.provider.useClass, context);
      } else if (providers_1.isFactoryProvider(registration.provider)) {
        resolved = registration.provider.useFactory(this);
      } else {
        resolved = this.construct(registration.provider, context);
      }
      if (registration.options.lifecycle === lifecycle_1.default.ResolutionScoped) {
        context.scopedResolutions.set(registration, resolved);
      }
      return resolved;
    }
    resolveAll(token, context = new resolution_context_1.default, isOptional = false) {
      this.ensureNotDisposed();
      const registrations = this.getAllRegistrations(token);
      if (!registrations && providers_1.isNormalToken(token)) {
        if (isOptional) {
          return [];
        }
        throw new Error(`Attempted to resolve unregistered dependency token: "${token.toString()}"`);
      }
      this.executePreResolutionInterceptor(token, "All");
      if (registrations) {
        const result2 = registrations.map((item) => this.resolveRegistration(item, context));
        this.executePostResolutionInterceptor(token, result2, "All");
        return result2;
      }
      const result = [this.construct(token, context)];
      this.executePostResolutionInterceptor(token, result, "All");
      return result;
    }
    isRegistered(token, recursive = false) {
      this.ensureNotDisposed();
      return this._registry.has(token) || recursive && (this.parent || false) && this.parent.isRegistered(token, true);
    }
    reset() {
      this.ensureNotDisposed();
      this._registry.clear();
      this.interceptors.preResolution.clear();
      this.interceptors.postResolution.clear();
    }
    clearInstances() {
      this.ensureNotDisposed();
      for (const [token, registrations] of this._registry.entries()) {
        this._registry.setAll(token, registrations.filter((registration) => !providers_1.isValueProvider(registration.provider)).map((registration) => {
          registration.instance = undefined;
          return registration;
        }));
      }
    }
    createChildContainer() {
      this.ensureNotDisposed();
      const childContainer = new InternalDependencyContainer(this);
      for (const [token, registrations] of this._registry.entries()) {
        if (registrations.some(({ options }) => options.lifecycle === lifecycle_1.default.ContainerScoped)) {
          childContainer._registry.setAll(token, registrations.map((registration) => {
            if (registration.options.lifecycle === lifecycle_1.default.ContainerScoped) {
              return {
                provider: registration.provider,
                options: registration.options
              };
            }
            return registration;
          }));
        }
      }
      return childContainer;
    }
    beforeResolution(token, callback, options = { frequency: "Always" }) {
      this.interceptors.preResolution.set(token, {
        callback,
        options
      });
    }
    afterResolution(token, callback, options = { frequency: "Always" }) {
      this.interceptors.postResolution.set(token, {
        callback,
        options
      });
    }
    dispose() {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        this.disposed = true;
        const promises = [];
        this.disposables.forEach((disposable) => {
          const maybePromise = disposable.dispose();
          if (maybePromise) {
            promises.push(maybePromise);
          }
        });
        yield Promise.all(promises);
      });
    }
    getRegistration(token) {
      if (this.isRegistered(token)) {
        return this._registry.get(token);
      }
      if (this.parent) {
        return this.parent.getRegistration(token);
      }
      return null;
    }
    getAllRegistrations(token) {
      if (this.isRegistered(token)) {
        return this._registry.getAll(token);
      }
      if (this.parent) {
        return this.parent.getAllRegistrations(token);
      }
      return null;
    }
    construct(ctor, context) {
      if (ctor instanceof lazy_helpers_1.DelayedConstructor) {
        return ctor.createProxy((target) => this.resolve(target, context));
      }
      const instance = (() => {
        const paramInfo = exports.typeInfo.get(ctor);
        if (!paramInfo || paramInfo.length === 0) {
          if (ctor.length === 0) {
            return new ctor;
          } else {
            throw new Error(`TypeInfo not known for "${ctor.name}"`);
          }
        }
        const params = paramInfo.map(this.resolveParams(context, ctor));
        return new ctor(...params);
      })();
      if (disposable_1.isDisposable(instance)) {
        this.disposables.add(instance);
      }
      return instance;
    }
    resolveParams(context, ctor) {
      return (param, idx) => {
        try {
          if (injection_token_1.isTokenDescriptor(param)) {
            if (injection_token_1.isTransformDescriptor(param)) {
              return param.multiple ? this.resolve(param.transform).transform(this.resolveAll(param.token, new resolution_context_1.default, param.isOptional), ...param.transformArgs) : this.resolve(param.transform).transform(this.resolve(param.token, context, param.isOptional), ...param.transformArgs);
            } else {
              return param.multiple ? this.resolveAll(param.token, new resolution_context_1.default, param.isOptional) : this.resolve(param.token, context, param.isOptional);
            }
          } else if (injection_token_1.isTransformDescriptor(param)) {
            return this.resolve(param.transform, context).transform(this.resolve(param.token, context), ...param.transformArgs);
          }
          return this.resolve(param, context);
        } catch (e) {
          throw new Error(error_helpers_1.formatErrorCtor(ctor, idx, e));
        }
      };
    }
    ensureNotDisposed() {
      if (this.disposed) {
        throw new Error("This container has been disposed, you cannot interact with a disposed container");
      }
    }
  }
  exports.instance = new InternalDependencyContainer;
  exports.default = exports.instance;
});

// node_modules/tsyringe/dist/cjs/decorators/auto-injectable.js
var require_auto_injectable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var reflection_helpers_1 = require_reflection_helpers();
  var dependency_container_1 = require_dependency_container();
  var injection_token_1 = require_injection_token();
  var error_helpers_1 = require_error_helpers();
  function autoInjectable() {
    return function(target) {
      const paramInfo = reflection_helpers_1.getParamInfo(target);
      return class extends target {
        constructor(...args) {
          super(...args.concat(paramInfo.slice(args.length).map((type, index) => {
            try {
              if (injection_token_1.isTokenDescriptor(type)) {
                if (injection_token_1.isTransformDescriptor(type)) {
                  return type.multiple ? dependency_container_1.instance.resolve(type.transform).transform(dependency_container_1.instance.resolveAll(type.token), ...type.transformArgs) : dependency_container_1.instance.resolve(type.transform).transform(dependency_container_1.instance.resolve(type.token), ...type.transformArgs);
                } else {
                  return type.multiple ? dependency_container_1.instance.resolveAll(type.token) : dependency_container_1.instance.resolve(type.token);
                }
              } else if (injection_token_1.isTransformDescriptor(type)) {
                return dependency_container_1.instance.resolve(type.transform).transform(dependency_container_1.instance.resolve(type.token), ...type.transformArgs);
              }
              return dependency_container_1.instance.resolve(type);
            } catch (e) {
              const argIndex = index + args.length;
              throw new Error(error_helpers_1.formatErrorCtor(target, argIndex, e));
            }
          })));
        }
      };
    };
  }
  exports.default = autoInjectable;
});

// node_modules/tsyringe/dist/cjs/decorators/inject.js
var require_inject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var reflection_helpers_1 = require_reflection_helpers();
  function inject(token, options) {
    const data = {
      token,
      multiple: false,
      isOptional: options && options.isOptional
    };
    return reflection_helpers_1.defineInjectionTokenMetadata(data);
  }
  exports.default = inject;
});

// node_modules/tsyringe/dist/cjs/decorators/injectable.js
var require_injectable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var reflection_helpers_1 = require_reflection_helpers();
  var dependency_container_1 = require_dependency_container();
  var dependency_container_2 = require_dependency_container();
  function injectable(options) {
    return function(target) {
      dependency_container_1.typeInfo.set(target, reflection_helpers_1.getParamInfo(target));
      if (options && options.token) {
        if (!Array.isArray(options.token)) {
          dependency_container_2.instance.register(options.token, target);
        } else {
          options.token.forEach((token) => {
            dependency_container_2.instance.register(token, target);
          });
        }
      }
    };
  }
  exports.default = injectable;
});

// node_modules/tsyringe/dist/cjs/decorators/registry.js
var require_registry2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var dependency_container_1 = require_dependency_container();
  function registry(registrations = []) {
    return function(target) {
      registrations.forEach((_a) => {
        var { token, options } = _a, provider = tslib_1.__rest(_a, ["token", "options"]);
        return dependency_container_1.instance.register(token, provider, options);
      });
      return target;
    };
  }
  exports.default = registry;
});

// node_modules/tsyringe/dist/cjs/decorators/singleton.js
var require_singleton = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var injectable_1 = require_injectable();
  var dependency_container_1 = require_dependency_container();
  function singleton() {
    return function(target) {
      injectable_1.default()(target);
      dependency_container_1.instance.registerSingleton(target);
    };
  }
  exports.default = singleton;
});

// node_modules/tsyringe/dist/cjs/decorators/inject-all.js
var require_inject_all = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var reflection_helpers_1 = require_reflection_helpers();
  function injectAll(token, options) {
    const data = {
      token,
      multiple: true,
      isOptional: options && options.isOptional
    };
    return reflection_helpers_1.defineInjectionTokenMetadata(data);
  }
  exports.default = injectAll;
});

// node_modules/tsyringe/dist/cjs/decorators/inject-all-with-transform.js
var require_inject_all_with_transform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var reflection_helpers_1 = require_reflection_helpers();
  function injectAllWithTransform(token, transformer, ...args) {
    const data = {
      token,
      multiple: true,
      transform: transformer,
      transformArgs: args
    };
    return reflection_helpers_1.defineInjectionTokenMetadata(data);
  }
  exports.default = injectAllWithTransform;
});

// node_modules/tsyringe/dist/cjs/decorators/inject-with-transform.js
var require_inject_with_transform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var reflection_helpers_1 = require_reflection_helpers();
  function injectWithTransform(token, transformer, ...args) {
    return reflection_helpers_1.defineInjectionTokenMetadata(token, {
      transformToken: transformer,
      args
    });
  }
  exports.default = injectWithTransform;
});

// node_modules/tsyringe/dist/cjs/decorators/scoped.js
var require_scoped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var injectable_1 = require_injectable();
  var dependency_container_1 = require_dependency_container();
  function scoped(lifecycle, token) {
    return function(target) {
      injectable_1.default()(target);
      dependency_container_1.instance.register(token || target, target, {
        lifecycle
      });
    };
  }
  exports.default = scoped;
});

// node_modules/tsyringe/dist/cjs/decorators/index.js
var require_decorators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var auto_injectable_1 = require_auto_injectable();
  Object.defineProperty(exports, "autoInjectable", { enumerable: true, get: function() {
    return auto_injectable_1.default;
  } });
  var inject_1 = require_inject();
  Object.defineProperty(exports, "inject", { enumerable: true, get: function() {
    return inject_1.default;
  } });
  var injectable_1 = require_injectable();
  Object.defineProperty(exports, "injectable", { enumerable: true, get: function() {
    return injectable_1.default;
  } });
  var registry_1 = require_registry2();
  Object.defineProperty(exports, "registry", { enumerable: true, get: function() {
    return registry_1.default;
  } });
  var singleton_1 = require_singleton();
  Object.defineProperty(exports, "singleton", { enumerable: true, get: function() {
    return singleton_1.default;
  } });
  var inject_all_1 = require_inject_all();
  Object.defineProperty(exports, "injectAll", { enumerable: true, get: function() {
    return inject_all_1.default;
  } });
  var inject_all_with_transform_1 = require_inject_all_with_transform();
  Object.defineProperty(exports, "injectAllWithTransform", { enumerable: true, get: function() {
    return inject_all_with_transform_1.default;
  } });
  var inject_with_transform_1 = require_inject_with_transform();
  Object.defineProperty(exports, "injectWithTransform", { enumerable: true, get: function() {
    return inject_with_transform_1.default;
  } });
  var scoped_1 = require_scoped();
  Object.defineProperty(exports, "scoped", { enumerable: true, get: function() {
    return scoped_1.default;
  } });
});

// node_modules/tsyringe/dist/cjs/factories/instance-caching-factory.js
var require_instance_caching_factory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function instanceCachingFactory(factoryFunc) {
    let instance;
    return (dependencyContainer) => {
      if (instance == undefined) {
        instance = factoryFunc(dependencyContainer);
      }
      return instance;
    };
  }
  exports.default = instanceCachingFactory;
});

// node_modules/tsyringe/dist/cjs/factories/instance-per-container-caching-factory.js
var require_instance_per_container_caching_factory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function instancePerContainerCachingFactory(factoryFunc) {
    const cache = new WeakMap;
    return (dependencyContainer) => {
      let instance = cache.get(dependencyContainer);
      if (instance == undefined) {
        instance = factoryFunc(dependencyContainer);
        cache.set(dependencyContainer, instance);
      }
      return instance;
    };
  }
  exports.default = instancePerContainerCachingFactory;
});

// node_modules/tsyringe/dist/cjs/factories/predicate-aware-class-factory.js
var require_predicate_aware_class_factory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function predicateAwareClassFactory(predicate, trueConstructor, falseConstructor, useCaching = true) {
    let instance;
    let previousPredicate;
    return (dependencyContainer) => {
      const currentPredicate = predicate(dependencyContainer);
      if (!useCaching || previousPredicate !== currentPredicate) {
        if (previousPredicate = currentPredicate) {
          instance = dependencyContainer.resolve(trueConstructor);
        } else {
          instance = dependencyContainer.resolve(falseConstructor);
        }
      }
      return instance;
    };
  }
  exports.default = predicateAwareClassFactory;
});

// node_modules/tsyringe/dist/cjs/factories/index.js
var require_factories = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var instance_caching_factory_1 = require_instance_caching_factory();
  Object.defineProperty(exports, "instanceCachingFactory", { enumerable: true, get: function() {
    return instance_caching_factory_1.default;
  } });
  var instance_per_container_caching_factory_1 = require_instance_per_container_caching_factory();
  Object.defineProperty(exports, "instancePerContainerCachingFactory", { enumerable: true, get: function() {
    return instance_per_container_caching_factory_1.default;
  } });
  var predicate_aware_class_factory_1 = require_predicate_aware_class_factory();
  Object.defineProperty(exports, "predicateAwareClassFactory", { enumerable: true, get: function() {
    return predicate_aware_class_factory_1.default;
  } });
});

// node_modules/tsyringe/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
    throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);
  }
  var types_1 = require_types2();
  Object.defineProperty(exports, "Lifecycle", { enumerable: true, get: function() {
    return types_1.Lifecycle;
  } });
  tslib_1.__exportStar(require_decorators(), exports);
  tslib_1.__exportStar(require_factories(), exports);
  tslib_1.__exportStar(require_providers(), exports);
  var lazy_helpers_1 = require_lazy_helpers();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return lazy_helpers_1.delay;
  } });
  var dependency_container_1 = require_dependency_container();
  Object.defineProperty(exports, "container", { enumerable: true, get: function() {
    return dependency_container_1.instance;
  } });
});

// node_modules/joi/node_modules/@hapi/hoek/lib/stringify.js
var require_stringify2 = __commonJS((exports, module) => {
  module.exports = function(...args) {
    try {
      return JSON.stringify(...args);
    } catch (err) {
      return "[Cannot display object: " + err.message + "]";
    }
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/error.js
var require_error = __commonJS((exports, module) => {
  var Stringify = require_stringify2();
  module.exports = class extends Error {
    constructor(args) {
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
      });
      super(msgs.join(" ") || "Unknown error");
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, exports.assert);
      }
    }
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/assert.js
var require_assert2 = __commonJS((exports, module) => {
  var AssertError = require_error();
  module.exports = function(condition, ...args) {
    if (condition) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Error) {
      throw args[0];
    }
    throw new AssertError(args);
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/reach.js
var require_reach2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var internals = {};
  module.exports = function(obj, chain, options) {
    if (chain === false || chain === null || chain === undefined) {
      return obj;
    }
    options = options || {};
    if (typeof options === "string") {
      options = { separator: options };
    }
    const isChainArray = Array.isArray(chain);
    Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
    const path2 = isChainArray ? chain : chain.split(options.separator || ".");
    let ref = obj;
    for (let i = 0;i < path2.length; ++i) {
      let key = path2[i];
      const type = options.iterables && internals.iterables(ref);
      if (Array.isArray(ref) || type === "set") {
        const number = Number(key);
        if (Number.isInteger(number)) {
          key = number < 0 ? ref.length + number : number;
        }
      }
      if (!ref || typeof ref === "function" && options.functions === false || !type && ref[key] === undefined) {
        Assert(!options.strict || i + 1 === path2.length, "Missing segment", key, "in reach path ", chain);
        Assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
        ref = options.default;
        break;
      }
      if (!type) {
        ref = ref[key];
      } else if (type === "set") {
        ref = [...ref][key];
      } else {
        ref = ref.get(key);
      }
    }
    return ref;
  };
  internals.iterables = function(ref) {
    if (ref instanceof Set) {
      return "set";
    }
    if (ref instanceof Map) {
      return "map";
    }
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/types.js
var require_types3 = __commonJS((exports, module) => {
  var internals = {};
  exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer && Buffer.prototype,
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
  };
  internals.typeMap = new Map([
    ["[object Error]", exports.error],
    ["[object Map]", exports.map],
    ["[object Promise]", exports.promise],
    ["[object Set]", exports.set],
    ["[object WeakMap]", exports.weakMap],
    ["[object WeakSet]", exports.weakSet]
  ]);
  exports.getInternalProto = function(obj) {
    if (Array.isArray(obj)) {
      return exports.array;
    }
    if (Buffer && obj instanceof Buffer) {
      return exports.buffer;
    }
    if (obj instanceof Date) {
      return exports.date;
    }
    if (obj instanceof RegExp) {
      return exports.regex;
    }
    if (obj instanceof Error) {
      return exports.error;
    }
    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/utils.js
var require_utils5 = __commonJS((exports) => {
  exports.keys = function(obj, options = {}) {
    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/clone.js
var require_clone2 = __commonJS((exports, module) => {
  var Reach = require_reach2();
  var Types = require_types3();
  var Utils = require_utils5();
  var internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
  };
  module.exports = internals.clone = function(obj, options = {}, _seen = null) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    let clone = internals.clone;
    let seen = _seen;
    if (options.shallow) {
      if (options.shallow !== true) {
        return internals.cloneWithShallow(obj, options);
      }
      clone = (value) => value;
    } else if (seen) {
      const lookup = seen.get(obj);
      if (lookup) {
        return lookup;
      }
    } else {
      seen = new Map;
    }
    const baseProto = Types.getInternalProto(obj);
    if (baseProto === Types.buffer) {
      return Buffer && Buffer.from(obj);
    }
    if (baseProto === Types.date) {
      return new Date(obj.getTime());
    }
    if (baseProto === Types.regex) {
      return new RegExp(obj);
    }
    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
      return obj;
    }
    if (seen) {
      seen.set(obj, newObj);
    }
    if (baseProto === Types.set) {
      for (const value of obj) {
        newObj.add(clone(value, options, seen));
      }
    } else if (baseProto === Types.map) {
      for (const [key, value] of obj) {
        newObj.set(key, clone(value, options, seen));
      }
    }
    const keys = Utils.keys(obj, options);
    for (const key of keys) {
      if (key === "__proto__") {
        continue;
      }
      if (baseProto === Types.array && key === "length") {
        newObj.length = obj.length;
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj, key);
      if (descriptor) {
        if (descriptor.get || descriptor.set) {
          Object.defineProperty(newObj, key, descriptor);
        } else if (descriptor.enumerable) {
          newObj[key] = clone(obj[key], options, seen);
        } else {
          Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
        }
      } else {
        Object.defineProperty(newObj, key, {
          enumerable: true,
          writable: true,
          configurable: true,
          value: clone(obj[key], options, seen)
        });
      }
    }
    return newObj;
  };
  internals.cloneWithShallow = function(source, options) {
    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;
    const seen = new Map;
    for (const key of keys) {
      const ref = Reach(source, key);
      if (typeof ref === "object" || typeof ref === "function") {
        seen.set(ref, ref);
      }
    }
    return internals.clone(source, options, seen);
  };
  internals.base = function(obj, baseProto, options) {
    if (options.prototype === false) {
      if (internals.needsProtoHack.has(baseProto)) {
        return new baseProto.constructor;
      }
      return baseProto === Types.array ? [] : {};
    }
    const proto2 = Object.getPrototypeOf(obj);
    if (proto2 && proto2.isImmutable) {
      return obj;
    }
    if (baseProto === Types.array) {
      const newObj = [];
      if (proto2 !== baseProto) {
        Object.setPrototypeOf(newObj, proto2);
      }
      return newObj;
    }
    if (internals.needsProtoHack.has(baseProto)) {
      const newObj = new proto2.constructor;
      if (proto2 !== baseProto) {
        Object.setPrototypeOf(newObj, proto2);
      }
      return newObj;
    }
    return Object.create(proto2);
  };
});

// node_modules/joi/package.json
var require_package4 = __commonJS((exports, module) => {
  module.exports = {
    name: "joi",
    description: "Object schema validation",
    version: "17.13.3",
    repository: "git://github.com/hapijs/joi",
    main: "lib/index.js",
    types: "lib/index.d.ts",
    browser: "dist/joi-browser.min.js",
    files: [
      "lib/**/*",
      "dist/*"
    ],
    keywords: [
      "schema",
      "validation"
    ],
    dependencies: {
      "@hapi/hoek": "^9.3.0",
      "@hapi/topo": "^5.1.0",
      "@sideway/address": "^4.1.5",
      "@sideway/formula": "^3.0.1",
      "@sideway/pinpoint": "^2.0.0"
    },
    devDependencies: {
      "@hapi/bourne": "2.x.x",
      "@hapi/code": "8.x.x",
      "@hapi/joi-legacy-test": "npm:@hapi/joi@15.x.x",
      "@hapi/lab": "^25.1.3",
      "@types/node": "^14.18.63",
      typescript: "4.3.x"
    },
    scripts: {
      prepublishOnly: "cd browser && npm install && npm run build",
      test: "lab -t 100 -a @hapi/code -L -Y",
      "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
    },
    license: "BSD-3-Clause"
  };
});

// node_modules/joi/lib/schemas.js
var require_schemas2 = __commonJS((exports) => {
  var Joi = require_lib39();
  var internals = {};
  internals.wrap = Joi.string().min(1).max(2).allow(false);
  exports.preferences = Joi.object({
    allowUnknown: Joi.boolean(),
    abortEarly: Joi.boolean(),
    artifacts: Joi.boolean(),
    cache: Joi.boolean(),
    context: Joi.object(),
    convert: Joi.boolean(),
    dateFormat: Joi.valid("date", "iso", "string", "time", "utc"),
    debug: Joi.boolean(),
    errors: {
      escapeHtml: Joi.boolean(),
      label: Joi.valid("path", "key", false),
      language: [
        Joi.string(),
        Joi.object().ref()
      ],
      render: Joi.boolean(),
      stack: Joi.boolean(),
      wrap: {
        label: internals.wrap,
        array: internals.wrap,
        string: internals.wrap
      }
    },
    externals: Joi.boolean(),
    messages: Joi.object(),
    noDefaults: Joi.boolean(),
    nonEnumerables: Joi.boolean(),
    presence: Joi.valid("required", "optional", "forbidden"),
    skipFunctions: Joi.boolean(),
    stripUnknown: Joi.object({
      arrays: Joi.boolean(),
      objects: Joi.boolean()
    }).or("arrays", "objects").allow(true, false),
    warnings: Joi.boolean()
  }).strict();
  internals.nameRx = /^[a-zA-Z0-9]\w*$/;
  internals.rule = Joi.object({
    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),
    args: Joi.array().items(Joi.string(), Joi.object({
      name: Joi.string().pattern(internals.nameRx).required(),
      ref: Joi.boolean(),
      assert: Joi.alternatives([
        Joi.function(),
        Joi.object().schema()
      ]).conditional("ref", { is: true, then: Joi.required() }),
      normalize: Joi.function(),
      message: Joi.string().when("assert", { is: Joi.function(), then: Joi.required() })
    })),
    convert: Joi.boolean(),
    manifest: Joi.boolean(),
    method: Joi.function().allow(false),
    multi: Joi.boolean(),
    validate: Joi.function()
  });
  exports.extension = Joi.object({
    type: Joi.alternatives([
      Joi.string(),
      Joi.object().regex()
    ]).required(),
    args: Joi.function(),
    cast: Joi.object().pattern(internals.nameRx, Joi.object({
      from: Joi.function().maxArity(1).required(),
      to: Joi.function().minArity(1).maxArity(2).required()
    })),
    base: Joi.object().schema().when("type", { is: Joi.object().regex(), then: Joi.forbidden() }),
    coerce: [
      Joi.function().maxArity(3),
      Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })
    ],
    flags: Joi.object().pattern(internals.nameRx, Joi.object({
      setter: Joi.string(),
      default: Joi.any()
    })),
    manifest: {
      build: Joi.function().arity(2)
    },
    messages: [Joi.object(), Joi.string()],
    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),
    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),
    prepare: Joi.function().maxArity(3),
    rebuild: Joi.function().arity(1),
    rules: Joi.object().pattern(internals.nameRx, internals.rule),
    terms: Joi.object().pattern(internals.nameRx, Joi.object({
      init: Joi.array().allow(null).required(),
      manifest: Joi.object().pattern(/.+/, [
        Joi.valid("schema", "single"),
        Joi.object({
          mapped: Joi.object({
            from: Joi.string().required(),
            to: Joi.string().required()
          }).required()
        })
      ])
    })),
    validate: Joi.function().maxArity(3)
  }).strict();
  exports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();
  internals.desc = {
    buffer: Joi.object({
      buffer: Joi.string()
    }),
    func: Joi.object({
      function: Joi.function().required(),
      options: {
        literal: true
      }
    }),
    override: Joi.object({
      override: true
    }),
    ref: Joi.object({
      ref: Joi.object({
        type: Joi.valid("value", "global", "local"),
        path: Joi.array().required(),
        separator: Joi.string().length(1).allow(false),
        ancestor: Joi.number().min(0).integer().allow("root"),
        map: Joi.array().items(Joi.array().length(2)).min(1),
        adjust: Joi.function(),
        iterables: Joi.boolean(),
        in: Joi.boolean(),
        render: Joi.boolean()
      }).required()
    }),
    regex: Joi.object({
      regex: Joi.string().min(3)
    }),
    special: Joi.object({
      special: Joi.valid("deep").required()
    }),
    template: Joi.object({
      template: Joi.string().required(),
      options: Joi.object()
    }),
    value: Joi.object({
      value: Joi.alternatives([Joi.object(), Joi.array()]).required()
    })
  };
  internals.desc.entity = Joi.alternatives([
    Joi.array().items(Joi.link("...")),
    Joi.boolean(),
    Joi.function(),
    Joi.number(),
    Joi.string(),
    internals.desc.buffer,
    internals.desc.func,
    internals.desc.ref,
    internals.desc.regex,
    internals.desc.special,
    internals.desc.template,
    internals.desc.value,
    Joi.link("/")
  ]);
  internals.desc.values = Joi.array().items(null, Joi.boolean(), Joi.function(), Joi.number().allow(Infinity, -Infinity), Joi.string().allow(""), Joi.symbol(), internals.desc.buffer, internals.desc.func, internals.desc.override, internals.desc.ref, internals.desc.regex, internals.desc.template, internals.desc.value);
  internals.desc.messages = Joi.object().pattern(/.+/, [
    Joi.string(),
    internals.desc.template,
    Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])
  ]);
  exports.description = Joi.object({
    type: Joi.string().required(),
    flags: Joi.object({
      cast: Joi.string(),
      default: Joi.any(),
      description: Joi.string(),
      empty: Joi.link("/"),
      failover: internals.desc.entity,
      id: Joi.string(),
      label: Joi.string(),
      only: true,
      presence: ["optional", "required", "forbidden"],
      result: ["raw", "strip"],
      strip: Joi.boolean(),
      unit: Joi.string()
    }).unknown(),
    preferences: {
      allowUnknown: Joi.boolean(),
      abortEarly: Joi.boolean(),
      artifacts: Joi.boolean(),
      cache: Joi.boolean(),
      convert: Joi.boolean(),
      dateFormat: ["date", "iso", "string", "time", "utc"],
      errors: {
        escapeHtml: Joi.boolean(),
        label: ["path", "key"],
        language: [
          Joi.string(),
          internals.desc.ref
        ],
        wrap: {
          label: internals.wrap,
          array: internals.wrap
        }
      },
      externals: Joi.boolean(),
      messages: internals.desc.messages,
      noDefaults: Joi.boolean(),
      nonEnumerables: Joi.boolean(),
      presence: ["required", "optional", "forbidden"],
      skipFunctions: Joi.boolean(),
      stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi.boolean()
    },
    allow: internals.desc.values,
    invalid: internals.desc.values,
    rules: Joi.array().min(1).items({
      name: Joi.string().required(),
      args: Joi.object().min(1),
      keep: Joi.boolean(),
      message: [
        Joi.string(),
        internals.desc.messages
      ],
      warn: Joi.boolean()
    }),
    keys: Joi.object().pattern(/.*/, Joi.link("/")),
    link: internals.desc.ref
  }).pattern(/^[a-z]\w*$/, Joi.any());
});

// node_modules/joi/node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml2 = __commonJS((exports, module) => {
  var internals = {};
  module.exports = function(input) {
    if (!input) {
      return "";
    }
    let escaped = "";
    for (let i = 0;i < input.length; ++i) {
      const charCode = input.charCodeAt(i);
      if (internals.isSafe(charCode)) {
        escaped += input[i];
      } else {
        escaped += internals.escapeHtmlChar(charCode);
      }
    }
    return escaped;
  };
  internals.escapeHtmlChar = function(charCode) {
    const namedEscape = internals.namedHtml.get(charCode);
    if (namedEscape) {
      return namedEscape;
    }
    if (charCode >= 256) {
      return "&#" + charCode + ";";
    }
    const hexValue = charCode.toString(16).padStart(2, "0");
    return `&#x${hexValue};`;
  };
  internals.isSafe = function(charCode) {
    return internals.safeCharCodes.has(charCode);
  };
  internals.namedHtml = new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [34, "&quot;"],
    [160, "&nbsp;"],
    [162, "&cent;"],
    [163, "&pound;"],
    [164, "&curren;"],
    [169, "&copy;"],
    [174, "&reg;"]
  ]);
  internals.safeCharCodes = function() {
    const safe = new Set;
    for (let i = 32;i < 123; ++i) {
      if (i >= 97 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 32 || i === 46 || i === 44 || i === 45 || i === 58 || i === 95) {
        safe.add(i);
      }
    }
    return safe;
  }();
});

// node_modules/@sideway/formula/lib/index.js
var require_lib36 = __commonJS((exports) => {
  var internals = {
    operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
    operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
    operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
    operatorsPrefix: ["!", "n"],
    literals: {
      '"': '"',
      "`": "`",
      "'": "'",
      "[": "]"
    },
    numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
    tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
    symbol: Symbol("formula"),
    settings: Symbol("settings")
  };
  exports.Parser = class {
    constructor(string, options = {}) {
      if (!options[internals.settings] && options.constants) {
        for (const constant in options.constants) {
          const value = options.constants[constant];
          if (value !== null && !["boolean", "number", "string"].includes(typeof value)) {
            throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
          }
        }
      }
      this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
      this.single = null;
      this._parts = null;
      this._parse(string);
    }
    _parse(string) {
      let parts = [];
      let current = "";
      let parenthesis = 0;
      let literal = false;
      const flush = (inner) => {
        if (parenthesis) {
          throw new Error("Formula missing closing parenthesis");
        }
        const last = parts.length ? parts[parts.length - 1] : null;
        if (!literal && !current && !inner) {
          return;
        }
        if (last && last.type === "reference" && inner === ")") {
          last.type = "function";
          last.value = this._subFormula(current, last.value);
          current = "";
          return;
        }
        if (inner === ")") {
          const sub = new exports.Parser(current, this.settings);
          parts.push({ type: "segment", value: sub });
        } else if (literal) {
          if (literal === "]") {
            parts.push({ type: "reference", value: current });
            current = "";
            return;
          }
          parts.push({ type: "literal", value: current });
        } else if (internals.operatorCharacters.includes(current)) {
          if (last && last.type === "operator" && internals.operators.includes(last.value + current)) {
            last.value += current;
          } else {
            parts.push({ type: "operator", value: current });
          }
        } else if (current.match(internals.numberRx)) {
          parts.push({ type: "constant", value: parseFloat(current) });
        } else if (this.settings.constants[current] !== undefined) {
          parts.push({ type: "constant", value: this.settings.constants[current] });
        } else {
          if (!current.match(internals.tokenRx)) {
            throw new Error(`Formula contains invalid token: ${current}`);
          }
          parts.push({ type: "reference", value: current });
        }
        current = "";
      };
      for (const c of string) {
        if (literal) {
          if (c === literal) {
            flush();
            literal = false;
          } else {
            current += c;
          }
        } else if (parenthesis) {
          if (c === "(") {
            current += c;
            ++parenthesis;
          } else if (c === ")") {
            --parenthesis;
            if (!parenthesis) {
              flush(c);
            } else {
              current += c;
            }
          } else {
            current += c;
          }
        } else if (c in internals.literals) {
          literal = internals.literals[c];
        } else if (c === "(") {
          flush();
          ++parenthesis;
        } else if (internals.operatorCharacters.includes(c)) {
          flush();
          current = c;
          flush();
        } else if (c !== " ") {
          current += c;
        } else {
          flush();
        }
      }
      flush();
      parts = parts.map((part, i) => {
        if (part.type !== "operator" || part.value !== "-" || i && parts[i - 1].type !== "operator") {
          return part;
        }
        return { type: "operator", value: "n" };
      });
      let operator = false;
      for (const part of parts) {
        if (part.type === "operator") {
          if (internals.operatorsPrefix.includes(part.value)) {
            continue;
          }
          if (!operator) {
            throw new Error("Formula contains an operator in invalid position");
          }
          if (!internals.operators.includes(part.value)) {
            throw new Error(`Formula contains an unknown operator ${part.value}`);
          }
        } else if (operator) {
          throw new Error("Formula missing expected operator");
        }
        operator = !operator;
      }
      if (!operator) {
        throw new Error("Formula contains invalid trailing operator");
      }
      if (parts.length === 1 && ["reference", "literal", "constant"].includes(parts[0].type)) {
        this.single = { type: parts[0].type === "reference" ? "reference" : "value", value: parts[0].value };
      }
      this._parts = parts.map((part) => {
        if (part.type === "operator") {
          return internals.operatorsPrefix.includes(part.value) ? part : part.value;
        }
        if (part.type !== "reference") {
          return part.value;
        }
        if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
          throw new Error(`Formula contains invalid reference ${part.value}`);
        }
        if (this.settings.reference) {
          return this.settings.reference(part.value);
        }
        return internals.reference(part.value);
      });
    }
    _subFormula(string, name) {
      const method = this.settings.functions[name];
      if (typeof method !== "function") {
        throw new Error(`Formula contains unknown function ${name}`);
      }
      let args = [];
      if (string) {
        let current = "";
        let parenthesis = 0;
        let literal = false;
        const flush = () => {
          if (!current) {
            throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
          }
          args.push(current);
          current = "";
        };
        for (let i = 0;i < string.length; ++i) {
          const c = string[i];
          if (literal) {
            current += c;
            if (c === literal) {
              literal = false;
            }
          } else if (c in internals.literals && !parenthesis) {
            current += c;
            literal = internals.literals[c];
          } else if (c === "," && !parenthesis) {
            flush();
          } else {
            current += c;
            if (c === "(") {
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
            }
          }
        }
        flush();
      }
      args = args.map((arg) => new exports.Parser(arg, this.settings));
      return function(context) {
        const innerValues = [];
        for (const arg of args) {
          innerValues.push(arg.evaluate(context));
        }
        return method.call(context, ...innerValues);
      };
    }
    evaluate(context) {
      const parts = this._parts.slice();
      for (let i = parts.length - 2;i >= 0; --i) {
        const part = parts[i];
        if (part && part.type === "operator") {
          const current = parts[i + 1];
          parts.splice(i + 1, 1);
          const value = internals.evaluate(current, context);
          parts[i] = internals.single(part.value, value);
        }
      }
      internals.operatorsOrder.forEach((set) => {
        for (let i = 1;i < parts.length - 1; ) {
          if (set.includes(parts[i])) {
            const operator = parts[i];
            const left = internals.evaluate(parts[i - 1], context);
            const right = internals.evaluate(parts[i + 1], context);
            parts.splice(i, 2);
            const result = internals.calculate(operator, left, right);
            parts[i - 1] = result === 0 ? 0 : result;
          } else {
            i += 2;
          }
        }
      });
      return internals.evaluate(parts[0], context);
    }
  };
  exports.Parser.prototype[internals.symbol] = true;
  internals.reference = function(name) {
    return function(context) {
      return context && context[name] !== undefined ? context[name] : null;
    };
  };
  internals.evaluate = function(part, context) {
    if (part === null) {
      return null;
    }
    if (typeof part === "function") {
      return part(context);
    }
    if (part[internals.symbol]) {
      return part.evaluate(context);
    }
    return part;
  };
  internals.single = function(operator, value) {
    if (operator === "!") {
      return value ? false : true;
    }
    const negative = -value;
    if (negative === 0) {
      return 0;
    }
    return negative;
  };
  internals.calculate = function(operator, left, right) {
    if (operator === "??") {
      return internals.exists(left) ? left : right;
    }
    if (typeof left === "string" || typeof right === "string") {
      if (operator === "+") {
        left = internals.exists(left) ? left : "";
        right = internals.exists(right) ? right : "";
        return left + right;
      }
    } else {
      switch (operator) {
        case "^":
          return Math.pow(left, right);
        case "*":
          return left * right;
        case "/":
          return left / right;
        case "%":
          return left % right;
        case "+":
          return left + right;
        case "-":
          return left - right;
      }
    }
    switch (operator) {
      case "<":
        return left < right;
      case "<=":
        return left <= right;
      case ">":
        return left > right;
      case ">=":
        return left >= right;
      case "==":
        return left === right;
      case "!=":
        return left !== right;
      case "&&":
        return left && right;
      case "||":
        return left || right;
    }
    return null;
  };
  internals.exists = function(value) {
    return value !== null && value !== undefined;
  };
});

// node_modules/joi/lib/annotate.js
var require_annotate2 = __commonJS((exports) => {
  var Clone = require_clone2();
  var Common = require_common2();
  var internals = {
    annotations: Symbol("annotations")
  };
  exports.error = function(stripColorCodes) {
    if (!this._original || typeof this._original !== "object") {
      return this.details[0].message;
    }
    const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
    const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
    const endColor = stripColorCodes ? "" : "\x1B[0m";
    const obj = Clone(this._original);
    for (let i = this.details.length - 1;i >= 0; --i) {
      const pos = i + 1;
      const error = this.details[i];
      const path2 = error.path;
      let node = obj;
      for (let j = 0;; ++j) {
        const seg = path2[j];
        if (Common.isSchema(node)) {
          node = node.clone();
        }
        if (j + 1 < path2.length && typeof node[seg] !== "string") {
          node = node[seg];
        } else {
          const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
          node[internals.annotations] = refAnnotations;
          const cacheKey = seg || error.context.key;
          if (node[seg] !== undefined) {
            refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
            refAnnotations.errors[cacheKey].push(pos);
          } else {
            refAnnotations.missing[cacheKey] = pos;
          }
          break;
        }
      }
    }
    const replacers = {
      key: /_\$key\$_([, \d]+)_\$end\$_"/g,
      missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
      arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
      specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };
    let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
    message = `${message}
${redFgEscape}`;
    for (let i = 0;i < this.details.length; ++i) {
      const pos = i + 1;
      message = `${message}
[${pos}] ${this.details[i].message}`;
    }
    message = message + endColor;
    return message;
  };
  internals.safeStringify = function(obj, spaces) {
    return JSON.stringify(obj, internals.serializer(), spaces);
  };
  internals.serializer = function() {
    const keys = [];
    const stack = [];
    const cycleReplacer = (key, value) => {
      if (stack[0] === value) {
        return "[Circular ~]";
      }
      return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
    };
    return function(key, value) {
      if (stack.length > 0) {
        const thisPos = stack.indexOf(this);
        if (~thisPos) {
          stack.length = thisPos + 1;
          keys.length = thisPos + 1;
          keys[thisPos] = key;
        } else {
          stack.push(this);
          keys.push(key);
        }
        if (~stack.indexOf(value)) {
          value = cycleReplacer.call(this, key, value);
        }
      } else {
        stack.push(value);
      }
      if (value) {
        const annotations = value[internals.annotations];
        if (annotations) {
          if (Array.isArray(value)) {
            const annotated = [];
            for (let i = 0;i < value.length; ++i) {
              if (annotations.errors[i]) {
                annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
              }
              annotated.push(value[i]);
            }
            value = annotated;
          } else {
            for (const errorKey in annotations.errors) {
              value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
              value[errorKey] = undefined;
            }
            for (const missingKey in annotations.missing) {
              value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
            }
          }
          return value;
        }
      }
      if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
        return "[" + value.toString() + "]";
      }
      return value;
    };
  };
});

// node_modules/joi/lib/errors.js
var require_errors3 = __commonJS((exports) => {
  var Annotate = require_annotate2();
  var Common = require_common2();
  var Template = require_template2();
  exports.Report = class {
    constructor(code, value, local, flags, messages, state, prefs) {
      this.code = code;
      this.flags = flags;
      this.messages = messages;
      this.path = state.path;
      this.prefs = prefs;
      this.state = state;
      this.value = value;
      this.message = null;
      this.template = null;
      this.local = local || {};
      this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);
      if (this.value !== undefined && !this.local.hasOwnProperty("value")) {
        this.local.value = this.value;
      }
      if (this.path.length) {
        const key = this.path[this.path.length - 1];
        if (typeof key !== "object") {
          this.local.key = key;
        }
      }
    }
    _setTemplate(template) {
      this.template = template;
      if (!this.flags.label && this.path.length === 0) {
        const localized = this._template(this.template, "root");
        if (localized) {
          this.local.label = localized;
        }
      }
    }
    toString() {
      if (this.message) {
        return this.message;
      }
      const code = this.code;
      if (!this.prefs.errors.render) {
        return this.code;
      }
      const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
      if (template === undefined) {
        return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
      }
      this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
      if (!this.prefs.errors.label) {
        this.message = this.message.replace(/^"" /, "").trim();
      }
      return this.message;
    }
    _template(messages, code) {
      return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
    }
  };
  exports.path = function(path2) {
    let label = "";
    for (const segment of path2) {
      if (typeof segment === "object") {
        continue;
      }
      if (typeof segment === "string") {
        if (label) {
          label += ".";
        }
        label += segment;
      } else {
        label += `[${segment}]`;
      }
    }
    return label;
  };
  exports.template = function(value, messages, code, state, prefs) {
    if (!messages) {
      return;
    }
    if (Template.isTemplate(messages)) {
      return code !== "root" ? messages : null;
    }
    let lang = prefs.errors.language;
    if (Common.isResolvable(lang)) {
      lang = lang.resolve(value, state, prefs);
    }
    if (lang && messages[lang]) {
      if (messages[lang][code] !== undefined) {
        return messages[lang][code];
      }
      if (messages[lang]["*"] !== undefined) {
        return messages[lang]["*"];
      }
    }
    if (!messages[code]) {
      return messages["*"];
    }
    return messages[code];
  };
  exports.label = function(flags, state, prefs, messages) {
    if (!prefs.errors.label) {
      return "";
    }
    if (flags.label) {
      return flags.label;
    }
    let path2 = state.path;
    if (prefs.errors.label === "key" && state.path.length > 1) {
      path2 = state.path.slice(-1);
    }
    const normalized = exports.path(path2);
    if (normalized) {
      return normalized;
    }
    return exports.template(null, prefs.messages, "root", state, prefs) || messages && exports.template(null, messages, "root", state, prefs) || "value";
  };
  exports.process = function(errors, original, prefs) {
    if (!errors) {
      return null;
    }
    const { override, message, details } = exports.details(errors);
    if (override) {
      return override;
    }
    if (prefs.errors.stack) {
      return new exports.ValidationError(message, details, original);
    }
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const validationError = new exports.ValidationError(message, details, original);
    Error.stackTraceLimit = limit;
    return validationError;
  };
  exports.details = function(errors, options = {}) {
    let messages = [];
    const details = [];
    for (const item of errors) {
      if (item instanceof Error) {
        if (options.override !== false) {
          return { override: item };
        }
        const message2 = item.toString();
        messages.push(message2);
        details.push({
          message: message2,
          type: "override",
          context: { error: item }
        });
        continue;
      }
      const message = item.toString();
      messages.push(message);
      details.push({
        message,
        path: item.path.filter((v) => typeof v !== "object"),
        type: item.code,
        context: item.local
      });
    }
    if (messages.length > 1) {
      messages = [...new Set(messages)];
    }
    return { message: messages.join(". "), details };
  };
  exports.ValidationError = class extends Error {
    constructor(message, details, original) {
      super(message);
      this._original = original;
      this.details = details;
    }
    static isError(err) {
      return err instanceof exports.ValidationError;
    }
  };
  exports.ValidationError.prototype.isJoi = true;
  exports.ValidationError.prototype.name = "ValidationError";
  exports.ValidationError.prototype.annotate = Annotate.error;
});

// node_modules/joi/lib/ref.js
var require_ref2 = __commonJS((exports) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Reach = require_reach2();
  var Common = require_common2();
  var Template;
  var internals = {
    symbol: Symbol("ref"),
    defaults: {
      adjust: null,
      in: false,
      iterables: null,
      map: null,
      separator: ".",
      type: "value"
    }
  };
  exports.create = function(key, options = {}) {
    Assert(typeof key === "string", "Invalid reference key:", key);
    Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]);
    Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
    const ref = Object.assign({}, internals.defaults, options);
    delete ref.prefix;
    const separator = ref.separator;
    const context = internals.context(key, separator, options.prefix);
    ref.type = context.type;
    key = context.key;
    if (ref.type === "value") {
      if (context.root) {
        Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
        ref.ancestor = "root";
        if (!key) {
          key = null;
        }
      }
      if (separator && separator === key) {
        key = null;
        ref.ancestor = 0;
      } else {
        if (ref.ancestor !== undefined) {
          Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
        } else {
          const [ancestor, slice] = internals.ancestor(key, separator);
          if (slice) {
            key = key.slice(slice);
            if (key === "") {
              key = null;
            }
          }
          ref.ancestor = ancestor;
        }
      }
    }
    ref.path = separator ? key === null ? [] : key.split(separator) : [key];
    return new internals.Ref(ref);
  };
  exports.in = function(key, options = {}) {
    return exports.create(key, { ...options, in: true });
  };
  exports.isRef = function(ref) {
    return ref ? !!ref[Common.symbols.ref] : false;
  };
  internals.Ref = class {
    constructor(options) {
      Assert(typeof options === "object", "Invalid reference construction");
      Common.assertOptions(options, [
        "adjust",
        "ancestor",
        "in",
        "iterables",
        "map",
        "path",
        "render",
        "separator",
        "type",
        "depth",
        "key",
        "root",
        "display"
      ]);
      Assert([false, undefined].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
      Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
      Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
      Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
      Object.assign(this, internals.defaults, options);
      Assert(this.type === "value" || this.ancestor === undefined, "Non-value references cannot reference ancestors");
      if (Array.isArray(this.map)) {
        this.map = new Map(this.map);
      }
      this.depth = this.path.length;
      this.key = this.path.length ? this.path.join(this.separator) : null;
      this.root = this.path[0];
      this.updateDisplay();
    }
    resolve(value, state, prefs, local, options = {}) {
      Assert(!this.in || options.in, "Invalid in() reference usage");
      if (this.type === "global") {
        return this._resolve(prefs.context, state, options);
      }
      if (this.type === "local") {
        return this._resolve(local, state, options);
      }
      if (!this.ancestor) {
        return this._resolve(value, state, options);
      }
      if (this.ancestor === "root") {
        return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
      }
      Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
      return this._resolve(state.ancestors[this.ancestor - 1], state, options);
    }
    _resolve(target, state, options) {
      let resolved;
      if (this.type === "value" && state.mainstay.shadow && options.shadow !== false) {
        resolved = state.mainstay.shadow.get(this.absolute(state));
      }
      if (resolved === undefined) {
        resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
      }
      if (this.adjust) {
        resolved = this.adjust(resolved);
      }
      if (this.map) {
        const mapped = this.map.get(resolved);
        if (mapped !== undefined) {
          resolved = mapped;
        }
      }
      if (state.mainstay) {
        state.mainstay.tracer.resolve(state, this, resolved);
      }
      return resolved;
    }
    toString() {
      return this.display;
    }
    absolute(state) {
      return [...state.path.slice(0, -this.ancestor), ...this.path];
    }
    clone() {
      return new internals.Ref(this);
    }
    describe() {
      const ref = { path: this.path };
      if (this.type !== "value") {
        ref.type = this.type;
      }
      if (this.separator !== ".") {
        ref.separator = this.separator;
      }
      if (this.type === "value" && this.ancestor !== 1) {
        ref.ancestor = this.ancestor;
      }
      if (this.map) {
        ref.map = [...this.map];
      }
      for (const key of ["adjust", "iterables", "render"]) {
        if (this[key] !== null && this[key] !== undefined) {
          ref[key] = this[key];
        }
      }
      if (this.in !== false) {
        ref.in = true;
      }
      return { ref };
    }
    updateDisplay() {
      const key = this.key !== null ? this.key : "";
      if (this.type !== "value") {
        this.display = `ref:${this.type}:${key}`;
        return;
      }
      if (!this.separator) {
        this.display = `ref:${key}`;
        return;
      }
      if (!this.ancestor) {
        this.display = `ref:${this.separator}${key}`;
        return;
      }
      if (this.ancestor === "root") {
        this.display = `ref:root:${key}`;
        return;
      }
      if (this.ancestor === 1) {
        this.display = `ref:${key || ".."}`;
        return;
      }
      const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
      this.display = `ref:${lead}${key || ""}`;
    }
  };
  internals.Ref.prototype[Common.symbols.ref] = true;
  exports.build = function(desc) {
    desc = Object.assign({}, internals.defaults, desc);
    if (desc.type === "value" && desc.ancestor === undefined) {
      desc.ancestor = 1;
    }
    return new internals.Ref(desc);
  };
  internals.context = function(key, separator, prefix = {}) {
    key = key.trim();
    if (prefix) {
      const globalp = prefix.global === undefined ? "$" : prefix.global;
      if (globalp !== separator && key.startsWith(globalp)) {
        return { key: key.slice(globalp.length), type: "global" };
      }
      const local = prefix.local === undefined ? "#" : prefix.local;
      if (local !== separator && key.startsWith(local)) {
        return { key: key.slice(local.length), type: "local" };
      }
      const root = prefix.root === undefined ? "/" : prefix.root;
      if (root !== separator && key.startsWith(root)) {
        return { key: key.slice(root.length), type: "value", root: true };
      }
    }
    return { key, type: "value" };
  };
  internals.ancestor = function(key, separator) {
    if (!separator) {
      return [1, 0];
    }
    if (key[0] !== separator) {
      return [1, 0];
    }
    if (key[1] !== separator) {
      return [0, 1];
    }
    let i = 2;
    while (key[i] === separator) {
      ++i;
    }
    return [i - 1, i];
  };
  exports.toSibling = 0;
  exports.toParent = 1;
  exports.Manager = class {
    constructor() {
      this.refs = [];
    }
    register(source, target) {
      if (!source) {
        return;
      }
      target = target === undefined ? exports.toParent : target;
      if (Array.isArray(source)) {
        for (const ref of source) {
          this.register(ref, target);
        }
        return;
      }
      if (Common.isSchema(source)) {
        for (const item of source._refs.refs) {
          if (item.ancestor - target >= 0) {
            this.refs.push({ ancestor: item.ancestor - target, root: item.root });
          }
        }
        return;
      }
      if (exports.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
        this.refs.push({ ancestor: source.ancestor - target, root: source.root });
      }
      Template = Template || require_template2();
      if (Template.isTemplate(source)) {
        this.register(source.refs(), target);
      }
    }
    get length() {
      return this.refs.length;
    }
    clone() {
      const copy = new exports.Manager;
      copy.refs = Clone(this.refs);
      return copy;
    }
    reset() {
      this.refs = [];
    }
    roots() {
      return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
    }
  };
});

// node_modules/joi/lib/template.js
var require_template2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var EscapeHtml = require_escapeHtml2();
  var Formula = require_lib36();
  var Common = require_common2();
  var Errors = require_errors3();
  var Ref = require_ref2();
  var internals = {
    symbol: Symbol("template"),
    opens: new Array(1000).join("\x00"),
    closes: new Array(1000).join("\x01"),
    dateFormat: {
      date: Date.prototype.toDateString,
      iso: Date.prototype.toISOString,
      string: Date.prototype.toString,
      time: Date.prototype.toTimeString,
      utc: Date.prototype.toUTCString
    }
  };
  module.exports = exports = internals.Template = class {
    constructor(source, options) {
      Assert(typeof source === "string", "Template source must be a string");
      Assert(!source.includes("\x00") && !source.includes("\x01"), "Template source cannot contain reserved control characters");
      this.source = source;
      this.rendered = source;
      this._template = null;
      if (options) {
        const { functions, ...opts } = options;
        this._settings = Object.keys(opts).length ? Clone(opts) : undefined;
        this._functions = functions;
        if (this._functions) {
          Assert(Object.keys(this._functions).every((key) => typeof key === "string"), "Functions keys must be strings");
          Assert(Object.values(this._functions).every((key) => typeof key === "function"), "Functions values must be functions");
        }
      } else {
        this._settings = undefined;
        this._functions = undefined;
      }
      this._parse();
    }
    _parse() {
      if (!this.source.includes("{")) {
        return;
      }
      const encoded = internals.encode(this.source);
      const parts = internals.split(encoded);
      let refs = false;
      const processed = [];
      const head = parts.shift();
      if (head) {
        processed.push(head);
      }
      for (const part of parts) {
        const raw = part[0] !== "{";
        const ender = raw ? "}" : "}}";
        const end = part.indexOf(ender);
        if (end === -1 || part[1] === "{") {
          processed.push(`{${internals.decode(part)}`);
          continue;
        }
        let variable = part.slice(raw ? 0 : 1, end);
        const wrapped = variable[0] === ":";
        if (wrapped) {
          variable = variable.slice(1);
        }
        const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
        processed.push(dynamic);
        if (typeof dynamic !== "string") {
          refs = true;
        }
        const rest = part.slice(end + ender.length);
        if (rest) {
          processed.push(internals.decode(rest));
        }
      }
      if (!refs) {
        this.rendered = processed.join("");
        return;
      }
      this._template = processed;
    }
    static date(date, prefs) {
      return internals.dateFormat[prefs.dateFormat].call(date);
    }
    describe(options = {}) {
      if (!this._settings && options.compact) {
        return this.source;
      }
      const desc = { template: this.source };
      if (this._settings) {
        desc.options = this._settings;
      }
      if (this._functions) {
        desc.functions = this._functions;
      }
      return desc;
    }
    static build(desc) {
      return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : undefined);
    }
    isDynamic() {
      return !!this._template;
    }
    static isTemplate(template) {
      return template ? !!template[Common.symbols.template] : false;
    }
    refs() {
      if (!this._template) {
        return;
      }
      const refs = [];
      for (const part of this._template) {
        if (typeof part !== "string") {
          refs.push(...part.refs);
        }
      }
      return refs;
    }
    resolve(value, state, prefs, local) {
      if (this._template && this._template.length === 1) {
        return this._part(this._template[0], value, state, prefs, local, {});
      }
      return this.render(value, state, prefs, local);
    }
    _part(part, ...args) {
      if (part.ref) {
        return part.ref.resolve(...args);
      }
      return part.formula.evaluate(args);
    }
    render(value, state, prefs, local, options = {}) {
      if (!this.isDynamic()) {
        return this.rendered;
      }
      const parts = [];
      for (const part of this._template) {
        if (typeof part === "string") {
          parts.push(part);
        } else {
          const rendered = this._part(part, value, state, prefs, local, options);
          const string = internals.stringify(rendered, value, state, prefs, local, options);
          if (string !== undefined) {
            const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
            parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
          }
        }
      }
      return parts.join("");
    }
    _ref(content, { raw, wrapped }) {
      const refs = [];
      const reference = (variable) => {
        const ref = Ref.create(variable, this._settings);
        refs.push(ref);
        return (context) => {
          const resolved = ref.resolve(...context);
          return resolved !== undefined ? resolved : null;
        };
      };
      try {
        const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;
        var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });
      } catch (err) {
        err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
        throw err;
      }
      if (formula.single) {
        if (formula.single.type === "reference") {
          const ref = refs[0];
          return { ref, raw, refs, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
        }
        return internals.stringify(formula.single.value);
      }
      return { formula, raw, refs };
    }
    toString() {
      return this.source;
    }
  };
  internals.Template.prototype[Common.symbols.template] = true;
  internals.Template.prototype.isImmutable = true;
  internals.encode = function(string) {
    return string.replace(/\\(\{+)/g, ($0, $1) => {
      return internals.opens.slice(0, $1.length);
    }).replace(/\\(\}+)/g, ($0, $1) => {
      return internals.closes.slice(0, $1.length);
    });
  };
  internals.decode = function(string) {
    return string.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
  };
  internals.split = function(string) {
    const parts = [];
    let current = "";
    for (let i = 0;i < string.length; ++i) {
      const char = string[i];
      if (char === "{") {
        let next = "";
        while (i + 1 < string.length && string[i + 1] === "{") {
          next += "{";
          ++i;
        }
        parts.push(current);
        current = next;
      } else {
        current += char;
      }
    }
    parts.push(current);
    return parts;
  };
  internals.wrap = function(value, ends) {
    if (!ends) {
      return value;
    }
    if (ends.length === 1) {
      return `${ends}${value}${ends}`;
    }
    return `${ends[0]}${value}${ends[1]}`;
  };
  internals.stringify = function(value, original, state, prefs, local, options = {}) {
    const type = typeof value;
    const wrap = prefs && prefs.errors && prefs.errors.wrap || {};
    let skipWrap = false;
    if (Ref.isRef(value) && value.render) {
      skipWrap = value.in;
      value = value.resolve(original, state, prefs, local, { in: value.in, ...options });
    }
    if (value === null) {
      return "null";
    }
    if (type === "string") {
      return internals.wrap(value, options.arrayItems && wrap.string);
    }
    if (type === "number" || type === "function" || type === "symbol") {
      return value.toString();
    }
    if (type !== "object") {
      return JSON.stringify(value);
    }
    if (value instanceof Date) {
      return internals.Template.date(value, prefs);
    }
    if (value instanceof Map) {
      const pairs = [];
      for (const [key, sym] of value.entries()) {
        pairs.push(`${key.toString()} -> ${sym.toString()}`);
      }
      value = pairs;
    }
    if (!Array.isArray(value)) {
      return value.toString();
    }
    const values = [];
    for (const item of value) {
      values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options }));
    }
    return internals.wrap(values.join(", "), !skipWrap && wrap.array);
  };
  internals.constants = {
    true: true,
    false: false,
    null: null,
    second: 1000,
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000
  };
  internals.functions = {
    if(condition, then, otherwise) {
      return condition ? then : otherwise;
    },
    length(item) {
      if (typeof item === "string") {
        return item.length;
      }
      if (!item || typeof item !== "object") {
        return null;
      }
      if (Array.isArray(item)) {
        return item.length;
      }
      return Object.keys(item).length;
    },
    msg(code) {
      const [value, state, prefs, local, options] = this;
      const messages = options.messages;
      if (!messages) {
        return "";
      }
      const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
      if (!template) {
        return "";
      }
      return template.render(value, state, prefs, local, options);
    },
    number(value) {
      if (typeof value === "number") {
        return value;
      }
      if (typeof value === "string") {
        return parseFloat(value);
      }
      if (typeof value === "boolean") {
        return value ? 1 : 0;
      }
      if (value instanceof Date) {
        return value.getTime();
      }
      return null;
    }
  };
});

// node_modules/joi/lib/messages.js
var require_messages3 = __commonJS((exports) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Template = require_template2();
  exports.compile = function(messages, target) {
    if (typeof messages === "string") {
      Assert(!target, "Cannot set single message string");
      return new Template(messages);
    }
    if (Template.isTemplate(messages)) {
      Assert(!target, "Cannot set single message template");
      return messages;
    }
    Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
    target = target ? Clone(target) : {};
    for (let code in messages) {
      const message = messages[code];
      if (code === "root" || Template.isTemplate(message)) {
        target[code] = message;
        continue;
      }
      if (typeof message === "string") {
        target[code] = new Template(message);
        continue;
      }
      Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
      const language = code;
      target[language] = target[language] || {};
      for (code in message) {
        const localized = message[code];
        if (code === "root" || Template.isTemplate(localized)) {
          target[language][code] = localized;
          continue;
        }
        Assert(typeof localized === "string", "Invalid message for", code, "in", language);
        target[language][code] = new Template(localized);
      }
    }
    return target;
  };
  exports.decompile = function(messages) {
    const target = {};
    for (let code in messages) {
      const message = messages[code];
      if (code === "root") {
        target.root = message;
        continue;
      }
      if (Template.isTemplate(message)) {
        target[code] = message.describe({ compact: true });
        continue;
      }
      const language = code;
      target[language] = {};
      for (code in message) {
        const localized = message[code];
        if (code === "root") {
          target[language].root = localized;
          continue;
        }
        target[language][code] = localized.describe({ compact: true });
      }
    }
    return target;
  };
  exports.merge = function(base, extended) {
    if (!base) {
      return exports.compile(extended);
    }
    if (!extended) {
      return base;
    }
    if (typeof extended === "string") {
      return new Template(extended);
    }
    if (Template.isTemplate(extended)) {
      return extended;
    }
    const target = Clone(base);
    for (let code in extended) {
      const message = extended[code];
      if (code === "root" || Template.isTemplate(message)) {
        target[code] = message;
        continue;
      }
      if (typeof message === "string") {
        target[code] = new Template(message);
        continue;
      }
      Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
      const language = code;
      target[language] = target[language] || {};
      for (code in message) {
        const localized = message[code];
        if (code === "root" || Template.isTemplate(localized)) {
          target[language][code] = localized;
          continue;
        }
        Assert(typeof localized === "string", "Invalid message for", code, "in", language);
        target[language][code] = new Template(localized);
      }
    }
    return target;
  };
});

// node_modules/joi/lib/common.js
var require_common2 = __commonJS((exports) => {
  var Assert = require_assert2();
  var AssertError = require_error();
  var Pkg = require_package4();
  var Messages;
  var Schemas;
  var internals = {
    isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
  };
  exports.version = Pkg.version;
  exports.defaults = {
    abortEarly: true,
    allowUnknown: false,
    artifacts: false,
    cache: true,
    context: null,
    convert: true,
    dateFormat: "iso",
    errors: {
      escapeHtml: false,
      label: "path",
      language: null,
      render: true,
      stack: false,
      wrap: {
        label: '"',
        array: "[]"
      }
    },
    externals: true,
    messages: {},
    nonEnumerables: false,
    noDefaults: false,
    presence: "optional",
    skipFunctions: false,
    stripUnknown: false,
    warnings: false
  };
  exports.symbols = {
    any: Symbol.for("@hapi/joi/schema"),
    arraySingle: Symbol("arraySingle"),
    deepDefault: Symbol("deepDefault"),
    errors: Symbol("errors"),
    literal: Symbol("literal"),
    override: Symbol("override"),
    parent: Symbol("parent"),
    prefs: Symbol("prefs"),
    ref: Symbol("ref"),
    template: Symbol("template"),
    values: Symbol("values")
  };
  exports.assertOptions = function(options, keys, name = "Options") {
    Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
  };
  exports.checkPreferences = function(prefs) {
    Schemas = Schemas || require_schemas2();
    const result = Schemas.preferences.validate(prefs);
    if (result.error) {
      throw new AssertError([result.error.details[0].message]);
    }
  };
  exports.compare = function(a, b, operator) {
    switch (operator) {
      case "=":
        return a === b;
      case ">":
        return a > b;
      case "<":
        return a < b;
      case ">=":
        return a >= b;
      case "<=":
        return a <= b;
    }
  };
  exports.default = function(value, defaultValue) {
    return value === undefined ? defaultValue : value;
  };
  exports.isIsoDate = function(date) {
    return internals.isoDate.test(date);
  };
  exports.isNumber = function(value) {
    return typeof value === "number" && !isNaN(value);
  };
  exports.isResolvable = function(obj) {
    if (!obj) {
      return false;
    }
    return obj[exports.symbols.ref] || obj[exports.symbols.template];
  };
  exports.isSchema = function(schema, options = {}) {
    const any = schema && schema[exports.symbols.any];
    if (!any) {
      return false;
    }
    Assert(options.legacy || any.version === exports.version, "Cannot mix different versions of joi schemas");
    return true;
  };
  exports.isValues = function(obj) {
    return obj[exports.symbols.values];
  };
  exports.limit = function(value) {
    return Number.isSafeInteger(value) && value >= 0;
  };
  exports.preferences = function(target, source) {
    Messages = Messages || require_messages3();
    target = target || {};
    source = source || {};
    const merged = Object.assign({}, target, source);
    if (source.errors && target.errors) {
      merged.errors = Object.assign({}, target.errors, source.errors);
      merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
    }
    if (source.messages) {
      merged.messages = Messages.compile(source.messages, target.messages);
    }
    delete merged[exports.symbols.prefs];
    return merged;
  };
  exports.tryWithPath = function(fn, key, options = {}) {
    try {
      return fn();
    } catch (err) {
      if (err.path !== undefined) {
        err.path = key + "." + err.path;
      } else {
        err.path = key;
      }
      if (options.append) {
        err.message = `${err.message} (${err.path})`;
      }
      throw err;
    }
  };
  exports.validateArg = function(value, label, { assert, message }) {
    if (exports.isSchema(assert)) {
      const result = assert.validate(value);
      if (!result.error) {
        return;
      }
      return result.error.message;
    } else if (!assert(value)) {
      return label ? `${label} ${message}` : message;
    }
  };
  exports.verifyFlat = function(args, method) {
    for (const arg of args) {
      Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
    }
  };
});

// node_modules/joi/lib/cache.js
var require_cache2 = __commonJS((exports) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Common = require_common2();
  var internals = {
    max: 1000,
    supported: new Set(["undefined", "boolean", "number", "string"])
  };
  exports.provider = {
    provision(options) {
      return new internals.Cache(options);
    }
  };
  internals.Cache = class {
    constructor(options = {}) {
      Common.assertOptions(options, ["max"]);
      Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), "Invalid max cache size");
      this._max = options.max || internals.max;
      this._map = new Map;
      this._list = new internals.List;
    }
    get length() {
      return this._map.size;
    }
    set(key, value) {
      if (key !== null && !internals.supported.has(typeof key)) {
        return;
      }
      let node = this._map.get(key);
      if (node) {
        node.value = value;
        this._list.first(node);
        return;
      }
      node = this._list.unshift({ key, value });
      this._map.set(key, node);
      this._compact();
    }
    get(key) {
      const node = this._map.get(key);
      if (node) {
        this._list.first(node);
        return Clone(node.value);
      }
    }
    _compact() {
      if (this._map.size > this._max) {
        const node = this._list.pop();
        this._map.delete(node.key);
      }
    }
  };
  internals.List = class {
    constructor() {
      this.tail = null;
      this.head = null;
    }
    unshift(node) {
      node.next = null;
      node.prev = this.head;
      if (this.head) {
        this.head.next = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      return node;
    }
    first(node) {
      if (node === this.head) {
        return;
      }
      this._remove(node);
      this.unshift(node);
    }
    pop() {
      return this._remove(this.tail);
    }
    _remove(node) {
      const { next, prev } = node;
      next.prev = prev;
      if (prev) {
        prev.next = next;
      }
      if (node === this.tail) {
        this.tail = next;
      }
      node.prev = null;
      node.next = null;
      return node;
    }
  };
});

// node_modules/joi/lib/compile.js
var require_compile2 = __commonJS((exports) => {
  var Assert = require_assert2();
  var Common = require_common2();
  var Ref = require_ref2();
  var internals = {};
  exports.schema = function(Joi, config, options = {}) {
    Common.assertOptions(options, ["appendPath", "override"]);
    try {
      return internals.schema(Joi, config, options);
    } catch (err) {
      if (options.appendPath && err.path !== undefined) {
        err.message = `${err.message} (${err.path})`;
      }
      throw err;
    }
  };
  internals.schema = function(Joi, config, options) {
    Assert(config !== undefined, "Invalid undefined schema");
    if (Array.isArray(config)) {
      Assert(config.length, "Invalid empty array schema");
      if (config.length === 1) {
        config = config[0];
      }
    }
    const valid = (base, ...values) => {
      if (options.override !== false) {
        return base.valid(Joi.override, ...values);
      }
      return base.valid(...values);
    };
    if (internals.simple(config)) {
      return valid(Joi, config);
    }
    if (typeof config === "function") {
      return Joi.custom(config);
    }
    Assert(typeof config === "object", "Invalid schema content:", typeof config);
    if (Common.isResolvable(config)) {
      return valid(Joi, config);
    }
    if (Common.isSchema(config)) {
      return config;
    }
    if (Array.isArray(config)) {
      for (const item of config) {
        if (!internals.simple(item)) {
          return Joi.alternatives().try(...config);
        }
      }
      return valid(Joi, ...config);
    }
    if (config instanceof RegExp) {
      return Joi.string().regex(config);
    }
    if (config instanceof Date) {
      return valid(Joi.date(), config);
    }
    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
    return Joi.object().keys(config);
  };
  exports.ref = function(id, options) {
    return Ref.isRef(id) ? id : Ref.create(id, options);
  };
  exports.compile = function(root, schema, options = {}) {
    Common.assertOptions(options, ["legacy"]);
    const any = schema && schema[Common.symbols.any];
    if (any) {
      Assert(options.legacy || any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
      return schema;
    }
    if (typeof schema !== "object" || !options.legacy) {
      return exports.schema(root, schema, { appendPath: true });
    }
    const compiler = internals.walk(schema);
    if (!compiler) {
      return exports.schema(root, schema, { appendPath: true });
    }
    return compiler.compile(compiler.root, schema);
  };
  internals.walk = function(schema) {
    if (typeof schema !== "object") {
      return null;
    }
    if (Array.isArray(schema)) {
      for (const item of schema) {
        const compiler = internals.walk(item);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    }
    const any = schema[Common.symbols.any];
    if (any) {
      return { root: schema[any.root], compile: any.compile };
    }
    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
    for (const key in schema) {
      const compiler = internals.walk(schema[key]);
      if (compiler) {
        return compiler;
      }
    }
    return null;
  };
  internals.simple = function(value) {
    return value === null || ["boolean", "string", "number"].includes(typeof value);
  };
  exports.when = function(schema, condition, options) {
    if (options === undefined) {
      Assert(condition && typeof condition === "object", "Missing options");
      options = condition;
      condition = Ref.create(".");
    }
    if (Array.isArray(options)) {
      options = { switch: options };
    }
    Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
    if (Common.isSchema(condition)) {
      Assert(options.is === undefined, '"is" can not be used with a schema condition');
      Assert(options.not === undefined, '"not" can not be used with a schema condition');
      Assert(options.switch === undefined, '"switch" can not be used with a schema condition');
      return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
    }
    Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
    Assert(options.not === undefined || options.is === undefined, 'Cannot combine "is" with "not"');
    if (options.switch === undefined) {
      let rule2 = options;
      if (options.not !== undefined) {
        rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
      }
      let is = rule2.is !== undefined ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
      Assert(rule2.then !== undefined || rule2.otherwise !== undefined, 'options must have at least one of "then", "otherwise", or "switch"');
      Assert(rule2.break === undefined || rule2.then === undefined || rule2.otherwise === undefined, "Cannot specify then, otherwise, and break all together");
      if (options.is !== undefined && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
        is = is.required();
      }
      return internals.condition(schema, { ref: exports.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
    }
    Assert(Array.isArray(options.switch), '"switch" must be an array');
    Assert(options.is === undefined, 'Cannot combine "switch" with "is"');
    Assert(options.not === undefined, 'Cannot combine "switch" with "not"');
    Assert(options.then === undefined, 'Cannot combine "switch" with "then"');
    const rule = {
      ref: exports.ref(condition),
      switch: [],
      break: options.break
    };
    for (let i = 0;i < options.switch.length; ++i) {
      const test = options.switch[i];
      const last = i === options.switch.length - 1;
      Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
      Assert(test.is !== undefined, 'Switch statement missing "is"');
      Assert(test.then !== undefined, 'Switch statement missing "then"');
      const item = {
        is: schema.$_compile(test.is),
        then: schema.$_compile(test.then)
      };
      if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
        item.is = item.is.required();
      }
      if (last) {
        Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify "otherwise" inside and outside a "switch"');
        const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;
        if (otherwise !== undefined) {
          Assert(rule.break === undefined, "Cannot specify both otherwise and break");
          item.otherwise = schema.$_compile(otherwise);
        }
      }
      rule.switch.push(item);
    }
    return rule;
  };
  internals.condition = function(schema, condition) {
    for (const key of ["then", "otherwise"]) {
      if (condition[key] === undefined) {
        delete condition[key];
      } else {
        condition[key] = schema.$_compile(condition[key]);
      }
    }
    return condition;
  };
});

// node_modules/joi/lib/extend.js
var require_extend2 = __commonJS((exports) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Common = require_common2();
  var Messages = require_messages3();
  var internals = {};
  exports.type = function(from, options) {
    const base = Object.getPrototypeOf(from);
    const prototype = Clone(base);
    const schema = from._assign(Object.create(prototype));
    const def = Object.assign({}, options);
    delete def.base;
    prototype._definition = def;
    const parent = base._definition || {};
    def.messages = Messages.merge(parent.messages, def.messages);
    def.properties = Object.assign({}, parent.properties, def.properties);
    schema.type = def.type;
    def.flags = Object.assign({}, parent.flags, def.flags);
    const terms = Object.assign({}, parent.terms);
    if (def.terms) {
      for (const name in def.terms) {
        const term = def.terms[name];
        Assert(schema.$_terms[name] === undefined, "Invalid term override for", def.type, name);
        schema.$_terms[name] = term.init;
        terms[name] = term;
      }
    }
    def.terms = terms;
    if (!def.args) {
      def.args = parent.args;
    }
    def.prepare = internals.prepare(def.prepare, parent.prepare);
    if (def.coerce) {
      if (typeof def.coerce === "function") {
        def.coerce = { method: def.coerce };
      }
      if (def.coerce.from && !Array.isArray(def.coerce.from)) {
        def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
      }
    }
    def.coerce = internals.coerce(def.coerce, parent.coerce);
    def.validate = internals.validate(def.validate, parent.validate);
    const rules = Object.assign({}, parent.rules);
    if (def.rules) {
      for (const name in def.rules) {
        const rule = def.rules[name];
        Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
        let method = rule.method;
        if (method === undefined) {
          method = function() {
            return this.$_addRule(name);
          };
        }
        if (method) {
          Assert(!prototype[name], "Rule conflict in", def.type, name);
          prototype[name] = method;
        }
        Assert(!rules[name], "Rule conflict in", def.type, name);
        rules[name] = rule;
        if (rule.alias) {
          const aliases = [].concat(rule.alias);
          for (const alias of aliases) {
            prototype[alias] = rule.method;
          }
        }
        if (rule.args) {
          rule.argsByName = new Map;
          rule.args = rule.args.map((arg) => {
            if (typeof arg === "string") {
              arg = { name: arg };
            }
            Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
            if (Common.isSchema(arg.assert)) {
              arg.assert = arg.assert.strict().label(arg.name);
            }
            rule.argsByName.set(arg.name, arg);
            return arg;
          });
        }
      }
    }
    def.rules = rules;
    const modifiers = Object.assign({}, parent.modifiers);
    if (def.modifiers) {
      for (const name in def.modifiers) {
        Assert(!prototype[name], "Rule conflict in", def.type, name);
        const modifier = def.modifiers[name];
        Assert(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
        const method = function(arg) {
          return this.rule({ [name]: arg });
        };
        prototype[name] = method;
        modifiers[name] = modifier;
      }
    }
    def.modifiers = modifiers;
    if (def.overrides) {
      prototype._super = base;
      schema.$_super = {};
      for (const override in def.overrides) {
        Assert(base[override], "Cannot override missing", override);
        def.overrides[override][Common.symbols.parent] = base[override];
        schema.$_super[override] = base[override].bind(schema);
      }
      Object.assign(prototype, def.overrides);
    }
    def.cast = Object.assign({}, parent.cast, def.cast);
    const manifest = Object.assign({}, parent.manifest, def.manifest);
    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
    def.manifest = manifest;
    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
    return schema;
  };
  internals.build = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(obj, desc) {
      return parent(child(obj, desc), desc);
    };
  };
  internals.coerce = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return {
      from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,
      method(value, helpers) {
        let coerced;
        if (!parent.from || parent.from.includes(typeof value)) {
          coerced = parent.method(value, helpers);
          if (coerced) {
            if (coerced.errors || coerced.value === undefined) {
              return coerced;
            }
            value = coerced.value;
          }
        }
        if (!child.from || child.from.includes(typeof value)) {
          const own = child.method(value, helpers);
          if (own) {
            return own;
          }
        }
        return coerced;
      }
    };
  };
  internals.prepare = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(value, helpers) {
      const prepared = child(value, helpers);
      if (prepared) {
        if (prepared.errors || prepared.value === undefined) {
          return prepared;
        }
        value = prepared.value;
      }
      return parent(value, helpers) || prepared;
    };
  };
  internals.rebuild = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(schema) {
      parent(schema);
      child(schema);
    };
  };
  internals.validate = function(child, parent) {
    if (!child || !parent) {
      return child || parent;
    }
    return function(value, helpers) {
      const result = parent(value, helpers);
      if (result) {
        if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
          return result;
        }
        value = result.value;
      }
      return child(value, helpers) || result;
    };
  };
});

// node_modules/joi/lib/manifest.js
var require_manifest = __commonJS((exports) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Common = require_common2();
  var Messages = require_messages3();
  var Ref = require_ref2();
  var Template = require_template2();
  var Schemas;
  var internals = {};
  exports.describe = function(schema) {
    const def = schema._definition;
    const desc = {
      type: schema.type,
      flags: {},
      rules: []
    };
    for (const flag in schema._flags) {
      if (flag[0] !== "_") {
        desc.flags[flag] = internals.describe(schema._flags[flag]);
      }
    }
    if (!Object.keys(desc.flags).length) {
      delete desc.flags;
    }
    if (schema._preferences) {
      desc.preferences = Clone(schema._preferences, { shallow: ["messages"] });
      delete desc.preferences[Common.symbols.prefs];
      if (desc.preferences.messages) {
        desc.preferences.messages = Messages.decompile(desc.preferences.messages);
      }
    }
    if (schema._valids) {
      desc.allow = schema._valids.describe();
    }
    if (schema._invalids) {
      desc.invalid = schema._invalids.describe();
    }
    for (const rule of schema._rules) {
      const ruleDef = def.rules[rule.name];
      if (ruleDef.manifest === false) {
        continue;
      }
      const item = { name: rule.name };
      for (const custom in def.modifiers) {
        if (rule[custom] !== undefined) {
          item[custom] = internals.describe(rule[custom]);
        }
      }
      if (rule.args) {
        item.args = {};
        for (const key in rule.args) {
          const arg = rule.args[key];
          if (key === "options" && !Object.keys(arg).length) {
            continue;
          }
          item.args[key] = internals.describe(arg, { assign: key });
        }
        if (!Object.keys(item.args).length) {
          delete item.args;
        }
      }
      desc.rules.push(item);
    }
    if (!desc.rules.length) {
      delete desc.rules;
    }
    for (const term in schema.$_terms) {
      if (term[0] === "_") {
        continue;
      }
      Assert(!desc[term], "Cannot describe schema due to internal name conflict with", term);
      const items = schema.$_terms[term];
      if (!items) {
        continue;
      }
      if (items instanceof Map) {
        if (items.size) {
          desc[term] = [...items.entries()];
        }
        continue;
      }
      if (Common.isValues(items)) {
        desc[term] = items.describe();
        continue;
      }
      Assert(def.terms[term], "Term", term, "missing configuration");
      const manifest = def.terms[term].manifest;
      const mapped = typeof manifest === "object";
      if (!items.length && !mapped) {
        continue;
      }
      const normalized = [];
      for (const item of items) {
        normalized.push(internals.describe(item));
      }
      if (mapped) {
        const { from, to } = manifest.mapped;
        desc[term] = {};
        for (const item of normalized) {
          desc[term][item[to]] = item[from];
        }
        continue;
      }
      if (manifest === "single") {
        Assert(normalized.length === 1, "Term", term, "contains more than one item");
        desc[term] = normalized[0];
        continue;
      }
      desc[term] = normalized;
    }
    internals.validate(schema.$_root, desc);
    return desc;
  };
  internals.describe = function(item, options = {}) {
    if (Array.isArray(item)) {
      return item.map(internals.describe);
    }
    if (item === Common.symbols.deepDefault) {
      return { special: "deep" };
    }
    if (typeof item !== "object" || item === null) {
      return item;
    }
    if (options.assign === "options") {
      return Clone(item);
    }
    if (Buffer && Buffer.isBuffer(item)) {
      return { buffer: item.toString("binary") };
    }
    if (item instanceof Date) {
      return item.toISOString();
    }
    if (item instanceof Error) {
      return item;
    }
    if (item instanceof RegExp) {
      if (options.assign === "regex") {
        return item.toString();
      }
      return { regex: item.toString() };
    }
    if (item[Common.symbols.literal]) {
      return { function: item.literal };
    }
    if (typeof item.describe === "function") {
      if (options.assign === "ref") {
        return item.describe().ref;
      }
      return item.describe();
    }
    const normalized = {};
    for (const key in item) {
      const value = item[key];
      if (value === undefined) {
        continue;
      }
      normalized[key] = internals.describe(value, { assign: key });
    }
    return normalized;
  };
  exports.build = function(joi, desc) {
    const builder = new internals.Builder(joi);
    return builder.parse(desc);
  };
  internals.Builder = class {
    constructor(joi) {
      this.joi = joi;
    }
    parse(desc) {
      internals.validate(this.joi, desc);
      let schema = this.joi[desc.type]()._bare();
      const def = schema._definition;
      if (desc.flags) {
        for (const flag in desc.flags) {
          const setter = def.flags[flag] && def.flags[flag].setter || flag;
          Assert(typeof schema[setter] === "function", "Invalid flag", flag, "for type", desc.type);
          schema = schema[setter](this.build(desc.flags[flag]));
        }
      }
      if (desc.preferences) {
        schema = schema.preferences(this.build(desc.preferences));
      }
      if (desc.allow) {
        schema = schema.allow(...this.build(desc.allow));
      }
      if (desc.invalid) {
        schema = schema.invalid(...this.build(desc.invalid));
      }
      if (desc.rules) {
        for (const rule of desc.rules) {
          Assert(typeof schema[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
          const args = [];
          if (rule.args) {
            const built = {};
            for (const key in rule.args) {
              built[key] = this.build(rule.args[key], { assign: key });
            }
            const keys = Object.keys(built);
            const definition = def.rules[rule.name].args;
            if (definition) {
              Assert(keys.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys.length, ")");
              for (const { name } of definition) {
                args.push(built[name]);
              }
            } else {
              Assert(keys.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys.length, ")");
              args.push(built[keys[0]]);
            }
          }
          schema = schema[rule.name](...args);
          const options = {};
          for (const custom in def.modifiers) {
            if (rule[custom] !== undefined) {
              options[custom] = this.build(rule[custom]);
            }
          }
          if (Object.keys(options).length) {
            schema = schema.rule(options);
          }
        }
      }
      const terms = {};
      for (const key in desc) {
        if (["allow", "flags", "invalid", "whens", "preferences", "rules", "type"].includes(key)) {
          continue;
        }
        Assert(def.terms[key], "Term", key, "missing configuration");
        const manifest = def.terms[key].manifest;
        if (manifest === "schema") {
          terms[key] = desc[key].map((item) => this.parse(item));
          continue;
        }
        if (manifest === "values") {
          terms[key] = desc[key].map((item) => this.build(item));
          continue;
        }
        if (manifest === "single") {
          terms[key] = this.build(desc[key]);
          continue;
        }
        if (typeof manifest === "object") {
          terms[key] = {};
          for (const name in desc[key]) {
            const value = desc[key][name];
            terms[key][name] = this.parse(value);
          }
          continue;
        }
        terms[key] = this.build(desc[key]);
      }
      if (desc.whens) {
        terms.whens = desc.whens.map((when) => this.build(when));
      }
      schema = def.manifest.build(schema, terms);
      schema.$_temp.ruleset = false;
      return schema;
    }
    build(desc, options = {}) {
      if (desc === null) {
        return null;
      }
      if (Array.isArray(desc)) {
        return desc.map((item) => this.build(item));
      }
      if (desc instanceof Error) {
        return desc;
      }
      if (options.assign === "options") {
        return Clone(desc);
      }
      if (options.assign === "regex") {
        return internals.regex(desc);
      }
      if (options.assign === "ref") {
        return Ref.build(desc);
      }
      if (typeof desc !== "object") {
        return desc;
      }
      if (Object.keys(desc).length === 1) {
        if (desc.buffer) {
          Assert(Buffer, "Buffers are not supported");
          return Buffer && Buffer.from(desc.buffer, "binary");
        }
        if (desc.function) {
          return { [Common.symbols.literal]: true, literal: desc.function };
        }
        if (desc.override) {
          return Common.symbols.override;
        }
        if (desc.ref) {
          return Ref.build(desc.ref);
        }
        if (desc.regex) {
          return internals.regex(desc.regex);
        }
        if (desc.special) {
          Assert(["deep"].includes(desc.special), "Unknown special value", desc.special);
          return Common.symbols.deepDefault;
        }
        if (desc.value) {
          return Clone(desc.value);
        }
      }
      if (desc.type) {
        return this.parse(desc);
      }
      if (desc.template) {
        return Template.build(desc);
      }
      const normalized = {};
      for (const key in desc) {
        normalized[key] = this.build(desc[key], { assign: key });
      }
      return normalized;
    }
  };
  internals.regex = function(string) {
    const end = string.lastIndexOf("/");
    const exp = string.slice(1, end);
    const flags = string.slice(end + 1);
    return new RegExp(exp, flags);
  };
  internals.validate = function(joi, desc) {
    Schemas = Schemas || require_schemas2();
    joi.assert(desc, Schemas.description);
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual2 = __commonJS((exports, module) => {
  var Types = require_types3();
  var internals = {
    mismatched: null
  };
  module.exports = function(obj, ref, options) {
    options = Object.assign({ prototype: true }, options);
    return !!internals.isDeepEqual(obj, ref, options, []);
  };
  internals.isDeepEqual = function(obj, ref, options, seen) {
    if (obj === ref) {
      return obj !== 0 || 1 / obj === 1 / ref;
    }
    const type = typeof obj;
    if (type !== typeof ref) {
      return false;
    }
    if (obj === null || ref === null) {
      return false;
    }
    if (type === "function") {
      if (!options.deepFunction || obj.toString() !== ref.toString()) {
        return false;
      }
    } else if (type !== "object") {
      return obj !== obj && ref !== ref;
    }
    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
      case Types.buffer:
        return Buffer && Buffer.prototype.equals.call(obj, ref);
      case Types.promise:
        return obj === ref;
      case Types.regex:
        return obj.toString() === ref.toString();
      case internals.mismatched:
        return false;
    }
    for (let i = seen.length - 1;i >= 0; --i) {
      if (seen[i].isSame(obj, ref)) {
        return true;
      }
    }
    seen.push(new internals.SeenEntry(obj, ref));
    try {
      return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    } finally {
      seen.pop();
    }
  };
  internals.getSharedType = function(obj, ref, checkPrototype) {
    if (checkPrototype) {
      if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
        return internals.mismatched;
      }
      return Types.getInternalProto(obj);
    }
    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
      return internals.mismatched;
    }
    return type;
  };
  internals.valueOf = function(obj) {
    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
      return obj;
    }
    try {
      return objValueOf.call(obj);
    } catch (err) {
      return err;
    }
  };
  internals.hasOwnEnumerableProperty = function(obj, key) {
    return Object.prototype.propertyIsEnumerable.call(obj, key);
  };
  internals.isSetSimpleEqual = function(obj, ref) {
    for (const entry of Set.prototype.values.call(obj)) {
      if (!Set.prototype.has.call(ref, entry)) {
        return false;
      }
    }
    return true;
  };
  internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;
    if (instanceType === Types.array) {
      if (options.part) {
        for (const objValue of obj) {
          for (const refValue of ref) {
            if (isDeepEqual(objValue, refValue, options, seen)) {
              return true;
            }
          }
        }
      } else {
        if (obj.length !== ref.length) {
          return false;
        }
        for (let i = 0;i < obj.length; ++i) {
          if (!isDeepEqual(obj[i], ref[i], options, seen)) {
            return false;
          }
        }
        return true;
      }
    } else if (instanceType === Types.set) {
      if (obj.size !== ref.size) {
        return false;
      }
      if (!internals.isSetSimpleEqual(obj, ref)) {
        const ref2 = new Set(Set.prototype.values.call(ref));
        for (const objEntry of Set.prototype.values.call(obj)) {
          if (ref2.delete(objEntry)) {
            continue;
          }
          let found = false;
          for (const refEntry of ref2) {
            if (isDeepEqual(objEntry, refEntry, options, seen)) {
              ref2.delete(refEntry);
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
      }
    } else if (instanceType === Types.map) {
      if (obj.size !== ref.size) {
        return false;
      }
      for (const [key, value] of Map.prototype.entries.call(obj)) {
        if (value === undefined && !Map.prototype.has.call(ref, key)) {
          return false;
        }
        if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
          return false;
        }
      }
    } else if (instanceType === Types.error) {
      if (obj.name !== ref.name || obj.message !== ref.message) {
        return false;
      }
    }
    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
      return false;
    }
    const objKeys = keys(obj);
    if (!options.part && objKeys.length !== keys(ref).length && !options.skip) {
      return false;
    }
    let skipped = 0;
    for (const key of objKeys) {
      if (options.skip && options.skip.includes(key)) {
        if (ref[key] === undefined) {
          ++skipped;
        }
        continue;
      }
      if (!hasOwnEnumerableProperty(ref, key)) {
        return false;
      }
      if (!isDeepEqual(obj[key], ref[key], options, seen)) {
        return false;
      }
    }
    if (!options.part && objKeys.length - skipped !== keys(ref).length) {
      return false;
    }
    if (options.symbols !== false) {
      const objSymbols = getOwnPropertySymbols(obj);
      const refSymbols = new Set(getOwnPropertySymbols(ref));
      for (const key of objSymbols) {
        if (!options.skip || !options.skip.includes(key)) {
          if (hasOwnEnumerableProperty(obj, key)) {
            if (!hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
            if (!isDeepEqual(obj[key], ref[key], options, seen)) {
              return false;
            }
          } else if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
        refSymbols.delete(key);
      }
      for (const key of refSymbols) {
        if (hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
      }
    }
    return true;
  };
  internals.SeenEntry = class {
    constructor(obj, ref) {
      this.obj = obj;
      this.ref = ref;
    }
    isSame(obj, ref) {
      return this.obj === obj && this.ref === ref;
    }
  };
});

// node_modules/@sideway/pinpoint/lib/index.js
var require_lib37 = __commonJS((exports) => {
  exports.location = function(depth = 0) {
    const orig = Error.prepareStackTrace;
    Error.prepareStackTrace = (ignore, stack) => stack;
    const capture = {};
    Error.captureStackTrace(capture, this);
    const line = capture.stack[depth + 1];
    Error.prepareStackTrace = orig;
    return {
      filename: line.getFileName(),
      line: line.getLineNumber()
    };
  };
});

// node_modules/joi/lib/trace.js
var require_trace = __commonJS((exports) => {
  var DeepEqual = require_deepEqual2();
  var Pinpoint = require_lib37();
  var Errors = require_errors3();
  var internals = {
    codes: {
      error: 1,
      pass: 2,
      full: 3
    },
    labels: {
      0: "never used",
      1: "always error",
      2: "always pass"
    }
  };
  exports.setup = function(root) {
    const trace = function() {
      root._tracer = root._tracer || new internals.Tracer;
      return root._tracer;
    };
    root.trace = trace;
    root[Symbol.for("@hapi/lab/coverage/initialize")] = trace;
    root.untrace = () => {
      root._tracer = null;
    };
  };
  exports.location = function(schema) {
    return schema.$_setFlag("_tracerLocation", Pinpoint.location(2));
  };
  internals.Tracer = class {
    constructor() {
      this.name = "Joi";
      this._schemas = new Map;
    }
    _register(schema) {
      const existing = this._schemas.get(schema);
      if (existing) {
        return existing.store;
      }
      const store = new internals.Store(schema);
      const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);
      this._schemas.set(schema, { filename, line, store });
      return store;
    }
    _combine(merged, sources) {
      for (const { store } of this._schemas.values()) {
        store._combine(merged, sources);
      }
    }
    report(file) {
      const coverage = [];
      for (const { filename, line, store } of this._schemas.values()) {
        if (file && file !== filename) {
          continue;
        }
        const missing = [];
        const skipped = [];
        for (const [schema, log] of store._sources.entries()) {
          if (internals.sub(log.paths, skipped)) {
            continue;
          }
          if (!log.entry) {
            missing.push({
              status: "never reached",
              paths: [...log.paths]
            });
            skipped.push(...log.paths);
            continue;
          }
          for (const type of ["valid", "invalid"]) {
            const set = schema[`_${type}s`];
            if (!set) {
              continue;
            }
            const values = new Set(set._values);
            const refs = new Set(set._refs);
            for (const { value, ref } of log[type]) {
              values.delete(value);
              refs.delete(ref);
            }
            if (values.size || refs.size) {
              missing.push({
                status: [...values, ...[...refs].map((ref) => ref.display)],
                rule: `${type}s`
              });
            }
          }
          const rules = schema._rules.map((rule) => rule.name);
          for (const type of ["default", "failover"]) {
            if (schema._flags[type] !== undefined) {
              rules.push(type);
            }
          }
          for (const name of rules) {
            const status = internals.labels[log.rule[name] || 0];
            if (status) {
              const report = { rule: name, status };
              if (log.paths.size) {
                report.paths = [...log.paths];
              }
              missing.push(report);
            }
          }
        }
        if (missing.length) {
          coverage.push({
            filename,
            line,
            missing,
            severity: "error",
            message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
          });
        }
      }
      return coverage.length ? coverage : null;
    }
  };
  internals.Store = class {
    constructor(schema) {
      this.active = true;
      this._sources = new Map;
      this._combos = new Map;
      this._scan(schema);
    }
    debug(state, source, name, result) {
      state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
    }
    entry(schema, state) {
      internals.debug(state, { type: "entry" });
      this._record(schema, (log) => {
        log.entry = true;
      });
    }
    filter(schema, state, source, value) {
      internals.debug(state, { type: source, ...value });
      this._record(schema, (log) => {
        log[source].add(value);
      });
    }
    log(schema, state, source, name, result) {
      internals.debug(state, { type: source, name, result: result === "full" ? "pass" : result });
      this._record(schema, (log) => {
        log[source][name] = log[source][name] || 0;
        log[source][name] |= internals.codes[result];
      });
    }
    resolve(state, ref, to) {
      if (!state.mainstay.debug) {
        return;
      }
      const log = { type: "resolve", ref: ref.display, to, path: state.path };
      state.mainstay.debug.push(log);
    }
    value(state, by, from, to, name) {
      if (!state.mainstay.debug || DeepEqual(from, to)) {
        return;
      }
      const log = { type: "value", by, from, to, path: state.path };
      if (name) {
        log.name = name;
      }
      state.mainstay.debug.push(log);
    }
    _record(schema, each) {
      const log = this._sources.get(schema);
      if (log) {
        each(log);
        return;
      }
      const sources = this._combos.get(schema);
      for (const source of sources) {
        this._record(source, each);
      }
    }
    _scan(schema, _path) {
      const path2 = _path || [];
      let log = this._sources.get(schema);
      if (!log) {
        log = {
          paths: new Set,
          entry: false,
          rule: {},
          valid: new Set,
          invalid: new Set
        };
        this._sources.set(schema, log);
      }
      if (path2.length) {
        log.paths.add(path2);
      }
      const each = (sub, source) => {
        const subId = internals.id(sub, source);
        this._scan(sub, path2.concat(subId));
      };
      schema.$_modify({ each, ref: false });
    }
    _combine(merged, sources) {
      this._combos.set(merged, sources);
    }
  };
  internals.message = function(item) {
    const path2 = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
    return `${path2}${item.rule || ""} (${item.status})`;
  };
  internals.id = function(schema, { source, name, path: path2, key }) {
    if (schema._flags.id) {
      return schema._flags.id;
    }
    if (key) {
      return key;
    }
    name = `@${name}`;
    if (source === "terms") {
      return [name, path2[Math.min(path2.length - 1, 1)]];
    }
    return name;
  };
  internals.sub = function(paths, skipped) {
    for (const path2 of paths) {
      for (const skip of skipped) {
        if (DeepEqual(path2.slice(0, skip.length), skip)) {
          return true;
        }
      }
    }
    return false;
  };
  internals.debug = function(state, event) {
    if (state.mainstay.debug) {
      event.path = state.debug ? [...state.path, state.debug] : state.path;
      state.mainstay.debug.push(event);
    }
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/merge.js
var require_merge2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Utils = require_utils5();
  var internals = {};
  module.exports = internals.merge = function(target, source, options) {
    Assert(target && typeof target === "object", "Invalid target value: must be an object");
    Assert(source === null || source === undefined || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
    if (!source) {
      return target;
    }
    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
    if (Array.isArray(source)) {
      Assert(Array.isArray(target), "Cannot merge array onto an object");
      if (!options.mergeArrays) {
        target.length = 0;
      }
      for (let i = 0;i < source.length; ++i) {
        target.push(Clone(source[i], { symbols: options.symbols }));
      }
      return target;
    }
    const keys = Utils.keys(source, options);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
        continue;
      }
      const value = source[key];
      if (value && typeof value === "object") {
        if (target[key] === value) {
          continue;
        }
        if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || value instanceof RegExp) {
          target[key] = Clone(value, { symbols: options.symbols });
        } else {
          internals.merge(target[key], value, options);
        }
      } else {
        if (value !== null && value !== undefined) {
          target[key] = value;
        } else if (options.nullOverride) {
          target[key] = value;
        }
      }
    }
    return target;
  };
});

// node_modules/joi/lib/modify.js
var require_modify2 = __commonJS((exports) => {
  var Assert = require_assert2();
  var Common = require_common2();
  var Ref = require_ref2();
  var internals = {};
  exports.Ids = internals.Ids = class {
    constructor() {
      this._byId = new Map;
      this._byKey = new Map;
      this._schemaChain = false;
    }
    clone() {
      const clone = new internals.Ids;
      clone._byId = new Map(this._byId);
      clone._byKey = new Map(this._byKey);
      clone._schemaChain = this._schemaChain;
      return clone;
    }
    concat(source) {
      if (source._schemaChain) {
        this._schemaChain = true;
      }
      for (const [id, value] of source._byId.entries()) {
        Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
        this._byId.set(id, value);
      }
      for (const [key, value] of source._byKey.entries()) {
        Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
        this._byKey.set(key, value);
      }
    }
    fork(path2, adjuster, root) {
      const chain = this._collect(path2);
      chain.push({ schema: root });
      const tail = chain.shift();
      let adjusted = { id: tail.id, schema: adjuster(tail.schema) };
      Assert(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
      for (const node of chain) {
        adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
      }
      return adjusted.schema;
    }
    labels(path2, behind = []) {
      const current = path2[0];
      const node = this._get(current);
      if (!node) {
        return [...behind, ...path2].join(".");
      }
      const forward = path2.slice(1);
      behind = [...behind, node.schema._flags.label || current];
      if (!forward.length) {
        return behind.join(".");
      }
      return node.schema._ids.labels(forward, behind);
    }
    reach(path2, behind = []) {
      const current = path2[0];
      const node = this._get(current);
      Assert(node, "Schema does not contain path", [...behind, ...path2].join("."));
      const forward = path2.slice(1);
      if (!forward.length) {
        return node.schema;
      }
      return node.schema._ids.reach(forward, [...behind, current]);
    }
    register(schema, { key } = {}) {
      if (!schema || !Common.isSchema(schema)) {
        return;
      }
      if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
        this._schemaChain = true;
      }
      const id = schema._flags.id;
      if (id) {
        const existing = this._byId.get(id);
        Assert(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
        Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
        this._byId.set(id, { schema, id });
      }
      if (key) {
        Assert(!this._byKey.has(key), "Schema already contains key:", key);
        Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
        this._byKey.set(key, { schema, id: key });
      }
    }
    reset() {
      this._byId = new Map;
      this._byKey = new Map;
      this._schemaChain = false;
    }
    _collect(path2, behind = [], nodes = []) {
      const current = path2[0];
      const node = this._get(current);
      Assert(node, "Schema does not contain path", [...behind, ...path2].join("."));
      nodes = [node, ...nodes];
      const forward = path2.slice(1);
      if (!forward.length) {
        return nodes;
      }
      return node.schema._ids._collect(forward, [...behind, current], nodes);
    }
    _get(id) {
      return this._byId.get(id) || this._byKey.get(id);
    }
  };
  internals.fork = function(schema, id, replacement) {
    const each = (item, { key }) => {
      if (id === (item._flags.id || key)) {
        return replacement;
      }
    };
    const obj = exports.schema(schema, { each, ref: false });
    return obj ? obj.$_mutateRebuild() : schema;
  };
  exports.schema = function(schema, options) {
    let obj;
    for (const name in schema._flags) {
      if (name[0] === "_") {
        continue;
      }
      const result = internals.scan(schema._flags[name], { source: "flags", name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        obj._flags[name] = result;
      }
    }
    for (let i = 0;i < schema._rules.length; ++i) {
      const rule = schema._rules[i];
      const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        const clone = Object.assign({}, rule);
        clone.args = result;
        obj._rules[i] = clone;
        const existingUnique = obj._singleRules.get(rule.name);
        if (existingUnique === rule) {
          obj._singleRules.set(rule.name, clone);
        }
      }
    }
    for (const name in schema.$_terms) {
      if (name[0] === "_") {
        continue;
      }
      const result = internals.scan(schema.$_terms[name], { source: "terms", name }, options);
      if (result !== undefined) {
        obj = obj || schema.clone();
        obj.$_terms[name] = result;
      }
    }
    return obj;
  };
  internals.scan = function(item, source, options, _path, _key) {
    const path2 = _path || [];
    if (item === null || typeof item !== "object") {
      return;
    }
    let clone;
    if (Array.isArray(item)) {
      for (let i = 0;i < item.length; ++i) {
        const key = source.source === "terms" && source.name === "keys" && item[i].key;
        const result = internals.scan(item[i], source, options, [i, ...path2], key);
        if (result !== undefined) {
          clone = clone || item.slice();
          clone[i] = result;
        }
      }
      return clone;
    }
    if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
      const result = options.each(item, { ...source, path: path2, key: _key });
      if (result === item) {
        return;
      }
      return result;
    }
    for (const key in item) {
      if (key[0] === "_") {
        continue;
      }
      const result = internals.scan(item[key], source, options, [key, ...path2], _key);
      if (result !== undefined) {
        clone = clone || Object.assign({}, item);
        clone[key] = result;
      }
    }
    return clone;
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/ignore.js
var require_ignore2 = __commonJS((exports, module) => {
  module.exports = function() {};
});

// node_modules/joi/lib/state.js
var require_state2 = __commonJS((exports, module) => {
  var Clone = require_clone2();
  var Reach = require_reach2();
  var Common = require_common2();
  var internals = {
    value: Symbol("value")
  };
  module.exports = internals.State = class {
    constructor(path2, ancestors, state) {
      this.path = path2;
      this.ancestors = ancestors;
      this.mainstay = state.mainstay;
      this.schemas = state.schemas;
      this.debug = null;
    }
    localize(path2, ancestors = null, schema = null) {
      const state = new internals.State(path2, ancestors, this);
      if (schema && state.schemas) {
        state.schemas = [internals.schemas(schema), ...state.schemas];
      }
      return state;
    }
    nest(schema, debug) {
      const state = new internals.State(this.path, this.ancestors, this);
      state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
      state.debug = debug;
      return state;
    }
    shadow(value, reason) {
      this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow;
      this.mainstay.shadow.set(this.path, value, reason);
    }
    snapshot() {
      if (this.mainstay.shadow) {
        this._snapshot = Clone(this.mainstay.shadow.node(this.path));
      }
      this.mainstay.snapshot();
    }
    restore() {
      if (this.mainstay.shadow) {
        this.mainstay.shadow.override(this.path, this._snapshot);
        this._snapshot = undefined;
      }
      this.mainstay.restore();
    }
    commit() {
      if (this.mainstay.shadow) {
        this.mainstay.shadow.override(this.path, this._snapshot);
        this._snapshot = undefined;
      }
      this.mainstay.commit();
    }
  };
  internals.schemas = function(schema) {
    if (Common.isSchema(schema)) {
      return { schema };
    }
    return schema;
  };
  internals.Shadow = class {
    constructor() {
      this._values = null;
    }
    set(path2, value, reason) {
      if (!path2.length) {
        return;
      }
      if (reason === "strip" && typeof path2[path2.length - 1] === "number") {
        return;
      }
      this._values = this._values || new Map;
      let node = this._values;
      for (let i = 0;i < path2.length; ++i) {
        const segment = path2[i];
        let next = node.get(segment);
        if (!next) {
          next = new Map;
          node.set(segment, next);
        }
        node = next;
      }
      node[internals.value] = value;
    }
    get(path2) {
      const node = this.node(path2);
      if (node) {
        return node[internals.value];
      }
    }
    node(path2) {
      if (!this._values) {
        return;
      }
      return Reach(this._values, path2, { iterables: true });
    }
    override(path2, node) {
      if (!this._values) {
        return;
      }
      const parents = path2.slice(0, -1);
      const own = path2[path2.length - 1];
      const parent = Reach(this._values, parents, { iterables: true });
      if (node) {
        parent.set(own, node);
        return;
      }
      if (parent) {
        parent.delete(own);
      }
    }
  };
});

// node_modules/joi/lib/validator.js
var require_validator2 = __commonJS((exports) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Ignore = require_ignore2();
  var Reach = require_reach2();
  var Common = require_common2();
  var Errors = require_errors3();
  var State = require_state2();
  var internals = {
    result: Symbol("result")
  };
  exports.entry = function(value, schema, prefs) {
    let settings = Common.defaults;
    if (prefs) {
      Assert(prefs.warnings === undefined, "Cannot override warnings preference in synchronous validation");
      Assert(prefs.artifacts === undefined, "Cannot override artifacts preference in synchronous validation");
      settings = Common.preferences(Common.defaults, prefs);
    }
    const result = internals.entry(value, schema, settings);
    Assert(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
    const outcome = { value: result.value };
    if (result.error) {
      outcome.error = result.error;
    }
    if (result.mainstay.warnings.length) {
      outcome.warning = Errors.details(result.mainstay.warnings);
    }
    if (result.mainstay.debug) {
      outcome.debug = result.mainstay.debug;
    }
    if (result.mainstay.artifacts) {
      outcome.artifacts = result.mainstay.artifacts;
    }
    return outcome;
  };
  exports.entryAsync = async function(value, schema, prefs) {
    let settings = Common.defaults;
    if (prefs) {
      settings = Common.preferences(Common.defaults, prefs);
    }
    const result = internals.entry(value, schema, settings);
    const mainstay = result.mainstay;
    if (result.error) {
      if (mainstay.debug) {
        result.error.debug = mainstay.debug;
      }
      throw result.error;
    }
    if (mainstay.externals.length) {
      let root = result.value;
      const errors = [];
      for (const external of mainstay.externals) {
        const path2 = external.state.path;
        const linked = external.schema.type === "link" ? mainstay.links.get(external.schema) : null;
        let node = root;
        let key;
        let parent;
        const ancestors = path2.length ? [root] : [];
        const original = path2.length ? Reach(value, path2) : value;
        if (path2.length) {
          key = path2[path2.length - 1];
          let current = root;
          for (const segment of path2.slice(0, -1)) {
            current = current[segment];
            ancestors.unshift(current);
          }
          parent = ancestors[0];
          node = parent[key];
        }
        try {
          const createError = (code, local) => (linked || external.schema).$_createError(code, node, local, external.state, settings);
          const output = await external.method(node, {
            schema: external.schema,
            linked,
            state: external.state,
            prefs,
            original,
            error: createError,
            errorsArray: internals.errorsArray,
            warn: (code, local) => mainstay.warnings.push((linked || external.schema).$_createError(code, node, local, external.state, settings)),
            message: (messages, local) => (linked || external.schema).$_createError("external", node, local, external.state, settings, { messages })
          });
          if (output === undefined || output === node) {
            continue;
          }
          if (output instanceof Errors.Report) {
            mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
            errors.push(output);
            if (settings.abortEarly) {
              break;
            }
            continue;
          }
          if (Array.isArray(output) && output[Common.symbols.errors]) {
            mainstay.tracer.log(external.schema, external.state, "rule", "external", "error");
            errors.push(...output);
            if (settings.abortEarly) {
              break;
            }
            continue;
          }
          if (parent) {
            mainstay.tracer.value(external.state, "rule", node, output, "external");
            parent[key] = output;
          } else {
            mainstay.tracer.value(external.state, "rule", root, output, "external");
            root = output;
          }
        } catch (err) {
          if (settings.errors.label) {
            err.message += ` (${external.label})`;
          }
          throw err;
        }
      }
      result.value = root;
      if (errors.length) {
        result.error = Errors.process(errors, value, settings);
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
    }
    if (!settings.warnings && !settings.debug && !settings.artifacts) {
      return result.value;
    }
    const outcome = { value: result.value };
    if (mainstay.warnings.length) {
      outcome.warning = Errors.details(mainstay.warnings);
    }
    if (mainstay.debug) {
      outcome.debug = mainstay.debug;
    }
    if (mainstay.artifacts) {
      outcome.artifacts = mainstay.artifacts;
    }
    return outcome;
  };
  internals.Mainstay = class {
    constructor(tracer, debug, links) {
      this.externals = [];
      this.warnings = [];
      this.tracer = tracer;
      this.debug = debug;
      this.links = links;
      this.shadow = null;
      this.artifacts = null;
      this._snapshots = [];
    }
    snapshot() {
      this._snapshots.push({
        externals: this.externals.slice(),
        warnings: this.warnings.slice()
      });
    }
    restore() {
      const snapshot = this._snapshots.pop();
      this.externals = snapshot.externals;
      this.warnings = snapshot.warnings;
    }
    commit() {
      this._snapshots.pop();
    }
  };
  internals.entry = function(value, schema, prefs) {
    const { tracer, cleanup } = internals.tracer(schema, prefs);
    const debug = prefs.debug ? [] : null;
    const links = schema._ids._schemaChain ? new Map : null;
    const mainstay = new internals.Mainstay(tracer, debug, links);
    const schemas = schema._ids._schemaChain ? [{ schema }] : null;
    const state = new State([], [], { mainstay, schemas });
    const result = exports.validate(value, schema, state, prefs);
    if (cleanup) {
      schema.$_root.untrace();
    }
    const error = Errors.process(result.errors, value, prefs);
    return { value: result.value, error, mainstay };
  };
  internals.tracer = function(schema, prefs) {
    if (schema.$_root._tracer) {
      return { tracer: schema.$_root._tracer._register(schema) };
    }
    if (prefs.debug) {
      Assert(schema.$_root.trace, "Debug mode not supported");
      return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
    }
    return { tracer: internals.ignore };
  };
  exports.validate = function(value, schema, state, prefs, overrides = {}) {
    if (schema.$_terms.whens) {
      schema = schema._generate(value, state, prefs).schema;
    }
    if (schema._preferences) {
      prefs = internals.prefs(schema, prefs);
    }
    if (schema._cache && prefs.cache) {
      const result = schema._cache.get(value);
      state.mainstay.tracer.debug(state, "validate", "cached", !!result);
      if (result) {
        return result;
      }
    }
    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);
    const helpers = {
      original: value,
      prefs,
      schema,
      state,
      error: createError,
      errorsArray: internals.errorsArray,
      warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),
      message: (messages, local) => schema.$_createError("custom", value, local, state, prefs, { messages })
    };
    state.mainstay.tracer.entry(schema, state);
    const def = schema._definition;
    if (def.prepare && value !== undefined && prefs.convert) {
      const prepared = def.prepare(value, helpers);
      if (prepared) {
        state.mainstay.tracer.value(state, "prepare", value, prepared.value);
        if (prepared.errors) {
          return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
        }
        value = prepared.value;
      }
    }
    if (def.coerce && value !== undefined && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
      const coerced = def.coerce.method(value, helpers);
      if (coerced) {
        state.mainstay.tracer.value(state, "coerced", value, coerced.value);
        if (coerced.errors) {
          return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
        }
        value = coerced.value;
      }
    }
    const empty = schema._flags.empty;
    if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {
      state.mainstay.tracer.value(state, "empty", value, undefined);
      value = undefined;
    }
    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
    if (value === undefined) {
      if (presence === "forbidden") {
        return internals.finalize(value, null, helpers);
      }
      if (presence === "required") {
        return internals.finalize(value, [schema.$_createError("any.required", value, null, state, prefs)], helpers);
      }
      if (presence === "optional") {
        if (schema._flags.default !== Common.symbols.deepDefault) {
          return internals.finalize(value, null, helpers);
        }
        state.mainstay.tracer.value(state, "default", value, {});
        value = {};
      }
    } else if (presence === "forbidden") {
      return internals.finalize(value, [schema.$_createError("any.unknown", value, null, state, prefs)], helpers);
    }
    const errors = [];
    if (schema._valids) {
      const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
      if (match) {
        if (prefs.convert) {
          state.mainstay.tracer.value(state, "valids", value, match.value);
          value = match.value;
        }
        state.mainstay.tracer.filter(schema, state, "valid", match);
        return internals.finalize(value, null, helpers);
      }
      if (schema._flags.only) {
        const report = schema.$_createError("any.only", value, { valids: schema._valids.values({ display: true }) }, state, prefs);
        if (prefs.abortEarly) {
          return internals.finalize(value, [report], helpers);
        }
        errors.push(report);
      }
    }
    if (schema._invalids) {
      const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
      if (match) {
        state.mainstay.tracer.filter(schema, state, "invalid", match);
        const report = schema.$_createError("any.invalid", value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
        if (prefs.abortEarly) {
          return internals.finalize(value, [report], helpers);
        }
        errors.push(report);
      }
    }
    if (def.validate) {
      const base = def.validate(value, helpers);
      if (base) {
        state.mainstay.tracer.value(state, "base", value, base.value);
        value = base.value;
        if (base.errors) {
          if (!Array.isArray(base.errors)) {
            errors.push(base.errors);
            return internals.finalize(value, errors, helpers);
          }
          if (base.errors.length) {
            errors.push(...base.errors);
            return internals.finalize(value, errors, helpers);
          }
        }
      }
    }
    if (!schema._rules.length) {
      return internals.finalize(value, errors, helpers);
    }
    return internals.rules(value, errors, helpers);
  };
  internals.rules = function(value, errors, helpers) {
    const { schema, state, prefs } = helpers;
    for (const rule of schema._rules) {
      const definition = schema._definition.rules[rule.method];
      if (definition.convert && prefs.convert) {
        state.mainstay.tracer.log(schema, state, "rule", rule.name, "full");
        continue;
      }
      let ret;
      let args = rule.args;
      if (rule._resolve.length) {
        args = Object.assign({}, args);
        for (const key of rule._resolve) {
          const resolver = definition.argsByName.get(key);
          const resolved = args[key].resolve(value, state, prefs);
          const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
          const invalid = Common.validateArg(normalized, null, resolver);
          if (invalid) {
            ret = schema.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
            break;
          }
          args[key] = normalized;
        }
      }
      ret = ret || definition.validate(value, helpers, args, rule);
      const result = internals.rule(ret, rule);
      if (result.errors) {
        state.mainstay.tracer.log(schema, state, "rule", rule.name, "error");
        if (rule.warn) {
          state.mainstay.warnings.push(...result.errors);
          continue;
        }
        if (prefs.abortEarly) {
          return internals.finalize(value, result.errors, helpers);
        }
        errors.push(...result.errors);
      } else {
        state.mainstay.tracer.log(schema, state, "rule", rule.name, "pass");
        state.mainstay.tracer.value(state, "rule", value, result.value, rule.name);
        value = result.value;
      }
    }
    return internals.finalize(value, errors, helpers);
  };
  internals.rule = function(ret, rule) {
    if (ret instanceof Errors.Report) {
      internals.error(ret, rule);
      return { errors: [ret], value: null };
    }
    if (Array.isArray(ret) && ret[Common.symbols.errors]) {
      ret.forEach((report) => internals.error(report, rule));
      return { errors: ret, value: null };
    }
    return { errors: null, value: ret };
  };
  internals.error = function(report, rule) {
    if (rule.message) {
      report._setTemplate(rule.message);
    }
    return report;
  };
  internals.finalize = function(value, errors, helpers) {
    errors = errors || [];
    const { schema, state, prefs } = helpers;
    if (errors.length) {
      const failover = internals.default("failover", undefined, errors, helpers);
      if (failover !== undefined) {
        state.mainstay.tracer.value(state, "failover", value, failover);
        value = failover;
        errors = [];
      }
    }
    if (errors.length && schema._flags.error) {
      if (typeof schema._flags.error === "function") {
        errors = schema._flags.error(errors);
        if (!Array.isArray(errors)) {
          errors = [errors];
        }
        for (const error of errors) {
          Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
        }
      } else {
        errors = [schema._flags.error];
      }
    }
    if (value === undefined) {
      const defaulted = internals.default("default", value, errors, helpers);
      state.mainstay.tracer.value(state, "default", value, defaulted);
      value = defaulted;
    }
    if (schema._flags.cast && value !== undefined) {
      const caster = schema._definition.cast[schema._flags.cast];
      if (caster.from(value)) {
        const casted = caster.to(value, helpers);
        state.mainstay.tracer.value(state, "cast", value, casted, schema._flags.cast);
        value = casted;
      }
    }
    if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {
      for (const { method } of schema.$_terms.externals) {
        state.mainstay.externals.push({ method, schema, state, label: Errors.label(schema._flags, state, prefs) });
      }
    }
    const result = { value, errors: errors.length ? errors : null };
    if (schema._flags.result) {
      result.value = schema._flags.result === "strip" ? undefined : helpers.original;
      state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
      state.shadow(value, schema._flags.result);
    }
    if (schema._cache && prefs.cache !== false && !schema._refs.length) {
      schema._cache.set(helpers.original, result);
    }
    if (value !== undefined && !result.errors && schema._flags.artifact !== undefined) {
      state.mainstay.artifacts = state.mainstay.artifacts || new Map;
      if (!state.mainstay.artifacts.has(schema._flags.artifact)) {
        state.mainstay.artifacts.set(schema._flags.artifact, []);
      }
      state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);
    }
    return result;
  };
  internals.prefs = function(schema, prefs) {
    const isDefaultOptions = prefs === Common.defaults;
    if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
      return schema._preferences[Common.symbols.prefs];
    }
    prefs = Common.preferences(prefs, schema._preferences);
    if (isDefaultOptions) {
      schema._preferences[Common.symbols.prefs] = prefs;
    }
    return prefs;
  };
  internals.default = function(flag, value, errors, helpers) {
    const { schema, state, prefs } = helpers;
    const source = schema._flags[flag];
    if (prefs.noDefaults || source === undefined) {
      return value;
    }
    state.mainstay.tracer.log(schema, state, "rule", flag, "full");
    if (!source) {
      return source;
    }
    if (typeof source === "function") {
      const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
      try {
        return source(...args);
      } catch (err) {
        errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
        return;
      }
    }
    if (typeof source !== "object") {
      return source;
    }
    if (source[Common.symbols.literal]) {
      return source.literal;
    }
    if (Common.isResolvable(source)) {
      return source.resolve(value, state, prefs);
    }
    return Clone(source);
  };
  internals.trim = function(value, schema) {
    if (typeof value !== "string") {
      return value;
    }
    const trim = schema.$_getRule("trim");
    if (!trim || !trim.args.enabled) {
      return value;
    }
    return value.trim();
  };
  internals.ignore = {
    active: false,
    debug: Ignore,
    entry: Ignore,
    filter: Ignore,
    log: Ignore,
    resolve: Ignore,
    value: Ignore
  };
  internals.errorsArray = function() {
    const errors = [];
    errors[Common.symbols.errors] = true;
    return errors;
  };
});

// node_modules/joi/lib/values.js
var require_values2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var DeepEqual = require_deepEqual2();
  var Common = require_common2();
  var internals = {};
  module.exports = internals.Values = class {
    constructor(values, refs) {
      this._values = new Set(values);
      this._refs = new Set(refs);
      this._lowercase = internals.lowercases(values);
      this._override = false;
    }
    get length() {
      return this._values.size + this._refs.size;
    }
    add(value, refs) {
      if (Common.isResolvable(value)) {
        if (!this._refs.has(value)) {
          this._refs.add(value);
          if (refs) {
            refs.register(value);
          }
        }
        return;
      }
      if (!this.has(value, null, null, false)) {
        this._values.add(value);
        if (typeof value === "string") {
          this._lowercase.set(value.toLowerCase(), value);
        }
      }
    }
    static merge(target, source, remove) {
      target = target || new internals.Values;
      if (source) {
        if (source._override) {
          return source.clone();
        }
        for (const item of [...source._values, ...source._refs]) {
          target.add(item);
        }
      }
      if (remove) {
        for (const item of [...remove._values, ...remove._refs]) {
          target.remove(item);
        }
      }
      return target.length ? target : null;
    }
    remove(value) {
      if (Common.isResolvable(value)) {
        this._refs.delete(value);
        return;
      }
      this._values.delete(value);
      if (typeof value === "string") {
        this._lowercase.delete(value.toLowerCase());
      }
    }
    has(value, state, prefs, insensitive) {
      return !!this.get(value, state, prefs, insensitive);
    }
    get(value, state, prefs, insensitive) {
      if (!this.length) {
        return false;
      }
      if (this._values.has(value)) {
        return { value };
      }
      if (typeof value === "string" && value && insensitive) {
        const found = this._lowercase.get(value.toLowerCase());
        if (found) {
          return { value: found };
        }
      }
      if (!this._refs.size && typeof value !== "object") {
        return false;
      }
      if (typeof value === "object") {
        for (const item of this._values) {
          if (DeepEqual(item, value)) {
            return { value: item };
          }
        }
      }
      if (state) {
        for (const ref of this._refs) {
          const resolved = ref.resolve(value, state, prefs, null, { in: true });
          if (resolved === undefined) {
            continue;
          }
          const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
          for (const item of items) {
            if (typeof item !== typeof value) {
              continue;
            }
            if (insensitive && value && typeof value === "string") {
              if (item.toLowerCase() === value.toLowerCase()) {
                return { value: item, ref };
              }
            } else {
              if (DeepEqual(item, value)) {
                return { value: item, ref };
              }
            }
          }
        }
      }
      return false;
    }
    override() {
      this._override = true;
    }
    values(options) {
      if (options && options.display) {
        const values = [];
        for (const item of [...this._values, ...this._refs]) {
          if (item !== undefined) {
            values.push(item);
          }
        }
        return values;
      }
      return Array.from([...this._values, ...this._refs]);
    }
    clone() {
      const set = new internals.Values(this._values, this._refs);
      set._override = this._override;
      return set;
    }
    concat(source) {
      Assert(!source._override, "Cannot concat override set of values");
      const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
      set._override = this._override;
      return set;
    }
    describe() {
      const normalized = [];
      if (this._override) {
        normalized.push({ override: true });
      }
      for (const value of this._values.values()) {
        normalized.push(value && typeof value === "object" ? { value } : value);
      }
      for (const value of this._refs.values()) {
        normalized.push(value.describe());
      }
      return normalized;
    }
  };
  internals.Values.prototype[Common.symbols.values] = true;
  internals.Values.prototype.slice = internals.Values.prototype.clone;
  internals.lowercases = function(from) {
    const map = new Map;
    if (from) {
      for (const value of from) {
        if (typeof value === "string") {
          map.set(value.toLowerCase(), value);
        }
      }
    }
    return map;
  };
});

// node_modules/joi/lib/base.js
var require_base2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var DeepEqual = require_deepEqual2();
  var Merge = require_merge2();
  var Cache = require_cache2();
  var Common = require_common2();
  var Compile = require_compile2();
  var Errors = require_errors3();
  var Extend = require_extend2();
  var Manifest = require_manifest();
  var Messages = require_messages3();
  var Modify = require_modify2();
  var Ref = require_ref2();
  var Trace = require_trace();
  var Validator = require_validator2();
  var Values = require_values2();
  var internals = {};
  internals.Base = class {
    constructor(type) {
      this.type = type;
      this.$_root = null;
      this._definition = {};
      this._reset();
    }
    _reset() {
      this._ids = new Modify.Ids;
      this._preferences = null;
      this._refs = new Ref.Manager;
      this._cache = null;
      this._valids = null;
      this._invalids = null;
      this._flags = {};
      this._rules = [];
      this._singleRules = new Map;
      this.$_terms = {};
      this.$_temp = {
        ruleset: null,
        whens: {}
      };
    }
    describe() {
      Assert(typeof Manifest.describe === "function", "Manifest functionality disabled");
      return Manifest.describe(this);
    }
    allow(...values) {
      Common.verifyFlat(values, "allow");
      return this._values(values, "_valids");
    }
    alter(targets) {
      Assert(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
      Assert(!this._inRuleset(), "Cannot set alterations inside a ruleset");
      const obj = this.clone();
      obj.$_terms.alterations = obj.$_terms.alterations || [];
      for (const target in targets) {
        const adjuster = targets[target];
        Assert(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
        obj.$_terms.alterations.push({ target, adjuster });
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    artifact(id) {
      Assert(id !== undefined, "Artifact cannot be undefined");
      Assert(!this._cache, "Cannot set an artifact with a rule cache");
      return this.$_setFlag("artifact", id);
    }
    cast(to) {
      Assert(to === false || typeof to === "string", "Invalid to value");
      Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
      return this.$_setFlag("cast", to === false ? undefined : to);
    }
    default(value, options) {
      return this._default("default", value, options);
    }
    description(desc) {
      Assert(desc && typeof desc === "string", "Description must be a non-empty string");
      return this.$_setFlag("description", desc);
    }
    empty(schema) {
      const obj = this.clone();
      if (schema !== undefined) {
        schema = obj.$_compile(schema, { override: false });
      }
      return obj.$_setFlag("empty", schema, { clone: false });
    }
    error(err) {
      Assert(err, "Missing error");
      Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
      return this.$_setFlag("error", err);
    }
    example(example, options = {}) {
      Assert(example !== undefined, "Missing example");
      Common.assertOptions(options, ["override"]);
      return this._inner("examples", example, { single: true, override: options.override });
    }
    external(method, description) {
      if (typeof method === "object") {
        Assert(!description, "Cannot combine options with description");
        description = method.description;
        method = method.method;
      }
      Assert(typeof method === "function", "Method must be a function");
      Assert(description === undefined || description && typeof description === "string", "Description must be a non-empty string");
      return this._inner("externals", { method, description }, { single: true });
    }
    failover(value, options) {
      return this._default("failover", value, options);
    }
    forbidden() {
      return this.presence("forbidden");
    }
    id(id) {
      if (!id) {
        return this.$_setFlag("id", undefined);
      }
      Assert(typeof id === "string", "id must be a non-empty string");
      Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
      return this.$_setFlag("id", id);
    }
    invalid(...values) {
      return this._values(values, "_invalids");
    }
    label(name) {
      Assert(name && typeof name === "string", "Label name must be a non-empty string");
      return this.$_setFlag("label", name);
    }
    meta(meta) {
      Assert(meta !== undefined, "Meta cannot be undefined");
      return this._inner("metas", meta, { single: true });
    }
    note(...notes) {
      Assert(notes.length, "Missing notes");
      for (const note of notes) {
        Assert(note && typeof note === "string", "Notes must be non-empty strings");
      }
      return this._inner("notes", notes);
    }
    only(mode = true) {
      Assert(typeof mode === "boolean", "Invalid mode:", mode);
      return this.$_setFlag("only", mode);
    }
    optional() {
      return this.presence("optional");
    }
    prefs(prefs) {
      Assert(prefs, "Missing preferences");
      Assert(prefs.context === undefined, "Cannot override context");
      Assert(prefs.externals === undefined, "Cannot override externals");
      Assert(prefs.warnings === undefined, "Cannot override warnings");
      Assert(prefs.debug === undefined, "Cannot override debug");
      Common.checkPreferences(prefs);
      const obj = this.clone();
      obj._preferences = Common.preferences(obj._preferences, prefs);
      return obj;
    }
    presence(mode) {
      Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
      return this.$_setFlag("presence", mode);
    }
    raw(enabled = true) {
      return this.$_setFlag("result", enabled ? "raw" : undefined);
    }
    result(mode) {
      Assert(["raw", "strip"].includes(mode), "Unknown result mode", mode);
      return this.$_setFlag("result", mode);
    }
    required() {
      return this.presence("required");
    }
    strict(enabled) {
      const obj = this.clone();
      const convert = enabled === undefined ? false : !enabled;
      obj._preferences = Common.preferences(obj._preferences, { convert });
      return obj;
    }
    strip(enabled = true) {
      return this.$_setFlag("result", enabled ? "strip" : undefined);
    }
    tag(...tags) {
      Assert(tags.length, "Missing tags");
      for (const tag of tags) {
        Assert(tag && typeof tag === "string", "Tags must be non-empty strings");
      }
      return this._inner("tags", tags);
    }
    unit(name) {
      Assert(name && typeof name === "string", "Unit name must be a non-empty string");
      return this.$_setFlag("unit", name);
    }
    valid(...values) {
      Common.verifyFlat(values, "valid");
      const obj = this.allow(...values);
      obj.$_setFlag("only", !!obj._valids, { clone: false });
      return obj;
    }
    when(condition, options) {
      const obj = this.clone();
      if (!obj.$_terms.whens) {
        obj.$_terms.whens = [];
      }
      const when = Compile.when(obj, condition, options);
      if (!["any", "link"].includes(obj.type)) {
        const conditions = when.is ? [when] : when.switch;
        for (const item of conditions) {
          Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
          Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
        }
      }
      obj.$_terms.whens.push(when);
      return obj.$_mutateRebuild();
    }
    cache(cache) {
      Assert(!this._inRuleset(), "Cannot set caching inside a ruleset");
      Assert(!this._cache, "Cannot override schema cache");
      Assert(this._flags.artifact === undefined, "Cannot cache a rule with an artifact");
      const obj = this.clone();
      obj._cache = cache || Cache.provider.provision();
      obj.$_temp.ruleset = false;
      return obj;
    }
    clone() {
      const obj = Object.create(Object.getPrototypeOf(this));
      return this._assign(obj);
    }
    concat(source) {
      Assert(Common.isSchema(source), "Invalid schema object");
      Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
      Assert(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
      Assert(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
      let obj = this.clone();
      if (this.type === "any" && source.type !== "any") {
        const tmpObj = source.clone();
        for (const key of Object.keys(obj)) {
          if (key !== "type") {
            tmpObj[key] = obj[key];
          }
        }
        obj = tmpObj;
      }
      obj._ids.concat(source._ids);
      obj._refs.register(source, Ref.toSibling);
      obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
      obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
      obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
      for (const name of source._singleRules.keys()) {
        if (obj._singleRules.has(name)) {
          obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
          obj._singleRules.delete(name);
        }
      }
      for (const test of source._rules) {
        if (!source._definition.rules[test.method].multi) {
          obj._singleRules.set(test.name, test);
        }
        obj._rules.push(test);
      }
      if (obj._flags.empty && source._flags.empty) {
        obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
        const flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else if (source._flags.empty) {
        obj._flags.empty = source._flags.empty;
        const flags = Object.assign({}, source._flags);
        delete flags.empty;
        Merge(obj._flags, flags);
      } else {
        Merge(obj._flags, source._flags);
      }
      for (const key in source.$_terms) {
        const terms = source.$_terms[key];
        if (!terms) {
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms;
          }
          continue;
        }
        if (!obj.$_terms[key]) {
          obj.$_terms[key] = terms.slice();
          continue;
        }
        obj.$_terms[key] = obj.$_terms[key].concat(terms);
      }
      if (this.$_root._tracer) {
        this.$_root._tracer._combine(obj, [this, source]);
      }
      return obj.$_mutateRebuild();
    }
    extend(options) {
      Assert(!options.base, "Cannot extend type with another base");
      return Extend.type(this, options);
    }
    extract(path2) {
      path2 = Array.isArray(path2) ? path2 : path2.split(".");
      return this._ids.reach(path2);
    }
    fork(paths, adjuster) {
      Assert(!this._inRuleset(), "Cannot fork inside a ruleset");
      let obj = this;
      for (let path2 of [].concat(paths)) {
        path2 = Array.isArray(path2) ? path2 : path2.split(".");
        obj = obj._ids.fork(path2, adjuster, obj);
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    rule(options) {
      const def = this._definition;
      Common.assertOptions(options, Object.keys(def.modifiers));
      Assert(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
      const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
      Assert(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
      const obj = this.clone();
      for (let i = start;i < obj._rules.length; ++i) {
        const original = obj._rules[i];
        const rule = Clone(original);
        for (const name in options) {
          def.modifiers[name](rule, options[name]);
          Assert(rule.name === original.name, "Cannot change rule name");
        }
        obj._rules[i] = rule;
        if (obj._singleRules.get(rule.name) === original) {
          obj._singleRules.set(rule.name, rule);
        }
      }
      obj.$_temp.ruleset = false;
      return obj.$_mutateRebuild();
    }
    get ruleset() {
      Assert(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
      const obj = this.clone();
      obj.$_temp.ruleset = obj._rules.length;
      return obj;
    }
    get $() {
      return this.ruleset;
    }
    tailor(targets) {
      targets = [].concat(targets);
      Assert(!this._inRuleset(), "Cannot tailor inside a ruleset");
      let obj = this;
      if (this.$_terms.alterations) {
        for (const { target, adjuster } of this.$_terms.alterations) {
          if (targets.includes(target)) {
            obj = adjuster(obj);
            Assert(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
          }
        }
      }
      obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
      obj.$_temp.ruleset = false;
      return obj.$_mutateRebuild();
    }
    tracer() {
      return Trace.location ? Trace.location(this) : this;
    }
    validate(value, options) {
      return Validator.entry(value, this, options);
    }
    validateAsync(value, options) {
      return Validator.entryAsync(value, this, options);
    }
    $_addRule(options) {
      if (typeof options === "string") {
        options = { name: options };
      }
      Assert(options && typeof options === "object", "Invalid options");
      Assert(options.name && typeof options.name === "string", "Invalid rule name");
      for (const key in options) {
        Assert(key[0] !== "_", "Cannot set private rule properties");
      }
      const rule = Object.assign({}, options);
      rule._resolve = [];
      rule.method = rule.method || rule.name;
      const definition = this._definition.rules[rule.method];
      const args = rule.args;
      Assert(definition, "Unknown rule", rule.method);
      const obj = this.clone();
      if (args) {
        Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
        for (const key in args) {
          let arg = args[key];
          if (definition.argsByName) {
            const resolver = definition.argsByName.get(key);
            if (resolver.ref && Common.isResolvable(arg)) {
              rule._resolve.push(key);
              obj.$_mutateRegister(arg);
            } else {
              if (resolver.normalize) {
                arg = resolver.normalize(arg);
                args[key] = arg;
              }
              if (resolver.assert) {
                const error = Common.validateArg(arg, key, resolver);
                Assert(!error, error, "or reference");
              }
            }
          }
          if (arg === undefined) {
            delete args[key];
            continue;
          }
          args[key] = arg;
        }
      }
      if (!definition.multi) {
        obj._ruleRemove(rule.name, { clone: false });
        obj._singleRules.set(rule.name, rule);
      }
      if (obj.$_temp.ruleset === false) {
        obj.$_temp.ruleset = null;
      }
      if (definition.priority) {
        obj._rules.unshift(rule);
      } else {
        obj._rules.push(rule);
      }
      return obj;
    }
    $_compile(schema, options) {
      return Compile.schema(this.$_root, schema, options);
    }
    $_createError(code, value, local, state, prefs, options = {}) {
      const flags = options.flags !== false ? this._flags : {};
      const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
      return new Errors.Report(code, value, local, flags, messages, state, prefs);
    }
    $_getFlag(name) {
      return this._flags[name];
    }
    $_getRule(name) {
      return this._singleRules.get(name);
    }
    $_mapLabels(path2) {
      path2 = Array.isArray(path2) ? path2 : path2.split(".");
      return this._ids.labels(path2);
    }
    $_match(value, state, prefs, overrides) {
      prefs = Object.assign({}, prefs);
      prefs.abortEarly = true;
      prefs._externals = false;
      state.snapshot();
      const result = !Validator.validate(value, this, state, prefs, overrides).errors;
      state.restore();
      return result;
    }
    $_modify(options) {
      Common.assertOptions(options, ["each", "once", "ref", "schema"]);
      return Modify.schema(this, options) || this;
    }
    $_mutateRebuild() {
      Assert(!this._inRuleset(), "Cannot add this rule inside a ruleset");
      this._refs.reset();
      this._ids.reset();
      const each = (item, { source, name, path: path2, key }) => {
        const family = this._definition[source][name] && this._definition[source][name].register;
        if (family !== false) {
          this.$_mutateRegister(item, { family, key });
        }
      };
      this.$_modify({ each });
      if (this._definition.rebuild) {
        this._definition.rebuild(this);
      }
      this.$_temp.ruleset = false;
      return this;
    }
    $_mutateRegister(schema, { family, key } = {}) {
      this._refs.register(schema, family);
      this._ids.register(schema, { key });
    }
    $_property(name) {
      return this._definition.properties[name];
    }
    $_reach(path2) {
      return this._ids.reach(path2);
    }
    $_rootReferences() {
      return this._refs.roots();
    }
    $_setFlag(name, value, options = {}) {
      Assert(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
      const flag = this._definition.flags[name] || {};
      if (DeepEqual(value, flag.default)) {
        value = undefined;
      }
      if (DeepEqual(value, this._flags[name])) {
        return this;
      }
      const obj = options.clone !== false ? this.clone() : this;
      if (value !== undefined) {
        obj._flags[name] = value;
        obj.$_mutateRegister(value);
      } else {
        delete obj._flags[name];
      }
      if (name[0] !== "_") {
        obj.$_temp.ruleset = false;
      }
      return obj;
    }
    $_parent(method, ...args) {
      return this[method][Common.symbols.parent].call(this, ...args);
    }
    $_validate(value, state, prefs) {
      return Validator.validate(value, this, state, prefs);
    }
    _assign(target) {
      target.type = this.type;
      target.$_root = this.$_root;
      target.$_temp = Object.assign({}, this.$_temp);
      target.$_temp.whens = {};
      target._ids = this._ids.clone();
      target._preferences = this._preferences;
      target._valids = this._valids && this._valids.clone();
      target._invalids = this._invalids && this._invalids.clone();
      target._rules = this._rules.slice();
      target._singleRules = Clone(this._singleRules, { shallow: true });
      target._refs = this._refs.clone();
      target._flags = Object.assign({}, this._flags);
      target._cache = null;
      target.$_terms = {};
      for (const key in this.$_terms) {
        target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
      }
      target.$_super = {};
      for (const override in this.$_super) {
        target.$_super[override] = this._super[override].bind(target);
      }
      return target;
    }
    _bare() {
      const obj = this.clone();
      obj._reset();
      const terms = obj._definition.terms;
      for (const name in terms) {
        const term = terms[name];
        obj.$_terms[name] = term.init;
      }
      return obj.$_mutateRebuild();
    }
    _default(flag, value, options = {}) {
      Common.assertOptions(options, "literal");
      Assert(value !== undefined, "Missing", flag, "value");
      Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
      if (typeof value === "function" && options.literal) {
        value = {
          [Common.symbols.literal]: true,
          literal: value
        };
      }
      const obj = this.$_setFlag(flag, value);
      return obj;
    }
    _generate(value, state, prefs) {
      if (!this.$_terms.whens) {
        return { schema: this };
      }
      const whens = [];
      const ids = [];
      for (let i = 0;i < this.$_terms.whens.length; ++i) {
        const when = this.$_terms.whens[i];
        if (when.concat) {
          whens.push(when.concat);
          ids.push(`${i}.concat`);
          continue;
        }
        const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
        const tests = when.is ? [when] : when.switch;
        const before = ids.length;
        for (let j = 0;j < tests.length; ++j) {
          const { is, then, otherwise } = tests[j];
          const baseId = `${i}${when.switch ? "." + j : ""}`;
          if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
            if (then) {
              const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
              break;
            }
          } else if (otherwise) {
            const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
            const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
            whens.push(generated);
            ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
            break;
          }
        }
        if (when.break && ids.length > before) {
          break;
        }
      }
      const id = ids.join(", ");
      state.mainstay.tracer.debug(state, "rule", "when", id);
      if (!id) {
        return { schema: this };
      }
      if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
        return { schema: this.$_temp.whens[id], id };
      }
      let obj = this;
      if (this._definition.generate) {
        obj = this._definition.generate(this, value, state, prefs);
      }
      for (const when of whens) {
        obj = obj.concat(when);
      }
      if (this.$_root._tracer) {
        this.$_root._tracer._combine(obj, [this, ...whens]);
      }
      this.$_temp.whens[id] = obj;
      return { schema: obj, id };
    }
    _inner(type, values, options = {}) {
      Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
      const obj = this.clone();
      if (!obj.$_terms[type] || options.override) {
        obj.$_terms[type] = [];
      }
      if (options.single) {
        obj.$_terms[type].push(values);
      } else {
        obj.$_terms[type].push(...values);
      }
      obj.$_temp.ruleset = false;
      return obj;
    }
    _inRuleset() {
      return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
    }
    _ruleRemove(name, options = {}) {
      if (!this._singleRules.has(name)) {
        return this;
      }
      const obj = options.clone !== false ? this.clone() : this;
      obj._singleRules.delete(name);
      const filtered = [];
      for (let i = 0;i < obj._rules.length; ++i) {
        const test = obj._rules[i];
        if (test.name === name && !test.keep) {
          if (obj._inRuleset() && i < obj.$_temp.ruleset) {
            --obj.$_temp.ruleset;
          }
          continue;
        }
        filtered.push(test);
      }
      obj._rules = filtered;
      return obj;
    }
    _values(values, key) {
      Common.verifyFlat(values, key.slice(1, -1));
      const obj = this.clone();
      const override = values[0] === Common.symbols.override;
      if (override) {
        values = values.slice(1);
      }
      if (!obj[key] && values.length) {
        obj[key] = new Values;
      } else if (override) {
        obj[key] = values.length ? new Values : null;
        obj.$_mutateRebuild();
      }
      if (!obj[key]) {
        return obj;
      }
      if (override) {
        obj[key].override();
      }
      for (const value of values) {
        Assert(value !== undefined, "Cannot call allow/valid/invalid with undefined");
        Assert(value !== Common.symbols.override, "Override must be the first value");
        const other = key === "_invalids" ? "_valids" : "_invalids";
        if (obj[other]) {
          obj[other].remove(value);
          if (!obj[other].length) {
            Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
            obj[other] = null;
          }
        }
        obj[key].add(value, obj._refs);
      }
      return obj;
    }
  };
  internals.Base.prototype[Common.symbols.any] = {
    version: Common.version,
    compile: Compile.compile,
    root: "$_root"
  };
  internals.Base.prototype.isImmutable = true;
  internals.Base.prototype.deny = internals.Base.prototype.invalid;
  internals.Base.prototype.disallow = internals.Base.prototype.invalid;
  internals.Base.prototype.equal = internals.Base.prototype.valid;
  internals.Base.prototype.exist = internals.Base.prototype.required;
  internals.Base.prototype.not = internals.Base.prototype.invalid;
  internals.Base.prototype.options = internals.Base.prototype.prefs;
  internals.Base.prototype.preferences = internals.Base.prototype.prefs;
  module.exports = new internals.Base;
});

// node_modules/joi/lib/types/any.js
var require_any2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Base = require_base2();
  var Common = require_common2();
  var Messages = require_messages3();
  module.exports = Base.extend({
    type: "any",
    flags: {
      only: { default: false }
    },
    terms: {
      alterations: { init: null },
      examples: { init: null },
      externals: { init: null },
      metas: { init: [] },
      notes: { init: [] },
      shared: { init: null },
      tags: { init: [] },
      whens: { init: null }
    },
    rules: {
      custom: {
        method(method, description) {
          Assert(typeof method === "function", "Method must be a function");
          Assert(description === undefined || description && typeof description === "string", "Description must be a non-empty string");
          return this.$_addRule({ name: "custom", args: { method, description } });
        },
        validate(value, helpers, { method }) {
          try {
            return method(value, helpers);
          } catch (err) {
            return helpers.error("any.custom", { error: err });
          }
        },
        args: ["method", "description"],
        multi: true
      },
      messages: {
        method(messages) {
          return this.prefs({ messages });
        }
      },
      shared: {
        method(schema) {
          Assert(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
          const obj = this.clone();
          obj.$_terms.shared = obj.$_terms.shared || [];
          obj.$_terms.shared.push(schema);
          obj.$_mutateRegister(schema);
          return obj;
        }
      },
      warning: {
        method(code, local) {
          Assert(code && typeof code === "string", "Invalid warning code");
          return this.$_addRule({ name: "warning", args: { code, local }, warn: true });
        },
        validate(value, helpers, { code, local }) {
          return helpers.error(code, local);
        },
        args: ["code", "local"],
        multi: true
      }
    },
    modifiers: {
      keep(rule, enabled = true) {
        rule.keep = enabled;
      },
      message(rule, message) {
        rule.message = Messages.compile(message);
      },
      warn(rule, enabled = true) {
        rule.warn = enabled;
      }
    },
    manifest: {
      build(obj, desc) {
        for (const key in desc) {
          const values = desc[key];
          if (["examples", "externals", "metas", "notes", "tags"].includes(key)) {
            for (const value of values) {
              obj = obj[key.slice(0, -1)](value);
            }
            continue;
          }
          if (key === "alterations") {
            const alter = {};
            for (const { target, adjuster } of values) {
              alter[target] = adjuster;
            }
            obj = obj.alter(alter);
            continue;
          }
          if (key === "whens") {
            for (const value of values) {
              const { ref, is, not, then, otherwise, concat } = value;
              if (concat) {
                obj = obj.concat(concat);
              } else if (ref) {
                obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
              } else {
                obj = obj.when(is, { then, otherwise, break: value.break });
              }
            }
            continue;
          }
          if (key === "shared") {
            for (const value of values) {
              obj = obj.shared(value);
            }
          }
        }
        return obj;
      }
    },
    messages: {
      "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
      "any.default": "{{#label}} threw an error when running default method",
      "any.failover": "{{#label}} threw an error when running failover method",
      "any.invalid": "{{#label}} contains an invalid value",
      "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
      "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
      "any.required": "{{#label}} is required",
      "any.unknown": "{{#label}} is not allowed"
    }
  });
});

// node_modules/joi/lib/types/alternatives.js
var require_alternatives2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Merge = require_merge2();
  var Any = require_any2();
  var Common = require_common2();
  var Compile = require_compile2();
  var Errors = require_errors3();
  var Ref = require_ref2();
  var internals = {};
  module.exports = Any.extend({
    type: "alternatives",
    flags: {
      match: { default: "any" }
    },
    terms: {
      matches: { init: [], register: Ref.toSibling }
    },
    args(schema, ...schemas) {
      if (schemas.length === 1) {
        if (Array.isArray(schemas[0])) {
          return schema.try(...schemas[0]);
        }
      }
      return schema.try(...schemas);
    },
    validate(value, helpers) {
      const { schema, error, state, prefs } = helpers;
      if (schema._flags.match) {
        const matched = [];
        const failed = [];
        for (let i = 0;i < schema.$_terms.matches.length; ++i) {
          const item = schema.$_terms.matches[i];
          const localState = state.nest(item.schema, `match.${i}`);
          localState.snapshot();
          const result = item.schema.$_validate(value, localState, prefs);
          if (!result.errors) {
            matched.push(result.value);
            localState.commit();
          } else {
            failed.push(result.errors);
            localState.restore();
          }
        }
        if (matched.length === 0) {
          const context = {
            details: failed.map((f) => Errors.details(f, { override: false }))
          };
          return { errors: error("alternatives.any", context) };
        }
        if (schema._flags.match === "one") {
          return matched.length === 1 ? { value: matched[0] } : { errors: error("alternatives.one") };
        }
        if (matched.length !== schema.$_terms.matches.length) {
          const context = {
            details: failed.map((f) => Errors.details(f, { override: false }))
          };
          return { errors: error("alternatives.all", context) };
        }
        const isAnyObj = (alternative) => {
          return alternative.$_terms.matches.some((v) => {
            return v.schema.type === "object" || v.schema.type === "alternatives" && isAnyObj(v.schema);
          });
        };
        return isAnyObj(schema) ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };
      }
      const errors = [];
      for (let i = 0;i < schema.$_terms.matches.length; ++i) {
        const item = schema.$_terms.matches[i];
        if (item.schema) {
          const localState = state.nest(item.schema, `match.${i}`);
          localState.snapshot();
          const result = item.schema.$_validate(value, localState, prefs);
          if (!result.errors) {
            localState.commit();
            return result;
          }
          localState.restore();
          errors.push({ schema: item.schema, reports: result.errors });
          continue;
        }
        const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
        const tests = item.is ? [item] : item.switch;
        for (let j = 0;j < tests.length; ++j) {
          const test = tests[j];
          const { is, then, otherwise } = test;
          const id = `match.${i}${item.switch ? "." + j : ""}`;
          if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
            if (otherwise) {
              return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
            }
          } else if (then) {
            return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
          }
        }
      }
      return internals.errors(errors, helpers);
    },
    rules: {
      conditional: {
        method(condition, options) {
          Assert(!this._flags._endedSwitch, "Unreachable condition");
          Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
          Assert(options.break === undefined, "Cannot use break option with alternatives conditional");
          const obj = this.clone();
          const match = Compile.when(obj, condition, options);
          const conditions = match.is ? [match] : match.switch;
          for (const item of conditions) {
            if (item.then && item.otherwise) {
              obj.$_setFlag("_endedSwitch", true, { clone: false });
              break;
            }
          }
          obj.$_terms.matches.push(match);
          return obj.$_mutateRebuild();
        }
      },
      match: {
        method(mode) {
          Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
          if (mode !== "any") {
            for (const match of this.$_terms.matches) {
              Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
            }
          }
          return this.$_setFlag("match", mode);
        }
      },
      try: {
        method(...schemas) {
          Assert(schemas.length, "Missing alternative schemas");
          Common.verifyFlat(schemas, "try");
          Assert(!this._flags._endedSwitch, "Unreachable condition");
          const obj = this.clone();
          for (const schema of schemas) {
            obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
          }
          return obj.$_mutateRebuild();
        }
      }
    },
    overrides: {
      label(name) {
        const obj = this.$_parent("label", name);
        const each = (item, source) => {
          return source.path[0] !== "is" && typeof item._flags.label !== "string" ? item.label(name) : undefined;
        };
        return obj.$_modify({ each, ref: false });
      }
    },
    rebuild(schema) {
      const each = (item) => {
        if (Common.isSchema(item) && item.type === "array") {
          schema.$_setFlag("_arrayItems", true, { clone: false });
        }
      };
      schema.$_modify({ each });
    },
    manifest: {
      build(obj, desc) {
        if (desc.matches) {
          for (const match of desc.matches) {
            const { schema, ref, is, not, then, otherwise } = match;
            if (schema) {
              obj = obj.try(schema);
            } else if (ref) {
              obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
            } else {
              obj = obj.conditional(is, { then, otherwise });
            }
          }
        }
        return obj;
      }
    },
    messages: {
      "alternatives.all": "{{#label}} does not match all of the required types",
      "alternatives.any": "{{#label}} does not match any of the allowed types",
      "alternatives.match": "{{#label}} does not match any of the allowed types",
      "alternatives.one": "{{#label}} matches more than one allowed type",
      "alternatives.types": "{{#label}} must be one of {{#types}}"
    }
  });
  internals.errors = function(failures, { error, state }) {
    if (!failures.length) {
      return { errors: error("alternatives.any") };
    }
    if (failures.length === 1) {
      return { errors: failures[0].reports };
    }
    const valids = new Set;
    const complex = [];
    for (const { reports, schema } of failures) {
      if (reports.length > 1) {
        return internals.unmatched(failures, error);
      }
      const report = reports[0];
      if (report instanceof Errors.Report === false) {
        return internals.unmatched(failures, error);
      }
      if (report.state.path.length !== state.path.length) {
        complex.push({ type: schema.type, report });
        continue;
      }
      if (report.code === "any.only") {
        for (const valid of report.local.valids) {
          valids.add(valid);
        }
        continue;
      }
      const [type, code] = report.code.split(".");
      if (code !== "base") {
        complex.push({ type: schema.type, report });
      } else if (report.code === "object.base") {
        valids.add(report.local.type);
      } else {
        valids.add(type);
      }
    }
    if (!complex.length) {
      return { errors: error("alternatives.types", { types: [...valids] }) };
    }
    if (complex.length === 1) {
      return { errors: complex[0].report };
    }
    return internals.unmatched(failures, error);
  };
  internals.unmatched = function(failures, error) {
    const errors = [];
    for (const failure of failures) {
      errors.push(...failure.reports);
    }
    return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
  };
});

// node_modules/joi/lib/types/array.js
var require_array2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var DeepEqual = require_deepEqual2();
  var Reach = require_reach2();
  var Any = require_any2();
  var Common = require_common2();
  var Compile = require_compile2();
  var internals = {};
  module.exports = Any.extend({
    type: "array",
    flags: {
      single: { default: false },
      sparse: { default: false }
    },
    terms: {
      items: { init: [], manifest: "schema" },
      ordered: { init: [], manifest: "schema" },
      _exclusions: { init: [] },
      _inclusions: { init: [] },
      _requireds: { init: [] }
    },
    coerce: {
      from: "object",
      method(value, { schema, state, prefs }) {
        if (!Array.isArray(value)) {
          return;
        }
        const sort = schema.$_getRule("sort");
        if (!sort) {
          return;
        }
        return internals.sort(schema, value, sort.args.options, state, prefs);
      }
    },
    validate(value, { schema, error }) {
      if (!Array.isArray(value)) {
        if (schema._flags.single) {
          const single = [value];
          single[Common.symbols.arraySingle] = true;
          return { value: single };
        }
        return { errors: error("array.base") };
      }
      if (!schema.$_getRule("items") && !schema.$_terms.externals) {
        return;
      }
      return { value: value.slice() };
    },
    rules: {
      has: {
        method(schema) {
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.$_addRule({ name: "has", args: { schema } });
          obj.$_mutateRegister(schema);
          return obj;
        },
        validate(value, { state, prefs, error }, { schema: has }) {
          const ancestors = [value, ...state.ancestors];
          for (let i = 0;i < value.length; ++i) {
            const localState = state.localize([...state.path, i], ancestors, has);
            if (has.$_match(value[i], localState, prefs)) {
              return value;
            }
          }
          const patternLabel = has._flags.label;
          if (patternLabel) {
            return error("array.hasKnown", { patternLabel });
          }
          return error("array.hasUnknown", null);
        },
        multi: true
      },
      items: {
        method(...schemas) {
          Common.verifyFlat(schemas, "items");
          const obj = this.$_addRule("items");
          for (let i = 0;i < schemas.length; ++i) {
            const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
            obj.$_terms.items.push(type);
          }
          return obj.$_mutateRebuild();
        },
        validate(value, { schema, error, state, prefs, errorsArray }) {
          const requireds = schema.$_terms._requireds.slice();
          const ordereds = schema.$_terms.ordered.slice();
          const inclusions = [...schema.$_terms._inclusions, ...requireds];
          const wasArray = !value[Common.symbols.arraySingle];
          delete value[Common.symbols.arraySingle];
          const errors = errorsArray();
          let il = value.length;
          for (let i = 0;i < il; ++i) {
            const item = value[i];
            let errored = false;
            let isValid = false;
            const key = wasArray ? i : new Number(i);
            const path2 = [...state.path, key];
            if (!schema._flags.sparse && item === undefined) {
              errors.push(error("array.sparse", { key, path: path2, pos: i, value: undefined }, state.localize(path2)));
              if (prefs.abortEarly) {
                return errors;
              }
              ordereds.shift();
              continue;
            }
            const ancestors = [value, ...state.ancestors];
            for (const exclusion of schema.$_terms._exclusions) {
              if (!exclusion.$_match(item, state.localize(path2, ancestors, exclusion), prefs, { presence: "ignore" })) {
                continue;
              }
              errors.push(error("array.excludes", { pos: i, value: item }, state.localize(path2)));
              if (prefs.abortEarly) {
                return errors;
              }
              errored = true;
              ordereds.shift();
              break;
            }
            if (errored) {
              continue;
            }
            if (schema.$_terms.ordered.length) {
              if (ordereds.length) {
                const ordered = ordereds.shift();
                const res = ordered.$_validate(item, state.localize(path2, ancestors, ordered), prefs);
                if (!res.errors) {
                  if (ordered._flags.result === "strip") {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                  } else if (!schema._flags.sparse && res.value === undefined) {
                    errors.push(error("array.sparse", { key, path: path2, pos: i, value: undefined }, state.localize(path2)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                    continue;
                  } else {
                    value[i] = res.value;
                  }
                } else {
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                }
                continue;
              } else if (!schema.$_terms.items.length) {
                errors.push(error("array.orderedLength", { pos: i, limit: schema.$_terms.ordered.length }));
                if (prefs.abortEarly) {
                  return errors;
                }
                break;
              }
            }
            const requiredChecks = [];
            let jl = requireds.length;
            for (let j = 0;j < jl; ++j) {
              const localState = state.localize(path2, ancestors, requireds[j]);
              localState.snapshot();
              const res = requireds[j].$_validate(item, localState, prefs);
              requiredChecks[j] = res;
              if (!res.errors) {
                localState.commit();
                value[i] = res.value;
                isValid = true;
                internals.fastSplice(requireds, j);
                --j;
                --jl;
                if (!schema._flags.sparse && res.value === undefined) {
                  errors.push(error("array.sparse", { key, path: path2, pos: i, value: undefined }, state.localize(path2)));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                }
                break;
              }
              localState.restore();
            }
            if (isValid) {
              continue;
            }
            const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
            jl = inclusions.length;
            for (const inclusion of inclusions) {
              let res;
              const previousCheck = requireds.indexOf(inclusion);
              if (previousCheck !== -1) {
                res = requiredChecks[previousCheck];
              } else {
                const localState = state.localize(path2, ancestors, inclusion);
                localState.snapshot();
                res = inclusion.$_validate(item, localState, prefs);
                if (!res.errors) {
                  localState.commit();
                  if (inclusion._flags.result === "strip") {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                  } else if (!schema._flags.sparse && res.value === undefined) {
                    errors.push(error("array.sparse", { key, path: path2, pos: i, value: undefined }, state.localize(path2)));
                    errored = true;
                  } else {
                    value[i] = res.value;
                  }
                  isValid = true;
                  break;
                }
                localState.restore();
              }
              if (jl === 1) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  isValid = true;
                  break;
                }
                errors.push(...res.errors);
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                break;
              }
            }
            if (errored) {
              continue;
            }
            if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) && !isValid) {
              if (stripUnknown) {
                internals.fastSplice(value, i);
                --i;
                --il;
                continue;
              }
              errors.push(error("array.includes", { pos: i, value: item }, state.localize(path2)));
              if (prefs.abortEarly) {
                return errors;
              }
            }
          }
          if (requireds.length) {
            internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
          }
          if (ordereds.length) {
            internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
            if (!errors.length) {
              internals.fillDefault(ordereds, value, state, prefs);
            }
          }
          return errors.length ? errors : value;
        },
        priority: true,
        manifest: false
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value.length, limit, operator)) {
            return value;
          }
          return helpers.error("array." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      },
      ordered: {
        method(...schemas) {
          Common.verifyFlat(schemas, "ordered");
          const obj = this.$_addRule("items");
          for (let i = 0;i < schemas.length; ++i) {
            const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
            internals.validateSingle(type, obj);
            obj.$_mutateRegister(type);
            obj.$_terms.ordered.push(type);
          }
          return obj.$_mutateRebuild();
        }
      },
      single: {
        method(enabled) {
          const value = enabled === undefined ? true : !!enabled;
          Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
          return this.$_setFlag("single", value);
        }
      },
      sort: {
        method(options = {}) {
          Common.assertOptions(options, ["by", "order"]);
          const settings = {
            order: options.order || "ascending"
          };
          if (options.by) {
            settings.by = Compile.ref(options.by, { ancestor: 0 });
            Assert(!settings.by.ancestor, "Cannot sort by ancestor");
          }
          return this.$_addRule({ name: "sort", args: { options: settings } });
        },
        validate(value, { error, state, prefs, schema }, { options }) {
          const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
          if (errors) {
            return errors;
          }
          for (let i = 0;i < value.length; ++i) {
            if (value[i] !== sorted[i]) {
              return error("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
            }
          }
          return value;
        },
        convert: true
      },
      sparse: {
        method(enabled) {
          const value = enabled === undefined ? true : !!enabled;
          if (this._flags.sparse === value) {
            return this;
          }
          const obj = value ? this.clone() : this.$_addRule("items");
          return obj.$_setFlag("sparse", value, { clone: false });
        }
      },
      unique: {
        method(comparator, options = {}) {
          Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
          Common.assertOptions(options, ["ignoreUndefined", "separator"]);
          const rule = { name: "unique", args: { options, comparator } };
          if (comparator) {
            if (typeof comparator === "string") {
              const separator = Common.default(options.separator, ".");
              rule.path = separator ? comparator.split(separator) : [comparator];
            } else {
              rule.comparator = comparator;
            }
          }
          return this.$_addRule(rule);
        },
        validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path: path2 }) {
          const found = {
            string: Object.create(null),
            number: Object.create(null),
            undefined: Object.create(null),
            boolean: Object.create(null),
            bigint: Object.create(null),
            object: new Map,
            function: new Map,
            custom: new Map
          };
          const compare = comparator || DeepEqual;
          const ignoreUndefined = options.ignoreUndefined;
          for (let i = 0;i < value.length; ++i) {
            const item = path2 ? Reach(value[i], path2) : value[i];
            const records = comparator ? found.custom : found[typeof item];
            Assert(records, "Failed to find unique map container for type", typeof item);
            if (records instanceof Map) {
              const entries = records.entries();
              let current;
              while (!(current = entries.next()).done) {
                if (compare(current.value[0], item)) {
                  const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: current.value[1],
                    dupeValue: value[current.value[1]]
                  };
                  if (path2) {
                    context.path = raw;
                  }
                  return error("array.unique", context, localState);
                }
              }
              records.set(item, i);
            } else {
              if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {
                const context = {
                  pos: i,
                  value: value[i],
                  dupePos: records[item],
                  dupeValue: value[records[item]]
                };
                if (path2) {
                  context.path = raw;
                }
                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                return error("array.unique", context, localState);
              }
              records[item] = i;
            }
          }
          return value;
        },
        args: ["comparator", "options"],
        multi: true
      }
    },
    cast: {
      set: {
        from: Array.isArray,
        to(value, helpers) {
          return new Set(value);
        }
      }
    },
    rebuild(schema) {
      schema.$_terms._inclusions = [];
      schema.$_terms._exclusions = [];
      schema.$_terms._requireds = [];
      for (const type of schema.$_terms.items) {
        internals.validateSingle(type, schema);
        if (type._flags.presence === "required") {
          schema.$_terms._requireds.push(type);
        } else if (type._flags.presence === "forbidden") {
          schema.$_terms._exclusions.push(type);
        } else {
          schema.$_terms._inclusions.push(type);
        }
      }
      for (const type of schema.$_terms.ordered) {
        internals.validateSingle(type, schema);
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.items) {
          obj = obj.items(...desc.items);
        }
        if (desc.ordered) {
          obj = obj.ordered(...desc.ordered);
        }
        return obj;
      }
    },
    messages: {
      "array.base": "{{#label}} must be an array",
      "array.excludes": "{{#label}} contains an excluded value",
      "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}",
      "array.hasUnknown": "{{#label}} does not contain at least one required match",
      "array.includes": "{{#label}} does not match any of the allowed types",
      "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
      "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
      "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
      "array.length": "{{#label}} must contain {{#limit}} items",
      "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
      "array.min": "{{#label}} must contain at least {{#limit}} items",
      "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
      "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
      "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
      "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
      "array.sparse": "{{#label}} must not be a sparse array item",
      "array.unique": "{{#label}} contains a duplicate value"
    }
  });
  internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
    const knownMisses = [];
    let unknownMisses = 0;
    for (const required of requireds) {
      const label = required._flags.label;
      if (label) {
        knownMisses.push(label);
      } else {
        ++unknownMisses;
      }
    }
    if (knownMisses.length) {
      if (unknownMisses) {
        errors.push(schema.$_createError("array.includesRequiredBoth", value, { knownMisses, unknownMisses }, state, prefs));
      } else {
        errors.push(schema.$_createError("array.includesRequiredKnowns", value, { knownMisses }, state, prefs));
      }
    } else {
      errors.push(schema.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
    }
  };
  internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
    const requiredOrdereds = [];
    for (const ordered of ordereds) {
      if (ordered._flags.presence === "required") {
        requiredOrdereds.push(ordered);
      }
    }
    if (requiredOrdereds.length) {
      internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
    }
  };
  internals.fillDefault = function(ordereds, value, state, prefs) {
    const overrides = [];
    let trailingUndefined = true;
    for (let i = ordereds.length - 1;i >= 0; --i) {
      const ordered = ordereds[i];
      const ancestors = [value, ...state.ancestors];
      const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;
      if (trailingUndefined) {
        if (override === undefined) {
          continue;
        }
        trailingUndefined = false;
      }
      overrides.unshift(override);
    }
    if (overrides.length) {
      value.push(...overrides);
    }
  };
  internals.fastSplice = function(arr, i) {
    let pos = i;
    while (pos < arr.length) {
      arr[pos++] = arr[pos];
    }
    --arr.length;
  };
  internals.validateSingle = function(type, obj) {
    if (type.type === "array" || type._flags._arrayItems) {
      Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
      obj.$_setFlag("_arrayItems", true, { clone: false });
    }
  };
  internals.sort = function(schema, value, settings, state, prefs) {
    const order = settings.order === "ascending" ? 1 : -1;
    const aFirst = -1 * order;
    const bFirst = order;
    const sort = (a, b) => {
      let compare = internals.compare(a, b, aFirst, bFirst);
      if (compare !== null) {
        return compare;
      }
      if (settings.by) {
        a = settings.by.resolve(a, state, prefs);
        b = settings.by.resolve(b, state, prefs);
      }
      compare = internals.compare(a, b, aFirst, bFirst);
      if (compare !== null) {
        return compare;
      }
      const type = typeof a;
      if (type !== typeof b) {
        throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
      }
      if (type !== "number" && type !== "string") {
        throw schema.$_createError("array.sort.unsupported", value, { type }, state, prefs);
      }
      if (type === "number") {
        return (a - b) * order;
      }
      return a < b ? aFirst : bFirst;
    };
    try {
      return { value: value.slice().sort(sort) };
    } catch (err) {
      return { errors: err };
    }
  };
  internals.compare = function(a, b, aFirst, bFirst) {
    if (a === b) {
      return 0;
    }
    if (a === undefined) {
      return 1;
    }
    if (b === undefined) {
      return -1;
    }
    if (a === null) {
      return bFirst;
    }
    if (b === null) {
      return aFirst;
    }
    return null;
  };
});

// node_modules/joi/lib/types/boolean.js
var require_boolean2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Any = require_any2();
  var Common = require_common2();
  var Values = require_values2();
  var internals = {};
  internals.isBool = function(value) {
    return typeof value === "boolean";
  };
  module.exports = Any.extend({
    type: "boolean",
    flags: {
      sensitive: { default: false }
    },
    terms: {
      falsy: {
        init: null,
        manifest: "values"
      },
      truthy: {
        init: null,
        manifest: "values"
      }
    },
    coerce(value, { schema }) {
      if (typeof value === "boolean") {
        return;
      }
      if (typeof value === "string") {
        const normalized = schema._flags.sensitive ? value : value.toLowerCase();
        value = normalized === "true" ? true : normalized === "false" ? false : value;
      }
      if (typeof value !== "boolean") {
        value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
      }
      return { value };
    },
    validate(value, { error }) {
      if (typeof value !== "boolean") {
        return { value, errors: error("boolean.base") };
      }
    },
    rules: {
      truthy: {
        method(...values) {
          Common.verifyFlat(values, "truthy");
          const obj = this.clone();
          obj.$_terms.truthy = obj.$_terms.truthy || new Values;
          for (let i = 0;i < values.length; ++i) {
            const value = values[i];
            Assert(value !== undefined, "Cannot call truthy with undefined");
            obj.$_terms.truthy.add(value);
          }
          return obj;
        }
      },
      falsy: {
        method(...values) {
          Common.verifyFlat(values, "falsy");
          const obj = this.clone();
          obj.$_terms.falsy = obj.$_terms.falsy || new Values;
          for (let i = 0;i < values.length; ++i) {
            const value = values[i];
            Assert(value !== undefined, "Cannot call falsy with undefined");
            obj.$_terms.falsy.add(value);
          }
          return obj;
        }
      },
      sensitive: {
        method(enabled = true) {
          return this.$_setFlag("sensitive", enabled);
        }
      }
    },
    cast: {
      number: {
        from: internals.isBool,
        to(value, helpers) {
          return value ? 1 : 0;
        }
      },
      string: {
        from: internals.isBool,
        to(value, helpers) {
          return value ? "true" : "false";
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.truthy) {
          obj = obj.truthy(...desc.truthy);
        }
        if (desc.falsy) {
          obj = obj.falsy(...desc.falsy);
        }
        return obj;
      }
    },
    messages: {
      "boolean.base": "{{#label}} must be a boolean"
    }
  });
});

// node_modules/joi/lib/types/date.js
var require_date2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Any = require_any2();
  var Common = require_common2();
  var Template = require_template2();
  var internals = {};
  internals.isDate = function(value) {
    return value instanceof Date;
  };
  module.exports = Any.extend({
    type: "date",
    coerce: {
      from: ["number", "string"],
      method(value, { schema }) {
        return { value: internals.parse(value, schema._flags.format) || value };
      }
    },
    validate(value, { schema, error, prefs }) {
      if (value instanceof Date && !isNaN(value.getTime())) {
        return;
      }
      const format = schema._flags.format;
      if (!prefs.convert || !format || typeof value !== "string") {
        return { value, errors: error("date.base") };
      }
      return { value, errors: error("date.format", { format }) };
    },
    rules: {
      compare: {
        method: false,
        validate(value, helpers, { date }, { name, operator, args }) {
          const to = date === "now" ? Date.now() : date.getTime();
          if (Common.compare(value.getTime(), to, operator)) {
            return value;
          }
          return helpers.error("date." + name, { limit: args.date, value });
        },
        args: [
          {
            name: "date",
            ref: true,
            normalize: (date) => {
              return date === "now" ? date : internals.parse(date);
            },
            assert: (date) => date !== null,
            message: "must have a valid date format"
          }
        ]
      },
      format: {
        method(format) {
          Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
          return this.$_setFlag("format", format);
        }
      },
      greater: {
        method(date) {
          return this.$_addRule({ name: "greater", method: "compare", args: { date }, operator: ">" });
        }
      },
      iso: {
        method() {
          return this.format("iso");
        }
      },
      less: {
        method(date) {
          return this.$_addRule({ name: "less", method: "compare", args: { date }, operator: "<" });
        }
      },
      max: {
        method(date) {
          return this.$_addRule({ name: "max", method: "compare", args: { date }, operator: "<=" });
        }
      },
      min: {
        method(date) {
          return this.$_addRule({ name: "min", method: "compare", args: { date }, operator: ">=" });
        }
      },
      timestamp: {
        method(type = "javascript") {
          Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
          return this.format(type);
        }
      }
    },
    cast: {
      number: {
        from: internals.isDate,
        to(value, helpers) {
          return value.getTime();
        }
      },
      string: {
        from: internals.isDate,
        to(value, { prefs }) {
          return Template.date(value, prefs);
        }
      }
    },
    messages: {
      "date.base": "{{#label}} must be a valid date",
      "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
      "date.greater": "{{#label}} must be greater than {{:#limit}}",
      "date.less": "{{#label}} must be less than {{:#limit}}",
      "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
      "date.min": "{{#label}} must be greater than or equal to {{:#limit}}",
      "date.format.iso": "ISO 8601 date",
      "date.format.javascript": "timestamp or number of milliseconds",
      "date.format.unix": "timestamp or number of seconds"
    }
  });
  internals.parse = function(value, format) {
    if (value instanceof Date) {
      return value;
    }
    if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
      return null;
    }
    if (/^\s*$/.test(value)) {
      return null;
    }
    if (format === "iso") {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      return internals.date(value.toString());
    }
    const original = value;
    if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
      value = parseFloat(value);
    }
    if (format) {
      if (format === "javascript") {
        return internals.date(1 * value);
      }
      if (format === "unix") {
        return internals.date(1000 * value);
      }
      if (typeof original === "string") {
        return null;
      }
    }
    return internals.date(value);
  };
  internals.date = function(value) {
    const date = new Date(value);
    if (!isNaN(date.getTime())) {
      return date;
    }
    return null;
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Merge = require_merge2();
  var Reach = require_reach2();
  var internals = {};
  module.exports = function(defaults2, source, options = {}) {
    Assert(defaults2 && typeof defaults2 === "object", "Invalid defaults value: must be an object");
    Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
    Assert(typeof options === "object", "Invalid options: must be an object");
    if (!source) {
      return null;
    }
    if (options.shallow) {
      return internals.applyToDefaultsWithShallow(defaults2, source, options);
    }
    const copy = Clone(defaults2);
    if (source === true) {
      return copy;
    }
    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.applyToDefaultsWithShallow = function(defaults2, source, options) {
    const keys = options.shallow;
    Assert(Array.isArray(keys), "Invalid keys");
    const seen = new Map;
    const merge = source === true ? null : new Set;
    for (let key of keys) {
      key = Array.isArray(key) ? key : key.split(".");
      const ref = Reach(defaults2, key);
      if (ref && typeof ref === "object") {
        seen.set(ref, merge && Reach(source, key) || ref);
      } else if (merge) {
        merge.add(key);
      }
    }
    const copy = Clone(defaults2, {}, seen);
    if (!merge) {
      return copy;
    }
    for (const key of merge) {
      internals.reachCopy(copy, source, key);
    }
    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.reachCopy = function(dst, src, path2) {
    for (const segment of path2) {
      if (!(segment in src)) {
        return;
      }
      const val = src[segment];
      if (typeof val !== "object" || val === null) {
        return;
      }
      src = val;
    }
    const value = src;
    let ref = dst;
    for (let i = 0;i < path2.length - 1; ++i) {
      const segment = path2[i];
      if (typeof ref[segment] !== "object") {
        ref[segment] = {};
      }
      ref = ref[segment];
    }
    ref[path2[path2.length - 1]] = value;
  };
});

// node_modules/joi/node_modules/@hapi/topo/lib/index.js
var require_lib38 = __commonJS((exports) => {
  var Assert = require_assert2();
  var internals = {};
  exports.Sorter = class {
    constructor() {
      this._items = [];
      this.nodes = [];
    }
    add(nodes, options) {
      options = options || {};
      const before = [].concat(options.before || []);
      const after = [].concat(options.after || []);
      const group = options.group || "?";
      const sort = options.sort || 0;
      Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
      Assert(!before.includes("?"), "Item cannot come before unassociated items");
      Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
      Assert(!after.includes("?"), "Item cannot come after unassociated items");
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (const node of nodes) {
        const item = {
          seq: this._items.length,
          sort,
          before,
          after,
          group,
          node
        };
        this._items.push(item);
      }
      if (!options.manual) {
        const valid = this._sort();
        Assert(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
      }
      return this.nodes;
    }
    merge(others) {
      if (!Array.isArray(others)) {
        others = [others];
      }
      for (const other of others) {
        if (other) {
          for (const item of other._items) {
            this._items.push(Object.assign({}, item));
          }
        }
      }
      this._items.sort(internals.mergeSort);
      for (let i = 0;i < this._items.length; ++i) {
        this._items[i].seq = i;
      }
      const valid = this._sort();
      Assert(valid, "merge created a dependencies error");
      return this.nodes;
    }
    sort() {
      const valid = this._sort();
      Assert(valid, "sort created a dependencies error");
      return this.nodes;
    }
    _sort() {
      const graph = {};
      const graphAfters = Object.create(null);
      const groups = Object.create(null);
      for (const item of this._items) {
        const seq = item.seq;
        const group = item.group;
        groups[group] = groups[group] || [];
        groups[group].push(seq);
        graph[seq] = item.before;
        for (const after of item.after) {
          graphAfters[after] = graphAfters[after] || [];
          graphAfters[after].push(seq);
        }
      }
      for (const node in graph) {
        const expandedGroups = [];
        for (const graphNodeItem in graph[node]) {
          const group = graph[node][graphNodeItem];
          groups[group] = groups[group] || [];
          expandedGroups.push(...groups[group]);
        }
        graph[node] = expandedGroups;
      }
      for (const group in graphAfters) {
        if (groups[group]) {
          for (const node of groups[group]) {
            graph[node].push(...graphAfters[group]);
          }
        }
      }
      const ancestors = {};
      for (const node in graph) {
        const children = graph[node];
        for (const child of children) {
          ancestors[child] = ancestors[child] || [];
          ancestors[child].push(node);
        }
      }
      const visited = {};
      const sorted = [];
      for (let i = 0;i < this._items.length; ++i) {
        let next = i;
        if (ancestors[i]) {
          next = null;
          for (let j = 0;j < this._items.length; ++j) {
            if (visited[j] === true) {
              continue;
            }
            if (!ancestors[j]) {
              ancestors[j] = [];
            }
            const shouldSeeCount = ancestors[j].length;
            let seenCount = 0;
            for (let k = 0;k < shouldSeeCount; ++k) {
              if (visited[ancestors[j][k]]) {
                ++seenCount;
              }
            }
            if (seenCount === shouldSeeCount) {
              next = j;
              break;
            }
          }
        }
        if (next !== null) {
          visited[next] = true;
          sorted.push(next);
        }
      }
      if (sorted.length !== this._items.length) {
        return false;
      }
      const seqIndex = {};
      for (const item of this._items) {
        seqIndex[item.seq] = item;
      }
      this._items = [];
      this.nodes = [];
      for (const value of sorted) {
        const sortedItem = seqIndex[value];
        this.nodes.push(sortedItem.node);
        this._items.push(sortedItem);
      }
      return true;
    }
  };
  internals.mergeSort = (a, b) => {
    return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
  };
});

// node_modules/joi/lib/types/keys.js
var require_keys2 = __commonJS((exports, module) => {
  var ApplyToDefaults = require_applyToDefaults2();
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Topo = require_lib38();
  var Any = require_any2();
  var Common = require_common2();
  var Compile = require_compile2();
  var Errors = require_errors3();
  var Ref = require_ref2();
  var Template = require_template2();
  var internals = {
    renameDefaults: {
      alias: false,
      multiple: false,
      override: false
    }
  };
  module.exports = Any.extend({
    type: "_keys",
    properties: {
      typeof: "object"
    },
    flags: {
      unknown: { default: undefined }
    },
    terms: {
      dependencies: { init: null },
      keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } },
      patterns: { init: null },
      renames: { init: null }
    },
    args(schema, keys) {
      return schema.keys(keys);
    },
    validate(value, { schema, error, state, prefs }) {
      if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
        return { value, errors: error("object.base", { type: schema.$_property("typeof") }) };
      }
      if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && !schema.$_terms.patterns && !schema.$_terms.externals) {
        return;
      }
      value = internals.clone(value, prefs);
      const errors = [];
      if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
        return { value, errors };
      }
      if (!schema.$_terms.keys && !schema.$_terms.patterns && !schema.$_terms.dependencies) {
        return { value, errors };
      }
      const unprocessed = new Set(Object.keys(value));
      if (schema.$_terms.keys) {
        const ancestors = [value, ...state.ancestors];
        for (const child of schema.$_terms.keys) {
          const key = child.key;
          const item = value[key];
          unprocessed.delete(key);
          const localState = state.localize([...state.path, key], ancestors, child);
          const result = child.schema.$_validate(item, localState, prefs);
          if (result.errors) {
            if (prefs.abortEarly) {
              return { value, errors: result.errors };
            }
            if (result.value !== undefined) {
              value[key] = result.value;
            }
            errors.push(...result.errors);
          } else if (child.schema._flags.result === "strip" || result.value === undefined && item !== undefined) {
            delete value[key];
          } else if (result.value !== undefined) {
            value[key] = result.value;
          }
        }
      }
      if (unprocessed.size || schema._flags._hasPatternMatch) {
        const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
        if (early) {
          return early;
        }
      }
      if (schema.$_terms.dependencies) {
        for (const dep of schema.$_terms.dependencies) {
          if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, { shadow: false })) === false) {
            continue;
          }
          const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
          if (failed) {
            const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
            if (prefs.abortEarly) {
              return { value, errors: report };
            }
            errors.push(report);
          }
        }
      }
      return { value, errors };
    },
    rules: {
      and: {
        method(...peers) {
          Common.verifyFlat(peers, "and");
          return internals.dependency(this, "and", null, peers);
        }
      },
      append: {
        method(schema) {
          if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
            return this;
          }
          return this.keys(schema);
        }
      },
      assert: {
        method(subject, schema, message) {
          if (!Template.isTemplate(subject)) {
            subject = Compile.ref(subject);
          }
          Assert(message === undefined || typeof message === "string", "Message must be a string");
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.$_addRule({ name: "assert", args: { subject, schema, message } });
          obj.$_mutateRegister(subject);
          obj.$_mutateRegister(schema);
          return obj;
        },
        validate(value, { error, prefs, state }, { subject, schema, message }) {
          const about = subject.resolve(value, state, prefs);
          const path2 = Ref.isRef(subject) ? subject.absolute(state) : [];
          if (schema.$_match(about, state.localize(path2, [value, ...state.ancestors], schema), prefs)) {
            return value;
          }
          return error("object.assert", { subject, message });
        },
        args: ["subject", "schema", "message"],
        multi: true
      },
      instance: {
        method(constructor, name) {
          Assert(typeof constructor === "function", "constructor must be a function");
          name = name || constructor.name;
          return this.$_addRule({ name: "instance", args: { constructor, name } });
        },
        validate(value, helpers, { constructor, name }) {
          if (value instanceof constructor) {
            return value;
          }
          return helpers.error("object.instance", { type: name, value });
        },
        args: ["constructor", "name"]
      },
      keys: {
        method(schema) {
          Assert(schema === undefined || typeof schema === "object", "Object schema must be a valid object");
          Assert(!Common.isSchema(schema), "Object schema cannot be a joi schema");
          const obj = this.clone();
          if (!schema) {
            obj.$_terms.keys = null;
          } else if (!Object.keys(schema).length) {
            obj.$_terms.keys = new internals.Keys;
          } else {
            obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys;
            for (const key in schema) {
              Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
            }
          }
          return obj.$_mutateRebuild();
        }
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(Object.keys(value).length, limit, operator)) {
            return value;
          }
          return helpers.error("object." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      },
      nand: {
        method(...peers) {
          Common.verifyFlat(peers, "nand");
          return internals.dependency(this, "nand", null, peers);
        }
      },
      or: {
        method(...peers) {
          Common.verifyFlat(peers, "or");
          return internals.dependency(this, "or", null, peers);
        }
      },
      oxor: {
        method(...peers) {
          return internals.dependency(this, "oxor", null, peers);
        }
      },
      pattern: {
        method(pattern, schema, options = {}) {
          const isRegExp = pattern instanceof RegExp;
          if (!isRegExp) {
            pattern = this.$_compile(pattern, { appendPath: true });
          }
          Assert(schema !== undefined, "Invalid rule");
          Common.assertOptions(options, ["fallthrough", "matches"]);
          if (isRegExp) {
            Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
          }
          schema = this.$_compile(schema, { appendPath: true });
          const obj = this.clone();
          obj.$_terms.patterns = obj.$_terms.patterns || [];
          const config = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema };
          if (options.matches) {
            config.matches = this.$_compile(options.matches);
            if (config.matches.type !== "array") {
              config.matches = config.matches.$_root.array().items(config.matches);
            }
            obj.$_mutateRegister(config.matches);
            obj.$_setFlag("_hasPatternMatch", true, { clone: false });
          }
          if (options.fallthrough) {
            config.fallthrough = true;
          }
          obj.$_terms.patterns.push(config);
          obj.$_mutateRegister(schema);
          return obj;
        }
      },
      ref: {
        method() {
          return this.$_addRule("ref");
        },
        validate(value, helpers) {
          if (Ref.isRef(value)) {
            return value;
          }
          return helpers.error("object.refType", { value });
        }
      },
      regex: {
        method() {
          return this.$_addRule("regex");
        },
        validate(value, helpers) {
          if (value instanceof RegExp) {
            return value;
          }
          return helpers.error("object.regex", { value });
        }
      },
      rename: {
        method(from, to, options = {}) {
          Assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
          Assert(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
          Assert(to !== from, "Cannot rename key to same name:", from);
          Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
          const obj = this.clone();
          obj.$_terms.renames = obj.$_terms.renames || [];
          for (const rename of obj.$_terms.renames) {
            Assert(rename.from !== from, "Cannot rename the same key multiple times");
          }
          if (to instanceof Template) {
            obj.$_mutateRegister(to);
          }
          obj.$_terms.renames.push({
            from,
            to,
            options: ApplyToDefaults(internals.renameDefaults, options)
          });
          return obj;
        }
      },
      schema: {
        method(type = "any") {
          return this.$_addRule({ name: "schema", args: { type } });
        },
        validate(value, helpers, { type }) {
          if (Common.isSchema(value) && (type === "any" || value.type === type)) {
            return value;
          }
          return helpers.error("object.schema", { type });
        }
      },
      unknown: {
        method(allow) {
          return this.$_setFlag("unknown", allow !== false);
        }
      },
      with: {
        method(key, peers, options = {}) {
          return internals.dependency(this, "with", key, peers, options);
        }
      },
      without: {
        method(key, peers, options = {}) {
          return internals.dependency(this, "without", key, peers, options);
        }
      },
      xor: {
        method(...peers) {
          Common.verifyFlat(peers, "xor");
          return internals.dependency(this, "xor", null, peers);
        }
      }
    },
    overrides: {
      default(value, options) {
        if (value === undefined) {
          value = Common.symbols.deepDefault;
        }
        return this.$_parent("default", value, options);
      }
    },
    rebuild(schema) {
      if (schema.$_terms.keys) {
        const topo = new Topo.Sorter;
        for (const child of schema.$_terms.keys) {
          Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
        }
        schema.$_terms.keys = new internals.Keys(...topo.nodes);
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.keys) {
          obj = obj.keys(desc.keys);
        }
        if (desc.dependencies) {
          for (const { rel, key = null, peers, options } of desc.dependencies) {
            obj = internals.dependency(obj, rel, key, peers, options);
          }
        }
        if (desc.patterns) {
          for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
            obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
          }
        }
        if (desc.renames) {
          for (const { from, to, options } of desc.renames) {
            obj = obj.rename(from, to, options);
          }
        }
        return obj;
      }
    },
    messages: {
      "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
      "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
      "object.base": "{{#label}} must be of type {{#type}}",
      "object.instance": "{{#label}} must be an instance of {{:#type}}",
      "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
      "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
      "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
      "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
      "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
      "object.refType": "{{#label}} must be a Joi reference",
      "object.regex": "{{#label}} must be a RegExp object",
      "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
      "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
      "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
      "object.unknown": "{{#label}} is not allowed",
      "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
      "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
      "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
    }
  });
  internals.clone = function(value, prefs) {
    if (typeof value === "object") {
      if (prefs.nonEnumerables) {
        return Clone(value, { shallow: true });
      }
      const clone2 = Object.create(Object.getPrototypeOf(value));
      Object.assign(clone2, value);
      return clone2;
    }
    const clone = function(...args) {
      return value.apply(this, args);
    };
    clone.prototype = Clone(value.prototype);
    Object.defineProperty(clone, "name", { value: value.name, writable: false });
    Object.defineProperty(clone, "length", { value: value.length, writable: false });
    Object.assign(clone, value);
    return clone;
  };
  internals.dependency = function(schema, rel, key, peers, options) {
    Assert(key === null || typeof key === "string", rel, "key must be a strings");
    if (!options) {
      options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
    }
    Common.assertOptions(options, ["separator", "isPresent"]);
    peers = [].concat(peers);
    const separator = Common.default(options.separator, ".");
    const paths = [];
    for (const peer of peers) {
      Assert(typeof peer === "string", rel, "peers must be strings");
      paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
    }
    if (key !== null) {
      key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
    }
    const obj = schema.clone();
    obj.$_terms.dependencies = obj.$_terms.dependencies || [];
    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));
    return obj;
  };
  internals.dependencies = {
    and(schema, dep, value, state, prefs) {
      const missing = [];
      const present = [];
      const count = dep.peers.length;
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
          missing.push(peer.key);
        } else {
          present.push(peer.key);
        }
      }
      if (missing.length !== count && present.length !== count) {
        return {
          code: "object.and",
          context: {
            present,
            presentWithLabels: internals.keysToLabels(schema, present),
            missing,
            missingWithLabels: internals.keysToLabels(schema, missing)
          }
        };
      }
    },
    nand(schema, dep, value, state, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (present.length !== dep.peers.length) {
        return;
      }
      const main = dep.paths[0];
      const values = dep.paths.slice(1);
      return {
        code: "object.nand",
        context: {
          main,
          mainWithLabel: internals.keysToLabels(schema, main),
          peers: values,
          peersWithLabels: internals.keysToLabels(schema, values)
        }
      };
    },
    or(schema, dep, value, state, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          return;
        }
      }
      return {
        code: "object.missing",
        context: {
          peers: dep.paths,
          peersWithLabels: internals.keysToLabels(schema, dep.paths)
        }
      };
    },
    oxor(schema, dep, value, state, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (!present.length || present.length === 1) {
        return;
      }
      const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
      context.present = present;
      context.presentWithLabels = internals.keysToLabels(schema, present);
      return { code: "object.oxor", context };
    },
    with(schema, dep, value, state, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {
          return {
            code: "object.with",
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    },
    without(schema, dep, value, state, prefs) {
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          return {
            code: "object.without",
            context: {
              main: dep.key.key,
              mainWithLabel: internals.keysToLabels(schema, dep.key.key),
              peer: peer.key,
              peerWithLabel: internals.keysToLabels(schema, peer.key)
            }
          };
        }
      }
    },
    xor(schema, dep, value, state, prefs) {
      const present = [];
      const isPresent = internals.isPresent(dep.options);
      for (const peer of dep.peers) {
        if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {
          present.push(peer.key);
        }
      }
      if (present.length === 1) {
        return;
      }
      const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
      if (present.length === 0) {
        return { code: "object.missing", context };
      }
      context.present = present;
      context.presentWithLabels = internals.keysToLabels(schema, present);
      return { code: "object.xor", context };
    }
  };
  internals.keysToLabels = function(schema, keys) {
    if (Array.isArray(keys)) {
      return keys.map((key) => schema.$_mapLabels(key));
    }
    return schema.$_mapLabels(keys);
  };
  internals.isPresent = function(options) {
    return typeof options.isPresent === "function" ? options.isPresent : (resolved) => resolved !== undefined;
  };
  internals.rename = function(schema, value, state, prefs, errors) {
    const renamed = {};
    for (const rename of schema.$_terms.renames) {
      const matches = [];
      const pattern = typeof rename.from !== "string";
      if (!pattern) {
        if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {
          matches.push(rename);
        }
      } else {
        for (const from in value) {
          if (value[from] === undefined && rename.options.ignoreUndefined) {
            continue;
          }
          if (from === rename.to) {
            continue;
          }
          const match = rename.from.exec(from);
          if (!match) {
            continue;
          }
          matches.push({ from, to: rename.to, match });
        }
      }
      for (const match of matches) {
        const from = match.from;
        let to = match.to;
        if (to instanceof Template) {
          to = to.render(value, state, prefs, match.match);
        }
        if (from === to) {
          continue;
        }
        if (!rename.options.multiple && renamed[to]) {
          errors.push(schema.$_createError("object.rename.multiple", value, { from, to, pattern }, state, prefs));
          if (prefs.abortEarly) {
            return false;
          }
        }
        if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
          errors.push(schema.$_createError("object.rename.override", value, { from, to, pattern }, state, prefs));
          if (prefs.abortEarly) {
            return false;
          }
        }
        if (value[from] === undefined) {
          delete value[to];
        } else {
          value[to] = value[from];
        }
        renamed[to] = true;
        if (!rename.options.alias) {
          delete value[from];
        }
      }
    }
    return true;
  };
  internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
    if (schema.$_terms.patterns) {
      let hasMatches = false;
      const matches = schema.$_terms.patterns.map((pattern) => {
        if (pattern.matches) {
          hasMatches = true;
          return [];
        }
      });
      const ancestors = [value, ...state.ancestors];
      for (const key of unprocessed) {
        const item = value[key];
        const path2 = [...state.path, key];
        for (let i = 0;i < schema.$_terms.patterns.length; ++i) {
          const pattern = schema.$_terms.patterns[i];
          if (pattern.regex) {
            const match = pattern.regex.test(key);
            state.mainstay.tracer.debug(state, "rule", `pattern.${i}`, match ? "pass" : "error");
            if (!match) {
              continue;
            }
          } else {
            if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
              continue;
            }
          }
          unprocessed.delete(key);
          const localState = state.localize(path2, ancestors, { schema: pattern.rule, key });
          const result = pattern.rule.$_validate(item, localState, prefs);
          if (result.errors) {
            if (prefs.abortEarly) {
              return { value, errors: result.errors };
            }
            errors.push(...result.errors);
          }
          if (pattern.matches) {
            matches[i].push(key);
          }
          value[key] = result.value;
          if (!pattern.fallthrough) {
            break;
          }
        }
      }
      if (hasMatches) {
        for (let i = 0;i < matches.length; ++i) {
          const match = matches[i];
          if (!match) {
            continue;
          }
          const stpm = schema.$_terms.patterns[i].matches;
          const localState = state.localize(state.path, ancestors, stpm);
          const result = stpm.$_validate(match, localState, prefs);
          if (result.errors) {
            const details = Errors.details(result.errors, { override: false });
            details.matches = match;
            const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
            if (prefs.abortEarly) {
              return { value, errors: report };
            }
            errors.push(report);
          }
        }
      }
    }
    if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
      return;
    }
    if (prefs.stripUnknown && typeof schema._flags.unknown === "undefined" || prefs.skipFunctions) {
      const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
      for (const key of unprocessed) {
        if (stripUnknown) {
          delete value[key];
          unprocessed.delete(key);
        } else if (typeof value[key] === "function") {
          unprocessed.delete(key);
        }
      }
    }
    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
    if (forbidUnknown) {
      for (const unprocessedKey of unprocessed) {
        const localState = state.localize([...state.path, unprocessedKey], []);
        const report = schema.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
        if (prefs.abortEarly) {
          return { value, errors: report };
        }
        errors.push(report);
      }
    }
  };
  internals.Dependency = class {
    constructor(rel, key, peers, paths, options) {
      this.rel = rel;
      this.key = key;
      this.peers = peers;
      this.paths = paths;
      this.options = options;
    }
    describe() {
      const desc = {
        rel: this.rel,
        peers: this.paths
      };
      if (this.key !== null) {
        desc.key = this.key.key;
      }
      if (this.peers[0].separator !== ".") {
        desc.options = { ...desc.options, separator: this.peers[0].separator };
      }
      if (this.options.isPresent) {
        desc.options = { ...desc.options, isPresent: this.options.isPresent };
      }
      return desc;
    }
  };
  internals.Keys = class extends Array {
    concat(source) {
      const result = this.slice();
      const keys = new Map;
      for (let i = 0;i < result.length; ++i) {
        keys.set(result[i].key, i);
      }
      for (const item of source) {
        const key = item.key;
        const pos = keys.get(key);
        if (pos !== undefined) {
          result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
        } else {
          result.push(item);
        }
      }
      return result;
    }
  };
});

// node_modules/joi/lib/types/function.js
var require_function2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Keys = require_keys2();
  module.exports = Keys.extend({
    type: "function",
    properties: {
      typeof: "function"
    },
    rules: {
      arity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
          return this.$_addRule({ name: "arity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length === n) {
            return value;
          }
          return helpers.error("function.arity", { n });
        }
      },
      class: {
        method() {
          return this.$_addRule("class");
        },
        validate(value, helpers) {
          if (/^\s*class\s/.test(value.toString())) {
            return value;
          }
          return helpers.error("function.class", { value });
        }
      },
      minArity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
          return this.$_addRule({ name: "minArity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length >= n) {
            return value;
          }
          return helpers.error("function.minArity", { n });
        }
      },
      maxArity: {
        method(n) {
          Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
          return this.$_addRule({ name: "maxArity", args: { n } });
        },
        validate(value, helpers, { n }) {
          if (value.length <= n) {
            return value;
          }
          return helpers.error("function.maxArity", { n });
        }
      }
    },
    messages: {
      "function.arity": "{{#label}} must have an arity of {{#n}}",
      "function.class": "{{#label}} must be a class",
      "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
      "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
    }
  });
});

// node_modules/joi/lib/types/link.js
var require_link2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Any = require_any2();
  var Common = require_common2();
  var Compile = require_compile2();
  var Errors = require_errors3();
  var internals = {};
  module.exports = Any.extend({
    type: "link",
    properties: {
      schemaChain: true
    },
    terms: {
      link: { init: null, manifest: "single", register: false }
    },
    args(schema, ref) {
      return schema.ref(ref);
    },
    validate(value, { schema, state, prefs }) {
      Assert(schema.$_terms.link, "Uninitialized link schema");
      const linked = internals.generate(schema, value, state, prefs);
      const ref = schema.$_terms.link[0].ref;
      return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
    },
    generate(schema, value, state, prefs) {
      return internals.generate(schema, value, state, prefs);
    },
    rules: {
      ref: {
        method(ref) {
          Assert(!this.$_terms.link, "Cannot reinitialize schema");
          ref = Compile.ref(ref);
          Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
          Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
          const obj = this.clone();
          obj.$_terms.link = [{ ref }];
          return obj;
        }
      },
      relative: {
        method(enabled = true) {
          return this.$_setFlag("relative", enabled);
        }
      }
    },
    overrides: {
      concat(source) {
        Assert(this.$_terms.link, "Uninitialized link schema");
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(source.type !== "link", "Cannot merge type link with another link");
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        obj.$_terms.whens.push({ concat: source });
        return obj.$_mutateRebuild();
      }
    },
    manifest: {
      build(obj, desc) {
        Assert(desc.link, "Invalid link description missing link");
        return obj.ref(desc.link);
      }
    }
  });
  internals.generate = function(schema, value, state, prefs) {
    let linked = state.mainstay.links.get(schema);
    if (linked) {
      return linked._generate(value, state, prefs).schema;
    }
    const ref = schema.$_terms.link[0].ref;
    const { perspective, path: path2 } = internals.perspective(ref, state);
    internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
    try {
      linked = path2.length ? perspective.$_reach(path2) : perspective;
    } catch (ignoreErr) {
      internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
    }
    internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
    if (!schema._flags.relative) {
      state.mainstay.links.set(schema, linked);
    }
    return linked._generate(value, state, prefs).schema;
  };
  internals.perspective = function(ref, state) {
    if (ref.type === "local") {
      for (const { schema, key } of state.schemas) {
        const id = schema._flags.id || key;
        if (id === ref.path[0]) {
          return { perspective: schema, path: ref.path.slice(1) };
        }
        if (schema.$_terms.shared) {
          for (const shared of schema.$_terms.shared) {
            if (shared._flags.id === ref.path[0]) {
              return { perspective: shared, path: ref.path.slice(1) };
            }
          }
        }
      }
      return { perspective: null, path: null };
    }
    if (ref.ancestor === "root") {
      return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
    }
    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
  };
  internals.assert = function(condition, message, ref, schema, state, prefs) {
    if (condition) {
      return;
    }
    Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
  };
});

// node_modules/joi/lib/types/number.js
var require_number2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Any = require_any2();
  var Common = require_common2();
  var internals = {
    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
    exponentialPartRegex: /[eE][+-]?\d+$/,
    leadingSignAndZerosRegex: /^[+-]?(0*)?/,
    dotRegex: /\./,
    trailingZerosRegex: /0+$/,
    decimalPlaces(value) {
      const str = value.toString();
      const dindex = str.indexOf(".");
      const eindex = str.indexOf("e");
      return (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) + (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))));
    }
  };
  module.exports = Any.extend({
    type: "number",
    flags: {
      unsafe: { default: false }
    },
    coerce: {
      from: "string",
      method(value, { schema, error }) {
        const matches = value.match(internals.numberRx);
        if (!matches) {
          return;
        }
        value = value.trim();
        const result = { value: parseFloat(value) };
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe) {
          if (value.match(/e/i)) {
            if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {
              result.errors = error("number.unsafe");
              return result;
            }
          } else {
            const string = result.value.toString();
            if (string.match(/e/i)) {
              return result;
            }
            if (string !== internals.normalizeDecimal(value)) {
              result.errors = error("number.unsafe");
              return result;
            }
          }
        }
        return result;
      }
    },
    validate(value, { schema, error, prefs }) {
      if (value === Infinity || value === -Infinity) {
        return { value, errors: error("number.infinity") };
      }
      if (!Common.isNumber(value)) {
        return { value, errors: error("number.base") };
      }
      const result = { value };
      if (prefs.convert) {
        const rule = schema.$_getRule("precision");
        if (rule) {
          const precision = Math.pow(10, rule.args.limit);
          result.value = Math.round(result.value * precision) / precision;
        }
      }
      if (result.value === 0) {
        result.value = 0;
      }
      if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
        result.errors = error("number.unsafe");
      }
      return result;
    },
    rules: {
      compare: {
        method: false,
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value, limit, operator)) {
            return value;
          }
          return helpers.error("number." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.isNumber,
            message: "must be a number"
          }
        ]
      },
      greater: {
        method(limit) {
          return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
        }
      },
      integer: {
        method() {
          return this.$_addRule("integer");
        },
        validate(value, helpers) {
          if (Math.trunc(value) - value === 0) {
            return value;
          }
          return helpers.error("number.integer");
        }
      },
      less: {
        method(limit) {
          return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
        }
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
        }
      },
      multiple: {
        method(base) {
          const baseDecimalPlace = typeof base === "number" ? internals.decimalPlaces(base) : null;
          const pfactor = Math.pow(10, baseDecimalPlace);
          return this.$_addRule({
            name: "multiple",
            args: {
              base,
              baseDecimalPlace,
              pfactor
            }
          });
        },
        validate(value, helpers, { base, baseDecimalPlace, pfactor }, options) {
          const valueDecimalPlace = internals.decimalPlaces(value);
          if (valueDecimalPlace > baseDecimalPlace) {
            return helpers.error("number.multiple", { multiple: options.args.base, value });
          }
          return Math.round(pfactor * value) % Math.round(pfactor * base) === 0 ? value : helpers.error("number.multiple", { multiple: options.args.base, value });
        },
        args: [
          {
            name: "base",
            ref: true,
            assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
            message: "must be a positive number"
          },
          "baseDecimalPlace",
          "pfactor"
        ],
        multi: true
      },
      negative: {
        method() {
          return this.sign("negative");
        }
      },
      port: {
        method() {
          return this.$_addRule("port");
        },
        validate(value, helpers) {
          if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
            return value;
          }
          return helpers.error("number.port");
        }
      },
      positive: {
        method() {
          return this.sign("positive");
        }
      },
      precision: {
        method(limit) {
          Assert(Number.isSafeInteger(limit), "limit must be an integer");
          return this.$_addRule({ name: "precision", args: { limit } });
        },
        validate(value, helpers, { limit }) {
          const places = value.toString().match(internals.precisionRx);
          const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
          if (decimals <= limit) {
            return value;
          }
          return helpers.error("number.precision", { limit, value });
        },
        convert: true
      },
      sign: {
        method(sign) {
          Assert(["negative", "positive"].includes(sign), "Invalid sign", sign);
          return this.$_addRule({ name: "sign", args: { sign } });
        },
        validate(value, helpers, { sign }) {
          if (sign === "negative" && value < 0 || sign === "positive" && value > 0) {
            return value;
          }
          return helpers.error(`number.${sign}`);
        }
      },
      unsafe: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_setFlag("unsafe", enabled);
        }
      }
    },
    cast: {
      string: {
        from: (value) => typeof value === "number",
        to(value, helpers) {
          return value.toString();
        }
      }
    },
    messages: {
      "number.base": "{{#label}} must be a number",
      "number.greater": "{{#label}} must be greater than {{#limit}}",
      "number.infinity": "{{#label}} cannot be infinity",
      "number.integer": "{{#label}} must be an integer",
      "number.less": "{{#label}} must be less than {{#limit}}",
      "number.max": "{{#label}} must be less than or equal to {{#limit}}",
      "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
      "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
      "number.negative": "{{#label}} must be a negative number",
      "number.port": "{{#label}} must be a valid port",
      "number.positive": "{{#label}} must be a positive number",
      "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
      "number.unsafe": "{{#label}} must be a safe number"
    }
  });
  internals.extractSignificantDigits = function(value) {
    return value.replace(internals.exponentialPartRegex, "").replace(internals.dotRegex, "").replace(internals.trailingZerosRegex, "").replace(internals.leadingSignAndZerosRegex, "");
  };
  internals.normalizeDecimal = function(str) {
    str = str.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2");
    if (str.includes(".") && str.endsWith("0")) {
      str = str.replace(/0+$/, "");
    }
    if (str === "-0") {
      return "0";
    }
    return str;
  };
});

// node_modules/joi/lib/types/object.js
var require_object2 = __commonJS((exports, module) => {
  var Keys = require_keys2();
  module.exports = Keys.extend({
    type: "object",
    cast: {
      map: {
        from: (value) => value && typeof value === "object",
        to(value, helpers) {
          return new Map(Object.entries(value));
        }
      }
    }
  });
});

// node_modules/@sideway/address/lib/errors.js
var require_errors4 = __commonJS((exports) => {
  exports.codes = {
    EMPTY_STRING: "Address must be a non-empty string",
    FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
    MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
    MISSING_AT_CHAR: "Address must contain one @ character",
    EMPTY_LOCAL: "Address local part cannot be empty",
    ADDRESS_TOO_LONG: "Address too long",
    LOCAL_TOO_LONG: "Address local part too long",
    EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
    INVALID_LOCAL_CHARS: "Address local part contains invalid character",
    DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
    DOMAIN_TOO_LONG: "Domain too long",
    DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
    DOMAIN_INVALID_CHARS: "Domain contains invalid character",
    DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
    DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
    DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
    DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
    DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
    DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
  };
  exports.code = function(code) {
    return { code, error: exports.codes[code] };
  };
});

// node_modules/@sideway/address/lib/domain.js
var require_domain = __commonJS((exports) => {
  var Url = __require("url");
  var Errors = require_errors4();
  var internals = {
    minDomainSegments: 2,
    nonAsciiRx: /[^\x00-\x7f]/,
    domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    URL: Url.URL || URL
  };
  exports.analyze = function(domain, options = {}) {
    if (!domain) {
      return Errors.code("DOMAIN_NON_EMPTY_STRING");
    }
    if (typeof domain !== "string") {
      throw new Error("Invalid input: domain must be a string");
    }
    if (domain.length > 256) {
      return Errors.code("DOMAIN_TOO_LONG");
    }
    const ascii = !internals.nonAsciiRx.test(domain);
    if (!ascii) {
      if (options.allowUnicode === false) {
        return Errors.code("DOMAIN_INVALID_UNICODE_CHARS");
      }
      domain = domain.normalize("NFC");
    }
    if (internals.domainControlRx.test(domain)) {
      return Errors.code("DOMAIN_INVALID_CHARS");
    }
    domain = internals.punycode(domain);
    if (options.allowFullyQualified && domain[domain.length - 1] === ".") {
      domain = domain.slice(0, -1);
    }
    const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;
    const segments = domain.split(".");
    if (segments.length < minDomainSegments) {
      return Errors.code("DOMAIN_SEGMENTS_COUNT");
    }
    if (options.maxDomainSegments) {
      if (segments.length > options.maxDomainSegments) {
        return Errors.code("DOMAIN_SEGMENTS_COUNT_MAX");
      }
    }
    const tlds = options.tlds;
    if (tlds) {
      const tld = segments[segments.length - 1].toLowerCase();
      if (tlds.deny && tlds.deny.has(tld) || tlds.allow && !tlds.allow.has(tld)) {
        return Errors.code("DOMAIN_FORBIDDEN_TLDS");
      }
    }
    for (let i = 0;i < segments.length; ++i) {
      const segment = segments[i];
      if (!segment.length) {
        return Errors.code("DOMAIN_EMPTY_SEGMENT");
      }
      if (segment.length > 63) {
        return Errors.code("DOMAIN_LONG_SEGMENT");
      }
      if (i < segments.length - 1) {
        if (!internals.domainSegmentRx.test(segment)) {
          return Errors.code("DOMAIN_INVALID_CHARS");
        }
      } else {
        if (!internals.tldSegmentRx.test(segment)) {
          return Errors.code("DOMAIN_INVALID_TLDS_CHARS");
        }
      }
    }
    return null;
  };
  exports.isValid = function(domain, options) {
    return !exports.analyze(domain, options);
  };
  internals.punycode = function(domain) {
    if (domain.includes("%")) {
      domain = domain.replace(/%/g, "%25");
    }
    try {
      return new internals.URL(`http://${domain}`).host;
    } catch (err) {
      return domain;
    }
  };
});

// node_modules/@sideway/address/lib/email.js
var require_email = __commonJS((exports) => {
  var Util = __require("util");
  var Domain = require_domain();
  var Errors = require_errors4();
  var internals = {
    nonAsciiRx: /[^\x00-\x7f]/,
    encoder: new (Util.TextEncoder || TextEncoder)
  };
  exports.analyze = function(email, options) {
    return internals.email(email, options);
  };
  exports.isValid = function(email, options) {
    return !internals.email(email, options);
  };
  internals.email = function(email, options = {}) {
    if (typeof email !== "string") {
      throw new Error("Invalid input: email must be a string");
    }
    if (!email) {
      return Errors.code("EMPTY_STRING");
    }
    const ascii = !internals.nonAsciiRx.test(email);
    if (!ascii) {
      if (options.allowUnicode === false) {
        return Errors.code("FORBIDDEN_UNICODE");
      }
      email = email.normalize("NFC");
    }
    const parts = email.split("@");
    if (parts.length !== 2) {
      return parts.length > 2 ? Errors.code("MULTIPLE_AT_CHAR") : Errors.code("MISSING_AT_CHAR");
    }
    const [local, domain] = parts;
    if (!local) {
      return Errors.code("EMPTY_LOCAL");
    }
    if (!options.ignoreLength) {
      if (email.length > 254) {
        return Errors.code("ADDRESS_TOO_LONG");
      }
      if (internals.encoder.encode(local).length > 64) {
        return Errors.code("LOCAL_TOO_LONG");
      }
    }
    return internals.local(local, ascii) || Domain.analyze(domain, options);
  };
  internals.local = function(local, ascii) {
    const segments = local.split(".");
    for (const segment of segments) {
      if (!segment.length) {
        return Errors.code("EMPTY_LOCAL_SEGMENT");
      }
      if (ascii) {
        if (!internals.atextRx.test(segment)) {
          return Errors.code("INVALID_LOCAL_CHARS");
        }
        continue;
      }
      for (const char of segment) {
        if (internals.atextRx.test(char)) {
          continue;
        }
        const binary = internals.binary(char);
        if (!internals.atomRx.test(binary)) {
          return Errors.code("INVALID_LOCAL_CHARS");
        }
      }
    }
  };
  internals.binary = function(char) {
    return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join("");
  };
  internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
  internals.atomRx = new RegExp([
    "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
    "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
    "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
  ].join("|"));
});

// node_modules/@sideway/address/node_modules/@hapi/hoek/lib/stringify.js
var require_stringify3 = __commonJS((exports, module) => {
  module.exports = function(...args) {
    try {
      return JSON.stringify(...args);
    } catch (err) {
      return "[Cannot display object: " + err.message + "]";
    }
  };
});

// node_modules/@sideway/address/node_modules/@hapi/hoek/lib/error.js
var require_error2 = __commonJS((exports, module) => {
  var Stringify = require_stringify3();
  module.exports = class extends Error {
    constructor(args) {
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
      });
      super(msgs.join(" ") || "Unknown error");
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, exports.assert);
      }
    }
  };
});

// node_modules/@sideway/address/node_modules/@hapi/hoek/lib/assert.js
var require_assert3 = __commonJS((exports, module) => {
  var AssertError = require_error2();
  module.exports = function(condition, ...args) {
    if (condition) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Error) {
      throw args[0];
    }
    throw new AssertError(args);
  };
});

// node_modules/@sideway/address/node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex2 = __commonJS((exports, module) => {
  module.exports = function(string) {
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
  };
});

// node_modules/@sideway/address/lib/uri.js
var require_uri = __commonJS((exports) => {
  var Assert = require_assert3();
  var EscapeRegex = require_escapeRegex2();
  var internals = {};
  internals.generate = function() {
    const rfc3986 = {};
    const hexDigit = "\\dA-Fa-f";
    const hexDigitOnly = "[" + hexDigit + "]";
    const unreserved = "\\w-\\.~";
    const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
    const pctEncoded = "%" + hexDigit;
    const pchar = unreserved + pctEncoded + subDelims + ":@";
    const pcharOnly = "[" + pchar + "]";
    const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
    rfc3986.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
    const h16 = hexDigitOnly + "{1,4}";
    const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4address + ")";
    const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
    const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
    const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
    const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
    const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
    const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
    const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
    const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
    const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
    rfc3986.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
    rfc3986.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
    rfc3986.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
    rfc3986.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
    rfc3986.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
    rfc3986.schemeRegex = new RegExp(rfc3986.scheme);
    const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
    const IPLiteral = "\\[(?:" + rfc3986.ipv6address + "|" + rfc3986.ipvFuture + ")\\]";
    const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
    const host = "(?:" + IPLiteral + "|" + rfc3986.ipv4address + "|" + regName + ")";
    const port = "\\d*";
    const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
    const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
    const segment = pcharOnly + "*";
    const segmentNz = pcharOnly + "+";
    const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@" + "]+";
    const pathEmpty = "";
    const pathAbEmpty = "(?:\\/" + segment + ")*";
    const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;
    const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
    rfc3986.hierPart = "(?:" + "(?:\\/\\/" + authority + pathAbEmpty + ")" + "|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
    rfc3986.hierPartCapture = "(?:" + "(?:\\/\\/" + authorityCapture + pathAbEmpty + ")" + "|" + pathAbsolute + "|" + pathRootless + ")";
    rfc3986.relativeRef = "(?:" + "(?:\\/\\/" + authority + pathAbEmpty + ")" + "|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
    rfc3986.relativeRefCapture = "(?:" + "(?:\\/\\/" + authorityCapture + pathAbEmpty + ")" + "|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
    rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
    rfc3986.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
    rfc3986.fragment = "[" + pchar + "\\/\\?]*";
    return rfc3986;
  };
  internals.rfc3986 = internals.generate();
  exports.ip = {
    v4Cidr: internals.rfc3986.ipv4Cidr,
    v6Cidr: internals.rfc3986.ipv6Cidr,
    ipv4: internals.rfc3986.ipv4address,
    ipv6: internals.rfc3986.ipv6address,
    ipvfuture: internals.rfc3986.ipvFuture
  };
  internals.createRegex = function(options) {
    const rfc = internals.rfc3986;
    const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
    const suffix = "(?:\\?" + query + ")?" + "(?:#" + rfc.fragment + ")?";
    const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;
    if (options.relativeOnly) {
      return internals.wrap(relative + suffix);
    }
    let customScheme = "";
    if (options.scheme) {
      Assert(options.scheme instanceof RegExp || typeof options.scheme === "string" || Array.isArray(options.scheme), "scheme must be a RegExp, String, or Array");
      const schemes = [].concat(options.scheme);
      Assert(schemes.length >= 1, "scheme must have at least 1 scheme specified");
      const selections = [];
      for (let i = 0;i < schemes.length; ++i) {
        const scheme2 = schemes[i];
        Assert(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i + " must be a RegExp or String");
        if (scheme2 instanceof RegExp) {
          selections.push(scheme2.source.toString());
        } else {
          Assert(rfc.schemeRegex.test(scheme2), "scheme at position " + i + " must be a valid scheme");
          selections.push(EscapeRegex(scheme2));
        }
      }
      customScheme = selections.join("|");
    }
    const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
    const absolute = "(?:" + scheme + ":" + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
    const prefix = options.allowRelative ? "(?:" + absolute + "|" + relative + ")" : absolute;
    return internals.wrap(prefix + suffix, customScheme);
  };
  internals.wrap = function(raw, scheme) {
    raw = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${raw}`;
    return {
      raw,
      regex: new RegExp(`^${raw}$`),
      scheme
    };
  };
  internals.uriRegex = internals.createRegex({});
  exports.regex = function(options = {}) {
    if (options.scheme || options.allowRelative || options.relativeOnly || options.allowQuerySquareBrackets || options.domain) {
      return internals.createRegex(options);
    }
    return internals.uriRegex;
  };
});

// node_modules/@sideway/address/lib/ip.js
var require_ip = __commonJS((exports) => {
  var Assert = require_assert3();
  var Uri = require_uri();
  exports.regex = function(options = {}) {
    Assert(options.cidr === undefined || typeof options.cidr === "string", "options.cidr must be a string");
    const cidr = options.cidr ? options.cidr.toLowerCase() : "optional";
    Assert(["required", "optional", "forbidden"].includes(cidr), "options.cidr must be one of required, optional, forbidden");
    Assert(options.version === undefined || typeof options.version === "string" || Array.isArray(options.version), "options.version must be a string or an array of string");
    let versions = options.version || ["ipv4", "ipv6", "ipvfuture"];
    if (!Array.isArray(versions)) {
      versions = [versions];
    }
    Assert(versions.length >= 1, "options.version must have at least 1 version specified");
    for (let i = 0;i < versions.length; ++i) {
      Assert(typeof versions[i] === "string", "options.version must only contain strings");
      versions[i] = versions[i].toLowerCase();
      Assert(["ipv4", "ipv6", "ipvfuture"].includes(versions[i]), "options.version contains unknown version " + versions[i] + " - must be one of ipv4, ipv6, ipvfuture");
    }
    versions = Array.from(new Set(versions));
    const parts = versions.map((version) => {
      if (cidr === "forbidden") {
        return Uri.ip[version];
      }
      const cidrpart = `\\/${version === "ipv4" ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;
      if (cidr === "required") {
        return `${Uri.ip[version]}${cidrpart}`;
      }
      return `${Uri.ip[version]}(?:${cidrpart})?`;
    });
    const raw = `(?:${parts.join("|")})`;
    const regex = new RegExp(`^${raw}$`);
    return { cidr, versions, regex, raw };
  };
});

// node_modules/joi/node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex3 = __commonJS((exports, module) => {
  module.exports = function(string) {
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
  };
});

// node_modules/@sideway/address/lib/tlds.js
var require_tlds = __commonJS((exports, module) => {
  var internals = {};
  internals.tlds = [
    "AAA",
    "AARP",
    "ABB",
    "ABBOTT",
    "ABBVIE",
    "ABC",
    "ABLE",
    "ABOGADO",
    "ABUDHABI",
    "AC",
    "ACADEMY",
    "ACCENTURE",
    "ACCOUNTANT",
    "ACCOUNTANTS",
    "ACO",
    "ACTOR",
    "AD",
    "ADS",
    "ADULT",
    "AE",
    "AEG",
    "AERO",
    "AETNA",
    "AF",
    "AFL",
    "AFRICA",
    "AG",
    "AGAKHAN",
    "AGENCY",
    "AI",
    "AIG",
    "AIRBUS",
    "AIRFORCE",
    "AIRTEL",
    "AKDN",
    "AL",
    "ALIBABA",
    "ALIPAY",
    "ALLFINANZ",
    "ALLSTATE",
    "ALLY",
    "ALSACE",
    "ALSTOM",
    "AM",
    "AMAZON",
    "AMERICANEXPRESS",
    "AMERICANFAMILY",
    "AMEX",
    "AMFAM",
    "AMICA",
    "AMSTERDAM",
    "ANALYTICS",
    "ANDROID",
    "ANQUAN",
    "ANZ",
    "AO",
    "AOL",
    "APARTMENTS",
    "APP",
    "APPLE",
    "AQ",
    "AQUARELLE",
    "AR",
    "ARAB",
    "ARAMCO",
    "ARCHI",
    "ARMY",
    "ARPA",
    "ART",
    "ARTE",
    "AS",
    "ASDA",
    "ASIA",
    "ASSOCIATES",
    "AT",
    "ATHLETA",
    "ATTORNEY",
    "AU",
    "AUCTION",
    "AUDI",
    "AUDIBLE",
    "AUDIO",
    "AUSPOST",
    "AUTHOR",
    "AUTO",
    "AUTOS",
    "AVIANCA",
    "AW",
    "AWS",
    "AX",
    "AXA",
    "AZ",
    "AZURE",
    "BA",
    "BABY",
    "BAIDU",
    "BANAMEX",
    "BAND",
    "BANK",
    "BAR",
    "BARCELONA",
    "BARCLAYCARD",
    "BARCLAYS",
    "BAREFOOT",
    "BARGAINS",
    "BASEBALL",
    "BASKETBALL",
    "BAUHAUS",
    "BAYERN",
    "BB",
    "BBC",
    "BBT",
    "BBVA",
    "BCG",
    "BCN",
    "BD",
    "BE",
    "BEATS",
    "BEAUTY",
    "BEER",
    "BENTLEY",
    "BERLIN",
    "BEST",
    "BESTBUY",
    "BET",
    "BF",
    "BG",
    "BH",
    "BHARTI",
    "BI",
    "BIBLE",
    "BID",
    "BIKE",
    "BING",
    "BINGO",
    "BIO",
    "BIZ",
    "BJ",
    "BLACK",
    "BLACKFRIDAY",
    "BLOCKBUSTER",
    "BLOG",
    "BLOOMBERG",
    "BLUE",
    "BM",
    "BMS",
    "BMW",
    "BN",
    "BNPPARIBAS",
    "BO",
    "BOATS",
    "BOEHRINGER",
    "BOFA",
    "BOM",
    "BOND",
    "BOO",
    "BOOK",
    "BOOKING",
    "BOSCH",
    "BOSTIK",
    "BOSTON",
    "BOT",
    "BOUTIQUE",
    "BOX",
    "BR",
    "BRADESCO",
    "BRIDGESTONE",
    "BROADWAY",
    "BROKER",
    "BROTHER",
    "BRUSSELS",
    "BS",
    "BT",
    "BUILD",
    "BUILDERS",
    "BUSINESS",
    "BUY",
    "BUZZ",
    "BV",
    "BW",
    "BY",
    "BZ",
    "BZH",
    "CA",
    "CAB",
    "CAFE",
    "CAL",
    "CALL",
    "CALVINKLEIN",
    "CAM",
    "CAMERA",
    "CAMP",
    "CANON",
    "CAPETOWN",
    "CAPITAL",
    "CAPITALONE",
    "CAR",
    "CARAVAN",
    "CARDS",
    "CARE",
    "CAREER",
    "CAREERS",
    "CARS",
    "CASA",
    "CASE",
    "CASH",
    "CASINO",
    "CAT",
    "CATERING",
    "CATHOLIC",
    "CBA",
    "CBN",
    "CBRE",
    "CC",
    "CD",
    "CENTER",
    "CEO",
    "CERN",
    "CF",
    "CFA",
    "CFD",
    "CG",
    "CH",
    "CHANEL",
    "CHANNEL",
    "CHARITY",
    "CHASE",
    "CHAT",
    "CHEAP",
    "CHINTAI",
    "CHRISTMAS",
    "CHROME",
    "CHURCH",
    "CI",
    "CIPRIANI",
    "CIRCLE",
    "CISCO",
    "CITADEL",
    "CITI",
    "CITIC",
    "CITY",
    "CK",
    "CL",
    "CLAIMS",
    "CLEANING",
    "CLICK",
    "CLINIC",
    "CLINIQUE",
    "CLOTHING",
    "CLOUD",
    "CLUB",
    "CLUBMED",
    "CM",
    "CN",
    "CO",
    "COACH",
    "CODES",
    "COFFEE",
    "COLLEGE",
    "COLOGNE",
    "COM",
    "COMCAST",
    "COMMBANK",
    "COMMUNITY",
    "COMPANY",
    "COMPARE",
    "COMPUTER",
    "COMSEC",
    "CONDOS",
    "CONSTRUCTION",
    "CONSULTING",
    "CONTACT",
    "CONTRACTORS",
    "COOKING",
    "COOL",
    "COOP",
    "CORSICA",
    "COUNTRY",
    "COUPON",
    "COUPONS",
    "COURSES",
    "CPA",
    "CR",
    "CREDIT",
    "CREDITCARD",
    "CREDITUNION",
    "CRICKET",
    "CROWN",
    "CRS",
    "CRUISE",
    "CRUISES",
    "CU",
    "CUISINELLA",
    "CV",
    "CW",
    "CX",
    "CY",
    "CYMRU",
    "CYOU",
    "CZ",
    "DABUR",
    "DAD",
    "DANCE",
    "DATA",
    "DATE",
    "DATING",
    "DATSUN",
    "DAY",
    "DCLK",
    "DDS",
    "DE",
    "DEAL",
    "DEALER",
    "DEALS",
    "DEGREE",
    "DELIVERY",
    "DELL",
    "DELOITTE",
    "DELTA",
    "DEMOCRAT",
    "DENTAL",
    "DENTIST",
    "DESI",
    "DESIGN",
    "DEV",
    "DHL",
    "DIAMONDS",
    "DIET",
    "DIGITAL",
    "DIRECT",
    "DIRECTORY",
    "DISCOUNT",
    "DISCOVER",
    "DISH",
    "DIY",
    "DJ",
    "DK",
    "DM",
    "DNP",
    "DO",
    "DOCS",
    "DOCTOR",
    "DOG",
    "DOMAINS",
    "DOT",
    "DOWNLOAD",
    "DRIVE",
    "DTV",
    "DUBAI",
    "DUNLOP",
    "DUPONT",
    "DURBAN",
    "DVAG",
    "DVR",
    "DZ",
    "EARTH",
    "EAT",
    "EC",
    "ECO",
    "EDEKA",
    "EDU",
    "EDUCATION",
    "EE",
    "EG",
    "EMAIL",
    "EMERCK",
    "ENERGY",
    "ENGINEER",
    "ENGINEERING",
    "ENTERPRISES",
    "EPSON",
    "EQUIPMENT",
    "ER",
    "ERICSSON",
    "ERNI",
    "ES",
    "ESQ",
    "ESTATE",
    "ET",
    "EU",
    "EUROVISION",
    "EUS",
    "EVENTS",
    "EXCHANGE",
    "EXPERT",
    "EXPOSED",
    "EXPRESS",
    "EXTRASPACE",
    "FAGE",
    "FAIL",
    "FAIRWINDS",
    "FAITH",
    "FAMILY",
    "FAN",
    "FANS",
    "FARM",
    "FARMERS",
    "FASHION",
    "FAST",
    "FEDEX",
    "FEEDBACK",
    "FERRARI",
    "FERRERO",
    "FI",
    "FIDELITY",
    "FIDO",
    "FILM",
    "FINAL",
    "FINANCE",
    "FINANCIAL",
    "FIRE",
    "FIRESTONE",
    "FIRMDALE",
    "FISH",
    "FISHING",
    "FIT",
    "FITNESS",
    "FJ",
    "FK",
    "FLICKR",
    "FLIGHTS",
    "FLIR",
    "FLORIST",
    "FLOWERS",
    "FLY",
    "FM",
    "FO",
    "FOO",
    "FOOD",
    "FOOTBALL",
    "FORD",
    "FOREX",
    "FORSALE",
    "FORUM",
    "FOUNDATION",
    "FOX",
    "FR",
    "FREE",
    "FRESENIUS",
    "FRL",
    "FROGANS",
    "FRONTIER",
    "FTR",
    "FUJITSU",
    "FUN",
    "FUND",
    "FURNITURE",
    "FUTBOL",
    "FYI",
    "GA",
    "GAL",
    "GALLERY",
    "GALLO",
    "GALLUP",
    "GAME",
    "GAMES",
    "GAP",
    "GARDEN",
    "GAY",
    "GB",
    "GBIZ",
    "GD",
    "GDN",
    "GE",
    "GEA",
    "GENT",
    "GENTING",
    "GEORGE",
    "GF",
    "GG",
    "GGEE",
    "GH",
    "GI",
    "GIFT",
    "GIFTS",
    "GIVES",
    "GIVING",
    "GL",
    "GLASS",
    "GLE",
    "GLOBAL",
    "GLOBO",
    "GM",
    "GMAIL",
    "GMBH",
    "GMO",
    "GMX",
    "GN",
    "GODADDY",
    "GOLD",
    "GOLDPOINT",
    "GOLF",
    "GOO",
    "GOODYEAR",
    "GOOG",
    "GOOGLE",
    "GOP",
    "GOT",
    "GOV",
    "GP",
    "GQ",
    "GR",
    "GRAINGER",
    "GRAPHICS",
    "GRATIS",
    "GREEN",
    "GRIPE",
    "GROCERY",
    "GROUP",
    "GS",
    "GT",
    "GU",
    "GUARDIAN",
    "GUCCI",
    "GUGE",
    "GUIDE",
    "GUITARS",
    "GURU",
    "GW",
    "GY",
    "HAIR",
    "HAMBURG",
    "HANGOUT",
    "HAUS",
    "HBO",
    "HDFC",
    "HDFCBANK",
    "HEALTH",
    "HEALTHCARE",
    "HELP",
    "HELSINKI",
    "HERE",
    "HERMES",
    "HIPHOP",
    "HISAMITSU",
    "HITACHI",
    "HIV",
    "HK",
    "HKT",
    "HM",
    "HN",
    "HOCKEY",
    "HOLDINGS",
    "HOLIDAY",
    "HOMEDEPOT",
    "HOMEGOODS",
    "HOMES",
    "HOMESENSE",
    "HONDA",
    "HORSE",
    "HOSPITAL",
    "HOST",
    "HOSTING",
    "HOT",
    "HOTELS",
    "HOTMAIL",
    "HOUSE",
    "HOW",
    "HR",
    "HSBC",
    "HT",
    "HU",
    "HUGHES",
    "HYATT",
    "HYUNDAI",
    "IBM",
    "ICBC",
    "ICE",
    "ICU",
    "ID",
    "IE",
    "IEEE",
    "IFM",
    "IKANO",
    "IL",
    "IM",
    "IMAMAT",
    "IMDB",
    "IMMO",
    "IMMOBILIEN",
    "IN",
    "INC",
    "INDUSTRIES",
    "INFINITI",
    "INFO",
    "ING",
    "INK",
    "INSTITUTE",
    "INSURANCE",
    "INSURE",
    "INT",
    "INTERNATIONAL",
    "INTUIT",
    "INVESTMENTS",
    "IO",
    "IPIRANGA",
    "IQ",
    "IR",
    "IRISH",
    "IS",
    "ISMAILI",
    "IST",
    "ISTANBUL",
    "IT",
    "ITAU",
    "ITV",
    "JAGUAR",
    "JAVA",
    "JCB",
    "JE",
    "JEEP",
    "JETZT",
    "JEWELRY",
    "JIO",
    "JLL",
    "JM",
    "JMP",
    "JNJ",
    "JO",
    "JOBS",
    "JOBURG",
    "JOT",
    "JOY",
    "JP",
    "JPMORGAN",
    "JPRS",
    "JUEGOS",
    "JUNIPER",
    "KAUFEN",
    "KDDI",
    "KE",
    "KERRYHOTELS",
    "KERRYLOGISTICS",
    "KERRYPROPERTIES",
    "KFH",
    "KG",
    "KH",
    "KI",
    "KIA",
    "KIDS",
    "KIM",
    "KINDLE",
    "KITCHEN",
    "KIWI",
    "KM",
    "KN",
    "KOELN",
    "KOMATSU",
    "KOSHER",
    "KP",
    "KPMG",
    "KPN",
    "KR",
    "KRD",
    "KRED",
    "KUOKGROUP",
    "KW",
    "KY",
    "KYOTO",
    "KZ",
    "LA",
    "LACAIXA",
    "LAMBORGHINI",
    "LAMER",
    "LANCASTER",
    "LAND",
    "LANDROVER",
    "LANXESS",
    "LASALLE",
    "LAT",
    "LATINO",
    "LATROBE",
    "LAW",
    "LAWYER",
    "LB",
    "LC",
    "LDS",
    "LEASE",
    "LECLERC",
    "LEFRAK",
    "LEGAL",
    "LEGO",
    "LEXUS",
    "LGBT",
    "LI",
    "LIDL",
    "LIFE",
    "LIFEINSURANCE",
    "LIFESTYLE",
    "LIGHTING",
    "LIKE",
    "LILLY",
    "LIMITED",
    "LIMO",
    "LINCOLN",
    "LINK",
    "LIPSY",
    "LIVE",
    "LIVING",
    "LK",
    "LLC",
    "LLP",
    "LOAN",
    "LOANS",
    "LOCKER",
    "LOCUS",
    "LOL",
    "LONDON",
    "LOTTE",
    "LOTTO",
    "LOVE",
    "LPL",
    "LPLFINANCIAL",
    "LR",
    "LS",
    "LT",
    "LTD",
    "LTDA",
    "LU",
    "LUNDBECK",
    "LUXE",
    "LUXURY",
    "LV",
    "LY",
    "MA",
    "MADRID",
    "MAIF",
    "MAISON",
    "MAKEUP",
    "MAN",
    "MANAGEMENT",
    "MANGO",
    "MAP",
    "MARKET",
    "MARKETING",
    "MARKETS",
    "MARRIOTT",
    "MARSHALLS",
    "MATTEL",
    "MBA",
    "MC",
    "MCKINSEY",
    "MD",
    "ME",
    "MED",
    "MEDIA",
    "MEET",
    "MELBOURNE",
    "MEME",
    "MEMORIAL",
    "MEN",
    "MENU",
    "MERCKMSD",
    "MG",
    "MH",
    "MIAMI",
    "MICROSOFT",
    "MIL",
    "MINI",
    "MINT",
    "MIT",
    "MITSUBISHI",
    "MK",
    "ML",
    "MLB",
    "MLS",
    "MM",
    "MMA",
    "MN",
    "MO",
    "MOBI",
    "MOBILE",
    "MODA",
    "MOE",
    "MOI",
    "MOM",
    "MONASH",
    "MONEY",
    "MONSTER",
    "MORMON",
    "MORTGAGE",
    "MOSCOW",
    "MOTO",
    "MOTORCYCLES",
    "MOV",
    "MOVIE",
    "MP",
    "MQ",
    "MR",
    "MS",
    "MSD",
    "MT",
    "MTN",
    "MTR",
    "MU",
    "MUSEUM",
    "MUSIC",
    "MV",
    "MW",
    "MX",
    "MY",
    "MZ",
    "NA",
    "NAB",
    "NAGOYA",
    "NAME",
    "NATURA",
    "NAVY",
    "NBA",
    "NC",
    "NE",
    "NEC",
    "NET",
    "NETBANK",
    "NETFLIX",
    "NETWORK",
    "NEUSTAR",
    "NEW",
    "NEWS",
    "NEXT",
    "NEXTDIRECT",
    "NEXUS",
    "NF",
    "NFL",
    "NG",
    "NGO",
    "NHK",
    "NI",
    "NICO",
    "NIKE",
    "NIKON",
    "NINJA",
    "NISSAN",
    "NISSAY",
    "NL",
    "NO",
    "NOKIA",
    "NORTON",
    "NOW",
    "NOWRUZ",
    "NOWTV",
    "NP",
    "NR",
    "NRA",
    "NRW",
    "NTT",
    "NU",
    "NYC",
    "NZ",
    "OBI",
    "OBSERVER",
    "OFFICE",
    "OKINAWA",
    "OLAYAN",
    "OLAYANGROUP",
    "OLLO",
    "OM",
    "OMEGA",
    "ONE",
    "ONG",
    "ONL",
    "ONLINE",
    "OOO",
    "OPEN",
    "ORACLE",
    "ORANGE",
    "ORG",
    "ORGANIC",
    "ORIGINS",
    "OSAKA",
    "OTSUKA",
    "OTT",
    "OVH",
    "PA",
    "PAGE",
    "PANASONIC",
    "PARIS",
    "PARS",
    "PARTNERS",
    "PARTS",
    "PARTY",
    "PAY",
    "PCCW",
    "PE",
    "PET",
    "PF",
    "PFIZER",
    "PG",
    "PH",
    "PHARMACY",
    "PHD",
    "PHILIPS",
    "PHONE",
    "PHOTO",
    "PHOTOGRAPHY",
    "PHOTOS",
    "PHYSIO",
    "PICS",
    "PICTET",
    "PICTURES",
    "PID",
    "PIN",
    "PING",
    "PINK",
    "PIONEER",
    "PIZZA",
    "PK",
    "PL",
    "PLACE",
    "PLAY",
    "PLAYSTATION",
    "PLUMBING",
    "PLUS",
    "PM",
    "PN",
    "PNC",
    "POHL",
    "POKER",
    "POLITIE",
    "PORN",
    "POST",
    "PR",
    "PRAMERICA",
    "PRAXI",
    "PRESS",
    "PRIME",
    "PRO",
    "PROD",
    "PRODUCTIONS",
    "PROF",
    "PROGRESSIVE",
    "PROMO",
    "PROPERTIES",
    "PROPERTY",
    "PROTECTION",
    "PRU",
    "PRUDENTIAL",
    "PS",
    "PT",
    "PUB",
    "PW",
    "PWC",
    "PY",
    "QA",
    "QPON",
    "QUEBEC",
    "QUEST",
    "RACING",
    "RADIO",
    "RE",
    "READ",
    "REALESTATE",
    "REALTOR",
    "REALTY",
    "RECIPES",
    "RED",
    "REDSTONE",
    "REDUMBRELLA",
    "REHAB",
    "REISE",
    "REISEN",
    "REIT",
    "RELIANCE",
    "REN",
    "RENT",
    "RENTALS",
    "REPAIR",
    "REPORT",
    "REPUBLICAN",
    "REST",
    "RESTAURANT",
    "REVIEW",
    "REVIEWS",
    "REXROTH",
    "RICH",
    "RICHARDLI",
    "RICOH",
    "RIL",
    "RIO",
    "RIP",
    "RO",
    "ROCKS",
    "RODEO",
    "ROGERS",
    "ROOM",
    "RS",
    "RSVP",
    "RU",
    "RUGBY",
    "RUHR",
    "RUN",
    "RW",
    "RWE",
    "RYUKYU",
    "SA",
    "SAARLAND",
    "SAFE",
    "SAFETY",
    "SAKURA",
    "SALE",
    "SALON",
    "SAMSCLUB",
    "SAMSUNG",
    "SANDVIK",
    "SANDVIKCOROMANT",
    "SANOFI",
    "SAP",
    "SARL",
    "SAS",
    "SAVE",
    "SAXO",
    "SB",
    "SBI",
    "SBS",
    "SC",
    "SCB",
    "SCHAEFFLER",
    "SCHMIDT",
    "SCHOLARSHIPS",
    "SCHOOL",
    "SCHULE",
    "SCHWARZ",
    "SCIENCE",
    "SCOT",
    "SD",
    "SE",
    "SEARCH",
    "SEAT",
    "SECURE",
    "SECURITY",
    "SEEK",
    "SELECT",
    "SENER",
    "SERVICES",
    "SEVEN",
    "SEW",
    "SEX",
    "SEXY",
    "SFR",
    "SG",
    "SH",
    "SHANGRILA",
    "SHARP",
    "SHAW",
    "SHELL",
    "SHIA",
    "SHIKSHA",
    "SHOES",
    "SHOP",
    "SHOPPING",
    "SHOUJI",
    "SHOW",
    "SI",
    "SILK",
    "SINA",
    "SINGLES",
    "SITE",
    "SJ",
    "SK",
    "SKI",
    "SKIN",
    "SKY",
    "SKYPE",
    "SL",
    "SLING",
    "SM",
    "SMART",
    "SMILE",
    "SN",
    "SNCF",
    "SO",
    "SOCCER",
    "SOCIAL",
    "SOFTBANK",
    "SOFTWARE",
    "SOHU",
    "SOLAR",
    "SOLUTIONS",
    "SONG",
    "SONY",
    "SOY",
    "SPA",
    "SPACE",
    "SPORT",
    "SPOT",
    "SR",
    "SRL",
    "SS",
    "ST",
    "STADA",
    "STAPLES",
    "STAR",
    "STATEBANK",
    "STATEFARM",
    "STC",
    "STCGROUP",
    "STOCKHOLM",
    "STORAGE",
    "STORE",
    "STREAM",
    "STUDIO",
    "STUDY",
    "STYLE",
    "SU",
    "SUCKS",
    "SUPPLIES",
    "SUPPLY",
    "SUPPORT",
    "SURF",
    "SURGERY",
    "SUZUKI",
    "SV",
    "SWATCH",
    "SWISS",
    "SX",
    "SY",
    "SYDNEY",
    "SYSTEMS",
    "SZ",
    "TAB",
    "TAIPEI",
    "TALK",
    "TAOBAO",
    "TARGET",
    "TATAMOTORS",
    "TATAR",
    "TATTOO",
    "TAX",
    "TAXI",
    "TC",
    "TCI",
    "TD",
    "TDK",
    "TEAM",
    "TECH",
    "TECHNOLOGY",
    "TEL",
    "TEMASEK",
    "TENNIS",
    "TEVA",
    "TF",
    "TG",
    "TH",
    "THD",
    "THEATER",
    "THEATRE",
    "TIAA",
    "TICKETS",
    "TIENDA",
    "TIPS",
    "TIRES",
    "TIROL",
    "TJ",
    "TJMAXX",
    "TJX",
    "TK",
    "TKMAXX",
    "TL",
    "TM",
    "TMALL",
    "TN",
    "TO",
    "TODAY",
    "TOKYO",
    "TOOLS",
    "TOP",
    "TORAY",
    "TOSHIBA",
    "TOTAL",
    "TOURS",
    "TOWN",
    "TOYOTA",
    "TOYS",
    "TR",
    "TRADE",
    "TRADING",
    "TRAINING",
    "TRAVEL",
    "TRAVELERS",
    "TRAVELERSINSURANCE",
    "TRUST",
    "TRV",
    "TT",
    "TUBE",
    "TUI",
    "TUNES",
    "TUSHU",
    "TV",
    "TVS",
    "TW",
    "TZ",
    "UA",
    "UBANK",
    "UBS",
    "UG",
    "UK",
    "UNICOM",
    "UNIVERSITY",
    "UNO",
    "UOL",
    "UPS",
    "US",
    "UY",
    "UZ",
    "VA",
    "VACATIONS",
    "VANA",
    "VANGUARD",
    "VC",
    "VE",
    "VEGAS",
    "VENTURES",
    "VERISIGN",
    "VERSICHERUNG",
    "VET",
    "VG",
    "VI",
    "VIAJES",
    "VIDEO",
    "VIG",
    "VIKING",
    "VILLAS",
    "VIN",
    "VIP",
    "VIRGIN",
    "VISA",
    "VISION",
    "VIVA",
    "VIVO",
    "VLAANDEREN",
    "VN",
    "VODKA",
    "VOLVO",
    "VOTE",
    "VOTING",
    "VOTO",
    "VOYAGE",
    "VU",
    "WALES",
    "WALMART",
    "WALTER",
    "WANG",
    "WANGGOU",
    "WATCH",
    "WATCHES",
    "WEATHER",
    "WEATHERCHANNEL",
    "WEBCAM",
    "WEBER",
    "WEBSITE",
    "WED",
    "WEDDING",
    "WEIBO",
    "WEIR",
    "WF",
    "WHOSWHO",
    "WIEN",
    "WIKI",
    "WILLIAMHILL",
    "WIN",
    "WINDOWS",
    "WINE",
    "WINNERS",
    "WME",
    "WOLTERSKLUWER",
    "WOODSIDE",
    "WORK",
    "WORKS",
    "WORLD",
    "WOW",
    "WS",
    "WTC",
    "WTF",
    "XBOX",
    "XEROX",
    "XFINITY",
    "XIHUAN",
    "XIN",
    "XN--11B4C3D",
    "XN--1CK2E1B",
    "XN--1QQW23A",
    "XN--2SCRJ9C",
    "XN--30RR7Y",
    "XN--3BST00M",
    "XN--3DS443G",
    "XN--3E0B707E",
    "XN--3HCRJ9C",
    "XN--3PXU8K",
    "XN--42C2D9A",
    "XN--45BR5CYL",
    "XN--45BRJ9C",
    "XN--45Q11C",
    "XN--4DBRK0CE",
    "XN--4GBRIM",
    "XN--54B7FTA0CC",
    "XN--55QW42G",
    "XN--55QX5D",
    "XN--5SU34J936BGSG",
    "XN--5TZM5G",
    "XN--6FRZ82G",
    "XN--6QQ986B3XL",
    "XN--80ADXHKS",
    "XN--80AO21A",
    "XN--80AQECDR1A",
    "XN--80ASEHDB",
    "XN--80ASWG",
    "XN--8Y0A063A",
    "XN--90A3AC",
    "XN--90AE",
    "XN--90AIS",
    "XN--9DBQ2A",
    "XN--9ET52U",
    "XN--9KRT00A",
    "XN--B4W605FERD",
    "XN--BCK1B9A5DRE4C",
    "XN--C1AVG",
    "XN--C2BR7G",
    "XN--CCK2B3B",
    "XN--CCKWCXETD",
    "XN--CG4BKI",
    "XN--CLCHC0EA0B2G2A9GCD",
    "XN--CZR694B",
    "XN--CZRS0T",
    "XN--CZRU2D",
    "XN--D1ACJ3B",
    "XN--D1ALF",
    "XN--E1A4C",
    "XN--ECKVDTC9D",
    "XN--EFVY88H",
    "XN--FCT429K",
    "XN--FHBEI",
    "XN--FIQ228C5HS",
    "XN--FIQ64B",
    "XN--FIQS8S",
    "XN--FIQZ9S",
    "XN--FJQ720A",
    "XN--FLW351E",
    "XN--FPCRJ9C3D",
    "XN--FZC2C9E2C",
    "XN--FZYS8D69UVGM",
    "XN--G2XX48C",
    "XN--GCKR3F0F",
    "XN--GECRJ9C",
    "XN--GK3AT1E",
    "XN--H2BREG3EVE",
    "XN--H2BRJ9C",
    "XN--H2BRJ9C8C",
    "XN--HXT814E",
    "XN--I1B6B1A6A2E",
    "XN--IMR513N",
    "XN--IO0A7I",
    "XN--J1AEF",
    "XN--J1AMH",
    "XN--J6W193G",
    "XN--JLQ480N2RG",
    "XN--JVR189M",
    "XN--KCRX77D1X4A",
    "XN--KPRW13D",
    "XN--KPRY57D",
    "XN--KPUT3I",
    "XN--L1ACC",
    "XN--LGBBAT1AD8J",
    "XN--MGB9AWBF",
    "XN--MGBA3A3EJT",
    "XN--MGBA3A4F16A",
    "XN--MGBA7C0BBN0A",
    "XN--MGBAAM7A8H",
    "XN--MGBAB2BD",
    "XN--MGBAH1A3HJKRD",
    "XN--MGBAI9AZGQP6J",
    "XN--MGBAYH7GPA",
    "XN--MGBBH1A",
    "XN--MGBBH1A71E",
    "XN--MGBC0A9AZCG",
    "XN--MGBCA7DZDO",
    "XN--MGBCPQ6GPA1A",
    "XN--MGBERP4A5D4AR",
    "XN--MGBGU82A",
    "XN--MGBI4ECEXP",
    "XN--MGBPL2FH",
    "XN--MGBT3DHD",
    "XN--MGBTX2B",
    "XN--MGBX4CD0AB",
    "XN--MIX891F",
    "XN--MK1BU44C",
    "XN--MXTQ1M",
    "XN--NGBC5AZD",
    "XN--NGBE9E0A",
    "XN--NGBRX",
    "XN--NODE",
    "XN--NQV7F",
    "XN--NQV7FS00EMA",
    "XN--NYQY26A",
    "XN--O3CW4H",
    "XN--OGBPF8FL",
    "XN--OTU796D",
    "XN--P1ACF",
    "XN--P1AI",
    "XN--PGBS0DH",
    "XN--PSSY2U",
    "XN--Q7CE6A",
    "XN--Q9JYB4C",
    "XN--QCKA1PMC",
    "XN--QXA6A",
    "XN--QXAM",
    "XN--RHQV96G",
    "XN--ROVU88B",
    "XN--RVC1E0AM3E",
    "XN--S9BRJ9C",
    "XN--SES554G",
    "XN--T60B56A",
    "XN--TCKWE",
    "XN--TIQ49XQYJ",
    "XN--UNUP4Y",
    "XN--VERMGENSBERATER-CTB",
    "XN--VERMGENSBERATUNG-PWB",
    "XN--VHQUV",
    "XN--VUQ861B",
    "XN--W4R85EL8FHU5DNRA",
    "XN--W4RS40L",
    "XN--WGBH1C",
    "XN--WGBL6A",
    "XN--XHQ521B",
    "XN--XKC2AL3HYE2A",
    "XN--XKC2DL3A5EE0H",
    "XN--Y9A3AQ",
    "XN--YFRO4I67O",
    "XN--YGBI2AMMX",
    "XN--ZFR164B",
    "XXX",
    "XYZ",
    "YACHTS",
    "YAHOO",
    "YAMAXUN",
    "YANDEX",
    "YE",
    "YODOBASHI",
    "YOGA",
    "YOKOHAMA",
    "YOU",
    "YOUTUBE",
    "YT",
    "YUN",
    "ZA",
    "ZAPPOS",
    "ZARA",
    "ZERO",
    "ZIP",
    "ZM",
    "ZONE",
    "ZUERICH",
    "ZW"
  ];
  module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));
});

// node_modules/joi/lib/types/string.js
var require_string2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Domain = require_domain();
  var Email = require_email();
  var Ip = require_ip();
  var EscapeRegex = require_escapeRegex3();
  var Tlds = require_tlds();
  var Uri = require_uri();
  var Any = require_any2();
  var Common = require_common2();
  var internals = {
    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,
    base64Regex: {
      true: {
        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
        false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
      },
      false: {
        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
        false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
      }
    },
    dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
    hexRegex: {
      withPrefix: /^0x[0-9a-f]+$/i,
      withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,
      withoutPrefix: /^[0-9a-f]+$/i
    },
    ipRegex: Ip.regex({ cidr: "forbidden" }).regex,
    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
    guidBrackets: {
      "{": "}",
      "[": "]",
      "(": ")",
      "": ""
    },
    guidVersions: {
      uuidv1: "1",
      uuidv2: "2",
      uuidv3: "3",
      uuidv4: "4",
      uuidv5: "5",
      uuidv6: "6",
      uuidv7: "7",
      uuidv8: "8"
    },
    guidSeparators: new Set([undefined, true, false, "-", ":"]),
    normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
  };
  module.exports = Any.extend({
    type: "string",
    flags: {
      insensitive: { default: false },
      truncate: { default: false }
    },
    terms: {
      replacements: { init: null }
    },
    coerce: {
      from: "string",
      method(value, { schema, state, prefs }) {
        const normalize = schema.$_getRule("normalize");
        if (normalize) {
          value = value.normalize(normalize.args.form);
        }
        const casing = schema.$_getRule("case");
        if (casing) {
          value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
        }
        const trim = schema.$_getRule("trim");
        if (trim && trim.args.enabled) {
          value = value.trim();
        }
        if (schema.$_terms.replacements) {
          for (const replacement of schema.$_terms.replacements) {
            value = value.replace(replacement.pattern, replacement.replacement);
          }
        }
        const hex = schema.$_getRule("hex");
        if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
          value = `0${value}`;
        }
        if (schema.$_getRule("isoDate")) {
          const iso = internals.isoDate(value);
          if (iso) {
            value = iso;
          }
        }
        if (schema._flags.truncate) {
          const rule = schema.$_getRule("max");
          if (rule) {
            let limit = rule.args.limit;
            if (Common.isResolvable(limit)) {
              limit = limit.resolve(value, state, prefs);
              if (!Common.limit(limit)) {
                return { value, errors: schema.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
              }
            }
            value = value.slice(0, limit);
          }
        }
        return { value };
      }
    },
    validate(value, { schema, error }) {
      if (typeof value !== "string") {
        return { value, errors: error("string.base") };
      }
      if (value === "") {
        const min = schema.$_getRule("min");
        if (min && min.args.limit === 0) {
          return;
        }
        return { value, errors: error("string.empty") };
      }
    },
    rules: {
      alphanum: {
        method() {
          return this.$_addRule("alphanum");
        },
        validate(value, helpers) {
          if (/^[a-zA-Z0-9]+$/.test(value)) {
            return value;
          }
          return helpers.error("string.alphanum");
        }
      },
      base64: {
        method(options = {}) {
          Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
          options = { urlSafe: false, paddingRequired: true, ...options };
          Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
          Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
          return this.$_addRule({ name: "base64", args: { options } });
        },
        validate(value, helpers, { options }) {
          const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
          if (regex.test(value)) {
            return value;
          }
          return helpers.error("string.base64");
        }
      },
      case: {
        method(direction) {
          Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
          return this.$_addRule({ name: "case", args: { direction } });
        },
        validate(value, helpers, { direction }) {
          if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
            return value;
          }
          return helpers.error(`string.${direction}case`);
        },
        convert: true
      },
      creditCard: {
        method() {
          return this.$_addRule("creditCard");
        },
        validate(value, helpers) {
          let i = value.length;
          let sum = 0;
          let mul = 1;
          while (i--) {
            const char = value.charAt(i) * mul;
            sum = sum + (char - (char > 9) * 9);
            mul = mul ^ 3;
          }
          if (sum > 0 && sum % 10 === 0) {
            return value;
          }
          return helpers.error("string.creditCard");
        }
      },
      dataUri: {
        method(options = {}) {
          Common.assertOptions(options, ["paddingRequired"]);
          options = { paddingRequired: true, ...options };
          Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
          return this.$_addRule({ name: "dataUri", args: { options } });
        },
        validate(value, helpers, { options }) {
          const matches = value.match(internals.dataUriRegex);
          if (matches) {
            if (!matches[2]) {
              return value;
            }
            if (matches[2] !== "base64") {
              return value;
            }
            const base64regex = internals.base64Regex[options.paddingRequired].false;
            if (base64regex.test(matches[3])) {
              return value;
            }
          }
          return helpers.error("string.dataUri");
        }
      },
      domain: {
        method(options) {
          if (options) {
            Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          }
          const address = internals.addressOptions(options);
          return this.$_addRule({ name: "domain", args: { options }, address });
        },
        validate(value, helpers, args, { address }) {
          if (Domain.isValid(value, address)) {
            return value;
          }
          return helpers.error("string.domain");
        }
      },
      email: {
        method(options = {}) {
          Common.assertOptions(options, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]);
          Assert(options.multiple === undefined || typeof options.multiple === "boolean", "multiple option must be an boolean");
          const address = internals.addressOptions(options);
          const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ","}]\\s*`);
          return this.$_addRule({ name: "email", args: { options }, regex, address });
        },
        validate(value, helpers, { options }, { regex, address }) {
          const emails = options.multiple ? value.split(regex) : [value];
          const invalids = [];
          for (const email of emails) {
            if (!Email.isValid(email, address)) {
              invalids.push(email);
            }
          }
          if (!invalids.length) {
            return value;
          }
          return helpers.error("string.email", { value, invalids });
        }
      },
      guid: {
        alias: "uuid",
        method(options = {}) {
          Common.assertOptions(options, ["version", "separator"]);
          let versionNumbers = "";
          if (options.version) {
            const versions = [].concat(options.version);
            Assert(versions.length >= 1, "version must have at least 1 valid version specified");
            const set = new Set;
            for (let i = 0;i < versions.length; ++i) {
              const version = versions[i];
              Assert(typeof version === "string", "version at position " + i + " must be a string");
              const versionNumber = internals.guidVersions[version.toLowerCase()];
              Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
              Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
              versionNumbers += versionNumber;
              set.add(versionNumber);
            }
          }
          Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
          const separator = options.separator === undefined ? "[:-]?" : options.separator === true ? "[:-]" : options.separator === false ? "[]?" : `\\${options.separator}`;
          const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
          return this.$_addRule({ name: "guid", args: { options }, regex });
        },
        validate(value, helpers, args, { regex }) {
          const results = regex.exec(value);
          if (!results) {
            return helpers.error("string.guid");
          }
          if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
            return helpers.error("string.guid");
          }
          return value;
        }
      },
      hex: {
        method(options = {}) {
          Common.assertOptions(options, ["byteAligned", "prefix"]);
          options = { byteAligned: false, prefix: false, ...options };
          Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
          Assert(typeof options.prefix === "boolean" || options.prefix === "optional", 'prefix must be boolean or "optional"');
          return this.$_addRule({ name: "hex", args: { options } });
        },
        validate(value, helpers, { options }) {
          const re = options.prefix === "optional" ? internals.hexRegex.withOptionalPrefix : options.prefix === true ? internals.hexRegex.withPrefix : internals.hexRegex.withoutPrefix;
          if (!re.test(value)) {
            return helpers.error("string.hex");
          }
          if (options.byteAligned && value.length % 2 !== 0) {
            return helpers.error("string.hexAlign");
          }
          return value;
        }
      },
      hostname: {
        method() {
          return this.$_addRule("hostname");
        },
        validate(value, helpers) {
          if (Domain.isValid(value, { minDomainSegments: 1 }) || internals.ipRegex.test(value)) {
            return value;
          }
          return helpers.error("string.hostname");
        }
      },
      insensitive: {
        method() {
          return this.$_setFlag("insensitive", true);
        }
      },
      ip: {
        method(options = {}) {
          Common.assertOptions(options, ["cidr", "version"]);
          const { cidr, versions, regex } = Ip.regex(options);
          const version = options.version ? versions : undefined;
          return this.$_addRule({ name: "ip", args: { options: { cidr, version } }, regex });
        },
        validate(value, helpers, { options }, { regex }) {
          if (regex.test(value)) {
            return value;
          }
          if (options.version) {
            return helpers.error("string.ipVersion", { value, cidr: options.cidr, version: options.version });
          }
          return helpers.error("string.ip", { value, cidr: options.cidr });
        }
      },
      isoDate: {
        method() {
          return this.$_addRule("isoDate");
        },
        validate(value, { error }) {
          if (internals.isoDate(value)) {
            return value;
          }
          return error("string.isoDate");
        }
      },
      isoDuration: {
        method() {
          return this.$_addRule("isoDuration");
        },
        validate(value, helpers) {
          if (internals.isoDurationRegex.test(value)) {
            return value;
          }
          return helpers.error("string.isoDuration");
        }
      },
      length: {
        method(limit, encoding) {
          return internals.length(this, "length", limit, "=", encoding);
        },
        validate(value, helpers, { limit, encoding }, { name, operator, args }) {
          const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
          if (Common.compare(length, limit, operator)) {
            return value;
          }
          return helpers.error("string." + name, { limit: args.limit, value, encoding });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          },
          "encoding"
        ]
      },
      lowercase: {
        method() {
          return this.case("lower");
        }
      },
      max: {
        method(limit, encoding) {
          return internals.length(this, "max", limit, "<=", encoding);
        },
        args: ["limit", "encoding"]
      },
      min: {
        method(limit, encoding) {
          return internals.length(this, "min", limit, ">=", encoding);
        },
        args: ["limit", "encoding"]
      },
      normalize: {
        method(form = "NFC") {
          Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
          return this.$_addRule({ name: "normalize", args: { form } });
        },
        validate(value, { error }, { form }) {
          if (value === value.normalize(form)) {
            return value;
          }
          return error("string.normalize", { value, form });
        },
        convert: true
      },
      pattern: {
        alias: "regex",
        method(regex, options = {}) {
          Assert(regex instanceof RegExp, "regex must be a RegExp");
          Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
          if (typeof options === "string") {
            options = { name: options };
          }
          Common.assertOptions(options, ["invert", "name"]);
          const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
          return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
        },
        validate(value, helpers, { regex, options }, { errorCode }) {
          const patternMatch = regex.test(value);
          if (patternMatch ^ options.invert) {
            return value;
          }
          return helpers.error(errorCode, { name: options.name, regex, value });
        },
        args: ["regex", "options"],
        multi: true
      },
      replace: {
        method(pattern, replacement) {
          if (typeof pattern === "string") {
            pattern = new RegExp(EscapeRegex(pattern), "g");
          }
          Assert(pattern instanceof RegExp, "pattern must be a RegExp");
          Assert(typeof replacement === "string", "replacement must be a String");
          const obj = this.clone();
          if (!obj.$_terms.replacements) {
            obj.$_terms.replacements = [];
          }
          obj.$_terms.replacements.push({ pattern, replacement });
          return obj;
        }
      },
      token: {
        method() {
          return this.$_addRule("token");
        },
        validate(value, helpers) {
          if (/^\w+$/.test(value)) {
            return value;
          }
          return helpers.error("string.token");
        }
      },
      trim: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_addRule({ name: "trim", args: { enabled } });
        },
        validate(value, helpers, { enabled }) {
          if (!enabled || value === value.trim()) {
            return value;
          }
          return helpers.error("string.trim");
        },
        convert: true
      },
      truncate: {
        method(enabled = true) {
          Assert(typeof enabled === "boolean", "enabled must be a boolean");
          return this.$_setFlag("truncate", enabled);
        }
      },
      uppercase: {
        method() {
          return this.case("upper");
        }
      },
      uri: {
        method(options = {}) {
          Common.assertOptions(options, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme", "encodeUri"]);
          if (options.domain) {
            Common.assertOptions(options.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          }
          const { regex, scheme } = Uri.regex(options);
          const domain = options.domain ? internals.addressOptions(options.domain) : null;
          return this.$_addRule({ name: "uri", args: { options }, regex, domain, scheme });
        },
        validate(value, helpers, { options }, { regex, domain, scheme }) {
          if (["http:/", "https:/"].includes(value)) {
            return helpers.error("string.uri");
          }
          let match = regex.exec(value);
          if (!match && helpers.prefs.convert && options.encodeUri) {
            const encoded = encodeURI(value);
            match = regex.exec(encoded);
            if (match) {
              value = encoded;
            }
          }
          if (match) {
            const matched = match[1] || match[2];
            if (domain && (!options.allowRelative || matched) && !Domain.isValid(matched, domain)) {
              return helpers.error("string.domain", { value: matched });
            }
            return value;
          }
          if (options.relativeOnly) {
            return helpers.error("string.uriRelativeOnly");
          }
          if (options.scheme) {
            return helpers.error("string.uriCustomScheme", { scheme, value });
          }
          return helpers.error("string.uri");
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.replacements) {
          for (const { pattern, replacement } of desc.replacements) {
            obj = obj.replace(pattern, replacement);
          }
        }
        return obj;
      }
    },
    messages: {
      "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
      "string.base": "{{#label}} must be a string",
      "string.base64": "{{#label}} must be a valid base64 string",
      "string.creditCard": "{{#label}} must be a credit card",
      "string.dataUri": "{{#label}} must be a valid dataUri string",
      "string.domain": "{{#label}} must contain a valid domain name",
      "string.email": "{{#label}} must be a valid email",
      "string.empty": "{{#label}} is not allowed to be empty",
      "string.guid": "{{#label}} must be a valid GUID",
      "string.hex": "{{#label}} must only contain hexadecimal characters",
      "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
      "string.hostname": "{{#label}} must be a valid hostname",
      "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
      "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
      "string.isoDate": "{{#label}} must be in iso format",
      "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
      "string.length": "{{#label}} length must be {{#limit}} characters long",
      "string.lowercase": "{{#label}} must only contain lowercase characters",
      "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
      "string.min": "{{#label}} length must be at least {{#limit}} characters long",
      "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
      "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
      "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
      "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
      "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
      "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
      "string.trim": "{{#label}} must not have leading or trailing whitespace",
      "string.uri": "{{#label}} must be a valid uri",
      "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
      "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
      "string.uppercase": "{{#label}} must only contain uppercase characters"
    }
  });
  internals.addressOptions = function(options) {
    if (!options) {
      return internals.tlds || options;
    }
    Assert(options.minDomainSegments === undefined || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, "minDomainSegments must be a positive integer");
    Assert(options.maxDomainSegments === undefined || Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, "maxDomainSegments must be a positive integer");
    if (options.tlds === false) {
      return options;
    }
    if (options.tlds === true || options.tlds === undefined) {
      Assert(internals.tlds, "Built-in TLD list disabled");
      return Object.assign({}, options, internals.tlds);
    }
    Assert(typeof options.tlds === "object", "tlds must be true, false, or an object");
    const deny = options.tlds.deny;
    if (deny) {
      if (Array.isArray(deny)) {
        options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
      }
      Assert(options.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
      Assert(!options.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
      internals.validateTlds(options.tlds.deny, "tlds.deny");
      return options;
    }
    const allow = options.tlds.allow;
    if (!allow) {
      return options;
    }
    if (allow === true) {
      Assert(internals.tlds, "Built-in TLD list disabled");
      return Object.assign({}, options, internals.tlds);
    }
    if (Array.isArray(allow)) {
      options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
    }
    Assert(options.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
    internals.validateTlds(options.tlds.allow, "tlds.allow");
    return options;
  };
  internals.validateTlds = function(set, source) {
    for (const tld of set) {
      Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);
    }
  };
  internals.isoDate = function(value) {
    if (!Common.isIsoDate(value)) {
      return null;
    }
    if (/.*T.*[+-]\d\d$/.test(value)) {
      value += "00";
    }
    const date = new Date(value);
    if (isNaN(date.getTime())) {
      return null;
    }
    return date.toISOString();
  };
  internals.length = function(schema, name, limit, operator, encoding) {
    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
    return schema.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
  };
});

// node_modules/joi/lib/types/symbol.js
var require_symbol2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Any = require_any2();
  var internals = {};
  internals.Map = class extends Map {
    slice() {
      return new internals.Map(this);
    }
  };
  module.exports = Any.extend({
    type: "symbol",
    terms: {
      map: { init: new internals.Map }
    },
    coerce: {
      method(value, { schema, error }) {
        const lookup = schema.$_terms.map.get(value);
        if (lookup) {
          value = lookup;
        }
        if (!schema._flags.only || typeof value === "symbol") {
          return { value };
        }
        return { value, errors: error("symbol.map", { map: schema.$_terms.map }) };
      }
    },
    validate(value, { error }) {
      if (typeof value !== "symbol") {
        return { value, errors: error("symbol.base") };
      }
    },
    rules: {
      map: {
        method(iterable) {
          if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
            iterable = Object.entries(iterable);
          }
          Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
          const obj = this.clone();
          const symbols = [];
          for (const entry of iterable) {
            Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
            const [key, value] = entry;
            Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
            Assert(typeof value === "symbol", "Value must be a Symbol");
            obj.$_terms.map.set(key, value);
            symbols.push(value);
          }
          return obj.valid(...symbols);
        }
      }
    },
    manifest: {
      build(obj, desc) {
        if (desc.map) {
          obj = obj.map(desc.map);
        }
        return obj;
      }
    },
    messages: {
      "symbol.base": "{{#label}} must be a symbol",
      "symbol.map": "{{#label}} must be one of {{#map}}"
    }
  });
});

// node_modules/joi/lib/types/binary.js
var require_binary2 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Any = require_any2();
  var Common = require_common2();
  module.exports = Any.extend({
    type: "binary",
    coerce: {
      from: ["string", "object"],
      method(value, { schema }) {
        if (typeof value === "string" || value !== null && value.type === "Buffer") {
          try {
            return { value: Buffer.from(value, schema._flags.encoding) };
          } catch (ignoreErr) {}
        }
      }
    },
    validate(value, { error }) {
      if (!Buffer.isBuffer(value)) {
        return { value, errors: error("binary.base") };
      }
    },
    rules: {
      encoding: {
        method(encoding) {
          Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
          return this.$_setFlag("encoding", encoding);
        }
      },
      length: {
        method(limit) {
          return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
        },
        validate(value, helpers, { limit }, { name, operator, args }) {
          if (Common.compare(value.length, limit, operator)) {
            return value;
          }
          return helpers.error("binary." + name, { limit: args.limit, value });
        },
        args: [
          {
            name: "limit",
            ref: true,
            assert: Common.limit,
            message: "must be a positive integer"
          }
        ]
      },
      max: {
        method(limit) {
          return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
        }
      },
      min: {
        method(limit) {
          return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
        }
      }
    },
    cast: {
      string: {
        from: (value) => Buffer.isBuffer(value),
        to(value, helpers) {
          return value.toString();
        }
      }
    },
    messages: {
      "binary.base": "{{#label}} must be a buffer or a string",
      "binary.length": "{{#label}} must be {{#limit}} bytes",
      "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
      "binary.min": "{{#label}} must be at least {{#limit}} bytes"
    }
  });
});

// node_modules/joi/lib/index.js
var require_lib39 = __commonJS((exports, module) => {
  var Assert = require_assert2();
  var Clone = require_clone2();
  var Cache = require_cache2();
  var Common = require_common2();
  var Compile = require_compile2();
  var Errors = require_errors3();
  var Extend = require_extend2();
  var Manifest = require_manifest();
  var Ref = require_ref2();
  var Template = require_template2();
  var Trace = require_trace();
  var Schemas;
  var internals = {
    types: {
      alternatives: require_alternatives2(),
      any: require_any2(),
      array: require_array2(),
      boolean: require_boolean2(),
      date: require_date2(),
      function: require_function2(),
      link: require_link2(),
      number: require_number2(),
      object: require_object2(),
      string: require_string2(),
      symbol: require_symbol2()
    },
    aliases: {
      alt: "alternatives",
      bool: "boolean",
      func: "function"
    }
  };
  if (Buffer) {
    internals.types.binary = require_binary2();
  }
  internals.root = function() {
    const root = {
      _types: new Set(Object.keys(internals.types))
    };
    for (const type of root._types) {
      root[type] = function(...args) {
        Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
        return internals.generate(this, internals.types[type], args);
      };
    }
    for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
      root[method] = function(...args) {
        return this.any()[method](...args);
      };
    }
    Object.assign(root, internals.methods);
    for (const alias in internals.aliases) {
      const target = internals.aliases[alias];
      root[alias] = root[target];
    }
    root.x = root.expression;
    if (Trace.setup) {
      Trace.setup(root);
    }
    return root;
  };
  internals.methods = {
    ValidationError: Errors.ValidationError,
    version: Common.version,
    cache: Cache.provider,
    assert(value, schema, ...args) {
      internals.assert(value, schema, true, args);
    },
    attempt(value, schema, ...args) {
      return internals.assert(value, schema, false, args);
    },
    build(desc) {
      Assert(typeof Manifest.build === "function", "Manifest functionality disabled");
      return Manifest.build(this, desc);
    },
    checkPreferences(prefs) {
      Common.checkPreferences(prefs);
    },
    compile(schema, options) {
      return Compile.compile(this, schema, options);
    },
    defaults(modifier) {
      Assert(typeof modifier === "function", "modifier must be a function");
      const joi = Object.assign({}, this);
      for (const type of joi._types) {
        const schema = modifier(joi[type]());
        Assert(Common.isSchema(schema), "modifier must return a valid schema object");
        joi[type] = function(...args) {
          return internals.generate(this, schema, args);
        };
      }
      return joi;
    },
    expression(...args) {
      return new Template(...args);
    },
    extend(...extensions) {
      Common.verifyFlat(extensions, "extend");
      Schemas = Schemas || require_schemas2();
      Assert(extensions.length, "You need to provide at least one extension");
      this.assert(extensions, Schemas.extensions);
      const joi = Object.assign({}, this);
      joi._types = new Set(joi._types);
      for (let extension of extensions) {
        if (typeof extension === "function") {
          extension = extension(joi);
        }
        this.assert(extension, Schemas.extension);
        const expanded = internals.expandExtension(extension, joi);
        for (const item of expanded) {
          Assert(joi[item.type] === undefined || joi._types.has(item.type), "Cannot override name", item.type);
          const base = item.base || this.any();
          const schema = Extend.type(base, item);
          joi._types.add(item.type);
          joi[item.type] = function(...args) {
            return internals.generate(this, schema, args);
          };
        }
      }
      return joi;
    },
    isError: Errors.ValidationError.isError,
    isExpression: Template.isTemplate,
    isRef: Ref.isRef,
    isSchema: Common.isSchema,
    in(...args) {
      return Ref.in(...args);
    },
    override: Common.symbols.override,
    ref(...args) {
      return Ref.create(...args);
    },
    types() {
      const types2 = {};
      for (const type of this._types) {
        types2[type] = this[type]();
      }
      for (const target in internals.aliases) {
        types2[target] = this[target]();
      }
      return types2;
    }
  };
  internals.assert = function(value, schema, annotate, args) {
    const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
    const options = message !== null ? args[1] : args[0];
    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
    let error = result.error;
    if (!error) {
      return result.value;
    }
    if (message instanceof Error) {
      throw message;
    }
    const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
    if (error instanceof Errors.ValidationError === false) {
      error = Clone(error);
    }
    error.message = message ? `${message} ${display}` : display;
    throw error;
  };
  internals.generate = function(root, schema, args) {
    Assert(root, "Must be invoked on a Joi instance.");
    schema.$_root = root;
    if (!schema._definition.args || !args.length) {
      return schema;
    }
    return schema._definition.args(schema, ...args);
  };
  internals.expandExtension = function(extension, joi) {
    if (typeof extension.type === "string") {
      return [extension];
    }
    const extended = [];
    for (const type of joi._types) {
      if (extension.type.test(type)) {
        const item = Object.assign({}, extension);
        item.type = type;
        item.base = joi[type]();
        extended.push(item);
      }
    }
    return extended;
  };
  module.exports = internals.root();
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
  function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  module.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  function base64Url(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function signatureAsBuffer(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer2.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0;offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o = offset;offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  module.exports = {
    derToJose,
    joseToDer
  };
});

// node_modules/@hapi/jwt/lib/utils.js
var require_utils6 = __commonJS((exports) => {
  var B64 = require_lib24();
  var Joi3 = require_lib39();
  exports.b64stringify = function(obj) {
    return B64.base64urlEncode(JSON.stringify(obj), "utf-8");
  };
  exports.toHex = function(number) {
    const nstr = number.toString(16);
    if (nstr.length % 2) {
      return `0${nstr}`;
    }
    return nstr;
  };
  exports.validHttpTokenSchema = Joi3.string().pattern(/^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/);
});

// node_modules/@hapi/jwt/lib/crypto.js
var require_crypto = __commonJS((exports) => {
  var Crypto = __require("crypto");
  var Cryptiles = require_lib23();
  var EcdsaSigFormatter = require_ecdsa_sig_formatter();
  var Utils = require_utils6();
  var internals = {
    algorithms: {
      RS256: "RSA-SHA256",
      RS384: "RSA-SHA384",
      RS512: "RSA-SHA512",
      PS256: "RSA-SHA256",
      PS384: "RSA-SHA384",
      PS512: "RSA-SHA512",
      ES256: "RSA-SHA256",
      ES384: "RSA-SHA384",
      ES512: "RSA-SHA512",
      EDDSA: "EdDSA",
      HS256: "sha256",
      HS384: "sha384",
      HS512: "sha512"
    }
  };
  exports.generate = function(value, algorithm, key) {
    algorithm = algorithm.toUpperCase();
    if (algorithm === "NONE") {
      return "";
    }
    const algo = internals.algorithms[algorithm];
    if (!algo) {
      throw new Error("Unsupported algorithm");
    }
    switch (algorithm) {
      case "RS256":
      case "RS384":
      case "RS512": {
        const signer = Crypto.createSign(algo);
        signer.update(value);
        const sig = signer.sign(key, "base64");
        return internals.b64urlEncode(sig);
      }
      case "PS256":
      case "PS384":
      case "PS512": {
        const signer = Crypto.createSign(algo);
        signer.update(value);
        const sig = signer.sign({ key, padding: Crypto.constants.RSA_PKCS1_PSS_PADDING, saltLength: Crypto.constants.RSA_PSS_SALTLEN_DIGEST }, "base64");
        return internals.b64urlEncode(sig);
      }
      case "ES256":
      case "ES384":
      case "ES512": {
        const signer = Crypto.createSign(algo);
        signer.update(value);
        const sig = signer.sign(key, "base64");
        return EcdsaSigFormatter.derToJose(sig, algorithm);
      }
      case "HS256":
      case "HS384":
      case "HS512": {
        const hmac = Crypto.createHmac(algo, key);
        hmac.update(value);
        const digest = hmac.digest("base64");
        return internals.b64urlEncode(digest);
      }
      case "EDDSA": {
        const sig = Crypto.sign(undefined, Buffer.from(value), key);
        return internals.b64urlEncode(sig.toString("base64"));
      }
    }
  };
  exports.verify = function(raw, algorithm, key) {
    algorithm = algorithm.toUpperCase();
    if (algorithm === "NONE") {
      return raw.signature === "";
    }
    const algo = internals.algorithms[algorithm];
    if (!algo) {
      throw new Error("Unsupported algorithm");
    }
    const value = `${raw.header}.${raw.payload}`;
    const signature = raw.signature;
    switch (algorithm) {
      case "RS256":
      case "RS384":
      case "RS512": {
        const verifier = Crypto.createVerify(algo);
        verifier.update(value);
        return verifier.verify(key, internals.b64urlDecode(signature), "base64");
      }
      case "PS256":
      case "PS384":
      case "PS512": {
        const verifier = Crypto.createVerify(algo);
        verifier.update(value);
        return verifier.verify({ key, padding: Crypto.constants.RSA_PKCS1_PSS_PADDING, saltLength: Crypto.constants.RSA_PSS_SALTLEN_DIGEST }, internals.b64urlDecode(signature), "base64");
      }
      case "ES256":
      case "ES384":
      case "ES512": {
        const sig = EcdsaSigFormatter.joseToDer(signature, algorithm).toString("base64");
        const verifier = Crypto.createVerify(algo);
        verifier.update(value);
        return verifier.verify(key, internals.b64urlDecode(sig), "base64");
      }
      case "HS256":
      case "HS384":
      case "HS512": {
        const compare = exports.generate(value, algorithm, key);
        return Cryptiles.fixedTimeComparison(signature, compare);
      }
      case "EDDSA": {
        const sig = Buffer.from(internals.b64urlDecode(signature), "base64");
        return Crypto.verify(undefined, Buffer.from(value), key, sig);
      }
    }
  };
  internals.b64urlEncode = function(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
  internals.b64urlDecode = function(b64url) {
    b64url = b64url.toString();
    const padding = 4 - b64url.length % 4;
    if (padding !== 4) {
      for (let i = 0;i < padding; ++i) {
        b64url += "=";
      }
    }
    return b64url.replace(/\-/g, "+").replace(/_/g, "/");
  };
  exports.certToPEM = function(cert) {
    return `-----BEGIN CERTIFICATE-----
${internals.chop(cert)}
-----END CERTIFICATE-----
`;
  };
  exports.rsaPublicKeyToPEM = function(modulusB64, exponentB64) {
    const modulusHex = internals.prepadSigned(Buffer.from(modulusB64, "base64").toString("hex"));
    const exponentHex = internals.prepadSigned(Buffer.from(exponentB64, "base64").toString("hex"));
    const modlen = modulusHex.length / 2;
    const explen = exponentHex.length / 2;
    const encodedModlen = internals.encodeLengthHex(modlen);
    const encodedExplen = internals.encodeLengthHex(explen);
    const encodedPubkey = "30" + internals.encodeLengthHex(modlen + explen + encodedModlen.length / 2 + encodedExplen.length / 2 + 2) + "02" + encodedModlen + modulusHex + "02" + encodedExplen + exponentHex;
    const der = internals.chop(Buffer.from(encodedPubkey, "hex").toString("base64"));
    return `-----BEGIN RSA PUBLIC KEY-----
${der}
-----END RSA PUBLIC KEY-----
`;
  };
  internals.prepadSigned = function(hexStr) {
    const msb = hexStr[0];
    if (msb > "7") {
      return `00${hexStr}`;
    }
    return hexStr;
  };
  internals.encodeLengthHex = function(n) {
    if (n <= 127) {
      return Utils.toHex(n);
    }
    const nHex = Utils.toHex(n);
    const lengthOfLengthByte = 128 + nHex.length / 2;
    return Utils.toHex(lengthOfLengthByte) + nHex;
  };
  internals.chop = function(cert) {
    return cert.match(/.{1,64}/g).join(`
`);
  };
});

// node_modules/@hapi/catbox-object/lib/index.js
var require_lib40 = __commonJS((exports) => {
  var Boom = require_lib13();
  var Hoek = require_lib8();
  var internals = {
    maxTimer: 2147483647,
    entrySize: 144
  };
  internals.defaults = {
    maxSize: 1000,
    minCleanupIntervalMsec: 1000
  };
  exports.Engine = class CatboxObjectEngine {
    constructor(options = {}) {
      Hoek.assert(options.maxSize === undefined || options.maxSize >= 0, "Invalid cache maxSize value");
      Hoek.assert(options.minCleanupIntervalMsec === undefined || options.minCleanupIntervalMsec < internals.maxTimer, "Invalid cache minCleanupIntervalMsec value");
      this.settings = Hoek.applyToDefaults(internals.defaults, options);
      this.cache = null;
      this._timer = null;
      this._timerDue = null;
    }
    start() {
      if (!this.cache) {
        this.cache = new Map;
        this.size = 0;
      }
    }
    _scheduleCleanup(msec) {
      const cleanup = () => {
        this._timer = null;
        this._timerDue = null;
        const now2 = Date.now();
        let next = Infinity;
        for (const [, segment] of this.cache) {
          for (const [id, envelope] of segment) {
            const ttl = envelope.stored + envelope.ttl - now2;
            if (ttl <= 0) {
              segment.delete(id);
              --this.size;
            } else {
              next = Math.min(next, ttl);
            }
          }
        }
        if (next !== Infinity) {
          this._scheduleCleanup(next);
        }
      };
      const now = Date.now();
      const timeout = Math.min(Math.max(this.settings.minCleanupIntervalMsec, msec), internals.maxTimer);
      if (this._timer) {
        if (this._timerDue - now < msec) {
          return;
        }
        clearTimeout(this._timer);
      }
      this._timerDue = now + timeout;
      this._timer = setTimeout(cleanup, timeout);
    }
    stop() {
      clearTimeout(this._timer);
      this._timer = null;
      this._timerDue = null;
      this.cache = null;
      this.size = 0;
    }
    isReady() {
      return !!this.cache;
    }
    validateSegmentName(name) {
      if (!name) {
        throw new Boom.Boom("Empty string");
      }
      if (name.indexOf("\x00") !== -1) {
        throw new Boom.Boom("Includes null character");
      }
      return null;
    }
    get(key) {
      if (!this.cache) {
        throw new Boom.Boom("Connection not started");
      }
      const segment = this.cache.get(key.segment);
      if (!segment) {
        return null;
      }
      const envelope = segment.get(key.id);
      if (!envelope) {
        return null;
      }
      if (envelope.stored + envelope.ttl < Date.now()) {
        this.drop(key);
        return null;
      }
      return envelope;
    }
    set(key, item, ttl) {
      if (!this.cache) {
        throw new Boom.Boom("Connection not started");
      }
      const envelope = {
        item,
        ttl,
        stored: Date.now()
      };
      let segment = this.cache.get(key.segment);
      if (!segment) {
        segment = new Map;
        this.cache.set(key.segment, segment);
      }
      const cachedItem = segment.get(key.id);
      if (cachedItem) {
        --this.size;
      }
      if (this.settings.maxSize && this.size >= this.settings.maxSize) {
        throw new Boom.Boom("Cache size limit reached");
      }
      this._scheduleCleanup(ttl);
      segment.set(key.id, envelope);
      ++this.size;
    }
    drop(key) {
      if (!this.cache) {
        throw new Boom.Boom("Connection not started");
      }
      const segment = this.cache.get(key.segment);
      if (segment) {
        const item = segment.get(key.id);
        if (item) {
          --this.size;
          segment.delete(key.id);
        }
      }
    }
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/stringify.js
var require_stringify4 = __commonJS((exports, module) => {
  module.exports = function(...args) {
    try {
      return JSON.stringify(...args);
    } catch (err) {
      return "[Cannot display object: " + err.message + "]";
    }
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/error.js
var require_error3 = __commonJS((exports, module) => {
  var Stringify = require_stringify4();
  module.exports = class extends Error {
    constructor(args) {
      const msgs = args.filter((arg) => arg !== "").map((arg) => {
        return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
      });
      super(msgs.join(" ") || "Unknown error");
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, exports.assert);
      }
    }
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/assert.js
var require_assert4 = __commonJS((exports, module) => {
  var AssertError = require_error3();
  module.exports = function(condition, ...args) {
    if (condition) {
      return;
    }
    if (args.length === 1 && args[0] instanceof Error) {
      throw args[0];
    }
    throw new AssertError(args);
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/reach.js
var require_reach3 = __commonJS((exports, module) => {
  var Assert = require_assert4();
  var internals = {};
  module.exports = function(obj, chain, options) {
    if (chain === false || chain === null || chain === undefined) {
      return obj;
    }
    options = options || {};
    if (typeof options === "string") {
      options = { separator: options };
    }
    const isChainArray = Array.isArray(chain);
    Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
    const path2 = isChainArray ? chain : chain.split(options.separator || ".");
    let ref = obj;
    for (let i = 0;i < path2.length; ++i) {
      let key = path2[i];
      const type = options.iterables && internals.iterables(ref);
      if (Array.isArray(ref) || type === "set") {
        const number = Number(key);
        if (Number.isInteger(number)) {
          key = number < 0 ? ref.length + number : number;
        }
      }
      if (!ref || typeof ref === "function" && options.functions === false || !type && ref[key] === undefined) {
        Assert(!options.strict || i + 1 === path2.length, "Missing segment", key, "in reach path ", chain);
        Assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
        ref = options.default;
        break;
      }
      if (!type) {
        ref = ref[key];
      } else if (type === "set") {
        ref = [...ref][key];
      } else {
        ref = ref.get(key);
      }
    }
    return ref;
  };
  internals.iterables = function(ref) {
    if (ref instanceof Set) {
      return "set";
    }
    if (ref instanceof Map) {
      return "map";
    }
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/types.js
var require_types4 = __commonJS((exports, module) => {
  var internals = {};
  exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer && Buffer.prototype,
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
  };
  internals.typeMap = new Map([
    ["[object Error]", exports.error],
    ["[object Map]", exports.map],
    ["[object Promise]", exports.promise],
    ["[object Set]", exports.set],
    ["[object WeakMap]", exports.weakMap],
    ["[object WeakSet]", exports.weakSet]
  ]);
  exports.getInternalProto = function(obj) {
    if (Array.isArray(obj)) {
      return exports.array;
    }
    if (Buffer && obj instanceof Buffer) {
      return exports.buffer;
    }
    if (obj instanceof Date) {
      return exports.date;
    }
    if (obj instanceof RegExp) {
      return exports.regex;
    }
    if (obj instanceof Error) {
      return exports.error;
    }
    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/utils.js
var require_utils7 = __commonJS((exports) => {
  exports.keys = function(obj, options = {}) {
    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/clone.js
var require_clone3 = __commonJS((exports, module) => {
  var Reach = require_reach3();
  var Types = require_types4();
  var Utils = require_utils7();
  var internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
  };
  module.exports = internals.clone = function(obj, options = {}, _seen = null) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    let clone = internals.clone;
    let seen = _seen;
    if (options.shallow) {
      if (options.shallow !== true) {
        return internals.cloneWithShallow(obj, options);
      }
      clone = (value) => value;
    } else if (seen) {
      const lookup = seen.get(obj);
      if (lookup) {
        return lookup;
      }
    } else {
      seen = new Map;
    }
    const baseProto = Types.getInternalProto(obj);
    if (baseProto === Types.buffer) {
      return Buffer && Buffer.from(obj);
    }
    if (baseProto === Types.date) {
      return new Date(obj.getTime());
    }
    if (baseProto === Types.regex) {
      return new RegExp(obj);
    }
    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
      return obj;
    }
    if (seen) {
      seen.set(obj, newObj);
    }
    if (baseProto === Types.set) {
      for (const value of obj) {
        newObj.add(clone(value, options, seen));
      }
    } else if (baseProto === Types.map) {
      for (const [key, value] of obj) {
        newObj.set(key, clone(value, options, seen));
      }
    }
    const keys = Utils.keys(obj, options);
    for (const key of keys) {
      if (key === "__proto__") {
        continue;
      }
      if (baseProto === Types.array && key === "length") {
        newObj.length = obj.length;
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj, key);
      if (descriptor) {
        if (descriptor.get || descriptor.set) {
          Object.defineProperty(newObj, key, descriptor);
        } else if (descriptor.enumerable) {
          newObj[key] = clone(obj[key], options, seen);
        } else {
          Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
        }
      } else {
        Object.defineProperty(newObj, key, {
          enumerable: true,
          writable: true,
          configurable: true,
          value: clone(obj[key], options, seen)
        });
      }
    }
    return newObj;
  };
  internals.cloneWithShallow = function(source, options) {
    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;
    const seen = new Map;
    for (const key of keys) {
      const ref = Reach(source, key);
      if (typeof ref === "object" || typeof ref === "function") {
        seen.set(ref, ref);
      }
    }
    return internals.clone(source, options, seen);
  };
  internals.base = function(obj, baseProto, options) {
    if (options.prototype === false) {
      if (internals.needsProtoHack.has(baseProto)) {
        return new baseProto.constructor;
      }
      return baseProto === Types.array ? [] : {};
    }
    const proto2 = Object.getPrototypeOf(obj);
    if (proto2 && proto2.isImmutable) {
      return obj;
    }
    if (baseProto === Types.array) {
      const newObj = [];
      if (proto2 !== baseProto) {
        Object.setPrototypeOf(newObj, proto2);
      }
      return newObj;
    }
    if (internals.needsProtoHack.has(baseProto)) {
      const newObj = new proto2.constructor;
      if (proto2 !== baseProto) {
        Object.setPrototypeOf(newObj, proto2);
      }
      return newObj;
    }
    return Object.create(proto2);
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/merge.js
var require_merge3 = __commonJS((exports, module) => {
  var Assert = require_assert4();
  var Clone = require_clone3();
  var Utils = require_utils7();
  var internals = {};
  module.exports = internals.merge = function(target, source, options) {
    Assert(target && typeof target === "object", "Invalid target value: must be an object");
    Assert(source === null || source === undefined || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
    if (!source) {
      return target;
    }
    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
    if (Array.isArray(source)) {
      Assert(Array.isArray(target), "Cannot merge array onto an object");
      if (!options.mergeArrays) {
        target.length = 0;
      }
      for (let i = 0;i < source.length; ++i) {
        target.push(Clone(source[i], { symbols: options.symbols }));
      }
      return target;
    }
    const keys = Utils.keys(source, options);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
        continue;
      }
      const value = source[key];
      if (value && typeof value === "object") {
        if (target[key] === value) {
          continue;
        }
        if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || value instanceof RegExp) {
          target[key] = Clone(value, { symbols: options.symbols });
        } else {
          internals.merge(target[key], value, options);
        }
      } else {
        if (value !== null && value !== undefined) {
          target[key] = value;
        } else if (options.nullOverride) {
          target[key] = value;
        }
      }
    }
    return target;
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults3 = __commonJS((exports, module) => {
  var Assert = require_assert4();
  var Clone = require_clone3();
  var Merge = require_merge3();
  var Reach = require_reach3();
  var internals = {};
  module.exports = function(defaults3, source, options = {}) {
    Assert(defaults3 && typeof defaults3 === "object", "Invalid defaults value: must be an object");
    Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
    Assert(typeof options === "object", "Invalid options: must be an object");
    if (!source) {
      return null;
    }
    if (options.shallow) {
      return internals.applyToDefaultsWithShallow(defaults3, source, options);
    }
    const copy = Clone(defaults3);
    if (source === true) {
      return copy;
    }
    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.applyToDefaultsWithShallow = function(defaults3, source, options) {
    const keys = options.shallow;
    Assert(Array.isArray(keys), "Invalid keys");
    const seen = new Map;
    const merge = source === true ? null : new Set;
    for (let key of keys) {
      key = Array.isArray(key) ? key : key.split(".");
      const ref = Reach(defaults3, key);
      if (ref && typeof ref === "object") {
        seen.set(ref, merge && Reach(source, key) || ref);
      } else if (merge) {
        merge.add(key);
      }
    }
    const copy = Clone(defaults3, {}, seen);
    if (!merge) {
      return copy;
    }
    for (const key of merge) {
      internals.reachCopy(copy, source, key);
    }
    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
  };
  internals.reachCopy = function(dst, src, path2) {
    for (const segment of path2) {
      if (!(segment in src)) {
        return;
      }
      const val = src[segment];
      if (typeof val !== "object" || val === null) {
        return;
      }
      src = val;
    }
    const value = src;
    let ref = dst;
    for (let i = 0;i < path2.length - 1; ++i) {
      const segment = path2[i];
      if (typeof ref[segment] !== "object") {
        ref[segment] = {};
      }
      ref = ref[segment];
    }
    ref[path2[path2.length - 1]] = value;
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/bench.js
var require_bench2 = __commonJS((exports, module) => {
  var internals = {};
  module.exports = internals.Bench = class {
    constructor() {
      this.ts = 0;
      this.reset();
    }
    reset() {
      this.ts = internals.Bench.now();
    }
    elapsed() {
      return internals.Bench.now() - this.ts;
    }
    static now() {
      const ts = process.hrtime();
      return ts[0] * 1000 + ts[1] / 1e6;
    }
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/ignore.js
var require_ignore3 = __commonJS((exports, module) => {
  module.exports = function() {};
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/block.js
var require_block2 = __commonJS((exports, module) => {
  var Ignore = require_ignore3();
  module.exports = function() {
    return new Promise(Ignore);
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual3 = __commonJS((exports, module) => {
  var Types = require_types4();
  var internals = {
    mismatched: null
  };
  module.exports = function(obj, ref, options) {
    options = Object.assign({ prototype: true }, options);
    return !!internals.isDeepEqual(obj, ref, options, []);
  };
  internals.isDeepEqual = function(obj, ref, options, seen) {
    if (obj === ref) {
      return obj !== 0 || 1 / obj === 1 / ref;
    }
    const type = typeof obj;
    if (type !== typeof ref) {
      return false;
    }
    if (obj === null || ref === null) {
      return false;
    }
    if (type === "function") {
      if (!options.deepFunction || obj.toString() !== ref.toString()) {
        return false;
      }
    } else if (type !== "object") {
      return obj !== obj && ref !== ref;
    }
    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
      case Types.buffer:
        return Buffer && Buffer.prototype.equals.call(obj, ref);
      case Types.promise:
        return obj === ref;
      case Types.regex:
        return obj.toString() === ref.toString();
      case internals.mismatched:
        return false;
    }
    for (let i = seen.length - 1;i >= 0; --i) {
      if (seen[i].isSame(obj, ref)) {
        return true;
      }
    }
    seen.push(new internals.SeenEntry(obj, ref));
    try {
      return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    } finally {
      seen.pop();
    }
  };
  internals.getSharedType = function(obj, ref, checkPrototype) {
    if (checkPrototype) {
      if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
        return internals.mismatched;
      }
      return Types.getInternalProto(obj);
    }
    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
      return internals.mismatched;
    }
    return type;
  };
  internals.valueOf = function(obj) {
    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
      return obj;
    }
    try {
      return objValueOf.call(obj);
    } catch (err) {
      return err;
    }
  };
  internals.hasOwnEnumerableProperty = function(obj, key) {
    return Object.prototype.propertyIsEnumerable.call(obj, key);
  };
  internals.isSetSimpleEqual = function(obj, ref) {
    for (const entry of Set.prototype.values.call(obj)) {
      if (!Set.prototype.has.call(ref, entry)) {
        return false;
      }
    }
    return true;
  };
  internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;
    if (instanceType === Types.array) {
      if (options.part) {
        for (const objValue of obj) {
          for (const refValue of ref) {
            if (isDeepEqual(objValue, refValue, options, seen)) {
              return true;
            }
          }
        }
      } else {
        if (obj.length !== ref.length) {
          return false;
        }
        for (let i = 0;i < obj.length; ++i) {
          if (!isDeepEqual(obj[i], ref[i], options, seen)) {
            return false;
          }
        }
        return true;
      }
    } else if (instanceType === Types.set) {
      if (obj.size !== ref.size) {
        return false;
      }
      if (!internals.isSetSimpleEqual(obj, ref)) {
        const ref2 = new Set(Set.prototype.values.call(ref));
        for (const objEntry of Set.prototype.values.call(obj)) {
          if (ref2.delete(objEntry)) {
            continue;
          }
          let found = false;
          for (const refEntry of ref2) {
            if (isDeepEqual(objEntry, refEntry, options, seen)) {
              ref2.delete(refEntry);
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
      }
    } else if (instanceType === Types.map) {
      if (obj.size !== ref.size) {
        return false;
      }
      for (const [key, value] of Map.prototype.entries.call(obj)) {
        if (value === undefined && !Map.prototype.has.call(ref, key)) {
          return false;
        }
        if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
          return false;
        }
      }
    } else if (instanceType === Types.error) {
      if (obj.name !== ref.name || obj.message !== ref.message) {
        return false;
      }
    }
    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
      return false;
    }
    const objKeys = keys(obj);
    if (!options.part && objKeys.length !== keys(ref).length && !options.skip) {
      return false;
    }
    let skipped = 0;
    for (const key of objKeys) {
      if (options.skip && options.skip.includes(key)) {
        if (ref[key] === undefined) {
          ++skipped;
        }
        continue;
      }
      if (!hasOwnEnumerableProperty(ref, key)) {
        return false;
      }
      if (!isDeepEqual(obj[key], ref[key], options, seen)) {
        return false;
      }
    }
    if (!options.part && objKeys.length - skipped !== keys(ref).length) {
      return false;
    }
    if (options.symbols !== false) {
      const objSymbols = getOwnPropertySymbols(obj);
      const refSymbols = new Set(getOwnPropertySymbols(ref));
      for (const key of objSymbols) {
        if (!options.skip?.includes(key)) {
          if (hasOwnEnumerableProperty(obj, key)) {
            if (!hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
            if (!isDeepEqual(obj[key], ref[key], options, seen)) {
              return false;
            }
          } else if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
        refSymbols.delete(key);
      }
      for (const key of refSymbols) {
        if (hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
      }
    }
    return true;
  };
  internals.SeenEntry = class {
    constructor(obj, ref) {
      this.obj = obj;
      this.ref = ref;
    }
    isSame(obj, ref) {
      return this.obj === obj && this.ref === ref;
    }
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex4 = __commonJS((exports, module) => {
  module.exports = function(string) {
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/contain.js
var require_contain2 = __commonJS((exports, module) => {
  var Assert = require_assert4();
  var DeepEqual = require_deepEqual3();
  var EscapeRegex = require_escapeRegex4();
  var Utils = require_utils7();
  var internals = {};
  module.exports = function(ref, values, options = {}) {
    if (typeof values !== "object") {
      values = [values];
    }
    Assert(!Array.isArray(values) || values.length, "Values array cannot be empty");
    if (typeof ref === "string") {
      return internals.string(ref, values, options);
    }
    if (Array.isArray(ref)) {
      return internals.array(ref, values, options);
    }
    Assert(typeof ref === "object", "Reference must be string or an object");
    return internals.object(ref, values, options);
  };
  internals.array = function(ref, values, options) {
    if (!Array.isArray(values)) {
      values = [values];
    }
    if (!ref.length) {
      return false;
    }
    if (options.only && options.once && ref.length !== values.length) {
      return false;
    }
    let compare;
    const map = new Map;
    for (const value of values) {
      if (!options.deep || !value || typeof value !== "object") {
        const existing = map.get(value);
        if (existing) {
          ++existing.allowed;
        } else {
          map.set(value, { allowed: 1, hits: 0 });
        }
      } else {
        compare = compare ?? internals.compare(options);
        let found = false;
        for (const [key, existing] of map.entries()) {
          if (compare(key, value)) {
            ++existing.allowed;
            found = true;
            break;
          }
        }
        if (!found) {
          map.set(value, { allowed: 1, hits: 0 });
        }
      }
    }
    let hits = 0;
    for (const item of ref) {
      let match;
      if (!options.deep || !item || typeof item !== "object") {
        match = map.get(item);
      } else {
        compare = compare ?? internals.compare(options);
        for (const [key, existing] of map.entries()) {
          if (compare(key, item)) {
            match = existing;
            break;
          }
        }
      }
      if (match) {
        ++match.hits;
        ++hits;
        if (options.once && match.hits > match.allowed) {
          return false;
        }
      }
    }
    if (options.only && hits !== ref.length) {
      return false;
    }
    for (const match of map.values()) {
      if (match.hits === match.allowed) {
        continue;
      }
      if (match.hits < match.allowed && !options.part) {
        return false;
      }
    }
    return !!hits;
  };
  internals.object = function(ref, values, options) {
    Assert(options.once === undefined, "Cannot use option once with object");
    const keys = Utils.keys(ref, options);
    if (!keys.length) {
      return false;
    }
    if (Array.isArray(values)) {
      return internals.array(keys, values, options);
    }
    const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
    const targets = [...Object.keys(values), ...symbols];
    const compare = internals.compare(options);
    const set = new Set(targets);
    for (const key of keys) {
      if (!set.has(key)) {
        if (options.only) {
          return false;
        }
        continue;
      }
      if (!compare(values[key], ref[key])) {
        return false;
      }
      set.delete(key);
    }
    if (set.size) {
      return options.part ? set.size < targets.length : false;
    }
    return true;
  };
  internals.string = function(ref, values, options) {
    if (ref === "") {
      return values.length === 1 && values[0] === "" || !options.once && !values.some((v) => v !== "");
    }
    const map = new Map;
    const patterns = [];
    for (const value of values) {
      Assert(typeof value === "string", "Cannot compare string reference to non-string value");
      if (value) {
        const existing = map.get(value);
        if (existing) {
          ++existing.allowed;
        } else {
          map.set(value, { allowed: 1, hits: 0 });
          patterns.push(EscapeRegex(value));
        }
      } else if (options.once || options.only) {
        return false;
      }
    }
    if (!patterns.length) {
      return true;
    }
    const regex = new RegExp(`(${patterns.join("|")})`, "g");
    const leftovers = ref.replace(regex, ($0, $1) => {
      ++map.get($1).hits;
      return "";
    });
    if (options.only && leftovers) {
      return false;
    }
    let any = false;
    for (const match of map.values()) {
      if (match.hits) {
        any = true;
      }
      if (match.hits === match.allowed) {
        continue;
      }
      if (match.hits < match.allowed && !options.part) {
        return false;
      }
      if (options.once) {
        return false;
      }
    }
    return !!any;
  };
  internals.compare = function(options) {
    if (!options.deep) {
      return internals.shallow;
    }
    const hasOnly = options.only !== undefined;
    const hasPart = options.part !== undefined;
    const flags = {
      prototype: hasOnly ? options.only : hasPart ? !options.part : false,
      part: hasOnly ? !options.only : hasPart ? options.part : false
    };
    return (a, b) => DeepEqual(a, b, flags);
  };
  internals.shallow = function(a, b) {
    return a === b;
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js
var require_escapeHeaderAttribute2 = __commonJS((exports, module) => {
  var Assert = require_assert4();
  module.exports = function(attribute) {
    Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
    return attribute.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"");
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml3 = __commonJS((exports, module) => {
  var internals = {};
  module.exports = function(input) {
    if (!input) {
      return "";
    }
    let escaped = "";
    for (let i = 0;i < input.length; ++i) {
      const charCode = input.charCodeAt(i);
      if (internals.isSafe(charCode)) {
        escaped += input[i];
      } else {
        escaped += internals.escapeHtmlChar(charCode);
      }
    }
    return escaped;
  };
  internals.escapeHtmlChar = function(charCode) {
    const namedEscape = internals.namedHtml.get(charCode);
    if (namedEscape) {
      return namedEscape;
    }
    if (charCode >= 256) {
      return "&#" + charCode + ";";
    }
    const hexValue = charCode.toString(16).padStart(2, "0");
    return `&#x${hexValue};`;
  };
  internals.isSafe = function(charCode) {
    return internals.safeCharCodes.has(charCode);
  };
  internals.namedHtml = new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [34, "&quot;"],
    [160, "&nbsp;"],
    [162, "&cent;"],
    [163, "&pound;"],
    [164, "&curren;"],
    [169, "&copy;"],
    [174, "&reg;"]
  ]);
  internals.safeCharCodes = function() {
    const safe = new Set;
    for (let i = 32;i < 123; ++i) {
      if (i >= 97 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 32 || i === 46 || i === 44 || i === 45 || i === 58 || i === 95) {
        safe.add(i);
      }
    }
    return safe;
  }();
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/escapeJson.js
var require_escapeJson2 = __commonJS((exports, module) => {
  var internals = {};
  module.exports = function(input) {
    if (!input) {
      return "";
    }
    return input.replace(/[<>&\u2028\u2029]/g, internals.escape);
  };
  internals.escape = function(char) {
    return internals.replacements.get(char);
  };
  internals.replacements = new Map([
    ["<", "\\u003c"],
    [">", "\\u003e"],
    ["&", "\\u0026"],
    ["\u2028", "\\u2028"],
    ["\u2029", "\\u2029"]
  ]);
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/flatten.js
var require_flatten2 = __commonJS((exports, module) => {
  var internals = {};
  module.exports = internals.flatten = function(array, target) {
    const result = target || [];
    for (const entry of array) {
      if (Array.isArray(entry)) {
        internals.flatten(entry, result);
      } else {
        result.push(entry);
      }
    }
    return result;
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/intersect.js
var require_intersect2 = __commonJS((exports, module) => {
  var internals = {};
  module.exports = function(array1, array2, options = {}) {
    if (!array1 || !array2) {
      return options.first ? null : [];
    }
    const common = [];
    const hash = Array.isArray(array1) ? new Set(array1) : array1;
    const found = new Set;
    for (const value of array2) {
      if (internals.has(hash, value) && !found.has(value)) {
        if (options.first) {
          return value;
        }
        common.push(value);
        found.add(value);
      }
    }
    return options.first ? null : common;
  };
  internals.has = function(ref, key) {
    if (typeof ref.has === "function") {
      return ref.has(key);
    }
    return ref[key] !== undefined;
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/isPromise.js
var require_isPromise2 = __commonJS((exports, module) => {
  module.exports = function(promise) {
    return typeof promise?.then === "function";
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/once.js
var require_once2 = __commonJS((exports, module) => {
  var internals = {
    wrapped: Symbol("wrapped")
  };
  module.exports = function(method) {
    if (method[internals.wrapped]) {
      return method;
    }
    let once = false;
    const wrappedFn = function(...args) {
      if (!once) {
        once = true;
        method(...args);
      }
    };
    wrappedFn[internals.wrapped] = true;
    return wrappedFn;
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/reachTemplate.js
var require_reachTemplate2 = __commonJS((exports, module) => {
  var Reach = require_reach3();
  module.exports = function(obj, template, options) {
    return template.replace(/{([^{}]+)}/g, ($0, chain) => {
      const value = Reach(obj, chain, options);
      return value ?? "";
    });
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/wait.js
var require_wait2 = __commonJS((exports, module) => {
  var internals = {
    maxTimer: 2 ** 31 - 1
  };
  module.exports = function(timeout, returnValue, options) {
    if (typeof timeout === "bigint") {
      timeout = Number(timeout);
    }
    if (timeout >= Number.MAX_SAFE_INTEGER) {
      timeout = Infinity;
    }
    if (typeof timeout !== "number" && timeout !== undefined) {
      throw new TypeError("Timeout must be a number or bigint");
    }
    return new Promise((resolve) => {
      const _setTimeout = options ? options.setTimeout : setTimeout;
      const activate = () => {
        const time = Math.min(timeout, internals.maxTimer);
        timeout -= time;
        _setTimeout(() => timeout > 0 ? activate() : resolve(returnValue), time);
      };
      if (timeout !== Infinity) {
        activate();
      }
    });
  };
});

// node_modules/@hapi/jwt/node_modules/@hapi/hoek/lib/index.js
var require_lib41 = __commonJS((exports) => {
  exports.applyToDefaults = require_applyToDefaults3();
  exports.assert = require_assert4();
  exports.Bench = require_bench2();
  exports.block = require_block2();
  exports.clone = require_clone3();
  exports.contain = require_contain2();
  exports.deepEqual = require_deepEqual3();
  exports.Error = require_error3();
  exports.escapeHeaderAttribute = require_escapeHeaderAttribute2();
  exports.escapeHtml = require_escapeHtml3();
  exports.escapeJson = require_escapeJson2();
  exports.escapeRegex = require_escapeRegex4();
  exports.flatten = require_flatten2();
  exports.ignore = require_ignore3();
  exports.intersect = require_intersect2();
  exports.isPromise = require_isPromise2();
  exports.merge = require_merge3();
  exports.once = require_once2();
  exports.reach = require_reach3();
  exports.reachTemplate = require_reachTemplate2();
  exports.stringify = require_stringify4();
  exports.wait = require_wait2();
});

// node_modules/@hapi/jwt/lib/keys.js
var require_keys3 = __commonJS((exports, module) => {
  var Boom = require_lib13();
  var Wreck = require_lib32();
  var Crypto = require_crypto();
  var internals = {
    keyAlgo: {
      none: ["none"],
      public: ["RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512", "EdDSA"],
      rsa: ["RS256", "RS384", "RS512", "PS256", "PS384", "PS512"],
      hmac: ["HS256", "HS384", "HS512"]
    },
    certRx: {
      public: /^[\s\-]*BEGIN (?:CERTIFICATE)|(?:PUBLIC KEY)/,
      rsa: /^[\s\-]*BEGIN RSA (?:PRIVATE)|(?:PUBLIC)/
    }
  };
  internals.supportedAlgorithms = internals.keyAlgo.public.concat(internals.keyAlgo.hmac);
  module.exports = internals.Provider = class {
    constructor(server, options) {
      this._server = server;
      this._settings = options;
      this._cache = null;
      this._statics = [];
      this._dynamics = [];
      this._remotes = new Map;
      for (const key of options.keys) {
        if (Buffer.isBuffer(key) || typeof key === "string") {
          this._statics.push({ key, algorithms: internals.Provider.keyAlgorithms(key) });
        } else if (typeof key === "function") {
          this._dynamics.push(key);
        } else if (key.key !== undefined) {
          this._statics.push({ key: key.key, algorithms: key.algorithms ?? internals.Provider.keyAlgorithms(key.key), kid: key.kid });
        } else {
          this._remotes.set(key.uri, { algorithms: key.algorithms, wreck: { json: "force", headers: key.headers, rejectUnauthorized: key.rejectUnauthorized } });
        }
      }
      this.hasJwks = !!this._remotes.size;
      this._server.plugins.jwt._providers.push(this);
    }
    initialize(segment) {
      if (!this.hasJwks) {
        return;
      }
      const cache = Object.assign({}, this._settings.cache);
      cache.segment = segment;
      cache.cache = this._server.plugins.jwt._cacheName;
      cache.generateFunc = internals.jwks(this);
      this._cache = this._server.cache(cache);
      const pending = [];
      for (const uri of this._remotes.keys()) {
        pending.push(this._cache.get(uri));
      }
      return Promise.all(pending);
    }
    async assign(artifacts, request) {
      const errors = [];
      const keys = [];
      internals.append(keys, this._statics, artifacts.decoded.header);
      const kid = artifacts.decoded.header.kid;
      if (kid && this._remotes.size) {
        if (!this._cache) {
          throw Boom.internal("Server is not initialized");
        }
        for (const uri of this._remotes.keys()) {
          try {
            const map = await this._cache.get(uri);
            internals.append(keys, map.get(kid), artifacts.decoded.header);
          } catch (err) {
            errors.push(err);
          }
        }
      }
      for (const method of this._dynamics) {
        try {
          internals.append(keys, await method(artifacts, request), artifacts.decoded.header);
        } catch (err) {
          errors.push(err);
        }
      }
      if (!keys.length) {
        if (errors.length) {
          throw Boom.internal("Failed to obtain keys", errors);
        }
        return;
      }
      if (errors.length) {
        artifacts.errors = errors;
      }
      artifacts.keys = keys;
    }
    static get supportedAlgorithms() {
      return internals.supportedAlgorithms;
    }
    static keyAlgorithms(key) {
      if (!key) {
        return internals.keyAlgo.none;
      }
      const keyString = key.toString();
      if (typeof key === "object" && key.asymmetricKeyType || internals.certRx.public.test(keyString)) {
        return internals.keyAlgo.public;
      }
      if (internals.certRx.rsa.test(keyString)) {
        return internals.keyAlgo.rsa;
      }
      return internals.keyAlgo.hmac;
    }
  };
  internals.append = function(to, from, { alg, kid }) {
    if (!from) {
      return;
    }
    const values = Array.isArray(from) ? from : [from];
    for (const value of values) {
      const key = internals.normalize(value);
      if (key.algorithms.includes(alg) && (!kid || !key.kid || kid === key.kid)) {
        to.push({ key: key.key, algorithm: alg, kid: key.kid });
      }
    }
  };
  internals.normalize = function(key) {
    if (typeof key === "string" || Buffer.isBuffer(key)) {
      return { key, algorithms: internals.Provider.keyAlgorithms(key) };
    }
    return key;
  };
  internals.jwks = function(provider) {
    return async function(uri) {
      const remote = provider._remotes.get(uri);
      try {
        var { payload } = await Wreck.get(uri, remote.wreck);
      } catch (err) {
        throw Boom.internal("JWKS endpoint error", err);
      }
      if (!payload) {
        throw Boom.internal("JWKS endpoint returned empty payload", { uri });
      }
      const source = payload.keys;
      if (!source || !Array.isArray(source) || !source.length) {
        throw Boom.internal("JWKS endpoint returned invalid payload", { uri, payload });
      }
      const keys = new Map;
      for (const key of source) {
        if (key.use !== "sig" || key.kty !== "RSA" || !key.kid) {
          continue;
        }
        if (key.x5c?.length) {
          const algorithms = internals.algorithms(key, remote, "public");
          if (algorithms) {
            keys.set(key.kid, { key: Crypto.certToPEM(key.x5c[0]), algorithms });
          }
        } else if (key.n && key.e) {
          const algorithms = internals.algorithms(key, remote, "rsa");
          if (algorithms) {
            keys.set(key.kid, { key: Crypto.rsaPublicKeyToPEM(key.n, key.e), algorithms });
          }
        }
      }
      if (!keys.size) {
        throw Boom.internal("JWKS endpoint response contained no valid keys", { uri, payload });
      }
      return keys;
    };
  };
  internals.algorithms = function(key, remote, type) {
    if (key.alg) {
      if (!remote.algorithms || remote.algorithms.includes(key.alg)) {
        return [key.alg];
      }
      return null;
    }
    if (remote.algorithms) {
      return remote.algorithms;
    }
    return internals.keyAlgo[type];
  };
});

// node_modules/@hapi/jwt/lib/token.js
var require_token2 = __commonJS((exports) => {
  var Bourne = require_lib22();
  var Crypto = require_crypto();
  var Keys = require_keys3();
  var Utils = require_utils6();
  var internals = {
    partRx: /^[\w\-]*$/,
    parts: ["header", "payload", "signature"],
    headless: Symbol("headless")
  };
  exports.generate = function(payload, secret, options = {}) {
    const { key, algorithms } = internals.secret(secret);
    let content = payload;
    const baseHeader = { alg: algorithms[0] };
    const clone = () => {
      if (content === payload) {
        content = Object.assign({}, content);
      }
    };
    if (content.iat === undefined && options.iat !== false) {
      clone();
      content.iat = internals.tsSecs(options.now);
    }
    if (content.exp === undefined && options.ttlSec) {
      clone();
      content.exp = options.ttlSec + internals.tsSecs(options.now);
    }
    if (options.typ !== false) {
      baseHeader.typ = "JWT";
    }
    const header = Object.assign(baseHeader, options.header);
    const value = `${Utils.b64stringify(header)}.${Utils.b64stringify(content)}`;
    const signature = Crypto.generate(value, header.alg, key);
    if (options.headless === true) {
      const parts = value.split(".");
      return `${parts[1]}.${signature}`;
    }
    return `${value}.${signature}`;
  };
  exports.decode = function(token, options = {}) {
    const artifacts = {
      token,
      decoded: {},
      raw: {}
    };
    const parts = token.split(".");
    if (parts.length === 3) {
      if (options.headless) {
        throw internals.error("Token contains header", artifacts);
      }
      artifacts.raw = { header: parts[0], payload: parts[1], signature: parts[2] };
      artifacts.decoded.header = internals.b64parse(artifacts.raw.header);
    } else if (parts.length === 2 && options.headless) {
      const headless = exports.headless(options);
      artifacts.token = `${headless.raw}.${token}`;
      artifacts.raw = { header: headless.raw, payload: parts[0], signature: parts[1] };
      artifacts.decoded.header = headless.decoded;
    } else {
      throw internals.error("Invalid token structure", artifacts);
    }
    for (const part of internals.parts) {
      if (!internals.partRx.test(artifacts.raw[part])) {
        throw internals.error(`Invalid token ${part} part`, artifacts);
      }
    }
    artifacts.decoded.payload = internals.b64decode(artifacts.raw.payload);
    artifacts.decoded.signature = artifacts.raw.signature;
    const header = artifacts.decoded.header;
    if (!header) {
      throw internals.error("Invalid token missing header", artifacts);
    }
    const parsed = Bourne.safeParse(artifacts.decoded.payload);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      throw internals.error("Invalid token payload", artifacts);
    }
    artifacts.decoded.payload = parsed;
    if (!artifacts.decoded.header.alg) {
      throw internals.error("Token header missing alg attribute", artifacts);
    }
    return artifacts;
  };
  exports.verify = function(artifacts, secret, options = {}) {
    exports.verifySignature(artifacts, secret);
    exports.verifyPayload(artifacts, options);
  };
  exports.verifySignature = function({ decoded, raw }, secret) {
    const { key, algorithm } = internals.key(decoded, secret);
    if (!Crypto.verify(raw, algorithm, key)) {
      throw new Error("Invalid token signature");
    }
  };
  exports.verifyPayload = function({ decoded }, options = {}) {
    const nowSec = internals.tsSecs(options.now);
    const skewSec = options.timeSkewSec ?? 0;
    const payload = decoded.payload;
    exports.verifyTime({ decoded }, options, nowSec);
    internals.audiance(payload.aud, options.aud);
    internals.match("iss", payload, options);
    internals.match("sub", payload, options);
    internals.match("jti", payload, options);
    internals.match("nonce", payload, options);
    if (options.nbf !== false && payload.nbf !== undefined) {
      if (typeof payload.nbf !== "number") {
        throw new Error("Invalid payload nbf value");
      }
      if (payload.nbf > nowSec + skewSec) {
        throw new Error("Token not yet active");
      }
    }
  };
  exports.verifyTime = function({ decoded }, options = {}, _nowSec = null) {
    const nowSec = _nowSec ?? internals.tsSecs(options.now);
    const skewSec = options.timeSkewSec ?? 0;
    const payload = decoded.payload;
    if (options.exp !== false && payload.exp !== undefined) {
      if (typeof payload.exp !== "number") {
        throw new Error("Invalid payload exp value");
      }
      if (payload.exp <= nowSec - skewSec) {
        throw new Error("Token expired");
      }
    }
    if (options.maxAgeSec) {
      if (!payload.iat || typeof payload.iat !== "number") {
        throw new Error("Missing or invalid payload iat value");
      }
      if (nowSec - payload.iat - skewSec > options.maxAgeSec) {
        throw new Error("Token maximum age exceeded");
      }
    }
  };
  exports.headless = function(options) {
    const headless = options.headless;
    if (!headless) {
      return null;
    }
    if (typeof headless === "object") {
      if (headless[internals.headless]) {
        return headless;
      }
      return {
        [internals.headless]: true,
        raw: Buffer.from(JSON.stringify(headless)).toString("base64"),
        decoded: headless
      };
    }
    return {
      [internals.headless]: true,
      raw: headless,
      decoded: internals.b64parse(headless)
    };
  };
  internals.error = function(message, artifacts) {
    const error = new Error(message);
    error.artifacts = artifacts;
    return error;
  };
  internals.b64decode = function(string) {
    return Buffer.from(string, "base64").toString();
  };
  internals.b64parse = function(string) {
    return Bourne.safeParse(internals.b64decode(string));
  };
  internals.key = function(decoded, secret) {
    const { key, algorithms } = internals.secret(secret);
    if (!algorithms.includes(decoded.header.alg)) {
      throw new Error("Unsupported algorithm");
    }
    return { key, algorithm: decoded.header.alg };
  };
  internals.secret = function(secret) {
    const set = typeof secret === "object" && secret.asymmetricKeyType || typeof secret === "string" || Buffer.isBuffer(secret) ? { key: secret } : secret;
    return {
      key: set.key,
      algorithms: set.algorithm ? [set.algorithm] : set.algorithms || Keys.keyAlgorithms(set.key)
    };
  };
  internals.audiance = function(aud, audiences) {
    if (!audiences) {
      return;
    }
    if (aud === undefined) {
      throw new Error("Token missing payload aud value");
    }
    const auds = Array.isArray(aud) ? aud : [aud];
    audiences = Array.isArray(audiences) ? audiences : [audiences];
    for (const compare of auds) {
      for (const match of audiences) {
        if (typeof match === "string") {
          if (compare === match) {
            return;
          }
        } else {
          if (match.test(compare)) {
            return;
          }
        }
      }
    }
    throw new Error("Token audience is not allowed");
  };
  internals.match = function(type, payload, options) {
    const matchTo = options[type];
    if (!matchTo) {
      return;
    }
    const value = payload[type];
    if (value === undefined) {
      throw new Error(`Token missing payload ${type} value`);
    }
    if (Array.isArray(matchTo) && matchTo.includes(value) || matchTo === value) {
      return;
    }
    throw new Error(`Token payload ${type} value not allowed`);
  };
  internals.tsSecs = function(ts) {
    return Math.floor((ts ?? Date.now()) / 1000);
  };
});

// node_modules/@hapi/jwt/package.json
var require_package5 = __commonJS((exports, module) => {
  module.exports = {
    name: "@hapi/jwt",
    description: "JWT (JSON Web Token) Authentication",
    version: "3.2.0",
    repository: "git://github.com/hapijs/jwt",
    main: "lib/index.js",
    types: "lib/index.d.ts",
    files: [
      "lib"
    ],
    keywords: [
      "jwt",
      "authentication",
      "plugin",
      "hapi"
    ],
    eslintConfig: {
      extends: [
        "plugin:@hapi/module"
      ]
    },
    dependencies: {
      "@hapi/b64": "^6.0.0",
      "@hapi/boom": "^10.0.0",
      "@hapi/bounce": "^3.0.0",
      "@hapi/bourne": "^3.0.0",
      "@hapi/catbox-object": "^3.0.0",
      "@hapi/cryptiles": "^6.0.0",
      "@hapi/hoek": "^10.0.0",
      "@hapi/wreck": "^18.0.0",
      "ecdsa-sig-formatter": "^1.0.0",
      joi: "^17.2.1"
    },
    devDependencies: {
      "@hapi/code": "^9.0.0",
      "@hapi/eslint-plugin": "^6.0.0",
      "@hapi/hapi": "^21.0.0",
      "@hapi/lab": "^25.0.1",
      "node-forge": "^1.0.0",
      "node-rsa": "^1.0.0"
    },
    scripts: {
      test: "lab -a @hapi/code -t 100 -L -m 10000",
      "test-cov-html": "lab -a @hapi/code -r html -o coverage.html"
    },
    license: "BSD-3-Clause"
  };
});

// node_modules/@hapi/jwt/lib/plugin.js
var require_plugin = __commonJS((exports) => {
  var Boom = require_lib13();
  var CatboxObject = require_lib40();
  var Hoek = require_lib41();
  var Joi3 = require_lib39();
  var Crypto = require_crypto();
  var Keys = require_keys3();
  var Token = require_token2();
  var Utils = require_utils6();
  var internals = {};
  exports.plugin = {
    pkg: require_package5(),
    requirements: {
      hapi: ">=20.0.0"
    },
    register: function(server) {
      server.expose("_providers", []);
      server.expose("_caching", false);
      server.expose("_cacheName", "@hapi/jwt");
      server.ext("onPreStart", internals.onPreStart);
      server.auth.scheme("jwt", internals.implementation);
    }
  };
  internals.onPreStart = function(server) {
    const providers = server.plugins.jwt._providers;
    const pendings = [];
    for (let i = 0;i < providers.length; ++i) {
      const provider = providers[i];
      pendings.push(provider.initialize(`s${i}`));
    }
    return Promise.all(pendings);
  };
  internals.schema = {
    algorithms: Joi3.array().items(Joi3.string().valid(...Keys.supportedAlgorithms)).min(1).single()
  };
  internals.schema.strategy = Joi3.object({
    cache: Joi3.object({
      segment: Joi3.forbidden(),
      generateFunc: Joi3.forbidden(),
      cache: Joi3.forbidden(),
      shared: Joi3.forbidden()
    }).unknown().default({
      expiresIn: 7 * 24 * 60 * 60 * 1000,
      staleIn: 60 * 60 * 1000,
      staleTimeout: 500,
      generateTimeout: 2 * 60 * 1000
    }),
    cookieName: Utils.validHttpTokenSchema.optional().messages({
      "string.pattern.base": "Cookie name cannot start or end with special characters. Valid characters in cookie name are _, -, numbers and alphabets"
    }),
    headerName: Joi3.any().when("cookieName", {
      is: Joi3.exist(),
      then: Joi3.string().forbidden().messages({ "any.unknown": "headerName not allowed when cookieName is specified" }),
      otherwise: Utils.validHttpTokenSchema.optional().default("authorization").messages({
        "string.pattern.base": "Header name must be a valid header name following https://tools.ietf.org/html/rfc7230#section-3.2.6"
      })
    }),
    headless: [Joi3.string(), Joi3.object({ alg: Joi3.string().valid(...Keys.supportedAlgorithms).required(), typ: Joi3.valid("JWT") }).unknown()],
    httpAuthScheme: Joi3.string().default("Bearer"),
    keys: Joi3.array().items(Joi3.string(), Joi3.binary(), Joi3.func(), {
      key: Joi3.valid("").default(""),
      algorithms: Joi3.array().items(Joi3.valid("none")).length(1).single().required(),
      kid: Joi3.string()
    }, {
      key: Joi3.alternatives([Joi3.string(), Joi3.binary()]).required(),
      algorithms: internals.schema.algorithms,
      kid: Joi3.string()
    }, {
      uri: Joi3.string().uri().required(),
      rejectUnauthorized: Joi3.boolean().default(true),
      headers: Joi3.object().pattern(/.+/, Joi3.string()),
      algorithms: internals.schema.algorithms
    }).min(1).single().when("verify", { is: false, otherwise: Joi3.required() }),
    unauthorizedAttributes: Joi3.object().pattern(/.+/, Joi3.string().allow(null, "")),
    validate: Joi3.func().allow(false).required(),
    verify: Joi3.object({
      aud: Joi3.array().items(Joi3.string(), Joi3.object().instance(RegExp)).min(1).single().allow(false).required(),
      exp: Joi3.boolean().default(true),
      iss: Joi3.array().items(Joi3.string()).min(1).single().allow(false).required(),
      nbf: Joi3.boolean().default(true),
      sub: Joi3.array().items(Joi3.string()).min(1).single().allow(false).required(),
      maxAgeSec: Joi3.number().integer().min(0).default(0),
      timeSkewSec: Joi3.number().integer().min(0).default(0)
    }).when(".validate", { is: Joi3.not(false), then: Joi3.allow(false) }).required()
  });
  internals.implementation = function(server, options) {
    Hoek.assert(options, "JWT authentication options missing");
    const settings = Joi3.attempt(Hoek.clone(options), internals.schema.strategy);
    settings.headless = Token.headless(settings);
    const unauthorized = (message = null) => Boom.unauthorized(message, settings.httpAuthScheme, settings.unauthorizedAttributes);
    const missing = unauthorized();
    const provider = new Keys(server, settings);
    if (provider.hasJwks && !server.plugins.jwt._caching) {
      server.plugins.jwt._caching = true;
      server.cache.provision({ provider: CatboxObject.Engine, name: server.plugins.jwt._cacheName });
    }
    return {
      authenticate: async function(request, h) {
        const result = { credentials: {} };
        const token = internals.token(request, settings, missing, unauthorized);
        try {
          result.artifacts = Token.decode(token, settings);
        } catch (err) {
          result.artifacts = err.artifacts;
          return h.unauthenticated(unauthorized(err.message), result);
        }
        await provider.assign(result.artifacts, request);
        if (!result.artifacts.keys) {
          return h.unauthenticated(unauthorized(""), result);
        }
        if (settings.verify) {
          try {
            Token.verifyPayload(result.artifacts, settings.verify);
          } catch (err) {
            return h.unauthenticated(unauthorized(err.message), result);
          }
          let valid = false;
          for (const key of result.artifacts.keys) {
            if (Crypto.verify(result.artifacts.raw, key.algorithm, key.key)) {
              valid = true;
              break;
            }
          }
          if (!valid) {
            return h.unauthenticated(unauthorized("Invalid token signature"), result);
          }
        }
        result.credentials = result.artifacts.decoded.payload;
        if (settings.validate) {
          try {
            var { isValid, credentials, response } = await settings.validate(result.artifacts, request, h);
          } catch (err) {
            result.error = err;
            return h.unauthenticated(unauthorized(err.message), result);
          }
          if (response !== undefined) {
            return h.response(response).takeover();
          }
          if (credentials) {
            result.credentials = credentials;
          }
          if (!isValid) {
            return h.unauthenticated(unauthorized("Invalid credentials"), result);
          }
        }
        return h.authenticated(result);
      },
      verify: function(auth) {
        if (settings.verify) {
          Token.verifyTime(auth.artifacts, settings.verify);
        }
      }
    };
  };
  internals.token = function(request, settings, missing, unauthorized) {
    let authorization = null;
    if (settings.headerName) {
      authorization = request.headers[settings.headerName];
    } else {
      authorization = request.state[settings.cookieName];
    }
    if (!authorization) {
      throw missing;
    }
    if (settings.headerName) {
      const parts = authorization.split(/\s+/);
      if (parts[0].toLowerCase() !== settings.httpAuthScheme.toLowerCase()) {
        throw missing;
      }
      if (parts.length !== 2) {
        throw unauthorized("Bad HTTP authentication header format");
      }
      const token = parts[1];
      if (!token) {
        throw missing;
      }
      return token;
    }
    return authorization;
  };
});

// node_modules/@hapi/jwt/lib/index.js
var require_lib42 = __commonJS((exports) => {
  var Crypto = require_crypto();
  var Plugin = require_plugin();
  var Token = require_token2();
  var Utils = require_utils6();
  exports.plugin = Plugin.plugin;
  exports.token = {
    generate: Token.generate,
    decode: Token.decode,
    verify: Token.verify,
    verifySignature: Token.verifySignature,
    verifyPayload: Token.verifyPayload,
    verifyTime: Token.verifyTime,
    signature: {
      generate: Crypto.generate,
      verify: Crypto.verify
    }
  };
  exports.crypto = {
    rsaPublicKeyToPEM: Crypto.rsaPublicKeyToPEM
  };
  exports.utils = Utils;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// node_modules/uuid/dist/regex.js
var require_regex2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex2());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = validate;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.default)(b);
  }
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parse(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = parse;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  exports.URL = exports.DNS = undefined;
  var _stringify = _interopRequireDefault(require_stringify5());
  var _parse = _interopRequireDefault(require_parse());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
  function _default(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.default)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v4(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.default)(rnds);
  }
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  }
  var _default = version;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify5());
  var _parse = _interopRequireDefault(require_parse());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
});

// src/server.ts
var import_reflect_metadata = __toESM(require_Reflect(), 1);

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => (key in env))) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix;
    endIndex = index + 1;
    index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf(`
`);
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/utils/logger.manager.ts
import path from "path";

// src/config/index.ts
var isProd = false;
var GetEnvValue = (prodValue, devValue) => {
  return isProd ? prodValue : devValue;
};
var Config = {
  environment: "development",
  server: {
    port: process.env.PORT_BACKEND || 3000,
    host: process.env.HOST_BACKEND || "localhost"
  },
  cookie: {
    isSecure: GetEnvValue(true, false),
    isHttpOnly: GetEnvValue(true, false),
    domain: GetEnvValue(process.env.COOKIE_DOMAIN, "localhost"),
    isSameSite: GetEnvValue(process.env.COOKIE_SAMESITE, "None")
  },
  cors: {
    origin: GetEnvValue([`https://*.${process.env.COOKIE_DOMAIN || "localhost"}`], ["*"])
  },
  key: {
    apiKey: process.env.API_KEY || "apikey",
    accessJwtKey: process.env.ACCESS_JWT_KEY || "jwtkey",
    refreshJwtKey: process.env.REFRESH_JWT_KEY || "jwtkey2",
    cookieKey: process.env.COOKIE_KEY || "12345678901234567890123456789012"
  },
  database: {
    user: GetEnvValue(process.env.POSTGRES_USER_PROD, process.env.POSTGRES_USER_DEV),
    host: GetEnvValue(process.env.POSTGRES_HOST_PROD, process.env.POSTGRES_HOST_DEV),
    database: GetEnvValue(process.env.POSTGRES_DB_PROD, process.env.POSTGRES_DB_DEV),
    password: GetEnvValue(process.env.POSTGRES_PASSWORD_PROD, process.env.POSTGRES_PASSWORD_DEV),
    port: GetEnvValue(parseInt(process.env.POSTGRES_PORT_PROD, 10), parseInt(process.env.POSTGRES_PORT_DEV, 10))
  },
  redis: {
    host: GetEnvValue(process.env.REDIS_HOST_PROD, process.env.REDIS_HOST_DEV),
    port: GetEnvValue(parseInt(process.env.REDIS_PORT_PROD, 10), parseInt(process.env.REDIS_PORT_DEV, 10)),
    password: GetEnvValue(process.env.REDIS_PASSWORD_PROD, process.env.REDIS_PASSWORD_DEV)
  },
  ttl: {
    session: 30 * 24 * 60 * 60,
    jwt: 1 * 24 * 60 * 60,
    otp: 5 * 60,
    cache: 1 * 60 * 60
  },
  logging: {
    level: process.env.LOG_LEVEL || "INFO"
  },
  storage: {
    defaultPhoto: process.env.STORAGE_DEFAULT_PHOTO
  }
};

// src/utils/logger.manager.ts
var isProduction = false;
var currentLogLevel = () => {
  const configLevel = Config.logging.level.toUpperCase();
  switch (configLevel) {
    case "DEBUG":
      return 0 /* DEBUG */;
    case "INFO":
      return 1 /* INFO */;
    case "WARN":
      return 2 /* WARN */;
    case "ERROR":
      return 3 /* ERROR */;
    case "FATAL":
      return 4 /* FATAL */;
    default:
      return isProduction ? 1 /* INFO */ : 0 /* DEBUG */;
  }
};
function shouldLog(level) {
  return level >= currentLogLevel();
}
function formatFileName(fileName) {
  const nameWithoutExtension = fileName.replace(/\.[^/.]+$/, "");
  const parts = nameWithoutExtension.split(/[.-]/);
  const reversedParts = parts.reverse().map((part) => part.charAt(0).toUpperCase() + part.slice(1));
  return reversedParts.join("-");
}
function getCallerFileName() {
  if (isProduction)
    return "";
  const error = new Error;
  const stack = error.stack?.split(`
`) || [];
  const callerLine = stack.find((line) => line.includes(".ts:") && !line.includes("logging.ts:") && !line.includes("node_modules/"));
  if (!callerLine)
    return "";
  const match = callerLine.match(/\(([^:]+):/);
  if (!match)
    return "";
  const filePath = match[1];
  return path.basename(filePath);
}
function extractErrorMessage(err) {
  if (!err)
    return "";
  if (err instanceof Error) {
    return err.message;
  } else if (typeof err === "string") {
    return err;
  } else if (typeof err === "object" && err !== null && "message" in err) {
    return String(err.message);
  }
  return "";
}
function LogInfo(message, ...args) {
  if (!shouldLog(1 /* INFO */))
    return;
  const timestamp = new Date().toISOString();
  if (isProduction) {
    console.log(`[${timestamp}] [INFO]  ${message}`, ...args);
    return;
  }
  const fileName = getCallerFileName();
  const formattedFileName = fileName ? formatFileName(fileName) : "";
  console.log(source_default.gray(`[${timestamp}]`) + source_default.blue(" [INFO] ") + (formattedFileName ? source_default.cyan(` [${formattedFileName}]`) : "") + source_default.white(` ${message}`), ...args);
}
function LogError(message, err, ...args) {
  if (!shouldLog(3 /* ERROR */))
    return;
  const timestamp = new Date().toISOString();
  const errorMessage = err ? extractErrorMessage(err) : "";
  if (isProduction) {
    console.error(`[${timestamp}] [ERROR] ${message}`, errorMessage, ...args);
    return;
  }
  const fileName = getCallerFileName();
  const formattedFileName = fileName ? formatFileName(fileName) : "";
  console.error(source_default.gray(`[${timestamp}]`) + source_default.red(" [ERROR]") + (formattedFileName ? source_default.cyan(` [${formattedFileName}]`) : "") + source_default.white(` ${message}`), errorMessage ? source_default.red(`(${errorMessage})`) : "", ...args);
}
function LogFatal(message, err, ...args) {
  if (!shouldLog(4 /* FATAL */))
    return;
  const timestamp = new Date().toISOString();
  const errorMessage = err ? extractErrorMessage(err) : "";
  if (isProduction) {
    console.error(`[${timestamp}] [FATAL] ${message}`, errorMessage, ...args);
    return;
  }
  const fileName = getCallerFileName();
  const formattedFileName = fileName ? formatFileName(fileName) : "";
  console.error(source_default.gray(`[${timestamp}]`) + source_default.hex("#8B0000")(" [FATAL]") + (formattedFileName ? source_default.cyan(` [${formattedFileName}]`) : "") + source_default.white(` ${message}`), errorMessage ? source_default.hex("#8B0000")(`(${errorMessage})`) : "", ...args);
}

// node_modules/pg/esm/index.mjs
var exports_esm = {};
__export(exports_esm, {
  types: () => types,
  escapeLiteral: () => escapeLiteral,
  escapeIdentifier: () => escapeIdentifier,
  defaults: () => defaults,
  default: () => esm_default,
  TypeOverrides: () => TypeOverrides,
  Result: () => Result,
  Query: () => Query,
  Pool: () => Pool2,
  DatabaseError: () => DatabaseError,
  Connection: () => Connection,
  Client: () => Client
});
var import_lib = __toESM(require_lib2(), 1);
var Client = import_lib.default.Client;
var Pool2 = import_lib.default.Pool;
var Connection = import_lib.default.Connection;
var types = import_lib.default.types;
var Query = import_lib.default.Query;
var DatabaseError = import_lib.default.DatabaseError;
var escapeIdentifier = import_lib.default.escapeIdentifier;
var escapeLiteral = import_lib.default.escapeLiteral;
var Result = import_lib.default.Result;
var TypeOverrides = import_lib.default.TypeOverrides;
var defaults = import_lib.default.defaults;
var esm_default = import_lib.default;

// src/connections/postgres.connection.ts
var { Pool: Pool3 } = exports_esm;
var createPostgresConnection = async () => {
  const pool = new Pool3({
    user: Config.database.user,
    host: Config.database.host,
    database: Config.database.database,
    password: Config.database.password,
    port: Config.database.port
  });
  try {
    const client = pool.connect();
    (await client).release();
    LogInfo("PostgreSQL connected successfully");
    return pool;
  } catch (error) {
    LogFatal("Failed to connect to PostgreSQL", error);
    process.exit(1);
  }
};
var shutdownPostgresConnection = async (pool) => {
  await pool.end();
};

// src/connections/redis.connection.ts
var import_redis = __toESM(require_dist4(), 1);
var createRedisConnection = async () => {
  const client = import_redis.default.createClient({
    socket: {
      host: Config.redis.host,
      port: Number(Config.redis.port)
    },
    password: Config.redis.password
  });
  try {
    await client.connect();
    LogInfo("Redis Client connected successfully");
    return client;
  } catch (error) {
    LogFatal("Failed to connect to Redis:", error);
    process.exit(1);
  }
};
var shutdownRedisConnection = async (client) => {
  await client.quit();
};

// node_modules/@hapi/hapi/lib/index.js
var Server = require_server();
var $server = Server;

// src/api/user/user.handler.ts
var import_tsyringe = __toESM(require_cjs(), 1);

// src/useCases/errors/application.error.ts
class ApplicationError extends Error {
  message;
  code;
  details;
  status;
  constructor(message, code, details, status = "fail") {
    super(message);
    this.message = message;
    this.code = code;
    this.details = details;
    this.status = status;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
  toResponse() {
    return {
      status: this.status,
      message: this.message
    };
  }
}

// src/useCases/errors/invariant.error.ts
class InvariantError extends ApplicationError {
  constructor(details) {
    super("Invalid Validation", 422, details);
    this.name = "InvariantError";
  }
  toResponse() {
    return {
      status: "fail",
      message: this.message,
      details: this.details
    };
  }
}

// src/validators/user/user.schema.ts
var import_joi = __toESM(require_lib39(), 1);
var UserRegistrationSchema = import_joi.default.object({
  first_name: import_joi.default.string().min(1).max(50).required().pattern(/^[a-zA-Z\s\-']+$/).messages({
    "string.base": `"first_name" should be a type of 'text'`,
    "string.empty": `"first_name" cannot be an empty field`,
    "string.min": `"first_name" should have a minimum length of {#limit}`,
    "string.max": `"first_name" should have a maximum length of {#limit}`,
    "any.required": `"first_name" is a required field`,
    "string.pattern.base": `"first_name" must contain only letters, spaces, hyphens, and apostrophes`
  }),
  last_name: import_joi.default.string().allow("", null).max(50).pattern(/^[a-zA-Z\s\-']*$/).messages({
    "string.base": `"last_name" should be a type of 'text'`,
    "string.max": `"last_name" should have a maximum length of {#limit}`,
    "string.pattern.base": `"last_name" must contain only letters, spaces, hyphens, and apostrophes`
  }),
  password: import_joi.default.string().min(8).max(128).required().pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/).messages({
    "string.base": `"password" should be a type of 'text'`,
    "string.empty": `"password" cannot be an empty field`,
    "string.min": `"password" should have a minimum length of {#limit}`,
    "string.max": `"password" should have a maximum length of {#limit}`,
    "any.required": `"password" is a required field`,
    "string.pattern.base": `"password" must contain at least one lowercase letter, one uppercase letter, one number, and one special character`
  }),
  confirm_password: import_joi.default.string().required().valid(import_joi.default.ref("password")).messages({
    "any.only": "Passwords do not match",
    "any.required": `"confirm_password" is a required field`
  }),
  email: import_joi.default.string().email().max(100).required().messages({
    "string.base": `"email" should be a type of 'text'`,
    "string.empty": `"email" cannot be an empty field`,
    "string.email": `"email" must be a valid email`,
    "string.max": `"email" should have a maximum length of {#limit}`,
    "any.required": `"email" is a required field`
  }),
  photo: import_joi.default.string().allow("", null).messages({
    "string.base": `"photo" should be a type of 'text'`
  }),
  otp_code: import_joi.default.number().required().min(1e5).max(999999).messages({
    "number.base": `"otp_code" should be a type of 'number'`,
    "number.empty": `"otp_code" cannot be an empty field`,
    "number.min": `"otp_code" must be exactly 6 digits`,
    "number.max": `"otp_code" must be exactly 6 digits`,
    "any.required": `"otp_code" is a required field`
  })
});
var UserLoginSchema = import_joi.default.object({
  email: import_joi.default.string().email().max(100).pattern(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/).required().messages({
    "string.base": `"email" should be a type of 'text'`,
    "string.empty": `"email" cannot be an empty field`,
    "string.email": `"email" must be a valid email`,
    "string.max": `"email" should have a maximum length of {#limit}`,
    "string.pattern.base": `"email" must be a valid email format`,
    "any.required": `"email" is a required field`
  }),
  password: import_joi.default.string().min(8).max(128).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/).required().messages({
    "string.base": `"password" should be a type of 'text'`,
    "string.empty": `"password" cannot be an empty field`,
    "string.min": `"password" should have a minimum length of {#limit}`,
    "string.max": `"password" should have a maximum length of {#limit}`,
    "string.pattern.base": `"password" must contain at least one lowercase letter, one uppercase letter, one number, and one special character`,
    "any.required": `"password" is a required field`
  })
});
var UserPasswordValidationSchema = import_joi.default.object({
  email: import_joi.default.string().email().max(100).pattern(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/).required().messages({
    "string.base": `"email" should be a type of 'text'`,
    "string.empty": `"email" cannot be an empty field`,
    "string.email": `"email" must be a valid email`,
    "string.max": `"email" should have a maximum length of {#limit}`,
    "string.pattern.base": `"email" must be a valid email format`,
    "any.required": `"email" is a required field`
  }),
  password: import_joi.default.string().min(8).max(128).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/).required().messages({
    "string.base": `"password" should be a type of 'text'`,
    "string.empty": `"password" cannot be an empty field`,
    "string.min": `"password" should have a minimum length of {#limit}`,
    "string.max": `"password" should have a maximum length of {#limit}`,
    "string.pattern.base": `"password" must contain at least one lowercase letter, one uppercase letter, one number, and one special character`,
    "any.required": `"password" is a required field`
  }),
  confirm_password: import_joi.default.string().required().valid(import_joi.default.ref("password")).messages({
    "any.only": "Passwords do not match",
    "any.required": `"confirm_password" is a required field`
  }),
  otp_code: import_joi.default.number().required().min(1e5).max(999999).messages({
    "number.base": `"otp_code" should be a type of 'number'`,
    "number.empty": `"otp_code" cannot be an empty field`,
    "number.min": `"otp_code" must be exactly 6 digits`,
    "number.max": `"otp_code" must be exactly 6 digits`,
    "any.required": `"otp_code" is a required field`
  })
});
var UserUpdateSchema = import_joi.default.object({
  first_name: import_joi.default.string().min(1).max(50).optional().pattern(/^[a-zA-Z\s\-']+$/).messages({
    "string.base": `"first_name" should be a type of 'text'`,
    "string.empty": `"first_name" cannot be an empty field`,
    "string.min": `"first_name" should have a minimum length of {#limit}`,
    "string.max": `"first_name" should have a maximum length of {#limit}`,
    "any.required": `"first_name" is a required field`,
    "string.pattern.base": `"first_name" must contain only letters, spaces, hyphens, and apostrophes`
  }),
  last_name: import_joi.default.string().allow("", null).max(50).pattern(/^[a-zA-Z\s\-']*$/).messages({
    "string.base": `"last_name" should be a type of 'text'`,
    "string.max": `"last_name" should have a maximum length of {#limit}`,
    "string.pattern.base": `"last_name" must contain only letters, spaces, hyphens, and apostrophes`
  }),
  password: import_joi.default.string().min(8).max(128).required().pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/).messages({
    "string.base": `"password" should be a type of 'text'`,
    "string.empty": `"password" cannot be an empty field`,
    "string.min": `"password" should have a minimum length of {#limit}`,
    "string.max": `"password" should have a maximum length of {#limit}`,
    "any.required": `"password" is a required field`,
    "string.pattern.base": `"password" must contain at least one lowercase letter, one uppercase letter, one number, and one special character`
  }),
  email: import_joi.default.string().email().max(100).optional().messages({
    "string.base": `"email" should be a type of 'text'`,
    "string.empty": `"email" cannot be an empty field`,
    "string.email": `"email" must be a valid email`,
    "string.max": `"email" should have a maximum length of {#limit}`,
    "any.required": `"email" is a required field`
  })
});

// src/validators/user/index.ts
var UsersValidator = {
  UserRegistrationValidation(payload) {
    const { error } = UserRegistrationSchema.validate(payload, { abortEarly: false });
    if (error) {
      throw new InvariantError(error.details.map((detail) => ({
        field: detail.path[0].toString(),
        message: detail.message
      })));
    }
  },
  UserLoginValidation(payload) {
    const { error } = UserLoginSchema.validate(payload, { abortEarly: false });
    if (error) {
      throw new InvariantError(error.details.map((detail) => ({
        field: detail.path[0].toString(),
        message: detail.message
      })));
    }
  },
  UserPasswordValidation(payload) {
    const { error } = UserPasswordValidationSchema.validate(payload, { abortEarly: false });
    if (error) {
      throw new InvariantError(error.details.map((detail) => ({
        field: detail.path[0].toString(),
        message: detail.message
      })));
    }
  },
  UserUpdateValidation(payload) {
    if (!payload) {
      throw new InvariantError([
        {
          field: "payload",
          message: "Payload is required"
        }
      ]);
    }
    const { error } = UserUpdateSchema.validate(payload, { abortEarly: false });
    if (error) {
      throw new InvariantError(error.details.map((detail) => ({
        field: detail.path[0].toString(),
        message: detail.message
      })));
    }
  }
};

// src/validators/general/general.schema.ts
var import_joi2 = __toESM(require_lib39(), 1);
var ApiKeySchema = import_joi2.default.string().pattern(/^[a-f0-9]{64}$/).required().messages({
  "string.base": `"apiKey" should be a type of 'text'`,
  "string.empty": `"apiKey" cannot be an empty field`,
  "string.pattern.base": `"apiKey" must be a valid SHA-256 hash`,
  "any.required": `"apiKey" is a required field`
});
var CookieSchema = import_joi2.default.string().pattern(/^[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$/).required().messages({
  "string.base": `"cookie" should be a type of 'text'`,
  "string.empty": `"cookie" cannot be an empty field`,
  "string.pattern.base": `"cookie" must be a valid JWT token in format "header.payload.signature"`,
  "any.required": `"cookie" is a required field`
});
var IdSchema = import_joi2.default.object({
  id: import_joi2.default.string().uuid().required().messages({
    "string.base": `"id" should be a type of 'text'`,
    "string.empty": `"id" cannot be an empty field`,
    "string.guid": `"id" must be a valid UUID`,
    "any.required": `"id" is a required field`
  })
});

// src/useCases/errors/unauthorized.error.ts
class UnauthorizedError extends ApplicationError {
  constructor(message) {
    const code = 401;
    super(message, code);
    this.name = "UnauthorizedError";
  }
  toResponse() {
    return {
      status: this.status,
      message: this.message
    };
  }
}

// src/validators/general/index.ts
var GeneralValidator = {
  ApiKeyValidation(payload) {
    const { error } = ApiKeySchema.validate(payload);
    if (!payload) {
      throw new UnauthorizedError("Unauthorized.");
    }
    if (error) {
      throw new UnauthorizedError("Unauthorized.");
    }
    if (payload !== Config.key.apiKey) {
      throw new UnauthorizedError("Unauthorized.");
    }
  },
  CookieValidation(payload) {
    const { error } = CookieSchema.validate(payload);
    if (!payload) {
      throw new UnauthorizedError("Session expired.");
    }
    if (error) {
      throw new UnauthorizedError("Session expired.");
    }
  },
  IdValidation(params) {
    const { error } = IdSchema.validate(params, { abortEarly: false });
    if (error) {
      throw new InvariantError(error.details.map((detail) => ({
        field: detail.path[0].toString(),
        message: detail.message
      })));
    }
  },
  UserAgentValidation(payload) {
    if (!payload) {
      throw new UnauthorizedError("Unauthorized.");
    }
  }
};

// src/api/user/user.handler.ts
class UsersHandler {
  _loginUserUseCase;
  _updateUserUseCase;
  _logoutUserUseCase;
  _deleteUserUseCase;
  _registerUserUseCase;
  _undeleteUserUseCase;
  _createSessionUseCase;
  _deleteSessionUseCase;
  _getProfileUserUseCase;
  constructor(_loginUserUseCase, _updateUserUseCase, _logoutUserUseCase, _deleteUserUseCase, _registerUserUseCase, _undeleteUserUseCase, _createSessionUseCase, _deleteSessionUseCase, _getProfileUserUseCase) {
    this._loginUserUseCase = _loginUserUseCase;
    this._updateUserUseCase = _updateUserUseCase;
    this._logoutUserUseCase = _logoutUserUseCase;
    this._deleteUserUseCase = _deleteUserUseCase;
    this._registerUserUseCase = _registerUserUseCase;
    this._undeleteUserUseCase = _undeleteUserUseCase;
    this._createSessionUseCase = _createSessionUseCase;
    this._deleteSessionUseCase = _deleteSessionUseCase;
    this._getProfileUserUseCase = _getProfileUserUseCase;
  }
  async _registerUserHandler(request, h, role) {
    const apiKey = request.headers["x-api-key"];
    const payload = request.payload;
    GeneralValidator.ApiKeyValidation(apiKey);
    UsersValidator.UserRegistrationValidation(payload);
    const restPayload = { ...payload, role };
    const userId = await this._registerUserUseCase.execute(restPayload);
    return h.response({
      status: "success",
      message: `User created successfully.`,
      data: {
        user_id: userId
      }
    }).code(201);
  }
  async registerUserRoleHandler(request, h) {
    return this._registerUserHandler(request, h, "client");
  }
  async registerAdminRoleHandler(request, h) {
    return this._registerUserHandler(request, h, "admin");
  }
  async registerModeratorRoleHandler(request, h) {
    return this._registerUserHandler(request, h, "moderator");
  }
  async loginUserHandler(request, h) {
    const apiKey = request.headers["x-api-key"];
    const user_agent = request.headers["user-agent"];
    const payload = request.payload;
    GeneralValidator.ApiKeyValidation(apiKey);
    GeneralValidator.UserAgentValidation(user_agent);
    UsersValidator.UserLoginValidation(payload);
    const token = await this._loginUserUseCase.execute(payload.email, payload.password);
    const session = await this._createSessionUseCase.execute({ user_agent, ...token });
    const cookieName = `refresh_token_${token.role}`;
    return h.response({
      status: "success",
      message: "User logged in successfully.",
      data: {
        session_id: session.sessionId,
        access_token: token.access_token
      }
    }).unstate(cookieName).state(cookieName, session.token, {
      isSecure: Config.cookie.isSecure,
      isHttpOnly: Config.cookie.isHttpOnly,
      domain: "." + Config.cookie.domain,
      isSameSite: Config.cookie.isSameSite,
      path: "/"
    }).code(200);
  }
  async getUserByIdHandler(request, h) {
    const { id, role } = request.auth.credentials;
    GeneralValidator.IdValidation({ id });
    const user = await this._getProfileUserUseCase.execute(id, role);
    return h.response({
      status: "success",
      message: "User retrieved successfully.",
      data: {
        user
      }
    }).code(200);
  }
  async updateUserHandler(request, h) {
    const { id, role } = request.auth.credentials;
    const payload = request.payload;
    GeneralValidator.IdValidation({ id });
    UsersValidator.UserUpdateValidation(payload);
    await this._updateUserUseCase.execute(role, { ...payload, id });
    return h.response({
      status: "success",
      message: "User updated successfully."
    }).code(200);
  }
  async logoutUserHandler(request, h) {
    const { id, role } = request.auth.credentials;
    const { sessionId } = request.params;
    GeneralValidator.IdValidation({ id });
    GeneralValidator.IdValidation({ id: sessionId });
    await this._logoutUserUseCase.execute(role, id);
    await this._deleteSessionUseCase.execute(sessionId, id);
    const cookieName = `refresh_token_${role}`;
    return h.response({
      status: "success",
      message: "User logged out successfully."
    }).unstate(cookieName).state(cookieName, "", {
      ttl: 0,
      isSecure: Config.cookie.isSecure,
      isHttpOnly: Config.cookie.isHttpOnly,
      domain: "." + Config.cookie.domain,
      isSameSite: Config.cookie.isSameSite,
      path: "/"
    }).code(200);
  }
  async deleteUserHandler(request, h) {
    const { id, role } = request.auth.credentials;
    const { clientId } = request.params;
    GeneralValidator.IdValidation({ id });
    GeneralValidator.IdValidation({ id: clientId });
    await this._deleteUserUseCase.execute(id, clientId, role);
    return h.response({
      status: "success",
      message: "User deleted successfully."
    }).code(200);
  }
  async undeleteUserHandler(request, h) {
    const { id, role } = request.auth.credentials;
    const { clientId } = request.params;
    GeneralValidator.IdValidation({ id });
    GeneralValidator.IdValidation({ id: clientId });
    await this._undeleteUserUseCase.execute(id, clientId, role);
    return h.response({
      status: "success",
      message: "User undeleted successfully."
    }).code(200);
  }
}
UsersHandler = __legacyDecorateClassTS([
  import_tsyringe.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe.inject("LoginUserUseCase")),
  __legacyDecorateParamTS(1, import_tsyringe.inject("UpdateUserUseCase")),
  __legacyDecorateParamTS(2, import_tsyringe.inject("LogoutUserUseCase")),
  __legacyDecorateParamTS(3, import_tsyringe.inject("DeleteUserUseCase")),
  __legacyDecorateParamTS(4, import_tsyringe.inject("RegisterUserUseCase")),
  __legacyDecorateParamTS(5, import_tsyringe.inject("UndeleteUserUseCase")),
  __legacyDecorateParamTS(6, import_tsyringe.inject("CreateSessionUseCase")),
  __legacyDecorateParamTS(7, import_tsyringe.inject("DeleteSessionUseCase")),
  __legacyDecorateParamTS(8, import_tsyringe.inject("GetProfileUserUseCase")),
  __legacyMetadataTS("design:paramtypes", [
    typeof LoginUserUseCase === "undefined" ? Object : LoginUserUseCase,
    typeof UpdateUserUseCase === "undefined" ? Object : UpdateUserUseCase,
    typeof LogoutUserUseCase === "undefined" ? Object : LogoutUserUseCase,
    typeof DeleteUserUseCase === "undefined" ? Object : DeleteUserUseCase,
    typeof RegisterUserUseCase === "undefined" ? Object : RegisterUserUseCase,
    typeof UndeleteUserUseCase === "undefined" ? Object : UndeleteUserUseCase,
    typeof CreateSessionUseCase === "undefined" ? Object : CreateSessionUseCase,
    typeof DeleteSessionUseCase === "undefined" ? Object : DeleteSessionUseCase,
    typeof GetProfileUserUseCase === "undefined" ? Object : GetProfileUserUseCase
  ])
], UsersHandler);

// src/api/user/user.route.ts
var import_tsyringe2 = __toESM(require_cjs(), 1);
var UserRoutes = (server, prefix) => {
  const usersHandler = import_tsyringe2.container.resolve(UsersHandler);
  server.route([
    {
      method: "POST",
      path: `/${prefix}/users/client`,
      handler: usersHandler.registerUserRoleHandler.bind(usersHandler)
    },
    {
      method: "POST",
      path: `/${prefix}/users/admin`,
      handler: usersHandler.registerAdminRoleHandler.bind(usersHandler)
    },
    {
      method: "POST",
      path: `/${prefix}/users/moderator`,
      handler: usersHandler.registerModeratorRoleHandler.bind(usersHandler)
    },
    {
      method: "POST",
      path: `/${prefix}/users/login`,
      handler: usersHandler.loginUserHandler.bind(usersHandler)
    },
    {
      method: "GET",
      path: `/${prefix}/users`,
      handler: usersHandler.getUserByIdHandler.bind(usersHandler),
      options: {
        auth: "jwt_auth"
      }
    },
    {
      method: "PUT",
      path: `/${prefix}/users/update`,
      handler: usersHandler.updateUserHandler.bind(usersHandler),
      options: {
        auth: "jwt_auth"
      }
    },
    {
      method: "DELETE",
      path: `/${prefix}/users/logout/{sessionId}`,
      handler: usersHandler.logoutUserHandler.bind(usersHandler),
      options: {
        auth: "jwt_auth"
      }
    },
    {
      method: "DELETE",
      path: `/${prefix}/users/{clientId}`,
      handler: usersHandler.deleteUserHandler.bind(usersHandler),
      options: {
        auth: "jwt_auth"
      }
    },
    {
      method: "PATCH",
      path: `/${prefix}/users/{clientId}/undelete`,
      handler: usersHandler.undeleteUserHandler.bind(usersHandler),
      options: {
        auth: "jwt_auth"
      }
    }
  ]);
};

// src/extensions/user.extensions.ts
var UsersPlugin = {
  name: "plugin/users",
  version: "1.0.0",
  dependencies: [],
  register: async (server) => {
    UserRoutes(server, "v1");
  }
};

// src/useCases/session/getSession.usecase.ts
var import_tsyringe4 = __toESM(require_cjs(), 1);

// src/useCases/errors/forbidden.error.ts
class ForbiddenError extends ApplicationError {
  constructor(message = "Forbidden access.") {
    const code = 403;
    super(message, code);
    this.name = "ForbiddenError";
  }
  toResponse() {
    return {
      status: this.status,
      message: this.message
    };
  }
}

// src/utils/encryption.manager.ts
var Iron = __toESM(require_lib25(), 1);
var import_tsyringe3 = __toESM(require_cjs(), 1);
class EncryptionManager {
  _password = Config.key.cookieKey;
  setPassword(password) {
    if (password.length < 32) {
      LogError("Password must be at least 32 characters long for adequate security");
    }
    this._password = password;
  }
  async seal(data, options) {
    const password = options?.password || this._password;
    return Iron.seal(data, password, Iron.defaults);
  }
  async unseal(sealed, options) {
    const password = options?.password || this._password;
    return Iron.unseal(sealed, password, Iron.defaults);
  }
  async isValid(sealed, options) {
    try {
      await this.unseal(sealed, options);
      return true;
    } catch (error) {
      LogError("Failed to validate sealed data:", error);
      return false;
    }
  }
}
EncryptionManager = __legacyDecorateClassTS([
  import_tsyringe3.injectable()
], EncryptionManager);

// src/useCases/session/getSession.usecase.ts
class GetSessionUseCase {
  _userRepository;
  _encryptionManager;
  _sessionRepository;
  constructor(_userRepository, _encryptionManager, _sessionRepository) {
    this._userRepository = _userRepository;
    this._encryptionManager = _encryptionManager;
    this._sessionRepository = _sessionRepository;
  }
  async execute(id) {
    const session = await this._sessionRepository.getSession(id);
    if (!session) {
      throw new UnauthorizedError("Session expired or not found.");
    }
    const user = await this._userRepository.getUserById(session.user_id);
    if (!user) {
      throw new ForbiddenError;
    }
    if (new Date(session.expires_at) <= new Date) {
      await this._sessionRepository.deleteExpiredSessions();
    }
    const decryptedToken = await this._encryptionManager.unseal(session.token);
    return {
      token: decryptedToken,
      role: user.role
    };
  }
}
GetSessionUseCase = __legacyDecorateClassTS([
  import_tsyringe4.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe4.inject("UserRepository")),
  __legacyDecorateParamTS(1, import_tsyringe4.inject("EncryptionManager")),
  __legacyDecorateParamTS(2, import_tsyringe4.inject("SessionRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof IUserRepository === "undefined" ? Object : IUserRepository,
    typeof EncryptionManager === "undefined" ? Object : EncryptionManager,
    typeof ISessionRepository === "undefined" ? Object : ISessionRepository
  ])
], GetSessionUseCase);

// src/useCases/session/validateToken.usecase.ts
var import_tsyringe6 = __toESM(require_cjs(), 1);

// src/utils/token.manager.ts
var import_jwt = __toESM(require_lib42(), 1);
var import_tsyringe5 = __toESM(require_cjs(), 1);

// node_modules/uuid/wrapper.mjs
var import_dist = __toESM(require_dist5(), 1);
var v1 = import_dist.default.v1;
var v3 = import_dist.default.v3;
var v4 = import_dist.default.v4;
var v5 = import_dist.default.v5;
var NIL = import_dist.default.NIL;
var version = import_dist.default.version;
var validate = import_dist.default.validate;
var stringify = import_dist.default.stringify;
var parse = import_dist.default.parse;

// src/utils/token.manager.ts
class TokenManager {
  _accessKey = Config.key.accessJwtKey;
  _refreshKey = Config.key.refreshJwtKey;
  async createAccessToken(payload) {
    const completePayload = {
      ...payload,
      iat: Math.floor(Date.now() / 1000),
      jti: v4()
    };
    return import_jwt.default.token.generate(completePayload, this._accessKey);
  }
  async createRefreshToken(payload) {
    const completePayload = {
      ...payload,
      iat: Math.floor(Date.now() / 1000),
      jti: v4()
    };
    return import_jwt.default.token.generate(completePayload, this._refreshKey);
  }
  async verifyToken(token) {
    const artifacts = import_jwt.default.token.decode(token);
    import_jwt.default.token.verifySignature(artifacts, this._refreshKey);
    return artifacts.decoded.payload;
  }
}
TokenManager = __legacyDecorateClassTS([
  import_tsyringe5.injectable()
], TokenManager);

// src/useCases/session/validateToken.usecase.ts
class ValidateTokenUseCase {
  _tokenManager;
  constructor(_tokenManager) {
    this._tokenManager = _tokenManager;
  }
  async execute(role, refreshToken, sessionToken) {
    if (refreshToken !== sessionToken) {
      throw new ForbiddenError;
    }
    const tokenPayload = await this._tokenManager.verifyToken(refreshToken);
    if (!tokenPayload) {
      throw new ForbiddenError;
    }
    if (tokenPayload.role !== role) {
      throw new ForbiddenError;
    }
    const accessToken = await this._tokenManager.createAccessToken(tokenPayload);
    return { token: accessToken, role: tokenPayload.role };
  }
}
ValidateTokenUseCase = __legacyDecorateClassTS([
  import_tsyringe6.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe6.inject("TokenManager")),
  __legacyMetadataTS("design:paramtypes", [
    typeof TokenManager === "undefined" ? Object : TokenManager
  ])
], ValidateTokenUseCase);

// src/api/auth/auth.handler.ts
var import_tsyringe7 = __toESM(require_cjs(), 1);
class AuthHandler {
  _getSessionUseCase;
  _validateTokenUseCase;
  constructor(_getSessionUseCase, _validateTokenUseCase) {
    this._getSessionUseCase = _getSessionUseCase;
    this._validateTokenUseCase = _validateTokenUseCase;
  }
  async refreshTokenHandler(request, h) {
    const apiKey = request.headers["x-api-key"];
    const { sessionId } = request.params;
    GeneralValidator.IdValidation({ id: sessionId });
    const userSession = await this._getSessionUseCase.execute(sessionId);
    const refreshToken = request.state[`refresh_token_${userSession.role}`];
    console.log(`Refresh token for role ${userSession.role}:`, refreshToken);
    GeneralValidator.ApiKeyValidation(apiKey);
    GeneralValidator.CookieValidation(refreshToken);
    const token = await this._validateTokenUseCase.execute(userSession.role, refreshToken, userSession.token);
    const cookieName = `refresh_token_${token.role}`;
    if (!token) {
      return h.response({
        status: "error",
        message: "Session expired."
      }).unstate(cookieName).state(cookieName, "", {
        ttl: 0,
        isSecure: Config.cookie.isSecure,
        isHttpOnly: Config.cookie.isHttpOnly,
        domain: "." + Config.cookie.domain,
        isSameSite: Config.cookie.isSameSite,
        path: "/"
      }).code(404);
    }
    return h.response({
      status: "success",
      message: "Token refreshed successfully.",
      data: {
        access_token: token.token
      }
    }).code(200);
  }
}
AuthHandler = __legacyDecorateClassTS([
  import_tsyringe7.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe7.inject("GetSessionUseCase")),
  __legacyDecorateParamTS(1, import_tsyringe7.inject("ValidateTokenUseCase")),
  __legacyMetadataTS("design:paramtypes", [
    typeof GetSessionUseCase === "undefined" ? Object : GetSessionUseCase,
    typeof ValidateTokenUseCase === "undefined" ? Object : ValidateTokenUseCase
  ])
], AuthHandler);

// src/api/auth/auth.route.ts
var import_tsyringe8 = __toESM(require_cjs(), 1);
var AuthRoutes = (server, prefix) => {
  const authHandler = import_tsyringe8.container.resolve(AuthHandler);
  server.route({
    method: "GET",
    path: `/${prefix}/auths/{sessionId}`,
    handler: authHandler.refreshTokenHandler.bind(authHandler)
  });
};

// src/extensions/auth.extensions.ts
var AuthPlugin = {
  name: "plugin/auth",
  version: "1.0.0",
  dependencies: [],
  register: async (server) => {
    AuthRoutes(server, "v1");
  }
};

// src/extensions/jwt.extensions.ts
var import_jwt2 = __toESM(require_lib42(), 1);
var validateJwtToken = (payload) => {
  return {
    isValid: true,
    credentials: {
      id: payload.decoded.payload.id,
      role: payload.decoded.payload.role
    }
  };
};
var getJwtOptions = () => ({
  keys: Config.key.accessJwtKey,
  verify: {
    aud: false,
    iss: false,
    sub: false,
    maxAgeSec: Config.ttl.jwt
  },
  validate: validateJwtToken
});
var JwtExtension = {
  name: "extension/jwt",
  version: "1.0.0",
  register: async (server) => {
    await server.register(import_jwt2.default);
    server.auth.strategy("jwt_auth", "jwt", getJwtOptions());
  }
};

// src/repositories/errors/infrastructure.error.ts
class InfrastructureError extends Error {
  constructor(message) {
    super(message);
    this.name = "InfrastructureError";
  }
}

// src/extensions/error.extensions.ts
var handleResponse = (request, h) => {
  const response = request.response;
  if (!(response instanceof Error)) {
    return h.continue;
  }
  if (response instanceof ApplicationError) {
    return h.response(response.toResponse()).code(response.code);
  }
  if (response.output.payload.message === "Token maximum age exceeded") {
    return h.response({
      status: "fail",
      message: "Token exceeded maximum age"
    }).code(401);
  }
  if (response.output.statusCode === 401 && response.message) {
    return h.response({
      status: "fail",
      message: "Unauthorized."
    }).code(401);
  }
  if (response.output && response.output.statusCode === 404) {
    return h.response({
      status: "fail",
      message: "Resource not found"
    }).code(404);
  }
  if (response.output.payload.message === "Unsupported Media Type") {
    return h.response({
      status: "fail",
      message: "Unsupported Media Type."
    }).code(415);
  }
  if (response instanceof InfrastructureError) {
    LogError(response.message);
  } else {
    request.log("error", {
      message: "Unhandled Error",
      errorMessage: response.message,
      request: {
        method: request.method.toUpperCase(),
        path: request.path,
        headers: request.headers,
        payload: request.payload
      }
    });
    console.error(response);
  }
  const errorResponse = h.response({
    status: "error",
    message: "Internal Server Error"
  });
  errorResponse.code(500);
  return errorResponse;
};
var ErrorExtension = {
  name: "extension/error",
  version: "1.0.0",
  register: async (server) => {
    server.ext("onPreResponse", handleResponse);
  }
};

// src/connections/hapi.connection.ts
var createServer = async () => {
  const corsOrigin = Config.cors.origin;
  const server = $server({
    port: Config.server.port,
    host: Config.server.host,
    routes: {
      cors: {
        origin: corsOrigin,
        credentials: true,
        additionalHeaders: [
          "cache-control",
          "x-requested-with",
          "content-type",
          "accept",
          "authorization"
        ],
        exposedHeaders: ["content-disposition"]
      }
    }
  });
  server.route({
    method: "OPTIONS",
    path: "/{any*}",
    handler: (request, h) => {
      return h.response().code(204);
    },
    options: {
      description: "CORS preflight handling",
      tags: ["cors"]
    }
  });
  await server.register([ErrorExtension, JwtExtension, UsersPlugin, AuthPlugin]);
  return server;
};
var shutdownServer = async (server) => {
  await server.stop({ timeout: 1e4 });
};

// src/dependencies/connection.dependency.ts
var import_tsyringe9 = __toESM(require_cjs(), 1);
var registerConnectionDepedencies = (PostgresPool, RedisClient) => {
  import_tsyringe9.container.register("PostgresPool", { useValue: PostgresPool });
  import_tsyringe9.container.register("RedisClient", { useValue: RedisClient });
};

// src/dependencies/users.dependency.ts
var import_tsyringe19 = __toESM(require_cjs(), 1);

// src/repositories/postgres/user.repository.ts
var import_tsyringe10 = __toESM(require_cjs(), 1);

// src/repositories/errors/postgres.error.ts
class PostgresError extends InfrastructureError {
  constructor(message) {
    super(message);
    this.name = "PostgresError";
  }
}

class PostgresCreationError extends PostgresError {
  constructor(message) {
    super(message);
    this.name = "PostgresCreationError";
  }
}

class PostgresNotFoundError extends PostgresError {
  constructor(message = "Data not found") {
    super(message);
    this.name = "PostgresNotFoundError";
  }
}

class PostgresUpdateError extends PostgresError {
  constructor(message) {
    super(message);
    this.name = "PostgresUpdateError";
  }
}

class PostgresNoUpdateFieldsError extends PostgresUpdateError {
  constructor() {
    super("No fields to update");
    this.name = "PostgresNoUpdateFieldsError";
  }
}
async function PostgresErrorHandling(fn) {
  try {
    return await fn();
  } catch (error) {
    if (error instanceof Error) {
      throw new PostgresError(`Postgres error: ${error.message}`);
    }
    throw new PostgresError("Postgres error: Unknown Error");
  }
}

// src/repositories/postgres/user.repository.ts
class UserRepository {
  _pool;
  _redisRepository;
  _userFactory;
  constructor(_pool, _redisRepository, _userFactory) {
    this._pool = _pool;
    this._redisRepository = _redisRepository;
    this._userFactory = _userFactory;
  }
  async getUserById(id) {
    return PostgresErrorHandling(async () => {
      const cachedUser = await this._redisRepository.getTableRow("user", "details", id);
      if (cachedUser) {
        return new this._userFactory(cachedUser);
      }
      const userQuery = {
        text: `
                    SELECT
                        id,
                        first_name,
                        last_name,
                        email,
                        password,
                        role,
                        photo,
                        created_at,
                        updated_at,
                        created_by,
                        updated_by,
                        is_deleted
                    FROM users
                    WHERE id = $1 AND is_deleted = FALSE
                    LIMIT 1
                `,
        values: [id]
      };
      const userResult = await this._pool.query(userQuery);
      if (userResult.rowCount === 0) {
        throw new Error("User not found");
      }
      const userData = userResult.rows[0];
      const user = new this._userFactory(userData);
      await this._redisRepository.setTableRow("user", "details", id, userData, Config.ttl.cache);
      return user;
    });
  }
  async getUserIdAndPasswordByEmail(email) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    SELECT id, password
                    FROM users
                    WHERE email = $1 AND is_deleted = FALSE
                    LIMIT 1
                `,
        values: [email]
      };
      const userResult = await this._pool.query(userQuery);
      if (userResult.rowCount === 0) {
        return null;
      }
      return userResult.rows[0];
    });
  }
  async checkUserExistsByEmail(email) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    SELECT EXISTS (
                        SELECT 1
                        FROM users
                        WHERE email = $1 AND is_deleted = FALSE
                    )
                `,
        values: [email]
      };
      const userResult = await this._pool.query(userQuery);
      return userResult.rows[0]?.exists ?? false;
    });
  }
  async checkUserExistsById(id) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    SELECT EXISTS (
                        SELECT 1
                        FROM users
                        WHERE id = $1 AND is_deleted = FALSE
                    )
                `,
        values: [id]
      };
      const userResult = await this._pool.query(userQuery);
      return userResult.rows[0]?.exists ?? false;
    });
  }
  async checkAnyUserExistsById(id) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    SELECT EXISTS (
                        SELECT 1
                        FROM users
                        WHERE id = $1
                    )
                `,
        values: [id]
      };
      const userResult = await this._pool.query(userQuery);
      return userResult.rows[0]?.exists ?? false;
    });
  }
  async checkDeletedUserExistsById(id) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    SELECT EXISTS (
                        SELECT 1
                        FROM users
                        WHERE id = $1 AND is_deleted = TRUE
                    )
                `,
        values: [id]
      };
      const userResult = await this._pool.query(userQuery);
      return userResult.rows[0]?.exists ?? false;
    });
  }
  async addUser(user) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    INSERT INTO users (
                        first_name,
                        last_name,
                        password,
                        email,
                        role,
                        photo
                    ) VALUES ($1, $2, $3, $4, $5, $6)
                    RETURNING id
                `,
        values: [
          user.first_name,
          user.last_name,
          user.password,
          user.email,
          user.role,
          user.photo
        ]
      };
      const userResult = await this._pool.query(userQuery);
      if (!userResult.rows[0]) {
        throw new PostgresCreationError("Failed to create user.");
      }
      return userResult.rows[0].id;
    });
  }
  async updateUserPassword(id, password) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    UPDATE users
                    SET password = $1
                    WHERE id = $2 AND is_deleted = FALSE
                `,
        values: [password, id]
      };
      const userResult = await this._pool.query(userQuery);
      if (userResult.rowCount === 0) {
        throw new PostgresNotFoundError;
      }
      await this._redisRepository.deleteTableRow("user", "details", id);
    });
  }
  async updateUser(user) {
    return PostgresErrorHandling(async () => {
      const fields = [];
      const values = [];
      let index = 1;
      if (user.first_name) {
        fields.push(`first_name = $${index++}`);
        values.push(user.first_name);
      }
      if (user.last_name) {
        fields.push(`last_name = $${index++}`);
        values.push(user.last_name);
      }
      if (user.email) {
        fields.push(`email = $${index++}`);
        values.push(user.email);
      }
      if (fields.length === 0) {
        throw new PostgresNoUpdateFieldsError;
      }
      const userQuery = {
        text: `
                    UPDATE users
                    SET ${fields.join(", ")}
                    WHERE id = $${index} AND is_deleted = FALSE
                `,
        values: [...values, user.id]
      };
      const userResult = await this._pool.query(userQuery);
      if (userResult.rowCount === 0) {
        throw new PostgresNotFoundError;
      }
      await this._redisRepository.deleteTableRow("user", "details", user.id);
    });
  }
  async updateUserPhoto(id, photoUrl) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    UPDATE users
                    SET photo = $1
                    WHERE id = $2 AND is_deleted = FALSE
                `,
        values: [photoUrl, id]
      };
      const userResult = await this._pool.query(userQuery);
      if (userResult.rowCount === 0) {
        throw new PostgresNotFoundError;
      }
      await this._redisRepository.deleteTableRow("user", "details", id);
    });
  }
  async softDeleteUser(id) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    UPDATE users
                    SET is_deleted = TRUE
                    WHERE id = $1 AND is_deleted = FALSE
                `,
        values: [id]
      };
      const userResult = await this._pool.query(userQuery);
      if (userResult.rowCount === 0) {
        throw new PostgresNotFoundError;
      }
      await this._redisRepository.deleteTableRow("user", "details", id);
    });
  }
  async undeleteUser(id) {
    return PostgresErrorHandling(async () => {
      const userQuery = {
        text: `
                    UPDATE users
                    SET is_deleted = FALSE
                    WHERE id = $1 AND is_deleted = TRUE
                `,
        values: [id]
      };
      const userResult = await this._pool.query(userQuery);
      if (userResult.rowCount === 0) {
        throw new PostgresNotFoundError;
      }
      await this._redisRepository.deleteTableRow("user", "details", id);
    });
  }
}
UserRepository = __legacyDecorateClassTS([
  import_tsyringe10.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe10.inject("PostgresPool")),
  __legacyDecorateParamTS(1, import_tsyringe10.inject("RedisRepository")),
  __legacyDecorateParamTS(2, import_tsyringe10.inject("User")),
  __legacyMetadataTS("design:paramtypes", [
    typeof Pool === "undefined" ? Object : Pool,
    typeof IRedisRepository === "undefined" ? Object : IRedisRepository,
    Object
  ])
], UserRepository);

// src/utils/hash.manager.ts
import crypto2 from "crypto";

// node_modules/bcryptjs/index.js
import nodeCrypto from "crypto";
var randomFallback = null;
function randomBytes(len) {
  try {
    return crypto.getRandomValues(new Uint8Array(len));
  } catch {}
  try {
    return nodeCrypto.randomBytes(len);
  } catch {}
  if (!randomFallback) {
    throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
  }
  return randomFallback(len);
}
function genSaltSync(rounds, seed_length) {
  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof rounds !== "number")
    throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
  if (rounds < 4)
    rounds = 4;
  else if (rounds > 31)
    rounds = 31;
  var salt = [];
  salt.push("$2b$");
  if (rounds < 10)
    salt.push("0");
  salt.push(rounds.toString());
  salt.push("$");
  salt.push(base64_encode(randomBytes(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
  return salt.join("");
}
function genSalt(rounds, seed_length, callback) {
  if (typeof seed_length === "function")
    callback = seed_length, seed_length = undefined;
  if (typeof rounds === "function")
    callback = rounds, rounds = undefined;
  if (typeof rounds === "undefined")
    rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
  else if (typeof rounds !== "number")
    throw Error("illegal arguments: " + typeof rounds);
  function _async(callback2) {
    nextTick(function() {
      try {
        callback2(null, genSaltSync(rounds));
      } catch (err) {
        callback2(err);
      }
    });
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function hash(password, salt, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password === "string" && typeof salt === "number")
      genSalt(salt, function(err, salt2) {
        _hash(password, salt2, callback2, progressCallback);
      });
    else if (typeof password === "string" && typeof salt === "string")
      _hash(password, salt, callback2, progressCallback);
    else
      nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof password + ", " + typeof salt)));
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function safeStringCompare(known, unknown) {
  var diff = known.length ^ unknown.length;
  for (var i = 0;i < known.length; ++i) {
    diff |= known.charCodeAt(i) ^ unknown.charCodeAt(i);
  }
  return diff === 0;
}
function compare(password, hashValue, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password !== "string" || typeof hashValue !== "string") {
      nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof password + ", " + typeof hashValue)));
      return;
    }
    if (hashValue.length !== 60) {
      nextTick(callback2.bind(this, null, false));
      return;
    }
    hash(password, hashValue.substring(0, 29), function(err, comp) {
      if (err)
        callback2(err);
      else
        callback2(null, safeStringCompare(comp, hashValue));
    }, progressCallback);
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
function utf8Length(string) {
  var len = 0, c = 0;
  for (var i = 0;i < string.length; ++i) {
    c = string.charCodeAt(i);
    if (c < 128)
      len += 1;
    else if (c < 2048)
      len += 2;
    else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else
      len += 3;
  }
  return len;
}
function utf8Array(string) {
  var offset = 0, c1, c2;
  var buffer = new Array(utf8Length(string));
  for (var i = 0, k = string.length;i < k; ++i) {
    c1 = string.charCodeAt(i);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return buffer;
}
var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
var BASE64_INDEX = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  -1,
  -1,
  -1,
  -1,
  -1
];
function base64_encode(b, len) {
  var off = 0, rs = [], c1, c2;
  if (len <= 0 || len > b.length)
    throw Error("Illegal len: " + len);
  while (off < len) {
    c1 = b[off++] & 255;
    rs.push(BASE64_CODE[c1 >> 2 & 63]);
    c1 = (c1 & 3) << 4;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 4 & 15;
    rs.push(BASE64_CODE[c1 & 63]);
    c1 = (c2 & 15) << 2;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 6 & 3;
    rs.push(BASE64_CODE[c1 & 63]);
    rs.push(BASE64_CODE[c2 & 63]);
  }
  return rs.join("");
}
function base64_decode(s, len) {
  var off = 0, slen = s.length, olen = 0, rs = [], c1, c2, c3, c4, o, code;
  if (len <= 0)
    throw Error("Illegal len: " + len);
  while (off < slen - 1 && olen < len) {
    code = s.charCodeAt(off++);
    c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    code = s.charCodeAt(off++);
    c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c1 == -1 || c2 == -1)
      break;
    o = c1 << 2 >>> 0;
    o |= (c2 & 48) >> 4;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen)
      break;
    code = s.charCodeAt(off++);
    c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c3 == -1)
      break;
    o = (c2 & 15) << 4 >>> 0;
    o |= (c3 & 60) >> 2;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen)
      break;
    code = s.charCodeAt(off++);
    c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    o = (c3 & 3) << 6 >>> 0;
    o |= c4;
    rs.push(String.fromCharCode(o));
    ++olen;
  }
  var res = [];
  for (off = 0;off < olen; off++)
    res.push(rs[off].charCodeAt(0));
  return res;
}
var BCRYPT_SALT_LEN = 16;
var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
var BLOWFISH_NUM_ROUNDS = 16;
var MAX_EXECUTION_TIME = 100;
var P_ORIG = [
  608135816,
  2242054355,
  320440878,
  57701188,
  2752067618,
  698298832,
  137296536,
  3964562569,
  1160258022,
  953160567,
  3193202383,
  887688300,
  3232508343,
  3380367581,
  1065670069,
  3041331479,
  2450970073,
  2306472731
];
var S_ORIG = [
  3509652390,
  2564797868,
  805139163,
  3491422135,
  3101798381,
  1780907670,
  3128725573,
  4046225305,
  614570311,
  3012652279,
  134345442,
  2240740374,
  1667834072,
  1901547113,
  2757295779,
  4103290238,
  227898511,
  1921955416,
  1904987480,
  2182433518,
  2069144605,
  3260701109,
  2620446009,
  720527379,
  3318853667,
  677414384,
  3393288472,
  3101374703,
  2390351024,
  1614419982,
  1822297739,
  2954791486,
  3608508353,
  3174124327,
  2024746970,
  1432378464,
  3864339955,
  2857741204,
  1464375394,
  1676153920,
  1439316330,
  715854006,
  3033291828,
  289532110,
  2706671279,
  2087905683,
  3018724369,
  1668267050,
  732546397,
  1947742710,
  3462151702,
  2609353502,
  2950085171,
  1814351708,
  2050118529,
  680887927,
  999245976,
  1800124847,
  3300911131,
  1713906067,
  1641548236,
  4213287313,
  1216130144,
  1575780402,
  4018429277,
  3917837745,
  3693486850,
  3949271944,
  596196993,
  3549867205,
  258830323,
  2213823033,
  772490370,
  2760122372,
  1774776394,
  2652871518,
  566650946,
  4142492826,
  1728879713,
  2882767088,
  1783734482,
  3629395816,
  2517608232,
  2874225571,
  1861159788,
  326777828,
  3124490320,
  2130389656,
  2716951837,
  967770486,
  1724537150,
  2185432712,
  2364442137,
  1164943284,
  2105845187,
  998989502,
  3765401048,
  2244026483,
  1075463327,
  1455516326,
  1322494562,
  910128902,
  469688178,
  1117454909,
  936433444,
  3490320968,
  3675253459,
  1240580251,
  122909385,
  2157517691,
  634681816,
  4142456567,
  3825094682,
  3061402683,
  2540495037,
  79693498,
  3249098678,
  1084186820,
  1583128258,
  426386531,
  1761308591,
  1047286709,
  322548459,
  995290223,
  1845252383,
  2603652396,
  3431023940,
  2942221577,
  3202600964,
  3727903485,
  1712269319,
  422464435,
  3234572375,
  1170764815,
  3523960633,
  3117677531,
  1434042557,
  442511882,
  3600875718,
  1076654713,
  1738483198,
  4213154764,
  2393238008,
  3677496056,
  1014306527,
  4251020053,
  793779912,
  2902807211,
  842905082,
  4246964064,
  1395751752,
  1040244610,
  2656851899,
  3396308128,
  445077038,
  3742853595,
  3577915638,
  679411651,
  2892444358,
  2354009459,
  1767581616,
  3150600392,
  3791627101,
  3102740896,
  284835224,
  4246832056,
  1258075500,
  768725851,
  2589189241,
  3069724005,
  3532540348,
  1274779536,
  3789419226,
  2764799539,
  1660621633,
  3471099624,
  4011903706,
  913787905,
  3497959166,
  737222580,
  2514213453,
  2928710040,
  3937242737,
  1804850592,
  3499020752,
  2949064160,
  2386320175,
  2390070455,
  2415321851,
  4061277028,
  2290661394,
  2416832540,
  1336762016,
  1754252060,
  3520065937,
  3014181293,
  791618072,
  3188594551,
  3933548030,
  2332172193,
  3852520463,
  3043980520,
  413987798,
  3465142937,
  3030929376,
  4245938359,
  2093235073,
  3534596313,
  375366246,
  2157278981,
  2479649556,
  555357303,
  3870105701,
  2008414854,
  3344188149,
  4221384143,
  3956125452,
  2067696032,
  3594591187,
  2921233993,
  2428461,
  544322398,
  577241275,
  1471733935,
  610547355,
  4027169054,
  1432588573,
  1507829418,
  2025931657,
  3646575487,
  545086370,
  48609733,
  2200306550,
  1653985193,
  298326376,
  1316178497,
  3007786442,
  2064951626,
  458293330,
  2589141269,
  3591329599,
  3164325604,
  727753846,
  2179363840,
  146436021,
  1461446943,
  4069977195,
  705550613,
  3059967265,
  3887724982,
  4281599278,
  3313849956,
  1404054877,
  2845806497,
  146425753,
  1854211946,
  1266315497,
  3048417604,
  3681880366,
  3289982499,
  2909710000,
  1235738493,
  2632868024,
  2414719590,
  3970600049,
  1771706367,
  1449415276,
  3266420449,
  422970021,
  1963543593,
  2690192192,
  3826793022,
  1062508698,
  1531092325,
  1804592342,
  2583117782,
  2714934279,
  4024971509,
  1294809318,
  4028980673,
  1289560198,
  2221992742,
  1669523910,
  35572830,
  157838143,
  1052438473,
  1016535060,
  1802137761,
  1753167236,
  1386275462,
  3080475397,
  2857371447,
  1040679964,
  2145300060,
  2390574316,
  1461121720,
  2956646967,
  4031777805,
  4028374788,
  33600511,
  2920084762,
  1018524850,
  629373528,
  3691585981,
  3515945977,
  2091462646,
  2486323059,
  586499841,
  988145025,
  935516892,
  3367335476,
  2599673255,
  2839830854,
  265290510,
  3972581182,
  2759138881,
  3795373465,
  1005194799,
  847297441,
  406762289,
  1314163512,
  1332590856,
  1866599683,
  4127851711,
  750260880,
  613907577,
  1450815602,
  3165620655,
  3734664991,
  3650291728,
  3012275730,
  3704569646,
  1427272223,
  778793252,
  1343938022,
  2676280711,
  2052605720,
  1946737175,
  3164576444,
  3914038668,
  3967478842,
  3682934266,
  1661551462,
  3294938066,
  4011595847,
  840292616,
  3712170807,
  616741398,
  312560963,
  711312465,
  1351876610,
  322626781,
  1910503582,
  271666773,
  2175563734,
  1594956187,
  70604529,
  3617834859,
  1007753275,
  1495573769,
  4069517037,
  2549218298,
  2663038764,
  504708206,
  2263041392,
  3941167025,
  2249088522,
  1514023603,
  1998579484,
  1312622330,
  694541497,
  2582060303,
  2151582166,
  1382467621,
  776784248,
  2618340202,
  3323268794,
  2497899128,
  2784771155,
  503983604,
  4076293799,
  907881277,
  423175695,
  432175456,
  1378068232,
  4145222326,
  3954048622,
  3938656102,
  3820766613,
  2793130115,
  2977904593,
  26017576,
  3274890735,
  3194772133,
  1700274565,
  1756076034,
  4006520079,
  3677328699,
  720338349,
  1533947780,
  354530856,
  688349552,
  3973924725,
  1637815568,
  332179504,
  3949051286,
  53804574,
  2852348879,
  3044236432,
  1282449977,
  3583942155,
  3416972820,
  4006381244,
  1617046695,
  2628476075,
  3002303598,
  1686838959,
  431878346,
  2686675385,
  1700445008,
  1080580658,
  1009431731,
  832498133,
  3223435511,
  2605976345,
  2271191193,
  2516031870,
  1648197032,
  4164389018,
  2548247927,
  300782431,
  375919233,
  238389289,
  3353747414,
  2531188641,
  2019080857,
  1475708069,
  455242339,
  2609103871,
  448939670,
  3451063019,
  1395535956,
  2413381860,
  1841049896,
  1491858159,
  885456874,
  4264095073,
  4001119347,
  1565136089,
  3898914787,
  1108368660,
  540939232,
  1173283510,
  2745871338,
  3681308437,
  4207628240,
  3343053890,
  4016749493,
  1699691293,
  1103962373,
  3625875870,
  2256883143,
  3830138730,
  1031889488,
  3479347698,
  1535977030,
  4236805024,
  3251091107,
  2132092099,
  1774941330,
  1199868427,
  1452454533,
  157007616,
  2904115357,
  342012276,
  595725824,
  1480756522,
  206960106,
  497939518,
  591360097,
  863170706,
  2375253569,
  3596610801,
  1814182875,
  2094937945,
  3421402208,
  1082520231,
  3463918190,
  2785509508,
  435703966,
  3908032597,
  1641649973,
  2842273706,
  3305899714,
  1510255612,
  2148256476,
  2655287854,
  3276092548,
  4258621189,
  236887753,
  3681803219,
  274041037,
  1734335097,
  3815195456,
  3317970021,
  1899903192,
  1026095262,
  4050517792,
  356393447,
  2410691914,
  3873677099,
  3682840055,
  3913112168,
  2491498743,
  4132185628,
  2489919796,
  1091903735,
  1979897079,
  3170134830,
  3567386728,
  3557303409,
  857797738,
  1136121015,
  1342202287,
  507115054,
  2535736646,
  337727348,
  3213592640,
  1301675037,
  2528481711,
  1895095763,
  1721773893,
  3216771564,
  62756741,
  2142006736,
  835421444,
  2531993523,
  1442658625,
  3659876326,
  2882144922,
  676362277,
  1392781812,
  170690266,
  3921047035,
  1759253602,
  3611846912,
  1745797284,
  664899054,
  1329594018,
  3901205900,
  3045908486,
  2062866102,
  2865634940,
  3543621612,
  3464012697,
  1080764994,
  553557557,
  3656615353,
  3996768171,
  991055499,
  499776247,
  1265440854,
  648242737,
  3940784050,
  980351604,
  3713745714,
  1749149687,
  3396870395,
  4211799374,
  3640570775,
  1161844396,
  3125318951,
  1431517754,
  545492359,
  4268468663,
  3499529547,
  1437099964,
  2702547544,
  3433638243,
  2581715763,
  2787789398,
  1060185593,
  1593081372,
  2418618748,
  4260947970,
  69676912,
  2159744348,
  86519011,
  2512459080,
  3838209314,
  1220612927,
  3339683548,
  133810670,
  1090789135,
  1078426020,
  1569222167,
  845107691,
  3583754449,
  4072456591,
  1091646820,
  628848692,
  1613405280,
  3757631651,
  526609435,
  236106946,
  48312990,
  2942717905,
  3402727701,
  1797494240,
  859738849,
  992217954,
  4005476642,
  2243076622,
  3870952857,
  3732016268,
  765654824,
  3490871365,
  2511836413,
  1685915746,
  3888969200,
  1414112111,
  2273134842,
  3281911079,
  4080962846,
  172450625,
  2569994100,
  980381355,
  4109958455,
  2819808352,
  2716589560,
  2568741196,
  3681446669,
  3329971472,
  1835478071,
  660984891,
  3704678404,
  4045999559,
  3422617507,
  3040415634,
  1762651403,
  1719377915,
  3470491036,
  2693910283,
  3642056355,
  3138596744,
  1364962596,
  2073328063,
  1983633131,
  926494387,
  3423689081,
  2150032023,
  4096667949,
  1749200295,
  3328846651,
  309677260,
  2016342300,
  1779581495,
  3079819751,
  111262694,
  1274766160,
  443224088,
  298511866,
  1025883608,
  3806446537,
  1145181785,
  168956806,
  3641502830,
  3584813610,
  1689216846,
  3666258015,
  3200248200,
  1692713982,
  2646376535,
  4042768518,
  1618508792,
  1610833997,
  3523052358,
  4130873264,
  2001055236,
  3610705100,
  2202168115,
  4028541809,
  2961195399,
  1006657119,
  2006996926,
  3186142756,
  1430667929,
  3210227297,
  1314452623,
  4074634658,
  4101304120,
  2273951170,
  1399257539,
  3367210612,
  3027628629,
  1190975929,
  2062231137,
  2333990788,
  2221543033,
  2438960610,
  1181637006,
  548689776,
  2362791313,
  3372408396,
  3104550113,
  3145860560,
  296247880,
  1970579870,
  3078560182,
  3769228297,
  1714227617,
  3291629107,
  3898220290,
  166772364,
  1251581989,
  493813264,
  448347421,
  195405023,
  2709975567,
  677966185,
  3703036547,
  1463355134,
  2715995803,
  1338867538,
  1343315457,
  2802222074,
  2684532164,
  233230375,
  2599980071,
  2000651841,
  3277868038,
  1638401717,
  4028070440,
  3237316320,
  6314154,
  819756386,
  300326615,
  590932579,
  1405279636,
  3267499572,
  3150704214,
  2428286686,
  3959192993,
  3461946742,
  1862657033,
  1266418056,
  963775037,
  2089974820,
  2263052895,
  1917689273,
  448879540,
  3550394620,
  3981727096,
  150775221,
  3627908307,
  1303187396,
  508620638,
  2975983352,
  2726630617,
  1817252668,
  1876281319,
  1457606340,
  908771278,
  3720792119,
  3617206836,
  2455994898,
  1729034894,
  1080033504,
  976866871,
  3556439503,
  2881648439,
  1522871579,
  1555064734,
  1336096578,
  3548522304,
  2579274686,
  3574697629,
  3205460757,
  3593280638,
  3338716283,
  3079412587,
  564236357,
  2993598910,
  1781952180,
  1464380207,
  3163844217,
  3332601554,
  1699332808,
  1393555694,
  1183702653,
  3581086237,
  1288719814,
  691649499,
  2847557200,
  2895455976,
  3193889540,
  2717570544,
  1781354906,
  1676643554,
  2592534050,
  3230253752,
  1126444790,
  2770207658,
  2633158820,
  2210423226,
  2615765581,
  2414155088,
  3127139286,
  673620729,
  2805611233,
  1269405062,
  4015350505,
  3341807571,
  4149409754,
  1057255273,
  2012875353,
  2162469141,
  2276492801,
  2601117357,
  993977747,
  3918593370,
  2654263191,
  753973209,
  36408145,
  2530585658,
  25011837,
  3520020182,
  2088578344,
  530523599,
  2918365339,
  1524020338,
  1518925132,
  3760827505,
  3759777254,
  1202760957,
  3985898139,
  3906192525,
  674977740,
  4174734889,
  2031300136,
  2019492241,
  3983892565,
  4153806404,
  3822280332,
  352677332,
  2297720250,
  60907813,
  90501309,
  3286998549,
  1016092578,
  2535922412,
  2839152426,
  457141659,
  509813237,
  4120667899,
  652014361,
  1966332200,
  2975202805,
  55981186,
  2327461051,
  676427537,
  3255491064,
  2882294119,
  3433927263,
  1307055953,
  942726286,
  933058658,
  2468411793,
  3933900994,
  4215176142,
  1361170020,
  2001714738,
  2830558078,
  3274259782,
  1222529897,
  1679025792,
  2729314320,
  3714953764,
  1770335741,
  151462246,
  3013232138,
  1682292957,
  1483529935,
  471910574,
  1539241949,
  458788160,
  3436315007,
  1807016891,
  3718408830,
  978976581,
  1043663428,
  3165965781,
  1927990952,
  4200891579,
  2372276910,
  3208408903,
  3533431907,
  1412390302,
  2931980059,
  4132332400,
  1947078029,
  3881505623,
  4168226417,
  2941484381,
  1077988104,
  1320477388,
  886195818,
  18198404,
  3786409000,
  2509781533,
  112762804,
  3463356488,
  1866414978,
  891333506,
  18488651,
  661792760,
  1628790961,
  3885187036,
  3141171499,
  876946877,
  2693282273,
  1372485963,
  791857591,
  2686433993,
  3759982718,
  3167212022,
  3472953795,
  2716379847,
  445679433,
  3561995674,
  3504004811,
  3574258232,
  54117162,
  3331405415,
  2381918588,
  3769707343,
  4154350007,
  1140177722,
  4074052095,
  668550556,
  3214352940,
  367459370,
  261225585,
  2610173221,
  4209349473,
  3468074219,
  3265815641,
  314222801,
  3066103646,
  3808782860,
  282218597,
  3406013506,
  3773591054,
  379116347,
  1285071038,
  846784868,
  2669647154,
  3771962079,
  3550491691,
  2305946142,
  453669953,
  1268987020,
  3317592352,
  3279303384,
  3744833421,
  2610507566,
  3859509063,
  266596637,
  3847019092,
  517658769,
  3462560207,
  3443424879,
  370717030,
  4247526661,
  2224018117,
  4143653529,
  4112773975,
  2788324899,
  2477274417,
  1456262402,
  2901442914,
  1517677493,
  1846949527,
  2295493580,
  3734397586,
  2176403920,
  1280348187,
  1908823572,
  3871786941,
  846861322,
  1172426758,
  3287448474,
  3383383037,
  1655181056,
  3139813346,
  901632758,
  1897031941,
  2986607138,
  3066810236,
  3447102507,
  1393639104,
  373351379,
  950779232,
  625454576,
  3124240540,
  4148612726,
  2007998917,
  544563296,
  2244738638,
  2330496472,
  2058025392,
  1291430526,
  424198748,
  50039436,
  29584100,
  3605783033,
  2429876329,
  2791104160,
  1057563949,
  3255363231,
  3075367218,
  3463963227,
  1469046755,
  985887462
];
var C_ORIG = [
  1332899944,
  1700884034,
  1701343084,
  1684370003,
  1668446532,
  1869963892
];
function _encipher(lr, off, P, S) {
  var n, l = lr[off], r = lr[off + 1];
  l ^= P[0];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[1];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[2];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[3];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[4];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[5];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[6];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[7];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[8];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[9];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[10];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[11];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[12];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[13];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[14];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[15];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[16];
  lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
  lr[off + 1] = l;
  return lr;
}
function _streamtoword(data, offp) {
  for (var i = 0, word = 0;i < 4; ++i)
    word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
  return { key: word, offp };
}
function _key(key, P, S) {
  var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0;i < plen; i++)
    sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
  for (i = 0;i < plen; i += 2)
    lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0;i < slen; i += 2)
    lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _ekskey(data, key, P, S) {
  var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0;i < plen; i++)
    sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
  offp = 0;
  for (i = 0;i < plen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0;i < slen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _crypt(b, salt, rounds, callback, progressCallback) {
  var cdata = C_ORIG.slice(), clen = cdata.length, err;
  if (rounds < 4 || rounds > 31) {
    err = Error("Illegal number of rounds (4-31): " + rounds);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.length !== BCRYPT_SALT_LEN) {
    err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  rounds = 1 << rounds >>> 0;
  var P, S, i = 0, j;
  if (typeof Int32Array === "function") {
    P = new Int32Array(P_ORIG);
    S = new Int32Array(S_ORIG);
  } else {
    P = P_ORIG.slice();
    S = S_ORIG.slice();
  }
  _ekskey(salt, b, P, S);
  function next() {
    if (progressCallback)
      progressCallback(i / rounds);
    if (i < rounds) {
      var start = Date.now();
      for (;i < rounds; ) {
        i = i + 1;
        _key(b, P, S);
        _key(salt, P, S);
        if (Date.now() - start > MAX_EXECUTION_TIME)
          break;
      }
    } else {
      for (i = 0;i < 64; i++)
        for (j = 0;j < clen >> 1; j++)
          _encipher(cdata, j << 1, P, S);
      var ret = [];
      for (i = 0;i < clen; i++)
        ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
      if (callback) {
        callback(null, ret);
        return;
      } else
        return ret;
    }
    if (callback)
      nextTick(next);
  }
  if (typeof callback !== "undefined") {
    next();
  } else {
    var res;
    while (true)
      if (typeof (res = next()) !== "undefined")
        return res || [];
  }
}
function _hash(password, salt, callback, progressCallback) {
  var err;
  if (typeof password !== "string" || typeof salt !== "string") {
    err = Error("Invalid string / salt: Not a string");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var minor, offset;
  if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
    err = Error("Invalid salt version: " + salt.substring(0, 2));
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.charAt(2) === "$")
    minor = String.fromCharCode(0), offset = 3;
  else {
    minor = salt.charAt(2);
    if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
      err = Error("Invalid salt revision: " + salt.substring(2, 4));
      if (callback) {
        nextTick(callback.bind(this, err));
        return;
      } else
        throw err;
    }
    offset = 4;
  }
  if (salt.charAt(offset + 2) > "$") {
    err = Error("Missing salt rounds");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
  password += minor >= "a" ? "\x00" : "";
  var passwordb = utf8Array(password), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
  function finish(bytes) {
    var res = [];
    res.push("$2");
    if (minor >= "a")
      res.push(minor);
    res.push("$");
    if (rounds < 10)
      res.push("0");
    res.push(rounds.toString());
    res.push("$");
    res.push(base64_encode(saltb, saltb.length));
    res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
    return res.join("");
  }
  if (typeof callback == "undefined")
    return finish(_crypt(passwordb, saltb, rounds));
  else {
    _crypt(passwordb, saltb, rounds, function(err2, bytes) {
      if (err2)
        callback(err2, null);
      else
        callback(null, finish(bytes));
    }, progressCallback);
  }
}

// src/utils/hash.manager.ts
var import_tsyringe11 = __toESM(require_cjs(), 1);
class HashManager2 {
  _saltRounds = 10;
  async hashData(data, algorithm = "sha256") {
    const hash2 = crypto2.createHash(algorithm);
    hash2.update(data);
    return hash2.digest("hex");
  }
  async compareHash(data, hash2, algorithm = "sha256") {
    const newHash = await this.hashData(data, algorithm);
    return newHash === hash2;
  }
  async hashWithSalt(data, salt) {
    const useSalt = salt || crypto2.randomBytes(16).toString("hex");
    const hash2 = crypto2.createHash("sha256");
    hash2.update(useSalt + data);
    return {
      hash: hash2.digest("hex"),
      salt: useSalt
    };
  }
  async compareDataWithSalt(data, salt, hash2) {
    const newHash = await this.hashWithSalt(data, salt);
    return newHash.hash === hash2;
  }
  async hashPassword(password) {
    return hash(password, this._saltRounds);
  }
  async comparePassword(password, hash2) {
    return compare(password, hash2);
  }
}
HashManager2 = __legacyDecorateClassTS([
  import_tsyringe11.injectable()
], HashManager2);

// src/useCases/errors/conflict.error.ts
class ConflictError extends ApplicationError {
  constructor(message) {
    const code = 409;
    super(message, code);
    this.name = "ConflictError";
  }
  toResponse() {
    return {
      status: this.status,
      message: this.message
    };
  }
}

// src/useCases/user/registration.usecase.ts
var import_tsyringe12 = __toESM(require_cjs(), 1);
class RegisterUserUseCase2 {
  _hashManager;
  _userRepository;
  _defaultPhotoUrl = Config.storage.defaultPhoto;
  constructor(_hashManager, _userRepository) {
    this._hashManager = _hashManager;
    this._userRepository = _userRepository;
  }
  async execute(userData) {
    const userExists = await this._userRepository.checkUserExistsByEmail(userData.email);
    if (userExists) {
      throw new ConflictError("Email already exists.");
    }
    const hashedPassword = await this._hashManager.hashPassword(userData.password);
    const userWithHashedPassword = {
      ...userData,
      password: hashedPassword,
      photo: this._defaultPhotoUrl
    };
    const userId = await this._userRepository.addUser(userWithHashedPassword);
    return userId;
  }
}
RegisterUserUseCase2 = __legacyDecorateClassTS([
  import_tsyringe12.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe12.inject("HashManager")),
  __legacyDecorateParamTS(1, import_tsyringe12.inject("UserRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof HashManager2 === "undefined" ? Object : HashManager2,
    typeof IUserRepository === "undefined" ? Object : IUserRepository
  ])
], RegisterUserUseCase2);

// src/useCases/user/getProfile.usecase.ts
var import_tsyringe13 = __toESM(require_cjs(), 1);

// src/useCases/errors/notFound.error.ts
class NotFoundError extends ApplicationError {
  constructor(message) {
    const code = 404;
    super(message, code);
    this.name = "NotFoundError";
  }
  toResponse() {
    return {
      status: this.status,
      message: this.message
    };
  }
}

// src/useCases/user/getProfile.usecase.ts
class GetProfileUserUseCase2 {
  _userRepository;
  constructor(_userRepository) {
    this._userRepository = _userRepository;
  }
  async execute(userId, userRole) {
    const user = await this._userRepository.getUserById(userId);
    if (!user) {
      throw new NotFoundError("User ID not found.");
    }
    if (user.role !== userRole) {
      throw new ForbiddenError;
    }
    return user;
  }
}
GetProfileUserUseCase2 = __legacyDecorateClassTS([
  import_tsyringe13.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe13.inject("UserRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof IUserRepository === "undefined" ? Object : IUserRepository
  ])
], GetProfileUserUseCase2);

// src/useCases/user/login.usecase.ts
var import_tsyringe14 = __toESM(require_cjs(), 1);

// src/useCases/errors/badRequest.error.ts
class BadRequestError extends ApplicationError {
  constructor(message) {
    const code = 400;
    super(message, code);
    this.name = "BadRequestError";
  }
  toResponse() {
    return {
      status: this.status,
      message: this.message
    };
  }
}

// src/useCases/user/login.usecase.ts
class LoginUserUseCase2 {
  _hashManager;
  _tokenManager;
  _userRepository;
  constructor(_hashManager, _tokenManager, _userRepository) {
    this._hashManager = _hashManager;
    this._tokenManager = _tokenManager;
    this._userRepository = _userRepository;
  }
  async execute(email, password) {
    const userCredentials = await this._userRepository.getUserIdAndPasswordByEmail(email);
    if (!userCredentials) {
      throw new BadRequestError("Invalid username or password.");
    }
    const isPasswordCorrect = await this._hashManager.comparePassword(password, userCredentials.password);
    if (!isPasswordCorrect) {
      throw new BadRequestError("Invalid username or password.");
    }
    const user = await this._userRepository.getUserById(userCredentials.id);
    if (!user) {
      throw new NotFoundError("User not found.");
    }
    const jwtPayload = {
      id: user.id,
      role: user.role
    };
    const [accessToken, refreshToken] = await Promise.all([
      this._tokenManager.createAccessToken(jwtPayload),
      this._tokenManager.createRefreshToken(jwtPayload)
    ]);
    return {
      access_token: accessToken,
      refresh_token: refreshToken,
      role: user.role,
      user_id: user.id
    };
  }
}
LoginUserUseCase2 = __legacyDecorateClassTS([
  import_tsyringe14.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe14.inject("HashManager")),
  __legacyDecorateParamTS(1, import_tsyringe14.inject("TokenManager")),
  __legacyDecorateParamTS(2, import_tsyringe14.inject("UserRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof HashManager2 === "undefined" ? Object : HashManager2,
    typeof TokenManager === "undefined" ? Object : TokenManager,
    typeof IUserRepository === "undefined" ? Object : IUserRepository
  ])
], LoginUserUseCase2);

// src/useCases/user/update.usecase.ts
var import_tsyringe15 = __toESM(require_cjs(), 1);
class UpdateUserUseCase2 {
  _hashManager;
  _userRepository;
  constructor(_hashManager, _userRepository) {
    this._hashManager = _hashManager;
    this._userRepository = _userRepository;
  }
  async execute(role, user) {
    const existingUser = await this._userRepository.getUserById(user.id);
    if (!existingUser || existingUser.role !== role) {
      throw new ForbiddenError;
    }
    const userCredentials = await this._userRepository.getUserIdAndPasswordByEmail(existingUser.email);
    if (!userCredentials) {
      throw new ForbiddenError;
    }
    const isPasswordCorrect = await this._hashManager.comparePassword(user.password, userCredentials.password);
    if (!isPasswordCorrect) {
      throw new BadRequestError("Invalid password.");
    }
    await this._userRepository.updateUser(user);
  }
}
UpdateUserUseCase2 = __legacyDecorateClassTS([
  import_tsyringe15.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe15.inject("HashManager")),
  __legacyDecorateParamTS(1, import_tsyringe15.inject("UserRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof HashManager === "undefined" ? Object : HashManager,
    typeof IUserRepository === "undefined" ? Object : IUserRepository
  ])
], UpdateUserUseCase2);

// src/useCases/user/logout.usecase.ts
var import_tsyringe16 = __toESM(require_cjs(), 1);
class LogoutUserUseCase2 {
  _userRepository;
  constructor(_userRepository) {
    this._userRepository = _userRepository;
  }
  async execute(role, userId) {
    const user = await this._userRepository.getUserById(userId);
    if (!user) {
      throw new NotFoundError("User ID not found.");
    }
    if (user.role !== role) {
      throw new ForbiddenError;
    }
  }
}
LogoutUserUseCase2 = __legacyDecorateClassTS([
  import_tsyringe16.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe16.inject("UserRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof IUserRepository === "undefined" ? Object : IUserRepository
  ])
], LogoutUserUseCase2);

// src/useCases/user/delete.usecase.ts
var import_tsyringe17 = __toESM(require_cjs(), 1);
class DeleteUserUseCase2 {
  _userRepository;
  _sessionRepository;
  constructor(_userRepository, _sessionRepository) {
    this._userRepository = _userRepository;
    this._sessionRepository = _sessionRepository;
  }
  async execute(adminId, userId, role) {
    const targetUser = await this._userRepository.getUserById(userId);
    if (!targetUser) {
      throw new NotFoundError("User ID not found.");
    }
    const hasActiveSession = await this._sessionRepository.checkSessionExistByUserId(userId);
    if (hasActiveSession) {
      await this._sessionRepository.deleteSessionByUserId(userId);
    }
    const adminUser = await this._userRepository.getUserById(adminId);
    if (!adminUser || role !== "admin") {
      throw new ForbiddenError;
    }
    await this._userRepository.softDeleteUser(userId);
  }
}
DeleteUserUseCase2 = __legacyDecorateClassTS([
  import_tsyringe17.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe17.inject("UserRepository")),
  __legacyDecorateParamTS(1, import_tsyringe17.inject("SessionRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof IUserRepository === "undefined" ? Object : IUserRepository,
    typeof ISessionRepository === "undefined" ? Object : ISessionRepository
  ])
], DeleteUserUseCase2);

// src/useCases/user/undelete.usecase.ts
var import_tsyringe18 = __toESM(require_cjs(), 1);
class UndeleteUserUseCase2 {
  _userRepository;
  constructor(_userRepository) {
    this._userRepository = _userRepository;
  }
  async execute(adminUserId, deletedUserId, adminRole) {
    const deletedUser = await this._userRepository.checkDeletedUserExistsById(deletedUserId);
    if (!deletedUser) {
      throw new NotFoundError("User ID not found.");
    }
    const adminUser = await this._userRepository.getUserById(adminUserId);
    if (!adminUser || adminRole !== "admin") {
      throw new ForbiddenError;
    }
    await this._userRepository.undeleteUser(deletedUserId);
  }
}
UndeleteUserUseCase2 = __legacyDecorateClassTS([
  import_tsyringe18.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe18.inject("UserRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof IUserRepository === "undefined" ? Object : IUserRepository
  ])
], UndeleteUserUseCase2);

// src/repositories/entities/user.entity.ts
class User {
  id;
  first_name;
  last_name;
  email;
  password;
  confirm_password;
  role;
  photo;
  created_at;
  updated_at;
  created_by;
  updated_by;
  is_deleted;
  constructor(data) {
    this.id = data.id || "";
    this.first_name = data.first_name;
    this.last_name = data.last_name;
    this.email = data.email;
    this.password = data.password;
    this.confirm_password = data.confirm_password;
    this.role = data.role;
    this.photo = data.photo;
    this.created_at = data.created_at;
    this.updated_at = data.updated_at;
    this.created_by = data.created_by;
    this.updated_by = data.updated_by;
    this.is_deleted = data.is_deleted || false;
  }
}

// src/dependencies/users.dependency.ts
var registerUserDependencies = () => {
  import_tsyringe19.container.registerInstance("User", User);
  import_tsyringe19.container.register("UserRepository", { useClass: UserRepository });
  import_tsyringe19.container.register("LoginUserUseCase", {
    useClass: LoginUserUseCase2
  });
  import_tsyringe19.container.register("RegisterUserUseCase", {
    useClass: RegisterUserUseCase2
  });
  import_tsyringe19.container.register("GetProfileUserUseCase", {
    useClass: GetProfileUserUseCase2
  });
  import_tsyringe19.container.register("UpdateUserUseCase", {
    useClass: UpdateUserUseCase2
  });
  import_tsyringe19.container.register("LogoutUserUseCase", {
    useClass: LogoutUserUseCase2
  });
  import_tsyringe19.container.register("DeleteUserUseCase", {
    useClass: DeleteUserUseCase2
  });
  import_tsyringe19.container.register("UndeleteUserUseCase", {
    useClass: UndeleteUserUseCase2
  });
};

// src/dependencies/utils.dependency.ts
var import_tsyringe20 = __toESM(require_cjs(), 1);
var registerUtilsDependencies = () => {
  import_tsyringe20.container.register("HashManager", { useClass: HashManager2 });
  import_tsyringe20.container.register("TokenManager", { useClass: TokenManager });
  import_tsyringe20.container.register("EncryptionManager", { useClass: EncryptionManager });
};

// src/dependencies/redis.dependency.ts
var import_tsyringe22 = __toESM(require_cjs(), 1);

// src/repositories/redis/redis.repository.ts
var import_tsyringe21 = __toESM(require_cjs(), 1);

// src/repositories/errors/redis.error.ts
class RedisError extends InfrastructureError {
  constructor(message) {
    super(message);
    this.name = "RedisError";
  }
}
async function RedisErrorHandling(fn) {
  try {
    return await fn();
  } catch (error) {
    if (error instanceof Error) {
      throw new RedisError(`Redis error: ${error.message}`);
    }
    throw new RedisError("Redis error: Unknown Error");
  }
}

// src/repositories/redis/redis.repository.ts
class RedisRepository {
  _client;
  _hashManager;
  constructor(_client, _hashManager) {
    this._client = _client;
    this._hashManager = _hashManager;
  }
  async _getCachedKey(parameter, addtionalInfo, key) {
    const hashedKey = await this._hashManager.hashData(key);
    return `${parameter}:${addtionalInfo}:${hashedKey}`;
  }
  async setTableRow(parameter, additionalInfo, rowKey, rowData, expireTime) {
    return RedisErrorHandling(async () => {
      const cachedKey = await this._getCachedKey(parameter, additionalInfo, rowKey);
      const redisData = {};
      for (const key in rowData) {
        redisData[key] = String(rowData[key]);
      }
      await this._client.hSet(cachedKey, redisData);
      if (expireTime > 0) {
        await this._client.expire(cachedKey, expireTime);
      }
    });
  }
  async getTableRow(parameter, addtionalInfo, rowKey) {
    return RedisErrorHandling(async () => {
      const cachedKey = await this._getCachedKey(parameter, addtionalInfo, rowKey);
      const data = await this._client.hGetAll(cachedKey);
      if (Object.keys(data).length === 0) {
        return null;
      }
      const tableRow = {};
      for (const key in data) {
        if (key === "last_name") {
          tableRow[key] = data[key];
        } else {
          const numValue = Number(data[key]);
          tableRow[key] = isNaN(numValue) ? data[key] : numValue;
        }
      }
      return tableRow;
    });
  }
  async setArrayData(parameter, additionalInfo, rowKey, arrayData, expireTime) {
    return RedisErrorHandling(async () => {
      const cachedKey = await this._getCachedKey(parameter, additionalInfo, rowKey);
      const redisData = {};
      redisData["length"] = String(arrayData.length);
      arrayData.forEach((item, index) => {
        redisData[String(index)] = typeof item === "object" ? JSON.stringify(item) : String(item);
      });
      await this._client.hSet(cachedKey, redisData);
      if (expireTime && expireTime > 0) {
        await this._client.expire(cachedKey, expireTime);
      }
    });
  }
  async getArrayData(parameter, additionalInfo, rowKey) {
    return RedisErrorHandling(async () => {
      const cachedKey = await this._getCachedKey(parameter, additionalInfo, rowKey);
      const data = await this._client.hGetAll(cachedKey);
      if (Object.keys(data).length === 0) {
        return null;
      }
      const length = parseInt(data["length"] || "0", 10);
      if (length === 0) {
        return [];
      }
      const resultArray = new Array(length);
      for (let i = 0;i < length; i++) {
        const value = data[String(i)];
        try {
          resultArray[i] = JSON.parse(value);
        } catch {
          const numValue = Number(value);
          if (!isNaN(numValue) && value !== "") {
            resultArray[i] = numValue;
          } else if (value === "true") {
            resultArray[i] = true;
          } else if (value === "false") {
            resultArray[i] = false;
          } else {
            resultArray[i] = value;
          }
        }
      }
      return resultArray;
    });
  }
  async deleteArrayData(parameter, additionalInfo, rowKey) {
    return this.deleteTableRow(parameter, additionalInfo, rowKey);
  }
  async deleteTableRow(parameter, addtionalInfo, rowKey) {
    return RedisErrorHandling(async () => {
      const cachedKey = await this._getCachedKey(parameter, addtionalInfo, rowKey);
      await this._client.del(cachedKey);
    });
  }
}
RedisRepository = __legacyDecorateClassTS([
  import_tsyringe21.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe21.inject("RedisClient")),
  __legacyDecorateParamTS(1, import_tsyringe21.inject("HashManager")),
  __legacyMetadataTS("design:paramtypes", [
    typeof TRedisClient === "undefined" ? Object : TRedisClient,
    typeof HashManager2 === "undefined" ? Object : HashManager2
  ])
], RedisRepository);

// src/dependencies/redis.dependency.ts
var registerRedisDependencies = () => {
  import_tsyringe22.container.register("RedisRepository", { useClass: RedisRepository });
};

// src/dependencies/sessions.dependency.ts
var import_tsyringe26 = __toESM(require_cjs(), 1);

// src/repositories/postgres/session.repository.ts
var import_tsyringe23 = __toESM(require_cjs(), 1);
class SessionRepository {
  _pool;
  _redisRepository;
  _sessionFactory;
  constructor(_pool, _redisRepository, _sessionFactory) {
    this._pool = _pool;
    this._redisRepository = _redisRepository;
    this._sessionFactory = _sessionFactory;
  }
  async getSession(id) {
    return PostgresErrorHandling(async () => {
      const cachedSession = await this._redisRepository.getTableRow("session", "details", id);
      if (cachedSession) {
        return new this._sessionFactory(cachedSession);
      }
      const sessionQuery = {
        text: `
                    SELECT
                        id,
                        user_id,
                        token,
                        user_agent,
                        expires_at,
                        created_at,
                        updated_at
                    FROM sessions
                    WHERE id = $1
                    LIMIT 1
                `,
        values: [id]
      };
      const sessionResult = await this._pool.query(sessionQuery);
      if (sessionResult.rowCount === 0) {
        throw new PostgresNotFoundError("Session not found");
      }
      const sessionData = sessionResult.rows[0];
      const session = new this._sessionFactory(sessionData);
      await this._redisRepository.setTableRow("session", "details", id, sessionData, Config.ttl.cache);
      return session;
    });
  }
  async checkTokenExist(id) {
    return PostgresErrorHandling(async () => {
      const sessionQuery = {
        text: `
                    SELECT EXISTS(
                        SELECT 1 FROM sessions WHERE id = $1
                    ) AS exists
                `,
        values: [id]
      };
      const sessionResult = await this._pool.query(sessionQuery);
      if (sessionResult.rowCount === 0) {
        return false;
      }
      return sessionResult.rows[0].exists;
    });
  }
  async checkSessionExistByUserId(userId) {
    return PostgresErrorHandling(async () => {
      const sessionQuery = {
        text: `
                    SELECT EXISTS(
                        SELECT 1 FROM sessions WHERE user_id = $1
                    ) AS exists
                `,
        values: [userId]
      };
      const sessionResult = await this._pool.query(sessionQuery);
      if (sessionResult.rowCount === 0) {
        return false;
      }
      return sessionResult.rows[0].exists;
    });
  }
  async addSession(session) {
    return PostgresErrorHandling(async () => {
      const sessionQuery = {
        text: `
                    INSERT INTO sessions (
                        user_id,
                        token,
                        user_agent,
                        expires_at
                    ) VALUES ($1, $2, $3, $4)
                    RETURNING id
                `,
        values: [session.user_id, session.token, session.user_agent, session.expires_at]
      };
      const sessionResult = await this._pool.query(sessionQuery);
      if (sessionResult.rowCount === 0) {
        throw new PostgresCreationError("Session not created");
      }
      return sessionResult.rows[0].id;
    });
  }
  async deleteSession(id, userId) {
    return PostgresErrorHandling(async () => {
      const sessionQuery = {
        text: `
                    DELETE FROM sessions
                    WHERE id = $1 AND user_id = $2
                `,
        values: [id, userId]
      };
      const sessionResult = await this._pool.query(sessionQuery);
      if (sessionResult.rowCount === 0) {
        throw new PostgresNotFoundError("Session not found");
      }
      await this._redisRepository.deleteTableRow("session", "details", id);
    });
  }
  async deleteSessionByUserId(userId) {
    return PostgresErrorHandling(async () => {
      const sessionIdsQuery = {
        text: `
                    SELECT id
                    FROM sessions
                    WHERE user_id = $1
                `,
        values: [userId]
      };
      const sessionIdsResult = await this._pool.query(sessionIdsQuery);
      const sessionIds = sessionIdsResult.rows.map((row) => row.id);
      const sessionQuery = {
        text: `
                    DELETE FROM sessions
                    WHERE user_id = $1
                `,
        values: [userId]
      };
      const sessionResult = await this._pool.query(sessionQuery);
      if (sessionResult.rowCount === 0) {
        throw new PostgresNotFoundError("Session not found");
      }
      for (const sessionId of sessionIds) {
        await this._redisRepository.deleteTableRow("session", "details", sessionId);
      }
    });
  }
  async deleteExpiredSessions() {
    return PostgresErrorHandling(async () => {
      const expiredSessionIdsQuery = {
        text: `
                    SELECT id
                    FROM sessions
                    WHERE expires_at < NOW()
                `
      };
      const expiredSessionIdsResult = await this._pool.query(expiredSessionIdsQuery);
      const expiredSessionIds = expiredSessionIdsResult.rows.map((row) => row.id);
      if (expiredSessionIds.length === 0) {
        return;
      }
      const sessionQuery = {
        text: `
                    DELETE FROM sessions
                    WHERE expires_at < NOW()
                `
      };
      await this._pool.query(sessionQuery);
      for (const sessionId of expiredSessionIds) {
        await this._redisRepository.deleteTableRow("session", "details", sessionId);
      }
    });
  }
}
SessionRepository = __legacyDecorateClassTS([
  import_tsyringe23.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe23.inject("PostgresPool")),
  __legacyDecorateParamTS(1, import_tsyringe23.inject("RedisRepository")),
  __legacyDecorateParamTS(2, import_tsyringe23.inject("Session")),
  __legacyMetadataTS("design:paramtypes", [
    typeof Pool === "undefined" ? Object : Pool,
    typeof IRedisRepository === "undefined" ? Object : IRedisRepository,
    Object
  ])
], SessionRepository);

// node_modules/date-fns/constants.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
var minTime = -maxTime;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;
var constructFromSymbol = Symbol.for("constructDateFrom");

// node_modules/date-fns/constructFrom.js
function constructFrom(date, value) {
  if (typeof date === "function")
    return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date)
    return new date.constructor(value);
  return new Date(value);
}

// node_modules/date-fns/toDate.js
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}

// node_modules/date-fns/addMilliseconds.js
function addMilliseconds(date, amount, options) {
  return constructFrom(options?.in || date, +toDate(date) + amount);
}

// node_modules/date-fns/addSeconds.js
function addSeconds(date, amount, options) {
  return addMilliseconds(date, amount * 1000, options);
}

// src/useCases/session/createSession.usecase.ts
var import_tsyringe24 = __toESM(require_cjs(), 1);
class CreateSessionUseCase2 {
  _encryptionManager;
  _sessionRepository;
  constructor(_encryptionManager, _sessionRepository) {
    this._encryptionManager = _encryptionManager;
    this._sessionRepository = _sessionRepository;
  }
  async execute(tokenData) {
    const expiresAt = addSeconds(new Date, Config.ttl.session);
    const encryptedRefreshToken = await this._encryptionManager.seal(tokenData.refresh_token);
    const sessionData = {
      id: "",
      user_id: tokenData.user_id,
      token: encryptedRefreshToken,
      user_agent: tokenData.user_agent,
      expires_at: expiresAt
    };
    const sessionId = await this._sessionRepository.addSession(sessionData);
    return {
      token: tokenData.refresh_token,
      sessionId
    };
  }
}
CreateSessionUseCase2 = __legacyDecorateClassTS([
  import_tsyringe24.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe24.inject("EncryptionManager")),
  __legacyDecorateParamTS(1, import_tsyringe24.inject("SessionRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof EncryptionManager === "undefined" ? Object : EncryptionManager,
    typeof ISessionRepository === "undefined" ? Object : ISessionRepository
  ])
], CreateSessionUseCase2);

// src/useCases/session/deleteSession.usecase.ts
var import_tsyringe25 = __toESM(require_cjs(), 1);
class DeleteSessionUseCase2 {
  _sessionRepository;
  constructor(_sessionRepository) {
    this._sessionRepository = _sessionRepository;
  }
  async execute(sessionId, userId) {
    const session = await this._sessionRepository.getSession(sessionId);
    if (!session) {
      throw new NotFoundError("Session ID not found.");
    }
    if (userId !== session.user_id) {
      throw new ForbiddenError;
    }
    await this._sessionRepository.deleteSession(sessionId, userId);
  }
}
DeleteSessionUseCase2 = __legacyDecorateClassTS([
  import_tsyringe25.injectable(),
  __legacyDecorateParamTS(0, import_tsyringe25.inject("SessionRepository")),
  __legacyMetadataTS("design:paramtypes", [
    typeof ISessionRepository === "undefined" ? Object : ISessionRepository
  ])
], DeleteSessionUseCase2);

// src/repositories/entities/session.entity.ts
class Session {
  id;
  user_id;
  token;
  user_agent;
  expires_at;
  created_at;
  updated_at;
  constructor(data) {
    this.id = data.id || "";
    this.user_id = data.user_id;
    this.token = data.token;
    this.user_agent = data.user_agent;
    this.expires_at = data.expires_at;
    this.created_at = data.created_at;
    this.updated_at = data.updated_at;
  }
}

// src/dependencies/sessions.dependency.ts
var registerSessionDependencies = () => {
  import_tsyringe26.container.registerInstance("Session", Session);
  import_tsyringe26.container.register("SessionRepository", { useClass: SessionRepository });
  import_tsyringe26.container.register("CreateSessionUseCase", {
    useClass: CreateSessionUseCase2
  });
  import_tsyringe26.container.register("GetSessionUseCase", {
    useClass: GetSessionUseCase
  });
  import_tsyringe26.container.register("ValidateTokenUseCase", {
    useClass: ValidateTokenUseCase
  });
  import_tsyringe26.container.register("DeleteSessionUseCase", {
    useClass: DeleteSessionUseCase2
  });
};

// src/server.ts
var init = async () => {
  let isShuttingDown = false;
  let postgresPool;
  let redisClient;
  let server;
  try {
    const [postgresConnectionResult, redisConnectionResult] = await Promise.all([
      createPostgresConnection(),
      createRedisConnection()
    ]);
    postgresPool = postgresConnectionResult;
    redisClient = redisConnectionResult;
    LogInfo("All connections established successfully");
    registerConnectionDepedencies(postgresPool, redisClient);
    await Promise.all([
      registerUserDependencies(),
      registerSessionDependencies(),
      registerRedisDependencies(),
      registerUtilsDependencies()
    ]);
    server = await createServer();
    await server.start();
    LogInfo("Server running on %s", server.info.uri);
  } catch (error) {
    LogError("Fatal error during initialization:", error);
    process.exit(1);
  }
  process.on("SIGINT", async (_signal) => {
    if (isShuttingDown)
      return;
    isShuttingDown = true;
    LogInfo("Starting graceful shutdown...");
    try {
      LogInfo("Closing PostgreSQL connection...");
      await shutdownPostgresConnection(postgresPool);
      LogInfo("PostgreSQL connection closed.");
      LogInfo("Closing Redis connection...");
      await shutdownRedisConnection(redisClient);
      LogInfo("Redis connection closed.");
      LogInfo("Stopping server...");
      await shutdownServer(server);
      LogInfo("Server stopped.");
      LogInfo("All connections closed, exiting process...");
      process.exit(0);
    } catch (error) {
      console.error("Error during shutdown:", error);
      process.exit(1);
    }
  });
  process.on("SIGTERM", () => {
    LogInfo("SIGTERM received");
    process.emit("SIGINT");
  });
  process.on("unhandledRejection", (err) => {
    console.error("Unhandled Rejection:", err);
    process.exit(1);
  });
};
init().catch((error) => {
  console.error("Fatal error during initialization:", error);
  process.exit(1);
});
